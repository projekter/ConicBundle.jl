/* ****************************************************************************

    Copyright (C) 2004-2021  Christoph Helmberg

    ConicBundle, Version 1.a.2
    File:  CBsources/Groundset.hxx
    This file is part of ConciBundle, a C/C++ library for convex optimization.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

***************************************************************************** */



#ifndef CONICBUNDLE_GROUNDSET_HXX
#define CONICBUNDLE_GROUNDSET_HXX


/**  @file Groundset.hxx
    @brief Header declaring the class ConicBundle::Groundset
    @version 1.0
    @date 2014-07-14
    @author Christoph Helmberg
*/

#include "BundleProxObject.hxx"
#include "QPSolverObject.hxx"
//#include "clock.hxx"

namespace ConicBundle {

/** @defgroup InternalGroundset Classes for Describing Types of Ground Sets and Ensuring Feasibility of y

   In nonsmooth convex optimization, ground sets are typically very
   simple, mostly the entire space or some box. While there is special
   support for these simple groundsets, the package currently also
   offers general LP-constrained groundsets, but in this case
   computations can be expected to be more involved.

   In ConicBundle box constrained ground sets may be treated directly
   by a QPSolver handling constraint or by an (unconstrained)
   UQPSolver in a Gauss-Seidel manner within the process of solving
   the bundle subproblem for determining the next candidate. To
   describe the essence of the second approach, convergence builds
   upon maintaining two aggregate subgradients, one for the cost
   function and one for the ground set. The basic assumption is that
   the indicator function of the ground set is understood sufficiently
   well so that a special aggregate subgradient of this indicator
   function can be generated directly (by some polynomial algorithm)
   with the following property. Given a feasible center y and any
   fixed aggregate of the cost function, the groundset aggregate gives
   rise to the proximal point over the cutting model generated by all
   subgradients of the characteristic function plus the fixed cost
   function aggregate. In particular, this proximal point is always
   feasible. The class Groundset has to provide the functionality to 
   compute a feasible starting point and to compute this ground set 
   aggregate. 

   
*/
//@{

/** @brief abstract representation of the feasible convex ground set to be optimized over, provides the QP solver for the bundle subproblem as well as routines for computing feasible points and ground set aggregates 

    This class serves as abstract base class for all ground set classes. 

    Besides the main task of ensuring feasibility by producing a 
    feasible starting point and by computing the ground set aggregate
    a lot of work is devoted to making problem changes efficient
    (addition/deletion of variables correspond to changes in dimension 
    of the ground set) and to provide support for other dynamic decisions
    like fixing variables at their bounds if the bound appears to be
    strongly active. 

    A good way to think about the convex ground set is to imagine it to be
    given by the convex indicator function of the set. This indicator
    function is added to the cost function. The ground set aggregate
    is a linear minorant of the indicator function, usually it even
    corresponds to a subgradient inequality. E.g., if the ground set
    is the entire space, then zero is the only feasible
    groundset aggregate and the only useful offset is zero as well.   

    It is conceivable but currently not in use that the groundset also
    contributes to VariableMetric so as to support staying inside the
    feasible set. To allow for this in certain situations the Groundset
    is a derived class of a VariableMetricModel.
 */

  class Groundset:virtual public VariableMetricModel 
{
  
public:
  /** @brief reset everything to initial state for an unconstrained ground set of dimension @a indim

      Note that a ground set is allowed to have dimension zero. This
      will lead to evaluating a function without arguments and is
      a realistic scenario in Lagrangean relaxation of cutting plane
      approaches if no cutting planes have been added yet. 

      If the changes to the ground set are to be counted by groundset_id,
      then it makes sense to enter the appropriate value in in_groundset_id.
   */
  virtual void clear( CH_Matrix_Classes::Integer indim=0, CH_Matrix_Classes::Integer in_groundset_id=0) =0;

  ///
  virtual ~Groundset();

  /// returns the current groundset_id, increased values indicate changes in the ground set  
  virtual CH_Matrix_Classes::Integer get_groundset_id() const =0;

  /// sets the groundset_id to the desired value, increasing it is safer here because this is used to indicate changes
  virtual void set_groundset_id(CH_Matrix_Classes::Integer gsid) =0;

  /// returns the dimension of the ground set, i.e., the length of the variables vector y
  virtual CH_Matrix_Classes::Integer get_dim() const =0;

  /** @brief returns false if the feasible set is the entire space (unconstrained optimization), true otherwise. 

      The current class implements the unconstrained case and always returns false.
  */
  virtual bool constrained() const =0;

  /** @brief on input value in_groundset_id the input y was feasible. Return true if the id did not change, otherwise check if y is still feasible for the given precision.

   The routine is called by the internal bundle solver to check
   whether the given center is still valid (in some applications the
   groundset might change during the runtime of the bundle method),
   where validity of y was already checked at a point in time when the
   groundset had the in_groundset_id. If the groundset_id is still the
   same, then y is simply assumed to be still correct (the precision
   is not even looked at in this case). Otherwise the routine checks
   the validitiy of y with respect to the given precision but does not
   enforce validity. It returns true if y is valid and false otherwise.
  */
  virtual bool is_feasible(CH_Matrix_Classes::Integer& in_groundset_id,
			    const CH_Matrix_Classes::Matrix& y,
			     CH_Matrix_Classes::Real relprec=1e-10)=0;

  /** @brief if the groundset_id changed, it checks feasibility of y with respect to the given precision. If infeasible it replaces y by its projection with respect to the norm of Hp and sets ychanged to true. 

   The routine is called by the internal bundle solver to check
   whether the given center is still valid (in some applications the
   groundset might change during the runtime of the bundle method),
   where, if @a ychanged is false on input, validity of @a y was 
   already checked at a point in time when the groundset had 
   the @a in_groundset_id. If @a ychanged==false and the groundset_id is
   still the same, then @a y is simply assumed to be still correct
   (the precision is not even looked at in this case).  Otherwise 
   the routine checks the validitiy of @a y with respect to the given 
   precision. If feasible, it returns the new
   groundset_id in @a in_groundset_id and keeps @a ychanged unaltered. 
   If @a y is infeasible, the rountine computes its projection
   onto the feasible set with respect to the norm of @a Hp (if ==0 then
   the Euclidean norm is used), stores it in @a y, sets @a ychanged to
   true, sets @a in_groundset_id to the current groundset_id and returns
   0. Should anything go wrong, it returns 1.

   This concrete base class represents the unconstrained case, so
   feasiblity only checks the dimension and never requires projections.
   */

  virtual int ensure_feasibility(CH_Matrix_Classes::Integer& in_groundset_id,
				 CH_Matrix_Classes::Matrix& y,
				 bool& ychanged,
				 BundleProxObject* Hp=0,
				 CH_Matrix_Classes::Real relprec=1e-10)=0;

  /// returns a pointer to an internal QPSolverObject that is able to solve bundle suproblems efficiently for this kind of groundset and scaling; if solves_model_without_gs == true the qp solver does not include the groundset and the groundset has to be dealt with by the Gauss Seidel approach 
  virtual QPSolverObject* get_qp_solver(bool& solves_model_without_gs,
					BundleProxObject* Hp) =0;
  
  /// set parameters for the QP_Solver  
  virtual int set_qp_solver_parameters(QPSolverParametersObject* in_qpsp) =0;

  /// returns a stored starting point, note: this need not be feasible; if generated automatically, its dimension is correct.  
  virtual const CH_Matrix_Classes::Matrix& get_starting_point() const =0;

  /// stores the a new starting point irrespective of whether it is feasible or not and returns 0 if it feasible, 1 if it is infeasible
  virtual int set_starting_point(const CH_Matrix_Classes::Matrix& vec)=0;

  /** @brief for a given model aggregate compute the groundset aggregate and the resulting (feasible) candidate

Let \f$ (\sigma,s) \f$ be the aggregate minorant \f$\sigma+s^\top y\le
f(y)\f$ of the cost function described by @a model_subg_offset and @a
model_subg, let \f$\hat y\f$ be the center of stability given by @a
center_y, let \f$H\f$ denote the positive definite scaling matrix with
weight \f$u\f$ given by @a Hp, let \f$Y\f$ denote this (convex)
feasible ground set and \f$i_Y\f$ its indicator function, then this
computes a saddle point \f$(y,(\gamma,g))\f$ of

\f[ \max_{(\gamma,g)\in\partial i_Y}\min_{y\in\mathbf{R}^n} [(s+g)^\top y + \gamma+\sigma +\frac{u}2\|y-\hat y\|_H^2],\f]

The resulting \f$y\f$ is feasible and stored in @a newy.
     @a linval gets \f$\gamma+\sigma+(g+s)^\top y\f$, 
     @a subgnorm2 gets \f$u\|y-\hat x\|_H^2\f$, 
     @a augval gets @a linval+@a subgnorm2 /2.

If @a delta_groundset_subg is not NULL, also 
     @a elta_groundset_subg_offset and @a delta index are assumed to be
     not NULL. Then all changes from the previous groundset aggregate
     minorant to the new groundset aggregate minorant \f$(\gamma,g)\f$ are
     stored in @a delta_groundset_subg_offset and @a delta_groundset_subg
     and @a delta_index holds the indices of the nonzero changes
     (mostly the groundset aggregate is sparse, e.g. due to complementarity).
     This is used in BundleProxObject::update_QP_costs().

On input \f$\varepsilon=\f$ @a relprec, \f$\bar f=\f$ @a
     center_value, and \f$\underline{f}=\f$ @a augval serve to form
     appropriate stopping criteria if solving the saddle point problem
     requires a nonlinear convex optimization method. The method is
     then assumed to produce a primal solution \f$y\in Y\f$ of value
     \f$\bar s\f$ and a dual solution \f$(\gamma,g)\f$ of value
     \f$\underline{g}\f$ with the properties \f$\underline g-\underline
     f\ge 0\f$ and \f$\bar f-\bar s\ge 0\f$ and \f$\bar
     s-\underline{g}\le\varepsilon(|\bar s|+1.)\f$.  In particular
     \f$y\in Y\f$ is assumed to hold to machine precision.

If use_yfixing is true (the fixing heuristic is switched on),
     then \f$y_i=\hat y_i\f$ is required to hold for all i with
     yfixed(i)!=0, so these coordinates are not allowed to change. In
     particular, this routine may also set yfixed(i)=2 for new
     coordinates i, where 2 is used to indicate newly fixed
     variables. These will be reset to 1 in
     BundleProxObject::compute_QP_costs() and
     BundleProxObject::update_QP_costs() 
     when this information has been digested.

In some derived classes a scaling heuristic is called that may influence
the scaling @a Hp so as to avoid going outside the feasible region too far.

  @param[out] gs_id
      the current groundset_id 

  @param[out] newy 
      the next candidate y (feasible)
 
  @param[out] cand_gs_val 
      the value of the groundset minorant in the candidate y (=groundset objective)
 
  @param[out] linval (CH_Matrix_Classes::Real&) value of linear minorant in y
  
  @param[in,out] augval_lb (CH_Matrix_Classes::Real&) 
      - on input: lower bound on value of augmented model in previous (maybe infeasible) candidate
      - on output: lower bound on value of augmented model in y

  @param[out] augval_ub (CH_Matrix_Classes::Real&) 
      - on output: upper bound on value of augmented model in y

  @param[out] subgnorm2 (CH_Matrix_Classes::Real&) 
      squared Hp-norm (with weight) of joint groundset and model aggregate

  @param[in] center_y (const CH_Matrix_Classes::Matrix&) 
      center of stability (feasible)
  
  @param[in] center_value (CH_Matrix_Classes::Real) 
      function value in center_y

  @param[in] model_minorant (const MinorantPoiner&) 
      aggregate linear minorant of the cost function

  @param[in,out] Hp (ConicBundle::BundleProxObject*) 
      pointer to  matrix H, may be influenced by a variable metric heuristic

  @param[in,out] delta_groundset_minorant (MinorantPointer*) 
      if not NULL, the change in groundset aggregate will be stored here

  @param[in,out] delta_index (CH_Matrix_Classes::Indexmatrix*) 
      must be not NULL iff delta_groundset_subg!=NULL or yfixed has changed, 
      will store nonzero indices of delta_groundset_subg
 
  @param[in] relprec (CH_Matrix_Classes::Real) 
      relative precision for termination in QP computations

  @return 0 on success, != 0 on failure

  */
  virtual int candidate(CH_Matrix_Classes::Integer& gs_id,
                        CH_Matrix_Classes::Matrix& newy,
			CH_Matrix_Classes::Real& cand_gs_val,
			CH_Matrix_Classes::Real& linval,
			CH_Matrix_Classes::Real& augval_lb,
			CH_Matrix_Classes::Real& augval_ub,
			CH_Matrix_Classes::Real& subgnorm2,
			const CH_Matrix_Classes::Matrix& center_y,
			CH_Matrix_Classes::Real center_value,
			const MinorantPointer& model_minorant,
			BundleProxObject* Hp,
			MinorantPointer* delta_groundset_minorant=0,
			CH_Matrix_Classes::Indexmatrix* delta_index=0,
			CH_Matrix_Classes::Real relprec=1e-2)=0;

  /// returns the groundset aggregate computed in candidate()
  virtual const MinorantPointer& get_gs_aggregate() const =0;

  /// returns the linear minorant valid on the entire ground set (e.g. a linear cost funciton)
  virtual const MinorantPointer& get_gs_minorant() const =0;

  /// if not NULL (iff get_use_yfixing()==false) it returns the vector yfixed with yfixed(i)=0 if not fixed, =1 is fixed already, =2 if newly fixed
  virtual const CH_Matrix_Classes::Indexmatrix* get_yfixed() const =0;

  /// if not NULL (iff get_use_yfixing()==false) returns the vector yfixed with yfixed(i)=0 if not fixed, =1 is fixed already, =2 if newly fixed
  virtual CH_Matrix_Classes::Indexmatrix* set_yfixed() =0;

  /// true if the cooridinate fixing heuristic is switched on (only constrained cases)
  virtual bool get_use_yfixing() const =0;

  /// set to true to switch on the cooridinate fixing heuristic (only constrained cases)
  virtual void set_use_yfixing(bool uyf) =0;

  /// return a new modification object on the heap that is initialized for modification of *this  
  virtual GroundsetModification* start_modification() =0;

  /// change the groundset description as specified by the argument 
  virtual int apply_modification(const GroundsetModification& mdf) =0;

  /// m-file output routine for debugging or testing in Matlab (not yet working)
  virtual int mfile_data(std::ostream& out) const =0;

};



  //@}

}

#endif

