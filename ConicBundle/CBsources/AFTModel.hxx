/* ****************************************************************************

    Copyright (C) 2004-2021  Christoph Helmberg

    ConicBundle, Version 1.a.2
    File:  CBsources/AFTModel.hxx
    This file is part of ConciBundle, a C/C++ library for convex optimization.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

***************************************************************************** */



#ifndef CONICBUNDLE_AFTMODEL_HXX
#define CONICBUNDLE_AFTMODEL_HXX

/**  @file AFTModel.hxx
    @brief Header declaring the class ConicBundle::AFTModel
    @version 1.0
    @date 2014-07-23
    @author Christoph Helmberg
*/


#include "SumBlockModel.hxx"
#include "AFTData.hxx"
#include "AffineFunctionTransformation.hxx"

namespace ConicBundle {

/** @ingroup InternalBundleModel
*/
//@{

/**@brief mimicks the model of a function with an AffineFunctionTransformation 
(AFT) applied to it. It does so by the chain rule and calling the original model of the function. 

The AFT may be modified without necessarily invalidating the function model if the AFT results in unchanged parameters. Ususally, on intialization, 
the AFTModel is assigned some SumBlockModel whose transformation it represents,
this is SumBlockModel is pointed to by the variable @a model. If 
@a model is not NULL, AFTModel first transforms the input parameters, then
calls @a model with these, and then transforms the ouptput parameters as its output.
If @a model is NULL, then AFTModel simply represents an affine function and
its own model.

The AFTModel may be a separate model component introduced by the
user or a transformation directly generated by any SumBlockModel @a *model 
as the @a model's own affine function transformation. In the latter case
the AFTModel will be initialized by @a model with the parameter 
@a model_is_owner set to true, the latter is false by default. 
If @a model_is_owner is true, the AFTModel will call the @a model routines 
directly without the intermediate smb_transform(). If @a model_is_owner is 
false the @a model routines will be called with the intermediate 
smb_transform(), because this function might then have its own
AFT that has to be carried out first. 
Similar distinctions occur
in the treatment of modifications, etc. 

 */

class AFTModel: public SumBlockModel
{
private:
  //==================  dummy oracle  =====================
  /// points to the model which this AFT works on
  SumBlockModel* model;
  /// the following is true if the model above is the owner of this AFTModel
  bool model_is_owner;
  /// the oracle object of this model
  ModifiableOracleObject dummy_oracle;

  //=================== data of the AFT  ==================
  /// the affine function transformation in use, must always be != NULL
  AffineFunctionTransformation* aft;
  /// the relevant data for running BundleSolver consistently
  AFTData data;

  //=================== data of function evaluations ==================
  ///number of calls to model->eval_function or  model->recompute_center
  CH_Matrix_Classes::Integer ncalls;

  //--- lazy evaluation of the the candidate subgradient
  /// the (lazy) transformed minorant in the candidate
  MinorantPointer cand_minorant;

  /// the (lazy) transformed minorant in the center
  MinorantPointer  center_minorant;

   
  //===================  quadratic subproblems ==================
  /// usually not used, but if aft->get_fun_coeff()==0 an empty block may have to be returned
  QPConeModelDataObject* block;

  /// if a MinorantPointer has already been transformed, this is stored here
  std::map<MinorantPointer,MinorantPointer> precomputed;
  /** @brief if its dimension is >0 it gives the (ordered) subset of indices for which subgradient entries are needed, otherwise all indices will be needed. If compute_qp_data_now==true, these also map the row index of qp_ycost and qp_matrix to the index of y.
   */ 
  CH_Matrix_Classes::Indexmatrix qp_indices;
  /// for checking whether the old results can be reused
  CH_Matrix_Classes::Indexmatrix old_indices;


  //=================== private functions ======================

  /// returns model if @a model_is_owner, and model->sbm_transform() otherwise
  SumBlockModel* cond_model_trafo()
  { return model_is_owner? model: model->sbm_transform();}
  /// const version of cond_model_trafo
  const SumBlockModel* cond_model_trafo() const
  { return model_is_owner? model: model->sbm_transform();}


  /** @brief computes and returns a reference to the transformed point (maybe the input point itself, if identity) and assigns a new aftpoint_id if necessary

      If @a cand_id matches @a data.center_id or @a data.cand_id and the
      transformation has already been stored in data for the
      respective point and the current aft version, nothing needs to
      be computed, the old data is only copied to the candidate (if
      needed).

      If @a cand_id is unknown or the transformation is no longer up to date
      (if aft was modified), an new @a aftpoint_id is assigned to this
      and the transformatoin is computed into @a data.aft_cand if necessary. 
      It is not necessary if the transformation is the identity, in this 
      case @a data.aft_cand is initialized to dimension zero and a 
      reference is returned to the input point @a cand_y itself.
      
   */
  const CH_Matrix_Classes::Matrix& 
  generate_aft_cand(
		    CH_Matrix_Classes::Integer cand_id,
		    const CH_Matrix_Classes::Matrix& cand_y
		    );

  /** @brief if a call to some function evaluation returned an increased function_id, this increases data.modification_id

      A change in the function_id signals a modification of the function for
      which this is the affine fucntion transformations (AFT). As the AFT
      itself is not changed, the transformed evaluation points do not change,
      but from outside the function still looks different. This is reflected
      in increasing data.modification_id, but it also sets the id marks
      of the point and function values to the appropriate values.
  */

  int check_function_id_change(CH_Matrix_Classes::Integer function_id);

  
  /// checks whether it is necessary to precompute the qp_data and does so if required
  int compute_qp_data(const CH_Matrix_Classes::Indexmatrix* indices=0) const;


public:
  /// resets all data to the inital state, except for aft which is unchanged unless @a inaft ist not NULL, which then replaces aft
  void clear(AffineFunctionTransformation* inaft,
	     CH_Matrix_Classes::Integer start_modification_id=0);

  /// overloads the SumBlockModel::clear calling the other clear with parameter 0
  virtual void clear(){clear(0);}

  /// sets @a model to @a in_model and  @a model_is_owner to @a in_model_is_owner (or false if @a in_model==0) and calls clear with parameters (inaft,start_modification_id)
  AFTModel(SumBlockModel* in_model,
	   AffineFunctionTransformation* inaft=0,
	   CH_Matrix_Classes::Integer start_modification_id=0,
	   bool in_model_is_owner=false,
	   CBout* cb=0);
  /// delets aft
  ~AFTModel();

  /// allows to inspect the current AffineFunctionTransformation
  const AffineFunctionTransformation* get_aft() const {return aft;}

  //----------------------------------------------------------------------
  /** @name implementations of abstract class BundleModel (maybe overloading some of SumBlockModel) */
  //@{
  
  /// see BundleModel::eval_function
  int eval_function(CH_Matrix_Classes::Integer& ub_fid,
		    CH_Matrix_Classes::Real& ub,
		    CH_Matrix_Classes::Integer y_id,
		    const CH_Matrix_Classes::Matrix& y,
		    CH_Matrix_Classes::Real nullstep_bound,
		    CH_Matrix_Classes::Real relprec);


  /// see BundleModel::eval_model
  int eval_model(CH_Matrix_Classes::Real& lb, 
		 CH_Matrix_Classes::Integer y_id,
		 const CH_Matrix_Classes::Matrix& y,
		 CH_Matrix_Classes::Real relprec);

  //eval_augmodel           //as in SumBlockModel
 
  //reeval_augmodel         //as in SumBlockModel

  //get_model_aggregate(three parameters) //as in SumBlockModel

  /// see BundleModel::update_model
  int update_model(ModelUpdate model_update,
		   CH_Matrix_Classes::Integer center_id,
		   const CH_Matrix_Classes::Matrix& center_y,
		   CH_Matrix_Classes::Integer cand_id,
		   const CH_Matrix_Classes::Matrix& cand_y,
		   CH_Matrix_Classes::Real model_maxviol,
		   BundleProxObject& H);

  /// see BundleModel::synchronize_ids
  int synchronize_ids(CH_Matrix_Classes::Integer& new_center_ub_fid, 
		      CH_Matrix_Classes::Integer new_center_id,
		      CH_Matrix_Classes::Integer old_center_id,
		      CH_Matrix_Classes::Integer& new_cand_ub_fid, 
		      CH_Matrix_Classes::Integer new_cand_id,
		      CH_Matrix_Classes::Integer old_cand_id,
		      CH_Matrix_Classes::Integer& new_aggregate_id);

  /// see BundleModel::center_modified
  bool center_modified(CH_Matrix_Classes::Integer& center_ub_fid,CH_Matrix_Classes::Integer center_id);

  /// see BundleModel::recompute_center
  int recompute_center(CH_Matrix_Classes::Integer& new_center_ub_fid,
		       CH_Matrix_Classes::Real& new_center_ub,
		       CH_Matrix_Classes::Integer center_id,
		       const CH_Matrix_Classes::Matrix& y,
		       bool accept_only_higher_values=false,
		       CH_Matrix_Classes::Real relprec=-1.);

  /// see BundleModel::model_aggregate_modified
  bool model_aggregate_modified(CH_Matrix_Classes::Integer old_model_aggregate_id);

  /// see BundleModel::provide_model_aggregate
  int provide_model_aggregate(CH_Matrix_Classes::Integer y_id,
			      const CH_Matrix_Classes::Matrix& y);

  /// see BundleModel::apply_modfication(CH_Matrix_Classes::Integer,const CH_Matrix_Classes::Matrix&,CH_Matrix_Classes::Integer,const CH_Matrix_Classes::Matrix&,const FunObjModMap&,const GroundsetModification&)
  int apply_modification(bool& no_changes,
			 const GroundsetModification& gsmdf,
			 const FunObjModMap& funmdfmap,
			 CH_Matrix_Classes::Integer new_center_id,
			 const CH_Matrix_Classes::Matrix& new_center,
			 CH_Matrix_Classes::Integer old_center_id,
			 const CH_Matrix_Classes::Matrix& old_center);

  /// see DynamicScaling   
  int add_variable_metric(VariableMetric& H,
			  CH_Matrix_Classes::Integer center_id,
			  const CH_Matrix_Classes::Matrix& y,
			  bool descent_step,
			  CH_Matrix_Classes::Real weightu,
			  CH_Matrix_Classes::Real model_maxviol,
			  const CH_Matrix_Classes::Indexmatrix* indices=0);

  /// see BundleModel::check_center_validity_by_candidate
  int check_center_validity_by_candidate(bool& cand_minorant_is_below,
					 CH_Matrix_Classes::Integer center_id,
					 const CH_Matrix_Classes::Matrix& center_y);

  //@}

  //----------------------------------------------------------------------
  /** @name implemented/overloaded routines of SumBlockModel */
  //@{
  
  /// as AFTModel has no oracle of its own, this returns the dummy oracle
  ModifiableOracleObject* get_oracle_object() {return &dummy_oracle;}

  // start_augmodel as in SumBlockModel::start_augmodel
   
  /// see SumBlockModel::make_model_aggregate
  int make_model_aggregate(bool& penalty_parameter_increased,
			   bool keep_penalty_fixed);  

  /// see SumBlockModle::get_modle_aggregate(CH_Matrix_Classes::Integer&,CH_Matrix_Classes::Real&,CH_Matrix_Classes::Matrix&,bool,bool,const AffineFunctionTransformation*)
  int get_model_aggregate(CH_Matrix_Classes::Integer& model_aggregate_id,
			  MinorantPointer& model_aggregate,
			  bool all_parts=true,
			  const AffineFunctionTransformation* aft=0);

  /// see SumBlockModel::lb_function
  CH_Matrix_Classes::Real lb_function(CH_Matrix_Classes::Integer y_id,
				      const CH_Matrix_Classes::Matrix& y);

  /// see SumBlockModel::get_function_minorant
  int get_function_minorant(MinorantPointer& minorant,
			  const AffineFunctionTransformation* aft=0);

  /// see SumBlockModel::get_center_minorant
  int get_center_minorant(MinorantPointer& minorant,
			  const AffineFunctionTransformation* aft=0);

  /// see SumBlockModel::adjust_multiplier
  int adjust_multiplier(bool& values_may_have_changed);  

  /// see SumBlockModel::sumbundle_mode
  int sumbundle_mode(SumBundle::Mode& mode,
		     SumBundleHandler* bh=0,
		     AffineFunctionTransformation* aft=0);


  ///see BundleModel::start_augmodel() for the first four parameters; for the others see sumbundle_contribution()
  virtual int start_sumaugmodel(QPModelDataPointer& blockp,
				CH_Matrix_Classes::Integer cand_id,
				const CH_Matrix_Classes::Matrix& cand_y,
				const CH_Matrix_Classes::Indexmatrix* indices=0,
				SumBundleHandler* bh=0,
				SumBundle::Mode mode=SumBundle::inactive,
				AffineFunctionTransformation* aft=0);


  /// see SumBlockModle::update_model(ModelUpdate,CH_Matrix_Classes::Integer,const CH_Matrix_Classes::Matrix&,CH_Matrix_Classes::Real)
  virtual int update_model(ModelUpdate model_update,
			   CH_Matrix_Classes::Integer center_id,
			   const CH_Matrix_Classes::Matrix& center_y,
			   CH_Matrix_Classes::Integer cand_id,
			   const CH_Matrix_Classes::Matrix& cand_y,
			   CH_Matrix_Classes::Real model_maxviol,
			   BundleProxObject& H,
			   CH_Matrix_Classes::Real& model_deviation,
			   CH_Matrix_Classes::Real& model_curvature);

  
  /// see SumBlockModel::get_data
  BundleData* get_data() {return &data;}

  /// see SumBlockModel::get_data
  const BundleData* get_data() const {return &data;}

  /// see SumBlockModel::set_data
  int set_data(BundleData* bd){return data.init(bd);}

  //@}

  //----------------------------------------------------------------------
  /** @name overloaded SumBlockModel messages for direct get/set requestss */
  //@{

  /// an AFT has no primals, so it returns 1, see SumBlockModel::get_approximate_primal
  const PrimalData* get_approximate_primal() const {return 0;}

  /// an AFT has no primals, so it returns 1, see SumBlockModel::get_center_primal
  const PrimalData* get_center_primal() const {return 0;}

  
   /// an AFT has no primals, so it returns 1, see SumBlockModel::get_candidate_primal 
  const PrimalData* get_candidate_primal() const {return 0;}

   /// an AFT has no primals, so it returns 1, see SumBlockModel::call_primal_extender 
  virtual int call_primal_extender(PrimalExtender& /* pext */) {return 1;}

  /// an AFT has no bundle, so it returns 1, see SumBlockModel::set_bundle_parameters
  int set_bundle_parameters(const BundleParameters& /* bp */) {return 1;}

  /// an AFT has no bundle, so it returns 1, see SumBlockModel::get_bundle_parameters  
  BundleParameters* get_bundle_parameters() const {return 0;}

  /// see SumBlockModel::clear_model
  void clear_model(bool discard_minorants_only=false);

  /// see SumBlockModel::clear_aggregates
  void clear_aggregates();  

  //get_ret_code()      // as in SumBlockModel

  //@}

  //---------------------------------------------------------------------- 
  /**@name overloaded routines of BundleQPData */
  //@{

  /// this outputs the qp model data recursively for testing purposes
  std::ostream& output_bundle_data(std::ostream& out) const;

  //@}
  //---------------------------------------------------------------------- 
  /**@name overloaded routines of SumBlockModel for output and statistics on solution times */
  //@{

  //get_QPcoeff_time()      // as in SumBlockModel

  //get_QPsolve_time()      // as in SumBlockModel

  //get_evalaugmodel_time() // as in SumBlockModel

  //get_evalmodel_time()    // as in SumBlockModel

  //get_updatemodel_time()  // as in SumBlockModel

  /// see SumBlockModel::get_preeval_time()
  virtual CH_Tools::Microseconds get_preeval_time() const 
  { 
    CH_Tools::Microseconds ms(preeval_time);
    if (model) ms+= model->get_preeval_time();
    return ms;
  }
  /// see SumBlockModel::get_eval_time()
  virtual CH_Tools::Microseconds get_eval_time() const 
  { 
    CH_Tools::Microseconds ms(eval_time);
    if (model) ms= model->get_eval_time();
    return ms;
  }

  /// see SumBlockModel::get_posteval_time()
  virtual CH_Tools::Microseconds get_posteval_time() const
  { 
    CH_Tools::Microseconds ms(posteval_time);
    if (model) ms+= model->get_posteval_time();
    return ms;
  }

  /// set output and outputlevel of warnings and errors recursively, see CBout
  void set_out(std::ostream* o=0,int pril=1)
  {
    SumBlockModel::set_out(o,pril);
    if (model)
      model->set_cbout(this,0);
    aft->set_cbout(this,0);
    if (block)
      block->set_cbout(this,-1);
  }

  //set_cbout()  // calls set_out in SumBlockModel


  //@}

};

  //@}

}

#endif

