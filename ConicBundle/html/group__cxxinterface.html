<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ConicBundle: Interface to ConicBundle for the Language C++</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ConicBundle
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Interface to ConicBundle for the Language C++</div>  </div>
</div><!--header-->
<div class="contents">

<p>Solve <img class="formulaInl" alt="$min_{y\in\mathbf{R}^m} f_0(y) + f_1(y) + ... + f_k(y)$" src="form_111.png"/> for convex functions f_i, the y-variables may be bounded or box constrained. The most important steps are explained here.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1PrimalData.html">ConicBundle::PrimalData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">In Lagrangean relaxation an approximate primal solution can be generated by supplying primal information derived from this abstract class for each epsilon subgradient within <a class="el" href="classConicBundle_1_1FunctionOracle.html#a10d135676ae61d26bb068fadef2526d3" title="Called by the solver. Has to Return function value and at least one (epsilon) subgradient and...">ConicBundle::FunctionOracle::evaluate()</a>.  <a href="classConicBundle_1_1PrimalData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1PrimalExtender.html">ConicBundle::PrimalExtender</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for extending <a class="el" href="classConicBundle_1_1PrimalData.html" title="In Lagrangean relaxation an approximate primal solution can be generated by supplying primal informat...">PrimalData</a>, e.g., in Lagrangian relaxation of column generation approaches.  <a href="classConicBundle_1_1PrimalExtender.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1FunctionObject.html">ConicBundle::FunctionObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">basic function object (abstract class). It serves for using the same interface on distinct oracle types, but is not yet needed in the standard C++ interface.  <a href="classConicBundle_1_1FunctionObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html">ConicBundle::Minorant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is used to describe affine minorants of convex functions that will be used for generating cutting models of these functions.  <a href="classConicBundle_1_1Minorant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MinorantExtender.html">ConicBundle::MinorantExtender</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for extending a <a class="el" href="classConicBundle_1_1Minorant.html" title="this is used to describe affine minorants of convex functions that will be used for generating cuttin...">Minorant</a>, e.g., in Lagrangian Relaxation of cutting plane approaches.  <a href="classConicBundle_1_1MinorantExtender.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1OracleModification.html">ConicBundle::OracleModification</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for informing oracles (or the solver) about dynamic changes in the number and sorting of the variables, if such changes occur at all.  <a href="classConicBundle_1_1OracleModification.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1PrimalDVector.html">ConicBundle::PrimalDVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If in Lagrangean relaxation primal solutions are in the form of a <a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b" title="A dense vector of double, arguments and subgradients are specified like this. ">ConicBundle::DVector</a>, then an approximate primal solution can be generated by supplying primal information of this form for each epsilon subgradient within <a class="el" href="classConicBundle_1_1FunctionOracle.html#a10d135676ae61d26bb068fadef2526d3" title="Called by the solver. Has to Return function value and at least one (epsilon) subgradient and...">ConicBundle::FunctionOracle::evaluate()</a>.  <a href="classConicBundle_1_1PrimalDVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1FunctionOracle.html">ConicBundle::FunctionOracle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">oracle interface (abstract class). For each of your functions, provide a derived class.  <a href="classConicBundle_1_1FunctionOracle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1BundleParameters.html">ConicBundle::BundleParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serves for specifying parameters regarding the construction of cutting models.  <a href="classConicBundle_1_1BundleParameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html">ConicBundle::CBSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bundle method solver.  <a href="classConicBundle_1_1CBSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gada58ad89c25718a894f1399f7c061f0b"><td class="memItemLeft" align="right" valign="top"><a id="gada58ad89c25718a894f1399f7c061f0b"></a>
typedef std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">ConicBundle::DVector</a></td></tr>
<tr class="memdesc:gada58ad89c25718a894f1399f7c061f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dense vector of double, arguments and subgradients are specified like this. <br /></td></tr>
<tr class="separator:gada58ad89c25718a894f1399f7c061f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ba782d3f05e6d9a1964638a6b97a390"><td class="memItemLeft" align="right" valign="top"><a id="ga2ba782d3f05e6d9a1964638a6b97a390"></a>
typedef std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxxinterface.html#ga2ba782d3f05e6d9a1964638a6b97a390">ConicBundle::IVector</a></td></tr>
<tr class="memdesc:ga2ba782d3f05e6d9a1964638a6b97a390"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dense vector of int, index vectors for deleting/reorganizing variables are specified like this. <br /></td></tr>
<tr class="separator:ga2ba782d3f05e6d9a1964638a6b97a390"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gad70e60e1e38a03d09f1e9b10b68bb0f2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxxinterface.html#gad70e60e1e38a03d09f1e9b10b68bb0f2">ConicBundle::FunctionTask</a> { <b>ObjectiveFunction</b> =0, 
<b>ConstantPenaltyFunction</b> =1, 
<b>AdaptivePenaltyFunction</b> =2
 }<tr class="memdesc:gad70e60e1e38a03d09f1e9b10b68bb0f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each function <img class="formulaInl" alt="$f$" src="form_5.png"/> represented by a FunctionModel is equipped with a <em>function_factor</em> <img class="formulaInl" alt="$\gamma&gt;0$" src="form_37.png"/> (it defaults to 1.) and may be declared as a usual objective function (default) or as a penalty function <img class="formulaInl" alt="$\gamma \max\{f,0\}$" src="form_112.png"/> with either a constant penalty factor or an adaptive penalty factor <img class="formulaInl" alt="$\gamma\in(0,\infty)$" src="form_113.png"/>.  <a href="group__cxxinterface.html#gad70e60e1e38a03d09f1e9b10b68bb0f2">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gad70e60e1e38a03d09f1e9b10b68bb0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga15948e7611155f822fc0331bcbb4a111"><td class="memItemLeft" align="right" valign="top"><a id="ga15948e7611155f822fc0331bcbb4a111"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxxinterface.html#ga15948e7611155f822fc0331bcbb4a111">ConicBundle::CB_plus_infinity</a></td></tr>
<tr class="memdesc:ga15948e7611155f822fc0331bcbb4a111"><td class="mdescLeft">&#160;</td><td class="mdescRight">serves as the value "minus infinity", i.e., all bounds &lt;= this value are set to this value and are regarded as minus infinity <br /></td></tr>
<tr class="separator:ga15948e7611155f822fc0331bcbb4a111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae58492af3631a196b0edb8a8ebcda567"><td class="memItemLeft" align="right" valign="top"><a id="gae58492af3631a196b0edb8a8ebcda567"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxxinterface.html#gae58492af3631a196b0edb8a8ebcda567">ConicBundle::CB_minus_infinity</a></td></tr>
<tr class="memdesc:gae58492af3631a196b0edb8a8ebcda567"><td class="mdescLeft">&#160;</td><td class="mdescRight">serves as the value "plus infinity", i.e., all bounds &gt;= this value are set to this value and are regarded as plus infinity <br /></td></tr>
<tr class="separator:gae58492af3631a196b0edb8a8ebcda567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0183b4724a5783c099911a5950c1401f"><td class="memItemLeft" align="right" valign="top"><a id="ga0183b4724a5783c099911a5950c1401f"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxxinterface.html#ga0183b4724a5783c099911a5950c1401f">ConicBundle::CB_minorant_zero_tolerance</a></td></tr>
<tr class="memdesc:ga0183b4724a5783c099911a5950c1401f"><td class="mdescLeft">&#160;</td><td class="mdescRight">serves as the default tolerance for considering minorant entries as zero <br /></td></tr>
<tr class="separator:ga0183b4724a5783c099911a5950c1401f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68d9c24386fc088ee22451d08dd2ea4a"><td class="memItemLeft" align="right" valign="top"><a id="ga68d9c24386fc088ee22451d08dd2ea4a"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxxinterface.html#ga68d9c24386fc088ee22451d08dd2ea4a">ConicBundle::CB_minorant_sparsity_ratio</a></td></tr>
<tr class="memdesc:ga68d9c24386fc088ee22451d08dd2ea4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">serves as the default ratio of nonzeros to dimension for using a sparse representatio of a minorant <br /></td></tr>
<tr class="separator:ga68d9c24386fc088ee22451d08dd2ea4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Solve <img class="formulaInl" alt="$min_{y\in\mathbf{R}^m} f_0(y) + f_1(y) + ... + f_k(y)$" src="form_111.png"/> for convex functions f_i, the y-variables may be bounded or box constrained. The most important steps are explained here. </p>
<p><b>Setting up the Problem, the Functions, and the Main Loop</b></p>
<p>First create a new problem/solver <a class="el" href="classConicBundle_1_1CBSolver.html" title="Bundle method solver. ">ConicBundle::CBSolver</a>, let us call it solver for brevity. In invoking the constructor a boolean flag may be set to enforce the use of a minimal bundle model that employs only one common aggregate and one common subgradient for all functions, so basically "no bundle", which may be favorable if fast iterations and/or little memory consumption are essential.</p>
<p>Next, set the dimension of the design variables/argument as well as possible box constraints on these by <a class="el" href="classConicBundle_1_1CBSolver.html#aaaca3b1092a1305a8ddf4f181e1bf256" title="Initializes the problem by setting up the design space (the dimension and possible box constraints of...">ConicBundle::CBSolver::init_problem()</a>.</p>
<p>Now set up each of your functions f_i as a <a class="el" href="classConicBundle_1_1FunctionOracle.html" title="oracle interface (abstract class). For each of your functions, provide a derived class. ">ConicBundle::FunctionOracle</a>. Via the routine <a class="el" href="classConicBundle_1_1FunctionOracle.html#a10d135676ae61d26bb068fadef2526d3" title="Called by the solver. Has to Return function value and at least one (epsilon) subgradient and...">ConicBundle::FunctionOracle::evaluate()</a> you will supply, for a given argument, the function value and a subgradient (=the gradient if the function is differentiable) to the solver. The function evaluate() is the only function that you definitely have to provide, see the miniature example below.</p>
<p>The function oracles have to be added to the solver using the routine <a class="el" href="classConicBundle_1_1CBSolver.html#a76de315bec233bec71b1cf9d2ed3df69" title="Adds a function, typically derived from ConicBundle::FunctionOracle; all functions added must have th...">ConicBundle::CBSolver::add_function()</a>.</p>
<p>Once all functions are added, the optimization process can be started. If you know a good starting point then set it with <a class="el" href="classConicBundle_1_1CBSolver.html#a8cf0a95dcbfdf10293a79f47af80b407" title="Set the starting point/center that will be used in the next call to solve(). Each call to this routin...">ConicBundle::CBSolver::set_new_center_point()</a> now, otherwise the method will pick the zero vector or, in the case of box constraints, the point closest to zero as starting point.</p>
<p>Finally, call <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a2dbe46bc6b34684ea4895f8527e3c493" title="solves or does a prescribed number of iterations ">ConicBundle::MatrixCBSolver::solve()</a> and retrieve <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a67e4eaa9ce3bd66f52387ccaa59908de" title="Returns the termination code of the bundle algorithm for the latest descent step. ...">ConicBundle::MatrixCBSolver::termination_code()</a> for getting the reason for termination. Via parameters in solve() you may also tell the solver to return after each descent step or also after a maximum number of null steps. This then only interrupts computations and calling solve() again continues as if there was not break at all.</p>
<p><b>Setting up the Problem, the Functions, and the Main Loop</b></p>
<p>After the first call to <a class="el" href="classConicBundle_1_1CBSolver.html#a208b141c3071b2e4b6c73c660db5ab84" title="solves or does a prescribed number of iterations ">ConicBundle::CBSolver::solve()</a> you can retrieve, at any time, the current objective value by <a class="el" href="classConicBundle_1_1CBSolver.html#a897f12f2423ac6208bb1e878c9ef566b" title="Returns the objective value resulting from last descent step (initially undefined). If no problem modification routines were called since then, it is the objective value at the point returned by get_center(). ">ConicBundle::CBSolver::get_objval()</a> and the argument leading to this value by <a class="el" href="classConicBundle_1_1CBSolver.html#aa0f91826bdb3247e7f7cdf39f9730eea" title="Returns the next center point that was produced by the latest call to solve() (in some problem modifi...">ConicBundle::CBSolver::get_center()</a>. For some screen output, use <a class="el" href="classConicBundle_1_1CBSolver.html#a51a582190b7e9d8863ae1e5ff8a0779e" title="Specifies the output level (out==NULL: no output at all, out!=NULL and level=0: errors and warnings...">ConicBundle::CBSolver::set_out()</a>.</p>
<p><b>Lagrangean Relaxation, Primal Approximations, and Cutting Planes</b></p>
<p>If you are optimizing the Lagrange multipliers of a Lagrangean relaxation, you might be interested in getting an approximation to your primal optimal solution. This can be done by specifying in each function for each (epsilon) subgradient the corresponding primal vectors that generate it, see the parameter primal_solutions in <a class="el" href="classConicBundle_1_1FunctionOracle.html#a10d135676ae61d26bb068fadef2526d3" title="Called by the solver. Has to Return function value and at least one (epsilon) subgradient and...">ConicBundle::FunctionOracle::evaluate()</a> as a start. Then for each of your functions, you can retrieve the current primal approximation using <a class="el" href="classConicBundle_1_1CBSolver.html#ad171dec64fe06f5478a3ab637c484e4c" title="returns the current approximate primal solution corresponding to the aggregate subgradient of the spe...">ConicBundle::CBSolver::get_approximate_primal()</a>.</p>
<p>If, in addition, you plan to improve your primal relaxation via cutting planes, that are strongly violated by the current primal approximation, you should have a look at <a class="el" href="classConicBundle_1_1CBSolver.html#a967e2643744ed0cedd2629e289032d7d" title="Append new variables (always in last postions in this order). ">ConicBundle::CBSolver::append_variables()</a>, ConicBundle::FunctionOracle::subgradient_extension() and <a class="el" href="classConicBundle_1_1CBSolver.html#a6375a055ccfa09179068674683c9f25c" title="Clears cutting model, subgradients and stored function values for the specified function. ">ConicBundle::CBSolver::reinit_function_model()</a>. If you want to get rid of primal constraints/dual variables, use <a class="el" href="classConicBundle_1_1CBSolver.html#a65253792ad3e1fc4a83f689764d13513" title="Returns the multipliers for the box constraints on the design variables; in Lagrangean relaxation the...">ConicBundle::CBSolver::get_approximate_slacks()</a> and <a class="el" href="classConicBundle_1_1CBSolver.html#ae4162fe243fd3550c18f73730dc6ca80" title="Deletes variables corresponding to the specified indices. ">ConicBundle::CBSolver::delete_variables()</a>.</p>
<div class="fragment"><div class="line"><span class="comment">//******************************************************************************</span></div><div class="line"><span class="comment">//*       Miniature Example in C++ for Convex Quadratic in Two Variables       * </span></div><div class="line"><span class="comment">//******************************************************************************</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="CBSolver_8hxx.html">CBSolver.hxx</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>std;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceConicBundle.html">ConicBundle</a>;</div><div class="line"></div><div class="line"><span class="comment">// f(x)=.5*x^TAx+b^Tx+c with A=[5 1;1 4], b=[-12;-10], c=3 </span></div><div class="line"><span class="keyword">class </span>QFunction: <span class="keyword">public</span> <a class="code" href="classConicBundle_1_1FunctionOracle.html">FunctionOracle</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  QFunction(){}</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> evaluate(<span class="keyword">const</span> <span class="keywordtype">double</span>* x, </div><div class="line">               <span class="keywordtype">double</span> <span class="comment">/* relprec */</span>, </div><div class="line">               <span class="keywordtype">double</span>&amp; objective_value,</div><div class="line">               vector&lt;Minorant*&gt;&amp;  minorants,</div><div class="line">               <a class="code" href="classConicBundle_1_1PrimalExtender.html">PrimalExtender</a>*&amp;)</div><div class="line">  {</div><div class="line">    <span class="comment">/* compute objective */</span></div><div class="line">    objective_value= .5*(5*x[0]*x[0]+2*x[0]*x[1]+4*x[1]*x[1])-12*x[0]-10*x[1]+3;</div><div class="line">    <span class="comment">/* compute and store one subgradient(=gradient) with two coordinates */</span></div><div class="line">    <a class="code" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">DVector</a> subg(2,0.);</div><div class="line">    subg[0]=(5*x[0]+x[1])-12;</div><div class="line">    subg[1]=(x[0]+4*x[1])-10;</div><div class="line">    minorants.push_back(<span class="keyword">new</span> <a class="code" href="classConicBundle_1_1Minorant.html">Minorant</a>(objective_value,subg));</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">  QFunction fun;</div><div class="line"></div><div class="line">  <a class="code" href="classConicBundle_1_1CBSolver.html">CBSolver</a> solver(&amp;cout, 1);            <span class="comment">// initilialize solver with basic output</span></div><div class="line">  solver.<a class="code" href="classConicBundle_1_1MatrixCBSolver.html#a5129b50d68be01aaa8cb6825058a8f13">init_problem</a>(2);               <span class="comment">// 2 variables, no bounds</span></div><div class="line">  solver.<a class="code" href="classConicBundle_1_1MatrixCBSolver.html#a3c503663b689ede0f1d004690d622e2f">add_function</a>(fun);      </div><div class="line"> </div><div class="line">  solver.<a class="code" href="classConicBundle_1_1MatrixCBSolver.html#abede1e498b73162f2b7e74f958df5bc0">set_term_relprec</a>(1e-8);        <span class="comment">// set relative precision</span></div><div class="line"> </div><div class="line">  solver.<a class="code" href="classConicBundle_1_1MatrixCBSolver.html#a2dbe46bc6b34684ea4895f8527e3c493">solve</a>();                       <span class="comment">// minimize the function</span></div><div class="line"></div><div class="line">  solver.<a class="code" href="classConicBundle_1_1MatrixCBSolver.html#a3a2fd1cb66cdd565a81879de422e45db">print_termination_code</a>(cout);</div><div class="line"></div><div class="line">  <a class="code" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">DVector</a> x;</div><div class="line">  solver.<a class="code" href="classConicBundle_1_1MatrixCBSolver.html#a40b4df10fa42d417881ec55fad3616cd">get_center</a>(x);                 <span class="comment">// retrieve the computed solution</span></div><div class="line">  cout&lt;&lt;<span class="stringliteral">&quot; x[0]=&quot;</span>&lt;&lt;x[0]&lt;&lt;<span class="stringliteral">&quot; x[1]=&quot;</span>&lt;&lt;x[1]&lt;&lt;<span class="stringliteral">&quot; objval=&quot;</span>&lt;&lt;solver.<a class="code" href="classConicBundle_1_1MatrixCBSolver.html#abadd5d33331ac8f52bb435a11d04a802">get_objval</a>()&lt;&lt;endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gad70e60e1e38a03d09f1e9b10b68bb0f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad70e60e1e38a03d09f1e9b10b68bb0f2">&#9670;&nbsp;</a></span>FunctionTask</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__cxxinterface.html#gad70e60e1e38a03d09f1e9b10b68bb0f2">ConicBundle::FunctionTask</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Each function <img class="formulaInl" alt="$f$" src="form_5.png"/> represented by a FunctionModel is equipped with a <em>function_factor</em> <img class="formulaInl" alt="$\gamma&gt;0$" src="form_37.png"/> (it defaults to 1.) and may be declared as a usual objective function (default) or as a penalty function <img class="formulaInl" alt="$\gamma \max\{f,0\}$" src="form_112.png"/> with either a constant penalty factor or an adaptive penalty factor <img class="formulaInl" alt="$\gamma\in(0,\infty)$" src="form_113.png"/>. </p>
<dl class="section attention"><dt>Attention</dt><dd>AdaptivePenaltyFunction is still very experimental and not yet reliable</dd></dl>
<ul>
<li>ObjectiveFunction adds <img class="formulaInl" alt="$\gamma f$" src="form_114.png"/></li>
<li>ConstantPenaltyFunction adds <img class="formulaInl" alt="$\gamma \max\{f,0\}$" src="form_112.png"/></li>
<li>AdaptivePenaltyFunction adds <img class="formulaInl" alt="$\gamma \max\{f,0\}$" src="form_112.png"/> for <img class="formulaInl" alt="$\gamma\to\infty$" src="form_115.png"/> so that the result should resemble the indicator of the level set to level 0 (in exact penalty cases there will be no need to go to infinity) </li>
</ul>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
