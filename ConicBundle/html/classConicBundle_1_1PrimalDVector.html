<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ConicBundle: ConicBundle::PrimalDVector Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ConicBundle
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceConicBundle.html">ConicBundle</a></li><li class="navelem"><a class="el" href="classConicBundle_1_1PrimalDVector.html">PrimalDVector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classConicBundle_1_1PrimalDVector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ConicBundle::PrimalDVector Class Reference<div class="ingroups"><a class="el" href="group__cxxinterface.html">Interface to ConicBundle for the Language C++</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>If in Lagrangean relaxation primal solutions are in the form of a <a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b" title="A dense vector of double, arguments and subgradients are specified like this. ">ConicBundle::DVector</a>, then an approximate primal solution can be generated by supplying primal information of this form for each epsilon subgradient within <a class="el" href="classConicBundle_1_1FunctionOracle.html#a10d135676ae61d26bb068fadef2526d3" title="Called by the solver. Has to Return function value and at least one (epsilon) subgradient and...">ConicBundle::FunctionOracle::evaluate()</a>.  
 <a href="classConicBundle_1_1PrimalDVector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CBSolver_8hxx_source.html">CBSolver.hxx</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ConicBundle::PrimalDVector:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classConicBundle_1_1PrimalDVector.png" usemap="#ConicBundle::PrimalDVector_map" alt=""/>
  <map id="ConicBundle::PrimalDVector_map" name="ConicBundle::PrimalDVector_map">
<area href="classConicBundle_1_1PrimalData.html" title="In Lagrangean relaxation an approximate primal solution can be generated by supplying primal informat..." alt="ConicBundle::PrimalData" shape="rect" coords="0,0,172,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aabeb8799543f2fb8263a5496b178dbea"><td class="memItemLeft" align="right" valign="top"><a id="aabeb8799543f2fb8263a5496b178dbea"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1PrimalDVector.html#aabeb8799543f2fb8263a5496b178dbea">PrimalDVector</a> (int n)</td></tr>
<tr class="memdesc:aabeb8799543f2fb8263a5496b178dbea"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct a primal double vector with n elements <br /></td></tr>
<tr class="separator:aabeb8799543f2fb8263a5496b178dbea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb448eff8d8a694bd0663a0fe2352e0"><td class="memItemLeft" align="right" valign="top"><a id="a0bb448eff8d8a694bd0663a0fe2352e0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1PrimalDVector.html#a0bb448eff8d8a694bd0663a0fe2352e0">PrimalDVector</a> (int n, double d)</td></tr>
<tr class="memdesc:a0bb448eff8d8a694bd0663a0fe2352e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct a primal double vector with n elements initialized to d <br /></td></tr>
<tr class="separator:a0bb448eff8d8a694bd0663a0fe2352e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0840a09dc8afd33b42692c7177932ced"><td class="memItemLeft" align="right" valign="top"><a id="a0840a09dc8afd33b42692c7177932ced"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1PrimalDVector.html#a0840a09dc8afd33b42692c7177932ced">PrimalDVector</a> (const <a class="el" href="classConicBundle_1_1PrimalDVector.html">PrimalDVector</a> &amp;pd)</td></tr>
<tr class="memdesc:a0840a09dc8afd33b42692c7177932ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor <br /></td></tr>
<tr class="separator:a0840a09dc8afd33b42692c7177932ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71fd6de098e03f929164eeedeab72e7"><td class="memItemLeft" align="right" valign="top"><a id="af71fd6de098e03f929164eeedeab72e7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1PrimalDVector.html#af71fd6de098e03f929164eeedeab72e7">PrimalDVector</a> (const <a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">DVector</a> &amp;pd)</td></tr>
<tr class="memdesc:af71fd6de098e03f929164eeedeab72e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">conversion from a DVector <br /></td></tr>
<tr class="separator:af71fd6de098e03f929164eeedeab72e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0057507c39878ffc6e3e4fe7b7ded168"><td class="memItemLeft" align="right" valign="top"><a id="a0057507c39878ffc6e3e4fe7b7ded168"></a>
<a class="el" href="classConicBundle_1_1PrimalDVector.html">PrimalDVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1PrimalDVector.html#a0057507c39878ffc6e3e4fe7b7ded168">operator=</a> (const <a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">DVector</a> &amp;pd)</td></tr>
<tr class="memdesc:a0057507c39878ffc6e3e4fe7b7ded168"><td class="mdescLeft">&#160;</td><td class="mdescRight">assignment of a DVector <br /></td></tr>
<tr class="separator:a0057507c39878ffc6e3e4fe7b7ded168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f2ae64f77ac857c2f82bdafb2787b9"><td class="memItemLeft" align="right" valign="top"><a id="af5f2ae64f77ac857c2f82bdafb2787b9"></a>
<a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1PrimalDVector.html#af5f2ae64f77ac857c2f82bdafb2787b9">clone_primal_data</a> () const</td></tr>
<tr class="memdesc:af5f2ae64f77ac857c2f82bdafb2787b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">produces a new <a class="el" href="classConicBundle_1_1PrimalDVector.html" title="If in Lagrangean relaxation primal solutions are in the form of a ConicBundle::DVector, then an approximate primal solution can be generated by supplying primal information of this form for each epsilon subgradient within ConicBundle::FunctionOracle::evaluate(). ">PrimalDVector</a> that is a copy of itself <br /></td></tr>
<tr class="separator:af5f2ae64f77ac857c2f82bdafb2787b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721b7d4db09c1ca60a4f1a9adc6ed825"><td class="memItemLeft" align="right" valign="top"><a id="a721b7d4db09c1ca60a4f1a9adc6ed825"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1PrimalDVector.html#a721b7d4db09c1ca60a4f1a9adc6ed825">assign_primal_data</a> (const <a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> &amp;it, double factor=1.)</td></tr>
<tr class="memdesc:a721b7d4db09c1ca60a4f1a9adc6ed825"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy its information to *this <br /></td></tr>
<tr class="separator:a721b7d4db09c1ca60a4f1a9adc6ed825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf64f99a0163c7af48e8b0ef78cf842e"><td class="memItemLeft" align="right" valign="top"><a id="adf64f99a0163c7af48e8b0ef78cf842e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1PrimalDVector.html#adf64f99a0163c7af48e8b0ef78cf842e">aggregate_primal_data</a> (const <a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> &amp;it, double factor=1.)</td></tr>
<tr class="memdesc:adf64f99a0163c7af48e8b0ef78cf842e"><td class="mdescLeft">&#160;</td><td class="mdescRight">if it is a <a class="el" href="classConicBundle_1_1PrimalDVector.html" title="If in Lagrangean relaxation primal solutions are in the form of a ConicBundle::DVector, then an approximate primal solution can be generated by supplying primal information of this form for each epsilon subgradient within ConicBundle::FunctionOracle::evaluate(). ">PrimalDVector</a> of the same dimension, add factor*it to *this <br /></td></tr>
<tr class="separator:adf64f99a0163c7af48e8b0ef78cf842e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf484aaaeed2d905eea8e6ed8454e7e"><td class="memItemLeft" align="right" valign="top"><a id="a2cf484aaaeed2d905eea8e6ed8454e7e"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1PrimalDVector.html#a2cf484aaaeed2d905eea8e6ed8454e7e">scale_primal_data</a> (double myfactor)</td></tr>
<tr class="memdesc:a2cf484aaaeed2d905eea8e6ed8454e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiply/scale *this with a nonnegative myfactor <br /></td></tr>
<tr class="separator:a2cf484aaaeed2d905eea8e6ed8454e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>If in Lagrangean relaxation primal solutions are in the form of a <a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b" title="A dense vector of double, arguments and subgradients are specified like this. ">ConicBundle::DVector</a>, then an approximate primal solution can be generated by supplying primal information of this form for each epsilon subgradient within <a class="el" href="classConicBundle_1_1FunctionOracle.html#a10d135676ae61d26bb068fadef2526d3" title="Called by the solver. Has to Return function value and at least one (epsilon) subgradient and...">ConicBundle::FunctionOracle::evaluate()</a>. </p>
<p>In many applications, e.g. in Lagrangean relaxation, the convex minimization problem arises as the dual of a convex primal maximization problem. In this case one is typically interested in obtaining a primal approximate solution in addition to the dual solution. Under reasonable conditions this is possible if the primal solutions that give rise to the subgradients are aggregated along with the subgradients within the bundle algorithm. If the primal data can be represented as a DVector then the user has to supply in the oracle for each sugradient the corresponding primal data in a PrimalDvector and the algorithm will do the rest. Observe that a <a class="el" href="classConicBundle_1_1PrimalDVector.html" title="If in Lagrangean relaxation primal solutions are in the form of a ConicBundle::DVector, then an approximate primal solution can be generated by supplying primal information of this form for each epsilon subgradient within ConicBundle::FunctionOracle::evaluate(). ">PrimalDVector</a> can be used exactly in the same way as a DVector and that they are assignable among each other.</p>
<p>The primal data has to be supplied within ConicBundle::FunctionOracle::Evaluate() and can be retrieved via the methods <a class="el" href="classConicBundle_1_1CBSolver.html#ad171dec64fe06f5478a3ab637c484e4c" title="returns the current approximate primal solution corresponding to the aggregate subgradient of the spe...">ConicBundle::CBSolver::get_approximate_primal()</a> and <a class="el" href="classConicBundle_1_1CBSolver.html#af3c96e5f61e6dc6b8223dd63760cd1ab" title="Returns the primal solution corresponding to the best epsilon subgradient returned in the evaluation ...">ConicBundle::CBSolver::get_center_primal()</a> </p>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="CBSolver_8hxx_source.html">CBSolver.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
