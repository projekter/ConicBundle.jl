<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ConicBundle: ConicBundle::CBSolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ConicBundle
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceConicBundle.html">ConicBundle</a></li><li class="navelem"><a class="el" href="classConicBundle_1_1CBSolver.html">CBSolver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classConicBundle_1_1CBSolver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ConicBundle::CBSolver Class Reference<div class="ingroups"><a class="el" href="group__cxxinterface.html">Interface to ConicBundle for the Language C++</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Bundle method solver.  
 <a href="classConicBundle_1_1CBSolver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CBSolver_8hxx_source.html">CBSolver.hxx</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac4eae45721f8e2453a7ba14855bcdfe1"><td class="memItemLeft" align="right" valign="top"><a id="ac4eae45721f8e2453a7ba14855bcdfe1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#ac4eae45721f8e2453a7ba14855bcdfe1">CBSolver</a> (std::ostream *out=0, int print_level=0)</td></tr>
<tr class="memdesc:ac4eae45721f8e2453a7ba14855bcdfe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor allows to set output level options from start (see also <a class="el" href="classConicBundle_1_1CBSolver.html#a51a582190b7e9d8863ae1e5ff8a0779e" title="Specifies the output level (out==NULL: no output at all, out!=NULL and level=0: errors and warnings...">set_out()</a>) <br /></td></tr>
<tr class="separator:ac4eae45721f8e2453a7ba14855bcdfe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Initialization</div></td></tr>
<tr class="memitem:a750dc103b6b3414317b45aea9551d2e3"><td class="memItemLeft" align="right" valign="top"><a id="a750dc103b6b3414317b45aea9551d2e3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a750dc103b6b3414317b45aea9551d2e3">clear</a> ()</td></tr>
<tr class="memdesc:a750dc103b6b3414317b45aea9551d2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all data structures and problem information but keeps ouptut settings and algorithmic parameter settings. <br /></td></tr>
<tr class="separator:a750dc103b6b3414317b45aea9551d2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a2702c0787f50c9eb62a80e868979f"><td class="memItemLeft" align="right" valign="top"><a id="a98a2702c0787f50c9eb62a80e868979f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a98a2702c0787f50c9eb62a80e868979f">set_defaults</a> ()</td></tr>
<tr class="memdesc:a98a2702c0787f50c9eb62a80e868979f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets default values for algorithmic parameters that are not function specific (e.g., relative precision, weight and weight bounds for the augmentedproblem, etc.) <br /></td></tr>
<tr class="separator:a98a2702c0787f50c9eb62a80e868979f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaca3b1092a1305a8ddf4f181e1bf256"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#aaaca3b1092a1305a8ddf4f181e1bf256">init_problem</a> (int dim, const <a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">DVector</a> *lbounds=0, const <a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">DVector</a> *ubounds=0)</td></tr>
<tr class="memdesc:aaaca3b1092a1305a8ddf4f181e1bf256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the problem by setting up the design space (the dimension and possible box constraints of the variables)  <a href="#aaaca3b1092a1305a8ddf4f181e1bf256">More...</a><br /></td></tr>
<tr class="separator:aaaca3b1092a1305a8ddf4f181e1bf256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76de315bec233bec71b1cf9d2ed3df69"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a76de315bec233bec71b1cf9d2ed3df69">add_function</a> (<a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function)</td></tr>
<tr class="memdesc:a76de315bec233bec71b1cf9d2ed3df69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a function, typically derived from <a class="el" href="classConicBundle_1_1FunctionOracle.html" title="oracle interface (abstract class). For each of your functions, provide a derived class. ">ConicBundle::FunctionOracle</a>; all functions added must have the same argument dimension.  <a href="#a76de315bec233bec71b1cf9d2ed3df69">More...</a><br /></td></tr>
<tr class="separator:a76de315bec233bec71b1cf9d2ed3df69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b67a6c37934a2751e46d65bab8ab0c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a5b67a6c37934a2751e46d65bab8ab0c1">set_lower_bound</a> (int i, double lb)</td></tr>
<tr class="memdesc:a5b67a6c37934a2751e46d65bab8ab0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets lower bound for variable i, use <a class="el" href="group__cxxinterface.html#gae58492af3631a196b0edb8a8ebcda567" title="serves as the value &quot;plus infinity&quot;, i.e., all bounds &gt;= this value are set to this value and are reg...">ConicBundle::CB_minus_infinity</a> for unbounded from below.  <a href="#a5b67a6c37934a2751e46d65bab8ab0c1">More...</a><br /></td></tr>
<tr class="separator:a5b67a6c37934a2751e46d65bab8ab0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95faba4e7c4b3331bb5892d14516b92"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#ad95faba4e7c4b3331bb5892d14516b92">set_upper_bound</a> (int i, double ub)</td></tr>
<tr class="memdesc:ad95faba4e7c4b3331bb5892d14516b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets upper bound for variable i, use <a class="el" href="group__cxxinterface.html#ga15948e7611155f822fc0331bcbb4a111" title="serves as the value &quot;minus infinity&quot;, i.e., all bounds &lt;= this value are set to this value and are re...">ConicBundle::CB_plus_infinity</a> for unbounded from below.  <a href="#ad95faba4e7c4b3331bb5892d14516b92">More...</a><br /></td></tr>
<tr class="separator:ad95faba4e7c4b3331bb5892d14516b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967e2643744ed0cedd2629e289032d7d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a967e2643744ed0cedd2629e289032d7d">append_variables</a> (int n_append, const <a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">DVector</a> *lbounds=0, const <a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">DVector</a> *ubounds=0)</td></tr>
<tr class="memdesc:a967e2643744ed0cedd2629e289032d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append new variables (always in last postions in this order).  <a href="#a967e2643744ed0cedd2629e289032d7d">More...</a><br /></td></tr>
<tr class="separator:a967e2643744ed0cedd2629e289032d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4162fe243fd3550c18f73730dc6ca80"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#ae4162fe243fd3550c18f73730dc6ca80">delete_variables</a> (const <a class="el" href="group__cxxinterface.html#ga2ba782d3f05e6d9a1964638a6b97a390">IVector</a> &amp;delete_indices, <a class="el" href="group__cxxinterface.html#ga2ba782d3f05e6d9a1964638a6b97a390">IVector</a> &amp;map_to_old)</td></tr>
<tr class="memdesc:ae4162fe243fd3550c18f73730dc6ca80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes variables corresponding to the specified indices.  <a href="#ae4162fe243fd3550c18f73730dc6ca80">More...</a><br /></td></tr>
<tr class="separator:ae4162fe243fd3550c18f73730dc6ca80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6b60c2cf0bdd6af826e96a14fc467b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#aaa6b60c2cf0bdd6af826e96a14fc467b">reassign_variables</a> (const <a class="el" href="group__cxxinterface.html#ga2ba782d3f05e6d9a1964638a6b97a390">IVector</a> &amp;assign_new_from_old)</td></tr>
<tr class="memdesc:aaa6b60c2cf0bdd6af826e96a14fc467b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reassigns variables to new index positions by mapping to position <em>i</em> the variable that previously had index <em>assign_new_from_old</em>[i].  <a href="#aaa6b60c2cf0bdd6af826e96a14fc467b">More...</a><br /></td></tr>
<tr class="separator:aaa6b60c2cf0bdd6af826e96a14fc467b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic Algorithmic Routines and Parameters</div></td></tr>
<tr class="memitem:a208b141c3071b2e4b6c73c660db5ab84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a208b141c3071b2e4b6c73c660db5ab84">solve</a> (int maxsteps=0, bool stop_at_descent_steps=false)</td></tr>
<tr class="memdesc:a208b141c3071b2e4b6c73c660db5ab84"><td class="mdescLeft">&#160;</td><td class="mdescRight">solves or does a prescribed number of iterations  <a href="#a208b141c3071b2e4b6c73c660db5ab84">More...</a><br /></td></tr>
<tr class="separator:a208b141c3071b2e4b6c73c660db5ab84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1b38a14ebbc57eb96c3207da7e6c3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#abb1b38a14ebbc57eb96c3207da7e6c3f">termination_code</a> () const</td></tr>
<tr class="memdesc:abb1b38a14ebbc57eb96c3207da7e6c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the termination code of the bundle algorithm for the latest descent step.  <a href="#abb1b38a14ebbc57eb96c3207da7e6c3f">More...</a><br /></td></tr>
<tr class="separator:abb1b38a14ebbc57eb96c3207da7e6c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfd9aa3966862e9e001fd4a3691213f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a0bfd9aa3966862e9e001fd4a3691213f">print_termination_code</a> (std::ostream &amp;out)</td></tr>
<tr class="memdesc:a0bfd9aa3966862e9e001fd4a3691213f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a text version of termination code, see <a class="el" href="classConicBundle_1_1CBSolver.html#abb1b38a14ebbc57eb96c3207da7e6c3f" title="Returns the termination code of the bundle algorithm for the latest descent step. ...">termination_code()</a>.  <a href="#a0bfd9aa3966862e9e001fd4a3691213f">More...</a><br /></td></tr>
<tr class="separator:a0bfd9aa3966862e9e001fd4a3691213f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897f12f2423ac6208bb1e878c9ef566b"><td class="memItemLeft" align="right" valign="top"><a id="a897f12f2423ac6208bb1e878c9ef566b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a897f12f2423ac6208bb1e878c9ef566b">get_objval</a> () const</td></tr>
<tr class="memdesc:a897f12f2423ac6208bb1e878c9ef566b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the objective value resulting from last descent step (initially undefined). If no problem modification routines were called since then, it is the objective value at the point returned by <a class="el" href="classConicBundle_1_1CBSolver.html#aa0f91826bdb3247e7f7cdf39f9730eea" title="Returns the next center point that was produced by the latest call to solve() (in some problem modifi...">get_center()</a>. <br /></td></tr>
<tr class="separator:a897f12f2423ac6208bb1e878c9ef566b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f91826bdb3247e7f7cdf39f9730eea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#aa0f91826bdb3247e7f7cdf39f9730eea">get_center</a> (<a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">DVector</a> &amp;center) const</td></tr>
<tr class="memdesc:aa0f91826bdb3247e7f7cdf39f9730eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next center point that was produced by the latest call to <a class="el" href="classConicBundle_1_1CBSolver.html#a208b141c3071b2e4b6c73c660db5ab84" title="solves or does a prescribed number of iterations ">solve()</a> (in some problem modification routines the center point may be updated immediately, in others the center point will be corrected automatically directly before starting the next descent step and its values may be infeasible till then).  <a href="#aa0f91826bdb3247e7f7cdf39f9730eea">More...</a><br /></td></tr>
<tr class="separator:aa0f91826bdb3247e7f7cdf39f9730eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc51bc5c5a5d6907a3748d90a1285082"><td class="memItemLeft" align="right" valign="top"><a id="abc51bc5c5a5d6907a3748d90a1285082"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#abc51bc5c5a5d6907a3748d90a1285082">get_sgnorm</a> () const</td></tr>
<tr class="memdesc:abc51bc5c5a5d6907a3748d90a1285082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Euclidean norm of the latest aggregate subgradient. <br /></td></tr>
<tr class="separator:abc51bc5c5a5d6907a3748d90a1285082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c36402ee2aa2e69ea2ee0fb9aa9bbab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a0c36402ee2aa2e69ea2ee0fb9aa9bbab">get_subgradient</a> (<a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">DVector</a> &amp;subgradient) const</td></tr>
<tr class="memdesc:a0c36402ee2aa2e69ea2ee0fb9aa9bbab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the latest aggregate subgradient.  <a href="#a0c36402ee2aa2e69ea2ee0fb9aa9bbab">More...</a><br /></td></tr>
<tr class="separator:a0c36402ee2aa2e69ea2ee0fb9aa9bbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0725a2d8d91005b1a64cf76819b18269"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a0725a2d8d91005b1a64cf76819b18269">get_candidate_value</a> () const</td></tr>
<tr class="memdesc:a0725a2d8d91005b1a64cf76819b18269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the objective value computed in the last step of <a class="el" href="classConicBundle_1_1CBSolver.html#a208b141c3071b2e4b6c73c660db5ab84" title="solves or does a prescribed number of iterations ">solve()</a>, independent of whether this was a descent step or a null step (initially undefined).  <a href="#a0725a2d8d91005b1a64cf76819b18269">More...</a><br /></td></tr>
<tr class="separator:a0725a2d8d91005b1a64cf76819b18269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a67a949e06f72bd7c0ebb4f7dc086a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#ac2a67a949e06f72bd7c0ebb4f7dc086a">get_candidate</a> (<a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">DVector</a> &amp;candidate) const</td></tr>
<tr class="memdesc:ac2a67a949e06f72bd7c0ebb4f7dc086a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last point, the "candidate", at which the function was evaluated in <a class="el" href="classConicBundle_1_1CBSolver.html#a208b141c3071b2e4b6c73c660db5ab84" title="solves or does a prescribed number of iterations ">solve()</a>.  <a href="#ac2a67a949e06f72bd7c0ebb4f7dc086a">More...</a><br /></td></tr>
<tr class="separator:ac2a67a949e06f72bd7c0ebb4f7dc086a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Advanced Algorithmic Routines and Parameters</div></td></tr>
<tr class="memitem:a219d05df5fe82c6cedb0f1203ba88afa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a219d05df5fe82c6cedb0f1203ba88afa">set_term_relprec</a> (const double term_relprec)</td></tr>
<tr class="memdesc:a219d05df5fe82c6cedb0f1203ba88afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the relative precision requirements for successful termination (default 1e-5).  <a href="#a219d05df5fe82c6cedb0f1203ba88afa">More...</a><br /></td></tr>
<tr class="separator:a219d05df5fe82c6cedb0f1203ba88afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf0a95dcbfdf10293a79f47af80b407"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a8cf0a95dcbfdf10293a79f47af80b407">set_new_center_point</a> (const <a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">DVector</a> &amp;center_point)</td></tr>
<tr class="memdesc:a8cf0a95dcbfdf10293a79f47af80b407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the starting point/center that will be used in the next call to <a class="el" href="classConicBundle_1_1CBSolver.html#a208b141c3071b2e4b6c73c660db5ab84" title="solves or does a prescribed number of iterations ">solve()</a>. Each call to this routine causes an immediate evaluation of all oracles.  <a href="#a8cf0a95dcbfdf10293a79f47af80b407">More...</a><br /></td></tr>
<tr class="separator:a8cf0a95dcbfdf10293a79f47af80b407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfde20a8947607a704470d9161bbf5c"><td class="memItemLeft" align="right" valign="top"><a id="a6cfde20a8947607a704470d9161bbf5c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a6cfde20a8947607a704470d9161bbf5c">get_function_status</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function) const</td></tr>
<tr class="memdesc:a6cfde20a8947607a704470d9161bbf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the return value of the latest evaluation call to this <em>function</em>. <br /></td></tr>
<tr class="separator:a6cfde20a8947607a704470d9161bbf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65253792ad3e1fc4a83f689764d13513"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a65253792ad3e1fc4a83f689764d13513">get_approximate_slacks</a> (<a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">DVector</a> &amp;center) const</td></tr>
<tr class="memdesc:a65253792ad3e1fc4a83f689764d13513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the multipliers for the box constraints on the design variables; in Lagrangean relaxation they may be interpreted as primal slacks for inequality constraints.  <a href="#a65253792ad3e1fc4a83f689764d13513">More...</a><br /></td></tr>
<tr class="separator:a65253792ad3e1fc4a83f689764d13513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad171dec64fe06f5478a3ab637c484e4c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#ad171dec64fe06f5478a3ab637c484e4c">get_approximate_primal</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function) const</td></tr>
<tr class="memdesc:ad171dec64fe06f5478a3ab637c484e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the current approximate primal solution corresponding to the aggregate subgradient of the specified <em>function</em>.  <a href="#ad171dec64fe06f5478a3ab637c484e4c">More...</a><br /></td></tr>
<tr class="separator:ad171dec64fe06f5478a3ab637c484e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c96e5f61e6dc6b8223dd63760cd1ab"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#af3c96e5f61e6dc6b8223dd63760cd1ab">get_center_primal</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function) const</td></tr>
<tr class="memdesc:af3c96e5f61e6dc6b8223dd63760cd1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the primal solution corresponding to the best epsilon subgradient returned in the evaluation of the specified <em>function</em> at the current center point. If no primal data is availalbe, the function returns NULL.  <a href="#af3c96e5f61e6dc6b8223dd63760cd1ab">More...</a><br /></td></tr>
<tr class="separator:af3c96e5f61e6dc6b8223dd63760cd1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d202c95fe6d7f0917eaf93c26a95c08"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a4d202c95fe6d7f0917eaf93c26a95c08">get_candidate_primal</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function) const</td></tr>
<tr class="memdesc:a4d202c95fe6d7f0917eaf93c26a95c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the primal solution corresponding to the best epsilon subgradient returned in the evaluation of the specified <em>function</em> at the point get_candidate. If no primal data is availalbe, the function returns NULL.  <a href="#a4d202c95fe6d7f0917eaf93c26a95c08">More...</a><br /></td></tr>
<tr class="separator:a4d202c95fe6d7f0917eaf93c26a95c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50625b7cf1b360bdaeb6da1782259304"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a50625b7cf1b360bdaeb6da1782259304">set_max_modelsize</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function, int max_modelsize)</td></tr>
<tr class="memdesc:a50625b7cf1b360bdaeb6da1782259304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum number of subgradients used in forming the cutting model of the specified <em>function</em>.  <a href="#a50625b7cf1b360bdaeb6da1782259304">More...</a><br /></td></tr>
<tr class="separator:a50625b7cf1b360bdaeb6da1782259304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224631e9141104becf6419967145e657"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a224631e9141104becf6419967145e657">set_max_bundlesize</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function, int max_bundlesize)</td></tr>
<tr class="memdesc:a224631e9141104becf6419967145e657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum number of subgradients stored for use in forming the model or determining scaling information, it must be as least as large as max_modelsize (and is increased to this if not)  <a href="#a224631e9141104becf6419967145e657">More...</a><br /></td></tr>
<tr class="separator:a224631e9141104becf6419967145e657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbb757d90a17dc1dd8d2161e69fb219"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a4bbb757d90a17dc1dd8d2161e69fb219">set_bundle_parameters</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function, const <a class="el" href="classConicBundle_1_1BundleParameters.html">BundleParameters</a> &amp;params)</td></tr>
<tr class="memdesc:a4bbb757d90a17dc1dd8d2161e69fb219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum bundlesize and the maximum number of new subgradients added in a bundle update of the cutting model for the specified <em>function</em>. The meaning of this routine may differ from standard for predefined special functions with special bundle types.  <a href="#a4bbb757d90a17dc1dd8d2161e69fb219">More...</a><br /></td></tr>
<tr class="separator:a4bbb757d90a17dc1dd8d2161e69fb219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394b98321443b41195b4c08db132b3a9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classConicBundle_1_1BundleParameters.html">BundleParameters</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a394b98321443b41195b4c08db132b3a9">get_bundle_parameters</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function) const</td></tr>
<tr class="memdesc:a394b98321443b41195b4c08db132b3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves current bundle parameters (not the actual size in use!) as set for the cutting model of the specified <em>function</em>.  <a href="#a394b98321443b41195b4c08db132b3a9">More...</a><br /></td></tr>
<tr class="separator:a394b98321443b41195b4c08db132b3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6375a055ccfa09179068674683c9f25c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a6375a055ccfa09179068674683c9f25c">reinit_function_model</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function)</td></tr>
<tr class="memdesc:a6375a055ccfa09179068674683c9f25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears cutting model, subgradients and stored function values for the specified <em>function</em>.  <a href="#a6375a055ccfa09179068674683c9f25c">More...</a><br /></td></tr>
<tr class="separator:a6375a055ccfa09179068674683c9f25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addaa5dde4b8b41db39826fb5c55bf023"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#addaa5dde4b8b41db39826fb5c55bf023">call_primal_extender</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function, <a class="el" href="classConicBundle_1_1PrimalExtender.html">PrimalExtender</a> &amp;primal_extender)</td></tr>
<tr class="memdesc:addaa5dde4b8b41db39826fb5c55bf023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asks <em>function</em> to call <em>primal_extender</em> for each of its primal objects (see also <a class="el" href="classConicBundle_1_1FunctionOracle.html#a10d135676ae61d26bb068fadef2526d3" title="Called by the solver. Has to Return function value and at least one (epsilon) subgradient and...">FunctionOracle::evaluate()</a> )  <a href="#addaa5dde4b8b41db39826fb5c55bf023">More...</a><br /></td></tr>
<tr class="separator:addaa5dde4b8b41db39826fb5c55bf023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc5543b0c41336fb5469bee22ad5b13"><td class="memItemLeft" align="right" valign="top"><a id="accc5543b0c41336fb5469bee22ad5b13"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#accc5543b0c41336fb5469bee22ad5b13">get_last_weight</a> () const</td></tr>
<tr class="memdesc:accc5543b0c41336fb5469bee22ad5b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current weight for the quadratic term in the augmented subproblem (may be interpreted as 1./step_size or 1./trustregion-radius). <br /></td></tr>
<tr class="separator:accc5543b0c41336fb5469bee22ad5b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af476f042f01a7f8489afce9c1deef5d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#af476f042f01a7f8489afce9c1deef5d0">set_next_weight</a> (const double weight)</td></tr>
<tr class="memdesc:af476f042f01a7f8489afce9c1deef5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the weight (&gt;0) to be used in the quadratic term of the next augmented subproblem (may be interpreted as 1./step_size or 1./trustregion-radius).  <a href="#af476f042f01a7f8489afce9c1deef5d0">More...</a><br /></td></tr>
<tr class="separator:af476f042f01a7f8489afce9c1deef5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bcbe0a5c886dd6ef0b9c4ddab70513"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a94bcbe0a5c886dd6ef0b9c4ddab70513">set_min_weight</a> (const double min_weight)</td></tr>
<tr class="memdesc:a94bcbe0a5c886dd6ef0b9c4ddab70513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a lower bound on the weight for the quadratic term of the augmented subproblem.  <a href="#a94bcbe0a5c886dd6ef0b9c4ddab70513">More...</a><br /></td></tr>
<tr class="separator:a94bcbe0a5c886dd6ef0b9c4ddab70513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4133adf8859616fbfacd30d05655f14c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a4133adf8859616fbfacd30d05655f14c">set_max_weight</a> (const double max_weight)</td></tr>
<tr class="memdesc:a4133adf8859616fbfacd30d05655f14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an upper bound on the weight for the quadratic term of the augmented subproblem.  <a href="#a4133adf8859616fbfacd30d05655f14c">More...</a><br /></td></tr>
<tr class="separator:a4133adf8859616fbfacd30d05655f14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb99f6aee2f055ed608bd638727eab1f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#abb99f6aee2f055ed608bd638727eab1f">set_variable_metric</a> (int do_scaling)</td></tr>
<tr class="memdesc:abb99f6aee2f055ed608bd638727eab1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a scaling heuristic or switch off scaling alltogether. (the scaling heuristic resets the quadratic term to some diagonal matrix, switching it off resets the diagonal term to the identity)  <a href="#abb99f6aee2f055ed608bd638727eab1f">More...</a><br /></td></tr>
<tr class="separator:abb99f6aee2f055ed608bd638727eab1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef10d25ef69bc3f9006a630a28fdb3e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#adef10d25ef69bc3f9006a630a28fdb3e">set_active_bounds_fixing</a> (bool allow_fixing)</td></tr>
<tr class="memdesc:adef10d25ef69bc3f9006a630a28fdb3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set to true (the default is false), some variables will be fixed automatically to the center value if their bounds are strongly active (i.e., the corresponding multipliers are big).  <a href="#adef10d25ef69bc3f9006a630a28fdb3e">More...</a><br /></td></tr>
<tr class="separator:adef10d25ef69bc3f9006a630a28fdb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196e3f4ff788883b692566a5fc03277d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a196e3f4ff788883b692566a5fc03277d">clear_fail_counts</a> (void)</td></tr>
<tr class="memdesc:a196e3f4ff788883b692566a5fc03277d"><td class="mdescLeft">&#160;</td><td class="mdescRight">clears all fail counts on numerical function oder model failures, may be useful if this caused premature termination.  <a href="#a196e3f4ff788883b692566a5fc03277d">More...</a><br /></td></tr>
<tr class="separator:a196e3f4ff788883b692566a5fc03277d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc77ce922362060d1e6888bcf2122992"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#acc77ce922362060d1e6888bcf2122992">set_eval_limit</a> (int eval_limit)</td></tr>
<tr class="memdesc:acc77ce922362060d1e6888bcf2122992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an upper bound on the number of calls to the oracle (use negative numbers for no limit).  <a href="#acc77ce922362060d1e6888bcf2122992">More...</a><br /></td></tr>
<tr class="separator:acc77ce922362060d1e6888bcf2122992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56763c7f2630c796e917ab47bc9b7e74"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a56763c7f2630c796e917ab47bc9b7e74">set_inner_update_limit</a> (int update_limit)</td></tr>
<tr class="memdesc:a56763c7f2630c796e917ab47bc9b7e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an upper bound on the number of inner updates for the cutting model with primal slacks within one null step (use negative numbers for no limit).  <a href="#a56763c7f2630c796e917ab47bc9b7e74">More...</a><br /></td></tr>
<tr class="separator:a56763c7f2630c796e917ab47bc9b7e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Look Up Basic Paramaters (dimension, number of functions, ...)</div></td></tr>
<tr class="memitem:aff40f604718d557fc14879da31018a1b"><td class="memItemLeft" align="right" valign="top"><a id="aff40f604718d557fc14879da31018a1b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#aff40f604718d557fc14879da31018a1b">get_dim</a> ()</td></tr>
<tr class="memdesc:aff40f604718d557fc14879da31018a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current dimension of the design space/argument or -1 if no dimension is set. <br /></td></tr>
<tr class="separator:aff40f604718d557fc14879da31018a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07523a454248e805a26041ee0414cbbb"><td class="memItemLeft" align="right" valign="top"><a id="a07523a454248e805a26041ee0414cbbb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a07523a454248e805a26041ee0414cbbb">get_n_functions</a> ()</td></tr>
<tr class="memdesc:a07523a454248e805a26041ee0414cbbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of functions in the problem. <br /></td></tr>
<tr class="separator:a07523a454248e805a26041ee0414cbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d7a4491e3ca47a24b0e4b3c9f90003"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a34d7a4491e3ca47a24b0e4b3c9f90003">get_fixed_active_bounds</a> (<a class="el" href="group__cxxinterface.html#ga2ba782d3f05e6d9a1964638a6b97a390">IVector</a> &amp;fixed_active_bounds) const</td></tr>
<tr class="memdesc:a34d7a4491e3ca47a24b0e4b3c9f90003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the indicator vector of variables temporarily fixed to the center value due to significantly positive multipliers for the box constraints.  <a href="#a34d7a4491e3ca47a24b0e4b3c9f90003">More...</a><br /></td></tr>
<tr class="separator:a34d7a4491e3ca47a24b0e4b3c9f90003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Output</div></td></tr>
<tr class="memitem:a51a582190b7e9d8863ae1e5ff8a0779e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a51a582190b7e9d8863ae1e5ff8a0779e">set_out</a> (std::ostream *out=0, int print_level=1)</td></tr>
<tr class="memdesc:a51a582190b7e9d8863ae1e5ff8a0779e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the output level (out==NULL: no output at all, out!=NULL and level=0: errors and warnings, level&gt;0 increasingly detailed information)  <a href="#a51a582190b7e9d8863ae1e5ff8a0779e">More...</a><br /></td></tr>
<tr class="separator:a51a582190b7e9d8863ae1e5ff8a0779e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a7cbddec3dd2f8a0816b748c9b20aaffc"><td class="memItemLeft" align="right" valign="top"><a id="a7cbddec3dd2f8a0816b748c9b20aaffc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a7cbddec3dd2f8a0816b748c9b20aaffc">CBSolver</a> (const <a class="el" href="classConicBundle_1_1CBSolver.html">CBSolver</a> &amp;)</td></tr>
<tr class="memdesc:a7cbddec3dd2f8a0816b748c9b20aaffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">not available, blocked deliberately <br /></td></tr>
<tr class="separator:a7cbddec3dd2f8a0816b748c9b20aaffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0340545ef038c53dd438a07e0d71e18"><td class="memItemLeft" align="right" valign="top"><a id="ab0340545ef038c53dd438a07e0d71e18"></a>
<a class="el" href="classConicBundle_1_1CBSolver.html">CBSolver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#ab0340545ef038c53dd438a07e0d71e18">operator=</a> (const <a class="el" href="classConicBundle_1_1CBSolver.html">CBSolver</a> &amp;)</td></tr>
<tr class="memdesc:ab0340545ef038c53dd438a07e0d71e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">not available, blocked deliberately <br /></td></tr>
<tr class="separator:ab0340545ef038c53dd438a07e0d71e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a15935e276c3dc50d8d5bec35b7af4c61"><td class="memItemLeft" align="right" valign="top"><a id="a15935e276c3dc50d8d5bec35b7af4c61"></a>
<a class="el" href="classConicBundle_1_1MatrixCBSolver.html">MatrixCBSolver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html#a15935e276c3dc50d8d5bec35b7af4c61">solver</a></td></tr>
<tr class="memdesc:a15935e276c3dc50d8d5bec35b7af4c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to internal solver <br /></td></tr>
<tr class="separator:a15935e276c3dc50d8d5bec35b7af4c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Bundle method solver. </p>
<p>Minimizes the sum of convex functions that are given via <a class="el" href="classConicBundle_1_1FunctionOracle.html" title="oracle interface (abstract class). For each of your functions, provide a derived class. ">ConicBundle::FunctionOracle</a> interfaces, see <a class="el" href="group__cxxinterface.html">the text explaining the C++ interface</a> for a quick overview.</p>
<p>It provides special support for Lagrangean relaxation by generating primal approximate solutions if such information is provided in the function oracles.</p>
<p>Based on these primal approximations it is also possible to implement cutting plane schemes. Routines for adding and deleting corresponding dual variables as well as a framework for extending subgradients in order not to loose the cutting model are available. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a76de315bec233bec71b1cf9d2ed3df69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76de315bec233bec71b1cf9d2ed3df69">&#9670;&nbsp;</a></span>add_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::CBSolver::add_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a function, typically derived from <a class="el" href="classConicBundle_1_1FunctionOracle.html" title="oracle interface (abstract class). For each of your functions, provide a derived class. ">ConicBundle::FunctionOracle</a>; all functions added must have the same argument dimension. </p>
<p>Besides the standard <a class="el" href="classConicBundle_1_1FunctionOracle.html" title="oracle interface (abstract class). For each of your functions, provide a derived class. ">ConicBundle::FunctionOracle</a> the interface only accepts a few other prespecified derivations of the class <a class="el" href="classConicBundle_1_1FunctionObject.html" title="basic function object (abstract class). It serves for using the same interface on distinct oracle typ...">FunctionObject</a> that come along with the <a class="el" href="namespaceCH__Matrix__Classes.html" title="Matrix Classes and Linear Algebra. See Matrix Classes (namespace CH_Matrix_Classes) for a quick intro...">CH_Matrix_Classes</a> interface (e.g. for semidefinite and second order cones). Functions not derived from these will fail to be added and return a value !=0.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a967e2643744ed0cedd2629e289032d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967e2643744ed0cedd2629e289032d7d">&#9670;&nbsp;</a></span>append_variables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::CBSolver::append_variables </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_append</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">DVector</a> *&#160;</td>
          <td class="paramname"><em>lbounds</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">DVector</a> *&#160;</td>
          <td class="paramname"><em>ubounds</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append new variables (always in last postions in this order). </p>
<p>If 0 is feasible for the new coordinates then this is selected as starting value for the new coordinates; otherwise, the number closest to zero is used. If all new coordinates can be set to zero then it is assumed that for an existing center point the function values need not be recomputed (this is e.g. the case in Lagrangean relaxation; if this is not correct call <a class="el" href="classConicBundle_1_1CBSolver.html#a6375a055ccfa09179068674683c9f25c" title="Clears cutting model, subgradients and stored function values for the specified function. ">reinit_function_model()</a> below). Otherwise the old function values will be marked as outdated and will be recomputed at the next call to e.g. <a class="el" href="classConicBundle_1_1CBSolver.html#a208b141c3071b2e4b6c73c660db5ab84" title="solves or does a prescribed number of iterations ">solve()</a>.</p>
<dl class="section attention"><dt>Attention</dt><dd>Be sure to update your objective functions so that they can handle the new variables before you call this and any further <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> routines that require function evaluations. Also, these operations may lead to inavailability of certain other data such as subgradients and primal approximations.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n_append</td><td>(int) number of variables to append (always in last position in the same order)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lbounds</td><td>(DVector*) If NULL, all appended variables are considered unbounded below, otherwise lowerb[i] gives the minimum feasible value for variable y[i], use <a class="el" href="group__cxxinterface.html#gae58492af3631a196b0edb8a8ebcda567" title="serves as the value &quot;plus infinity&quot;, i.e., all bounds &gt;= this value are set to this value and are reg...">ConicBundle::CB_minus_infinity</a> for unbounded below.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ubounds</td><td>(DVector*) If NULL, all appended variables are considered unbounded above, otherwise upperb[i] gives the maximum feasible value for variable y[i], use <a class="el" href="group__cxxinterface.html#ga15948e7611155f822fc0331bcbb4a111" title="serves as the value &quot;minus infinity&quot;, i.e., all bounds &lt;= this value are set to this value and are re...">ConicBundle::CB_plus_infinity</a> for unbounded above.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="addaa5dde4b8b41db39826fb5c55bf023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addaa5dde4b8b41db39826fb5c55bf023">&#9670;&nbsp;</a></span>call_primal_extender()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::CBSolver::call_primal_extender </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1PrimalExtender.html">PrimalExtender</a> &amp;&#160;</td>
          <td class="paramname"><em>primal_extender</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asks <em>function</em> to call <em>primal_extender</em> for each of its primal objects (see also <a class="el" href="classConicBundle_1_1FunctionOracle.html#a10d135676ae61d26bb068fadef2526d3" title="Called by the solver. Has to Return function value and at least one (epsilon) subgradient and...">FunctionOracle::evaluate()</a> ) </p>
<p>If the function is the Lagrangian dual of a primal problem and primal_data returned previous calls to the oracle has now to be updated due to changes in the primal problem &ndash; e.g., this may happen in column generation &ndash; the call causes updates of all internally stored primal_data objects by calling <a class="el" href="classConicBundle_1_1PrimalExtender.html#a13fc586276e23d575b935dbfe12495c0" title="called by ConicBundle to update internal PrimalData objects, has to return 0 on success ...">PrimalExtender::extend</a> on each of these.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>(const <a class="el" href="classConicBundle_1_1FunctionObject.html" title="basic function object (abstract class). It serves for using the same interface on distinct oracle typ...">FunctionObject</a>&amp;) the function added in <a class="el" href="classConicBundle_1_1CBSolver.html#a76de315bec233bec71b1cf9d2ed3df69" title="Adds a function, typically derived from ConicBundle::FunctionOracle; all functions added must have th...">add_function()</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">primal_extender</td><td>(<a class="el" href="classConicBundle_1_1PrimalExtender.html" title="Interface for extending PrimalData, e.g., in Lagrangian relaxation of column generation approaches...">PrimalExtender</a>&amp;) the object holding the extension function for primal_data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>1 if for this function it is not possible to use a primal_extender</li>
<li>2 if the primal_extender would be applicable but there is no primal_data </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a196e3f4ff788883b692566a5fc03277d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a196e3f4ff788883b692566a5fc03277d">&#9670;&nbsp;</a></span>clear_fail_counts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ConicBundle::CBSolver::clear_fail_counts </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>clears all fail counts on numerical function oder model failures, may be useful if this caused premature termination. </p>

</div>
</div>
<a id="ae4162fe243fd3550c18f73730dc6ca80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4162fe243fd3550c18f73730dc6ca80">&#9670;&nbsp;</a></span>delete_variables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::CBSolver::delete_variables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxxinterface.html#ga2ba782d3f05e6d9a1964638a6b97a390">IVector</a> &amp;&#160;</td>
          <td class="paramname"><em>delete_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cxxinterface.html#ga2ba782d3f05e6d9a1964638a6b97a390">IVector</a> &amp;&#160;</td>
          <td class="paramname"><em>map_to_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes variables corresponding to the specified indices. </p>
<p>The indices of the remaining variables are reassigned so that they are consecutive again, the routine returns in <em>map_to_old</em> a vector giving for each new index of these remaining variables the old coordinate.</p>
<p>If all of the deleted variables are zero, function values are assumed to remain correct (if this is not so, call <a class="el" href="classConicBundle_1_1CBSolver.html#a6375a055ccfa09179068674683c9f25c" title="Clears cutting model, subgradients and stored function values for the specified function. ">reinit_function_model()</a> below) Otherwise the old function values will be marked as outdated and will be recomputed at the next call to e.g. <a class="el" href="classConicBundle_1_1CBSolver.html#a208b141c3071b2e4b6c73c660db5ab84" title="solves or does a prescribed number of iterations ">solve()</a>.</p>
<dl class="section attention"><dt>Attention</dt><dd>Be sure to update your objective functions so that they can handle the new variables before you call any further <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> routines that require function evaluations. Also, these operations may lead to inavailability of certain other data such as subgradients and primal approximations.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delete_indices</td><td>(const IVector&amp;) the entries delete_indices[i] specify the indices of the variables to be deleted</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">map_to_old</td><td>(IVector&amp;) after the call, element map_to_old[i] gives the old index (before the call) of the variable that now has index position i.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad171dec64fe06f5478a3ab637c484e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad171dec64fe06f5478a3ab637c484e4c">&#9670;&nbsp;</a></span>get_approximate_primal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a>* ConicBundle::CBSolver::get_approximate_primal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the current approximate primal solution corresponding to the aggregate subgradient of the specified <em>function</em>. </p>
<p><a class="el" href="classConicBundle_1_1PrimalData.html" title="In Lagrangean relaxation an approximate primal solution can be generated by supplying primal informat...">PrimalData</a> solutions must have been supplied in all previous calls to evaluate; In this case it returns the current approximate primal solution aggregated alongside with the aggregate subgradient. A primal solution may not be available after addition of constraints, if extension of the aggregate subgradient to the new coordinates failed. If no primal data is availalbe, the function returns NULL.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>pointer to the primal data of the aggregate of this function object</li>
<li>0 if no primal is available </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a65253792ad3e1fc4a83f689764d13513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65253792ad3e1fc4a83f689764d13513">&#9670;&nbsp;</a></span>get_approximate_slacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::CBSolver::get_approximate_slacks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">DVector</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the multipliers for the box constraints on the design variables; in Lagrangean relaxation they may be interpreted as primal slacks for inequality constraints. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a394b98321443b41195b4c08db132b3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394b98321443b41195b4c08db132b3a9">&#9670;&nbsp;</a></span>get_bundle_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classConicBundle_1_1BundleParameters.html">BundleParameters</a>* ConicBundle::CBSolver::get_bundle_parameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves current bundle parameters (not the actual size in use!) as set for the cutting model of the specified <em>function</em>. </p>
<p>This may differ for predefined special functions with derived BundleParameter classes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>(const <a class="el" href="classConicBundle_1_1FunctionObject.html" title="basic function object (abstract class). It serves for using the same interface on distinct oracle typ...">FunctionObject</a>&amp;) the function added in <a class="el" href="classConicBundle_1_1CBSolver.html#a76de315bec233bec71b1cf9d2ed3df69" title="Adds a function, typically derived from ConicBundle::FunctionOracle; all functions added must have th...">add_function()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if no such function or such data is available</li>
<li>otherwise a pointer to the <a class="el" href="classConicBundle_1_1BundleParameters.html" title="Serves for specifying parameters regarding the construction of cutting models. ">BundleParameters</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac2a67a949e06f72bd7c0ebb4f7dc086a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a67a949e06f72bd7c0ebb4f7dc086a">&#9670;&nbsp;</a></span>get_candidate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ConicBundle::CBSolver::get_candidate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">DVector</a> &amp;&#160;</td>
          <td class="paramname"><em>candidate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last point, the "candidate", at which the function was evaluated in <a class="el" href="classConicBundle_1_1CBSolver.html#a208b141c3071b2e4b6c73c660db5ab84" title="solves or does a prescribed number of iterations ">solve()</a>. </p>
<p>If this evaluation lead to a descent step, it is the same point as in <a class="el" href="classConicBundle_1_1CBSolver.html#aa0f91826bdb3247e7f7cdf39f9730eea" title="Returns the next center point that was produced by the latest call to solve() (in some problem modifi...">get_center()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4d202c95fe6d7f0917eaf93c26a95c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d202c95fe6d7f0917eaf93c26a95c08">&#9670;&nbsp;</a></span>get_candidate_primal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a>* ConicBundle::CBSolver::get_candidate_primal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the primal solution corresponding to the best epsilon subgradient returned in the evaluation of the specified <em>function</em> at the point get_candidate. If no primal data is availalbe, the function returns NULL. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>pointer to the primal data of the minorant returned on evaluation of this function object at the current candidate</li>
<li>0 if no primal is available </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0725a2d8d91005b1a64cf76819b18269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0725a2d8d91005b1a64cf76819b18269">&#9670;&nbsp;</a></span>get_candidate_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double ConicBundle::CBSolver::get_candidate_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the objective value computed in the last step of <a class="el" href="classConicBundle_1_1CBSolver.html#a208b141c3071b2e4b6c73c660db5ab84" title="solves or does a prescribed number of iterations ">solve()</a>, independent of whether this was a descent step or a null step (initially undefined). </p>
<p>If no problem modification routines were called since then, it is the objective value at the point returned by <a class="el" href="classConicBundle_1_1CBSolver.html#ac2a67a949e06f72bd7c0ebb4f7dc086a" title="Returns the last point, the &quot;candidate&quot;, at which the function was evaluated in solve(). ">get_candidate()</a>. If this last evaluation led to a descent step, then it is the same value as in <a class="el" href="classConicBundle_1_1CBSolver.html#a897f12f2423ac6208bb1e878c9ef566b" title="Returns the objective value resulting from last descent step (initially undefined). If no problem modification routines were called since then, it is the objective value at the point returned by get_center(). ">get_objval()</a>. </p>

</div>
</div>
<a id="aa0f91826bdb3247e7f7cdf39f9730eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f91826bdb3247e7f7cdf39f9730eea">&#9670;&nbsp;</a></span>get_center()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::CBSolver::get_center </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">DVector</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the next center point that was produced by the latest call to <a class="el" href="classConicBundle_1_1CBSolver.html#a208b141c3071b2e4b6c73c660db5ab84" title="solves or does a prescribed number of iterations ">solve()</a> (in some problem modification routines the center point may be updated immediately, in others the center point will be corrected automatically directly before starting the next descent step and its values may be infeasible till then). </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af3c96e5f61e6dc6b8223dd63760cd1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c96e5f61e6dc6b8223dd63760cd1ab">&#9670;&nbsp;</a></span>get_center_primal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a>* ConicBundle::CBSolver::get_center_primal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the primal solution corresponding to the best epsilon subgradient returned in the evaluation of the specified <em>function</em> at the current center point. If no primal data is availalbe, the function returns NULL. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>pointer to the primal data of the minorant returned on evaluation of this function object at the current center</li>
<li>0 if no primal is available </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a34d7a4491e3ca47a24b0e4b3c9f90003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d7a4491e3ca47a24b0e4b3c9f90003">&#9670;&nbsp;</a></span>get_fixed_active_bounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::CBSolver::get_fixed_active_bounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxxinterface.html#ga2ba782d3f05e6d9a1964638a6b97a390">IVector</a> &amp;&#160;</td>
          <td class="paramname"><em>fixed_active_bounds</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the indicator vector of variables temporarily fixed to the center value due to significantly positive multipliers for the box constraints. </p>
<p>Such a fixing indicates that the corresponding variables would like to stay at their bounds. There will be nonzero entries only if <a class="el" href="classConicBundle_1_1CBSolver.html#adef10d25ef69bc3f9006a630a28fdb3e" title="If set to true (the default is false), some variables will be fixed automatically to the center value...">set_active_bounds_fixing()</a> is switched on. </p>

</div>
</div>
<a id="a0c36402ee2aa2e69ea2ee0fb9aa9bbab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c36402ee2aa2e69ea2ee0fb9aa9bbab">&#9670;&nbsp;</a></span>get_subgradient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::CBSolver::get_subgradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">DVector</a> &amp;&#160;</td>
          <td class="paramname"><em>subgradient</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the latest aggregate subgradient. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aaaca3b1092a1305a8ddf4f181e1bf256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaca3b1092a1305a8ddf4f181e1bf256">&#9670;&nbsp;</a></span>init_problem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::CBSolver::init_problem </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">DVector</a> *&#160;</td>
          <td class="paramname"><em>lbounds</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">DVector</a> *&#160;</td>
          <td class="paramname"><em>ubounds</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the problem by setting up the design space (the dimension and possible box constraints of the variables) </p>
<p>Clears all data structures and sets the dimension @ m for a new problem. for solving min_{y in R^m} f_0(y) + f_1(y) + ... Box constraints may be specified for y. (The functions f_i must be added by <a class="el" href="classConicBundle_1_1CBSolver.html#a76de315bec233bec71b1cf9d2ed3df69" title="Adds a function, typically derived from ConicBundle::FunctionOracle; all functions added must have th...">add_function()</a>).</p>
<p>Lower and/or upper bounds must be speicified for all variables or for none of them. To specify no bounds at all, give Null pointers. Otherwise use <a class="el" href="group__cxxinterface.html#gae58492af3631a196b0edb8a8ebcda567" title="serves as the value &quot;plus infinity&quot;, i.e., all bounds &gt;= this value are set to this value and are reg...">ConicBundle::CB_minus_infinity</a> for unbounded below and <a class="el" href="group__cxxinterface.html#ga15948e7611155f822fc0331bcbb4a111" title="serves as the value &quot;minus infinity&quot;, i.e., all bounds &lt;= this value are set to this value and are re...">ConicBundle::CB_plus_infinity</a> for unbounded above. For NULL pointers, unbounded will be used as default for all variables. Specifying bounds selectively is also possible by <a class="el" href="classConicBundle_1_1CBSolver.html#a5b67a6c37934a2751e46d65bab8ab0c1" title="Sets lower bound for variable i, use ConicBundle::CB_minus_infinity for unbounded from below...">set_lower_bound()</a> or <a class="el" href="classConicBundle_1_1CBSolver.html#ad95faba4e7c4b3331bb5892d14516b92" title="Sets upper bound for variable i, use ConicBundle::CB_plus_infinity for unbounded from below...">set_upper_bound()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>(int) the dimension of the argument/design space/the number of Lagrange multipliers</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lbounds</td><td>(const DVector*) If NULL, all variables are considered unbounded below, otherwise lowerb[i] gives the minimum feasible value for variable y[i], use <a class="el" href="group__cxxinterface.html#gae58492af3631a196b0edb8a8ebcda567" title="serves as the value &quot;plus infinity&quot;, i.e., all bounds &gt;= this value are set to this value and are reg...">ConicBundle::CB_minus_infinity</a> for unbounded below.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ubounds</td><td>(const DVector*) If NULL, all variables are considered unbounded above, otherwise upperb[i] gives the maximum feasible value for variable y[i], use <a class="el" href="group__cxxinterface.html#ga15948e7611155f822fc0331bcbb4a111" title="serves as the value &quot;minus infinity&quot;, i.e., all bounds &lt;= this value are set to this value and are re...">ConicBundle::CB_plus_infinity</a> for unbounded above.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0bfd9aa3966862e9e001fd4a3691213f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bfd9aa3966862e9e001fd4a3691213f">&#9670;&nbsp;</a></span>print_termination_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; ConicBundle::CBSolver::print_termination_code </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a text version of termination code, see <a class="el" href="classConicBundle_1_1CBSolver.html#abb1b38a14ebbc57eb96c3207da7e6c3f" title="Returns the termination code of the bundle algorithm for the latest descent step. ...">termination_code()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aaa6b60c2cf0bdd6af826e96a14fc467b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa6b60c2cf0bdd6af826e96a14fc467b">&#9670;&nbsp;</a></span>reassign_variables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::CBSolver::reassign_variables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxxinterface.html#ga2ba782d3f05e6d9a1964638a6b97a390">IVector</a> &amp;&#160;</td>
          <td class="paramname"><em>assign_new_from_old</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reassigns variables to new index positions by mapping to position <em>i</em> the variable that previously had index <em>assign_new_from_old</em>[i]. </p>
<p>Old variables, that are not mapped to any position will be deleted. It is allowed to generate several copies of old variables.</p>
<p>If all of the deleted variables as well as new multiple copies are zero, function values are assumed to remain correct (if this is not so, call <a class="el" href="classConicBundle_1_1CBSolver.html#a6375a055ccfa09179068674683c9f25c" title="Clears cutting model, subgradients and stored function values for the specified function. ">reinit_function_model()</a> below). Otherwise the old function values will be marked as outdated and will be recomputed at the next call to e.g. <a class="el" href="classConicBundle_1_1CBSolver.html#a208b141c3071b2e4b6c73c660db5ab84" title="solves or does a prescribed number of iterations ">solve()</a>.</p>
<dl class="section attention"><dt>Attention</dt><dd>Be sure to update your objective functions so that they can handle the new variables before you call any further <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> routines that require function evaluations. Also, these operations may lead to inavailability of certain other data such as subgradients and primal approximations.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">assign_new_from_old</td><td>(const IVector&amp;) entry assign_new_from_old[i] specifies the old index of the variable, that has to be copied to index position i.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6375a055ccfa09179068674683c9f25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6375a055ccfa09179068674683c9f25c">&#9670;&nbsp;</a></span>reinit_function_model()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::CBSolver::reinit_function_model </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears cutting model, subgradients and stored function values for the specified <em>function</em>. </p>
<p>This has to be called whenever the specified function was modified so that the old subgradients and/or primal generators are no longer valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>(const <a class="el" href="classConicBundle_1_1FunctionObject.html" title="basic function object (abstract class). It serves for using the same interface on distinct oracle typ...">FunctionObject</a>&amp;) the function added in <a class="el" href="classConicBundle_1_1CBSolver.html#a76de315bec233bec71b1cf9d2ed3df69" title="Adds a function, typically derived from ConicBundle::FunctionOracle; all functions added must have th...">add_function()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="adef10d25ef69bc3f9006a630a28fdb3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef10d25ef69bc3f9006a630a28fdb3e">&#9670;&nbsp;</a></span>set_active_bounds_fixing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ConicBundle::CBSolver::set_active_bounds_fixing </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_fixing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If set to true (the default is false), some variables will be fixed automatically to the center value if their bounds are strongly active (i.e., the corresponding multipliers are big). </p>
<p>The coordinates to be fixed are redetermined in each call following a descent step or a change of the function. An indicator vector of the variables fixed in the last call can be obtained via the routine <a class="el" href="classConicBundle_1_1CBSolver.html#a34d7a4491e3ca47a24b0e4b3c9f90003" title="Returns the indicator vector of variables temporarily fixed to the center value due to significantly ...">get_fixed_active_bounds()</a>.</p>
<p>Setting this value to true might improve the performance of the algorithm in some instances but there is no convergence theory. It might be particularly helpful within Lagrangian relaxation if a primal cutting plane approach is used and non-tight inequalities should be eliminated quickly (fixing then indicates large primal slack values).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allow_fixing</td><td>(bool) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4bbb757d90a17dc1dd8d2161e69fb219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbb757d90a17dc1dd8d2161e69fb219">&#9670;&nbsp;</a></span>set_bundle_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::CBSolver::set_bundle_parameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1BundleParameters.html">BundleParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum bundlesize and the maximum number of new subgradients added in a bundle update of the cutting model for the specified <em>function</em>. The meaning of this routine may differ from standard for predefined special functions with special bundle types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>(const <a class="el" href="classConicBundle_1_1FunctionObject.html" title="basic function object (abstract class). It serves for using the same interface on distinct oracle typ...">FunctionObject</a>&amp;) the function added in <a class="el" href="classConicBundle_1_1CBSolver.html#a76de315bec233bec71b1cf9d2ed3df69" title="Adds a function, typically derived from ConicBundle::FunctionOracle; all functions added must have th...">add_function()</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>(const <a class="el" href="classConicBundle_1_1BundleParameters.html" title="Serves for specifying parameters regarding the construction of cutting models. ">BundleParameters</a>&amp;) some update parameters for the cutting model, see e.g. <a class="el" href="classConicBundle_1_1BundleParameters.html" title="Serves for specifying parameters regarding the construction of cutting models. ">ConicBundle::BundleParameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="acc77ce922362060d1e6888bcf2122992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc77ce922362060d1e6888bcf2122992">&#9670;&nbsp;</a></span>set_eval_limit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ConicBundle::CBSolver::set_eval_limit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eval_limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets an upper bound on the number of calls to the oracle (use negative numbers for no limit). </p>
<p>If this number is reached, the algorithm will terminate independently of whether the last step was a descent or a null step. A negative number will be interepreted as no limit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eval_limit</td><td>(int) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56763c7f2630c796e917ab47bc9b7e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56763c7f2630c796e917ab47bc9b7e74">&#9670;&nbsp;</a></span>set_inner_update_limit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ConicBundle::CBSolver::set_inner_update_limit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>update_limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an upper bound on the number of inner updates for the cutting model with primal slacks within one null step (use negative numbers for no limit). </p>
<p>A negative number will be interepreted as no limit, i.e., the updates will be done till a certain precision of the cutting model is achieved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">update_limit</td><td>(int) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b67a6c37934a2751e46d65bab8ab0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b67a6c37934a2751e46d65bab8ab0c1">&#9670;&nbsp;</a></span>set_lower_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::CBSolver::set_lower_bound </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets lower bound for variable i, use <a class="el" href="group__cxxinterface.html#gae58492af3631a196b0edb8a8ebcda567" title="serves as the value &quot;plus infinity&quot;, i.e., all bounds &gt;= this value are set to this value and are reg...">ConicBundle::CB_minus_infinity</a> for unbounded from below. </p>
<p>The algorithm may have to adapt the center point aftwards. In this case the old function values will be marked as outdated and will be recomputed at the next call to e.g. <a class="el" href="classConicBundle_1_1CBSolver.html#a208b141c3071b2e4b6c73c660db5ab84" title="solves or does a prescribed number of iterations ">solve()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a224631e9141104becf6419967145e657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224631e9141104becf6419967145e657">&#9670;&nbsp;</a></span>set_max_bundlesize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::CBSolver::set_max_bundlesize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_bundlesize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum number of subgradients stored for use in forming the model or determining scaling information, it must be as least as large as max_modelsize (and is increased to this if not) </p>
<p>The meaning of this routine may differ from standard for predefined special functions with special bundle types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>(const <a class="el" href="classConicBundle_1_1FunctionObject.html" title="basic function object (abstract class). It serves for using the same interface on distinct oracle typ...">FunctionObject</a>&amp;) the function added in <a class="el" href="classConicBundle_1_1CBSolver.html#a76de315bec233bec71b1cf9d2ed3df69" title="Adds a function, typically derived from ConicBundle::FunctionOracle; all functions added must have th...">add_function()</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_bundlesize</td><td>(int) maximum number of new epsilon subgradients to be used in bundle updates</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a50625b7cf1b360bdaeb6da1782259304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50625b7cf1b360bdaeb6da1782259304">&#9670;&nbsp;</a></span>set_max_modelsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::CBSolver::set_max_modelsize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_modelsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum number of subgradients used in forming the cutting model of the specified <em>function</em>. </p>
<p>Quite often a very small model, e.g., 2, yields very fast iterations and good progress in time (sometimes at the cost of more evaluations). By limited numerical experience, a significant reduction in the number of evaluations can only be expected if the bundle is large enough to wrap the function rather tightly. Quite frequently, unfortunately, this entails that solving the quadratic subproblems is more expensive than function evaluation.</p>
<p>The meaning of this routine may differ from standard for predefined special functions with special bundle types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>(const <a class="el" href="classConicBundle_1_1FunctionObject.html" title="basic function object (abstract class). It serves for using the same interface on distinct oracle typ...">FunctionObject</a>&amp;) the function added in <a class="el" href="classConicBundle_1_1CBSolver.html#a76de315bec233bec71b1cf9d2ed3df69" title="Adds a function, typically derived from ConicBundle::FunctionOracle; all functions added must have th...">add_function()</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_modelsize</td><td>(int) maximum number of subgradients to be used in forming the cutting model</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4133adf8859616fbfacd30d05655f14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4133adf8859616fbfacd30d05655f14c">&#9670;&nbsp;</a></span>set_max_weight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::CBSolver::set_max_weight </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>max_weight</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an upper bound on the weight for the quadratic term of the augmented subproblem. </p>
<p>Nonpositive values indicate no bound. The new value shows its effect only at first dynamic change of the weight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_weight</td><td>(double)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a94bcbe0a5c886dd6ef0b9c4ddab70513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bcbe0a5c886dd6ef0b9c4ddab70513">&#9670;&nbsp;</a></span>set_min_weight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::CBSolver::set_min_weight </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>min_weight</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a lower bound on the weight for the quadratic term of the augmented subproblem. </p>
<p>Nonpositive values indicate no bound. The new value shows its effect only at first dynamic change of the weight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">min_weight</td><td>(double)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8cf0a95dcbfdf10293a79f47af80b407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf0a95dcbfdf10293a79f47af80b407">&#9670;&nbsp;</a></span>set_new_center_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::CBSolver::set_new_center_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">DVector</a> &amp;&#160;</td>
          <td class="paramname"><em>center_point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the starting point/center that will be used in the next call to <a class="el" href="classConicBundle_1_1CBSolver.html#a208b141c3071b2e4b6c73c660db5ab84" title="solves or does a prescribed number of iterations ">solve()</a>. Each call to this routine causes an immediate evaluation of all oracles. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af476f042f01a7f8489afce9c1deef5d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af476f042f01a7f8489afce9c1deef5d0">&#9670;&nbsp;</a></span>set_next_weight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::CBSolver::set_next_weight </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>weight</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the weight (&gt;0) to be used in the quadratic term of the next augmented subproblem (may be interpreted as 1./step_size or 1./trustregion-radius). </p>
<p>Independent of whether the weight violates current min- and max-bounds set in <a class="el" href="classConicBundle_1_1CBSolver.html#a94bcbe0a5c886dd6ef0b9c4ddab70513" title="Sets a lower bound on the weight for the quadratic term of the augmented subproblem. ">set_min_weight()</a> and <a class="el" href="classConicBundle_1_1CBSolver.html#a4133adf8859616fbfacd30d05655f14c" title="Sets an upper bound on the weight for the quadratic term of the augmented subproblem. ">set_max_weight()</a>, the next model will be computed for this value. Thereafter, however, it will be updated as usual; in particular, it may be truncated by min and max bounds immediately after the first subproblem.</p>
<p>In order to guarantee a constant weight (e.g. 1 is frequently a reasonable choice if the automatic default heuristic performs poorly), set the min and max bounds to the same value, too.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>(double)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a51a582190b7e9d8863ae1e5ff8a0779e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a582190b7e9d8863ae1e5ff8a0779e">&#9670;&nbsp;</a></span>set_out()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConicBundle::CBSolver::set_out </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>out</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>print_level</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the output level (out==NULL: no output at all, out!=NULL and level=0: errors and warnings, level&gt;0 increasingly detailed information) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>(ostream*) direct all output to (*out). If out==NULL, there will be no output at all.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">print_level</td><td>(int)</td></tr>
  </table>
  </dd>
</dl>
<p>Output levels for print_level:</p><ul>
<li>0 ... no output except for errors and warnings</li>
<li>1 ... line summary after each descent step</li>
<li>&gt;1 ... undocumented and increasingly detailed log information. These higher levels should only be used if requested for debugging purposes.</li>
</ul>
<p>Example for level 1:</p>
<pre class="fragment">00:00:00.00 endit  1   1   1   563.    563.  39041.188  39043.162
00:00:00.00 endit  2   2   2   563.    559.  38488.165  38490.200
00:00:00.00 endit  3   3   3   56.3    555.  33014.533  33211.856
00:00:00.00 endit  4   4   4   5.63    517. -14306.459  2738.0343
00:00:00.00 endit  5   5   5   4.04    148. -2692.1131  2.2150883
00:00:00.00 endit  6   6   6   4.01    1.29  1.7908952  2.0000581
00:00:00.00 endit  7   7   7   3.95  0.0213  1.9999387  2.0000000
00:00:00.00 _endit  8   8   8   3.95 2.94e-05  2.0000000  2.0000000

Column 1      2     3   4   5    6       7       8          9
</pre><ul>
<li>Column 1: computation time in hh:mm:ss.dd,</li>
<li>Column 2: "endit" is convenient for grep and stands for "end of iteration". Iterations with <a class="el" href="classConicBundle_1_1CBSolver.html#abb1b38a14ebbc57eb96c3207da7e6c3f" title="Returns the termination code of the bundle algorithm for the latest descent step. ...">termination_code()</a>!=0 are marked with "_endit".</li>
<li>Column 3: number of descent steps</li>
<li>Column 4: number of descent and null steps. Up to initialization calls and reevaluations, this is the number of evaluation calls to the function oracles from within the bundle method. In the example all calls led to descent steps.</li>
<li>Column 5: number of innermost iterations. It differs from column 5 only in the case of variables with bounds in which case it gives the number of updates of the multipliers for the bounds (or primal slacks in Lagrangean relaxation). Exceedingly high numbers in this column indicate that some variables are constantly at their bounds and it might be possible to improve convergence by deleting them (i.e. set them as constants to this bound and remove the variable).</li>
<li>Column 6: the weight of the quadratic term in the augmented problem.</li>
<li>Column 7: the norm of the aggregate subgradient. If it is small, say below 0.1, then mostly this is good indication that the objective value is close to optimal.</li>
<li>Column 8: the value of the cutting model in the last candidate point. It is always a lower bound on the true function value in this point</li>
<li>Column 9: the objective value in the latest point that led to a descent step, i.e., the point returend by <a class="el" href="classConicBundle_1_1CBSolver.html#aa0f91826bdb3247e7f7cdf39f9730eea" title="Returns the next center point that was produced by the latest call to solve() (in some problem modifi...">get_center()</a>. Whenever <a class="el" href="classConicBundle_1_1CBSolver.html#abb1b38a14ebbc57eb96c3207da7e6c3f" title="Returns the termination code of the bundle algorithm for the latest descent step. ...">termination_code()</a> returns 0 this is also the objective value of the latest evaluation call to the function oracles and the value in the center point of the next iteration. </li>
</ul>

</div>
</div>
<a id="a219d05df5fe82c6cedb0f1203ba88afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219d05df5fe82c6cedb0f1203ba88afa">&#9670;&nbsp;</a></span>set_term_relprec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::CBSolver::set_term_relprec </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>term_relprec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the relative precision requirements for successful termination (default 1e-5). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">term_relprec</td><td>(double) The algorithm stops with termination code 1, if predicted progress for the next step is less than term_relprec times absolute function value plus one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad95faba4e7c4b3331bb5892d14516b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95faba4e7c4b3331bb5892d14516b92">&#9670;&nbsp;</a></span>set_upper_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::CBSolver::set_upper_bound </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets upper bound for variable i, use <a class="el" href="group__cxxinterface.html#ga15948e7611155f822fc0331bcbb4a111" title="serves as the value &quot;minus infinity&quot;, i.e., all bounds &lt;= this value are set to this value and are re...">ConicBundle::CB_plus_infinity</a> for unbounded from below. </p>
<p>The algorithm may have to adapt the center point aftwards. In this case the old function values will be marked as outdated and will be recomputed at the next call to e.g. <a class="el" href="classConicBundle_1_1CBSolver.html#a208b141c3071b2e4b6c73c660db5ab84" title="solves or does a prescribed number of iterations ">solve()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="abb99f6aee2f055ed608bd638727eab1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb99f6aee2f055ed608bd638727eab1f">&#9670;&nbsp;</a></span>set_variable_metric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ConicBundle::CBSolver::set_variable_metric </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>do_scaling</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use a scaling heuristic or switch off scaling alltogether. (the scaling heuristic resets the quadratic term to some diagonal matrix, switching it off resets the diagonal term to the identity) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">do_scaling</td><td>(int)<ul>
<li>0 switch off the scaling heuristic</li>
<li>1 use a diagonal scaling heuristic</li>
<li>2 use a diagonal scaling heuristic combined with one for the bounds</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a208b141c3071b2e4b6c73c660db5ab84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208b141c3071b2e4b6c73c660db5ab84">&#9670;&nbsp;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::CBSolver::solve </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxsteps</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stop_at_descent_steps</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>solves or does a prescribed number of iterations </p>
<p>Bundle methods solve a problem by a sequence of so called descent steps that actually bring progress by moving from the current "center point" to a new center with better objective. A descent step may consist of several function evaluations (null steps), that lead to no immediate progress but mainly improve a cutting model of the objective function close to the current center point. A minimizer to the model is accepted as descent step if the function value at this point satisfies a sufficient decrease criterion in comparison to the decrease predicted by the model. Having found a descent step, the next center is automatically shifted to this successful candidate. Termination criteria may stop the process of seeking for a descent step, in which case the current center is kept and the routine <a class="el" href="classConicBundle_1_1CBSolver.html#abb1b38a14ebbc57eb96c3207da7e6c3f" title="Returns the termination code of the bundle algorithm for the latest descent step. ...">termination_code()</a> returns the termination code.</p>
<p>Restarting, after each descent step, the bundle method from scratch with the new center as starting point does not endanger convergence. Therefore, a descent step is the smallest unit, after which user interaction can take place safely. To allow this there is a flag stop_at_descent_steps that will cause the code to return after the next descent step.</p>
<p>If you know what your are doing, you may also use the input parameter maxsteps to force the algorithm to return after at most maxsteps null steps. Calling <a class="el" href="classConicBundle_1_1CBSolver.html#a208b141c3071b2e4b6c73c660db5ab84" title="solves or does a prescribed number of iterations ">solve()</a> again without any intermediate problem configurations will then simply continue the process where it stopped and convergence is save. During null steps one may not decrease the weight or delete nonzero variables of the center or the current candidate!</p>
<p>In a Lagrangean relaxation cutting plane approach one may want to separate and enlarge the dimension after a certain number of null steps. In this case the code will try to preserve the model, given appropriate subgradient extension routines have been provided. If the model cannot be extended, it has to be discarded (if subgradient extension is not successful this is done automatically), and the algorithm will be restarted from the current center point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxsteps</td><td>(int) if maxsteps&gt;0 the code returns after at most so many null steps</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stop_at_descent_steps</td><td>(int) if true the code also returns whenever a descent step occured</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="abb1b38a14ebbc57eb96c3207da7e6c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb1b38a14ebbc57eb96c3207da7e6c3f">&#9670;&nbsp;</a></span>termination_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::CBSolver::termination_code </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the termination code of the bundle algorithm for the latest descent step. </p>
<p>For resetting all counters relevant for termination see <a class="el" href="classConicBundle_1_1CBSolver.html#a196e3f4ff788883b692566a5fc03277d" title="clears all fail counts on numerical function oder model failures, may be useful if this caused premat...">clear_fail_counts()</a> .</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 : Not terminated. (Continue with the next <a class="el" href="classConicBundle_1_1CBSolver.html#a208b141c3071b2e4b6c73c660db5ab84" title="solves or does a prescribed number of iterations ">solve()</a>)</li>
<li>1 : Relative precision criterion satisfied. (See <a class="el" href="classConicBundle_1_1CBSolver.html#a219d05df5fe82c6cedb0f1203ba88afa" title="Sets the relative precision requirements for successful termination (default 1e-5). ">set_term_relprec()</a>)</li>
<li>2 : Timelimit exceeded. (Currently the C interface does not offer a timelimit.)</li>
<li>4 : Maximum number of function reevaluations exceeded. (Indicates that there is a problem with one of the function oracles that seems to deliver no valid upper bounds on the true function value for descent steps)</li>
<li>8 : Maximum number of quadratic subproblem failures exceeded. (Indicates that the numerical limits of the inner quadratic programming solver are reached, no further progress expected)</li>
<li>16 : maximum number of model evaluation failures exceeded (Indicates that the numerical limits of the setup of the subproblem are reached, no further progress expected)</li>
<li>32 : maximum number of failures to increase the augmented model value exceeded (Indicates that the numerical limits of the interplay between subproblem and quadratic programming solver are reached, no further progress expected)<ul>
<li>64 : maximum number of oracle calls (function evaluations) exceeded, see <a class="el" href="classConicBundle_1_1CBSolver.html#acc77ce922362060d1e6888bcf2122992" title="Sets an upper bound on the number of calls to the oracle (use negative numbers for no limit)...">set_eval_limit()</a></li>
<li>128 : maximum number of oracle failures exceeded. This refers to function evaluations that terminate with insufficient precision but still provide a new approximate subgradient. A failure typically indicates numerical difficulties with the precision requirements. (Currently the interface does not allow to manipulate the limit, it is set to 10) </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="CBSolver_8hxx_source.html">CBSolver.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
