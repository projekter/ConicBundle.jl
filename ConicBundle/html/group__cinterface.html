<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ConicBundle: Interface to ConicBundle for the Language C</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ConicBundle
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Interface to ConicBundle for the Language C</div>  </div>
</div><!--header-->
<div class="contents">

<p>Solve <img class="formulaInl" alt="$min_{y\in\mathbf{R}^m} f_0(y) + f_1(y) + ... + f_k(y)$" src="form_111.png"/> for convex functions f_i, the y-variables may be bounded or box constrained. The most important steps are explained here. Internal details are sketched in <a class="el" href="group__internal__cinterface.html">Internal implementation of the "C" interface</a>.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga3db3fcd0373ad6168ac6a75f9f2f4291"><td class="memItemLeft" align="right" valign="top"><a id="ga3db3fcd0373ad6168ac6a75f9f2f4291"></a>
typedef struct <a class="el" href="classCB__CSolver.html">CB_CSolver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a></td></tr>
<tr class="memdesc:ga3db3fcd0373ad6168ac6a75f9f2f4291"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to a <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> problem <br /></td></tr>
<tr class="separator:ga3db3fcd0373ad6168ac6a75f9f2f4291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga494501102ced30c7e69f92670fc43d13"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga494501102ced30c7e69f92670fc43d13">cb_functionp</a>) (void *function_key, double *arg, double relprec, int max_subg, double *objective_value, int *n_subgrads, double *subg_values, double *subgradients, double *primal)</td></tr>
<tr class="memdesc:ga494501102ced30c7e69f92670fc43d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">function oracle; describe your function as a function of this type to pass it to the solver  <a href="#ga494501102ced30c7e69f92670fc43d13">More...</a><br /></td></tr>
<tr class="separator:ga494501102ced30c7e69f92670fc43d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa68f5a81ff149a7e4ff5ea5b7bef08f0"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa68f5a81ff149a7e4ff5ea5b7bef08f0">cb_subgextp</a>) (void *function_key, double *generating_primal, int n_indices, int *variable_indices, double *new_subgradient_values)</td></tr>
<tr class="memdesc:gaa68f5a81ff149a7e4ff5ea5b7bef08f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine is not needed unless variabls (constraints in Lagrangean relaxation) are added on the fly.  <a href="#gaa68f5a81ff149a7e4ff5ea5b7bef08f0">More...</a><br /></td></tr>
<tr class="separator:gaa68f5a81ff149a7e4ff5ea5b7bef08f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga807cf763dcc577a01ac76814b9c8a2bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga807cf763dcc577a01ac76814b9c8a2bc">cb_construct_problem</a> (int no_bundle)</td></tr>
<tr class="memdesc:ga807cf763dcc577a01ac76814b9c8a2bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a a new problem object and returns a pointer to it.  <a href="#ga807cf763dcc577a01ac76814b9c8a2bc">More...</a><br /></td></tr>
<tr class="separator:ga807cf763dcc577a01ac76814b9c8a2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70f97962511ee09f1456e032061d2e30"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga70f97962511ee09f1456e032061d2e30">cb_destruct_problem</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> *p)</td></tr>
<tr class="memdesc:ga70f97962511ee09f1456e032061d2e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs and frees the problem object.  <a href="#ga70f97962511ee09f1456e032061d2e30">More...</a><br /></td></tr>
<tr class="separator:ga70f97962511ee09f1456e032061d2e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b839895c52febec613647f425ebb9fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8b839895c52febec613647f425ebb9fd">cb_clear</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p)</td></tr>
<tr class="memdesc:ga8b839895c52febec613647f425ebb9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all data structures and problem information but keeps ouptut settings and algorithmic parameter settings.  <a href="#ga8b839895c52febec613647f425ebb9fd">More...</a><br /></td></tr>
<tr class="separator:ga8b839895c52febec613647f425ebb9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6c1f335e1b8ab61bb854665a03a45f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad6c1f335e1b8ab61bb854665a03a45f0">cb_set_defaults</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p)</td></tr>
<tr class="memdesc:gad6c1f335e1b8ab61bb854665a03a45f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets default values for algorithmic parameters that are not function specific (e.g., relative precision, weight and weight bounds for the augmentedproblem, etc.)  <a href="#gad6c1f335e1b8ab61bb854665a03a45f0">More...</a><br /></td></tr>
<tr class="separator:gad6c1f335e1b8ab61bb854665a03a45f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b579e5fc1a75e5bc3b61ec02c45a527"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga2b579e5fc1a75e5bc3b61ec02c45a527">cb_init_problem</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, int m, double *lowerb, double *upperb)</td></tr>
<tr class="memdesc:ga2b579e5fc1a75e5bc3b61ec02c45a527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the problem by setting the design space (the dimension and possible box constraints of the variables)  <a href="#ga2b579e5fc1a75e5bc3b61ec02c45a527">More...</a><br /></td></tr>
<tr class="separator:ga2b579e5fc1a75e5bc3b61ec02c45a527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96316b3769d671690ffddf3c0d98e7cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc">cb_add_function</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, void *function_key, <a class="el" href="group__cinterface.html#ga494501102ced30c7e69f92670fc43d13">cb_functionp</a> f, <a class="el" href="group__cinterface.html#gaa68f5a81ff149a7e4ff5ea5b7bef08f0">cb_subgextp</a> se, int primaldim)</td></tr>
<tr class="memdesc:ga96316b3769d671690ffddf3c0d98e7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the function, the sum of which should be minimized, to the problem description.  <a href="#ga96316b3769d671690ffddf3c0d98e7cc">More...</a><br /></td></tr>
<tr class="separator:ga96316b3769d671690ffddf3c0d98e7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc6ea382c7f9352615238d8913f8fbee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gafc6ea382c7f9352615238d8913f8fbee">cb_set_lower_bound</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, int i, double lower_bound)</td></tr>
<tr class="memdesc:gafc6ea382c7f9352615238d8913f8fbee"><td class="mdescLeft">&#160;</td><td class="mdescRight">set lower bound for variable i, use <a class="el" href="group__cinterface.html#ga7969bf339ee57ce667278104ad9adcf7" title="Returns the value &quot;minus infinity&quot;, i.e., all bounds &lt;= this value are set to this value and are rega...">cb_get_minus_infinity()</a> for unbounded from below.  <a href="#gafc6ea382c7f9352615238d8913f8fbee">More...</a><br /></td></tr>
<tr class="separator:gafc6ea382c7f9352615238d8913f8fbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga490345cc46c2a3cdd32741fe27234ee5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga490345cc46c2a3cdd32741fe27234ee5">cb_set_upper_bound</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, int i, double upper_bound)</td></tr>
<tr class="memdesc:ga490345cc46c2a3cdd32741fe27234ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">set upper bound for variable i, use <a class="el" href="group__cinterface.html#ga7889cf44af8cc62fbffa30f0143e1fb9" title="Returns the value &quot;plus infinity&quot;, i.e., all bounds &gt;= this value are set to this value and are regar...">cb_get_plus_infinity()</a> for unbounded above.  <a href="#ga490345cc46c2a3cdd32741fe27234ee5">More...</a><br /></td></tr>
<tr class="separator:ga490345cc46c2a3cdd32741fe27234ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga623f0cb78f14b20bf6c58db8f50a5290"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga623f0cb78f14b20bf6c58db8f50a5290">cb_append_variables</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, int n_append, double *lower_bound, double *upper_bound)</td></tr>
<tr class="memdesc:ga623f0cb78f14b20bf6c58db8f50a5290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append new variables (always in last postions in this order).  <a href="#ga623f0cb78f14b20bf6c58db8f50a5290">More...</a><br /></td></tr>
<tr class="separator:ga623f0cb78f14b20bf6c58db8f50a5290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6f318b3a93b7109393194cb9e2fa86d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa6f318b3a93b7109393194cb9e2fa86d">cb_delete_variables</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, int n_del, int *delete_indices, int *map_to_old)</td></tr>
<tr class="memdesc:gaa6f318b3a93b7109393194cb9e2fa86d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes variables corresponding to the specified indices.  <a href="#gaa6f318b3a93b7109393194cb9e2fa86d">More...</a><br /></td></tr>
<tr class="separator:gaa6f318b3a93b7109393194cb9e2fa86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga175ef1a2e40596de40cb8e62d451d20e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga175ef1a2e40596de40cb8e62d451d20e">cb_reassign_variables</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, int n_assign, int *assign_new_from_old)</td></tr>
<tr class="memdesc:ga175ef1a2e40596de40cb8e62d451d20e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reassigns variables to new index positions by mapping to position <em>i</em> the variable that previously had index <em>assign_new_from_old</em>[i].  <a href="#ga175ef1a2e40596de40cb8e62d451d20e">More...</a><br /></td></tr>
<tr class="separator:ga175ef1a2e40596de40cb8e62d451d20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e57f869702bc27ce9304f21054700b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga2e57f869702bc27ce9304f21054700b8">cb_solve</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, int maxsteps, int stop_at_descent_steps)</td></tr>
<tr class="memdesc:ga2e57f869702bc27ce9304f21054700b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">solves or does a prescribed number of  <a href="#ga2e57f869702bc27ce9304f21054700b8">More...</a><br /></td></tr>
<tr class="separator:ga2e57f869702bc27ce9304f21054700b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3b07ae3eeadb1e39f92cf054f41abd1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa3b07ae3eeadb1e39f92cf054f41abd1">cb_termination_code</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p)</td></tr>
<tr class="memdesc:gaa3b07ae3eeadb1e39f92cf054f41abd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the termination code of the bundle algorithm for the latest descent step.  <a href="#gaa3b07ae3eeadb1e39f92cf054f41abd1">More...</a><br /></td></tr>
<tr class="separator:gaa3b07ae3eeadb1e39f92cf054f41abd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb69b4a3769e26ce8e72fadb68cf0b6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gacb69b4a3769e26ce8e72fadb68cf0b6b">cb_print_termination_code</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p)</td></tr>
<tr class="memdesc:gacb69b4a3769e26ce8e72fadb68cf0b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a text version of termination code, see <a class="el" href="group__cinterface.html#gaa3b07ae3eeadb1e39f92cf054f41abd1" title="Returns the termination code of the bundle algorithm for the latest descent step. ...">cb_termination_code()</a>.  <a href="#gacb69b4a3769e26ce8e72fadb68cf0b6b">More...</a><br /></td></tr>
<tr class="separator:gacb69b4a3769e26ce8e72fadb68cf0b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c2bc6d66d23d5a335d5694727797a31"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6c2bc6d66d23d5a335d5694727797a31">cb_get_objval</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p)</td></tr>
<tr class="memdesc:ga6c2bc6d66d23d5a335d5694727797a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the objective value resulting from last descent step (initially undefined).  <a href="#ga6c2bc6d66d23d5a335d5694727797a31">More...</a><br /></td></tr>
<tr class="separator:ga6c2bc6d66d23d5a335d5694727797a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14ae01f65c97695217a9144638970eb6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga14ae01f65c97695217a9144638970eb6">cb_get_center</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, double *center)</td></tr>
<tr class="memdesc:ga14ae01f65c97695217a9144638970eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next center point that was produced by the last call to cb_do_descent_step (in some problem modification routines the center point may be updated immediately, in others the center point will be corrected automatically directly before starting the next descent step and its values may be infeasible till then).  <a href="#ga14ae01f65c97695217a9144638970eb6">More...</a><br /></td></tr>
<tr class="separator:ga14ae01f65c97695217a9144638970eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6726b5f928d838ad359cbb69fdc5e0b0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6726b5f928d838ad359cbb69fdc5e0b0">cb_get_sgnorm</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p)</td></tr>
<tr class="memdesc:ga6726b5f928d838ad359cbb69fdc5e0b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Euclidean norm of the latest aggregate subgradient.  <a href="#ga6726b5f928d838ad359cbb69fdc5e0b0">More...</a><br /></td></tr>
<tr class="separator:ga6726b5f928d838ad359cbb69fdc5e0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga896e34b83c271271169057668f1c44c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga896e34b83c271271169057668f1c44c7">cb_get_subgradient</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, double *subgradient)</td></tr>
<tr class="memdesc:ga896e34b83c271271169057668f1c44c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the latest aggregate subgradient.  <a href="#ga896e34b83c271271169057668f1c44c7">More...</a><br /></td></tr>
<tr class="separator:ga896e34b83c271271169057668f1c44c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95296a6cd39a49c689bc6179653805a0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga95296a6cd39a49c689bc6179653805a0">cb_get_candidate_value</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p)</td></tr>
<tr class="memdesc:ga95296a6cd39a49c689bc6179653805a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the objective value computed in the last step of do_descent_step(), independent of whether this was a descent step or a null step (initially undefined).  <a href="#ga95296a6cd39a49c689bc6179653805a0">More...</a><br /></td></tr>
<tr class="separator:ga95296a6cd39a49c689bc6179653805a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61d22658a33503ff35b5972e10cf6651"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga61d22658a33503ff35b5972e10cf6651">cb_get_candidate</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, double *candidate)</td></tr>
<tr class="memdesc:ga61d22658a33503ff35b5972e10cf6651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last point, the "candidate", at which the function was evaluated in cb_do_descent_step().  <a href="#ga61d22658a33503ff35b5972e10cf6651">More...</a><br /></td></tr>
<tr class="separator:ga61d22658a33503ff35b5972e10cf6651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65b10cf79c9523c122369a37ad4eee67"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga65b10cf79c9523c122369a37ad4eee67">cb_set_term_relprec</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, double term_relprec)</td></tr>
<tr class="memdesc:ga65b10cf79c9523c122369a37ad4eee67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the relative precision requirements for successful termination (default 1e-5).  <a href="#ga65b10cf79c9523c122369a37ad4eee67">More...</a><br /></td></tr>
<tr class="separator:ga65b10cf79c9523c122369a37ad4eee67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45bdcc8c58aa94a1b8231bf38f1d8097"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga45bdcc8c58aa94a1b8231bf38f1d8097">cb_set_new_center_point</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, double *center)</td></tr>
<tr class="memdesc:ga45bdcc8c58aa94a1b8231bf38f1d8097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the starting point/center that will be used in the next call to cb_do_descent_step(). Each call to this routine causes an immediate evaluation of all oracles.  <a href="#ga45bdcc8c58aa94a1b8231bf38f1d8097">More...</a><br /></td></tr>
<tr class="separator:ga45bdcc8c58aa94a1b8231bf38f1d8097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5043cc3bcf11c4e5df41563da73d524"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae5043cc3bcf11c4e5df41563da73d524">cb_get_function_status</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, void *function_key)</td></tr>
<tr class="memdesc:gae5043cc3bcf11c4e5df41563da73d524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the return value of the latest evaluation call to the function with this <em>function_key</em>.  <a href="#gae5043cc3bcf11c4e5df41563da73d524">More...</a><br /></td></tr>
<tr class="separator:gae5043cc3bcf11c4e5df41563da73d524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ef418836d555c0b55bd9f198109e61d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga3ef418836d555c0b55bd9f198109e61d">cb_get_approximate_slacks</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, double *slacks)</td></tr>
<tr class="memdesc:ga3ef418836d555c0b55bd9f198109e61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the multipliers for the bound constraints on the design variables; in Lagrangean relaxation they may be interpreted as primal slacks for inequality constraints.  <a href="#ga3ef418836d555c0b55bd9f198109e61d">More...</a><br /></td></tr>
<tr class="separator:ga3ef418836d555c0b55bd9f198109e61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32cd4b02ba0eac656f5970f64daf68c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga32cd4b02ba0eac656f5970f64daf68c3">cb_get_approximate_primal</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, void *function_key, double *primal)</td></tr>
<tr class="memdesc:ga32cd4b02ba0eac656f5970f64daf68c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current approximate primal solution for the function having this <em>function_key</em>.  <a href="#ga32cd4b02ba0eac656f5970f64daf68c3">More...</a><br /></td></tr>
<tr class="separator:ga32cd4b02ba0eac656f5970f64daf68c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga499088981d7a12f5f86c8cac6e8000c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga499088981d7a12f5f86c8cac6e8000c7">cb_get_center_primal</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, void *function_key, double *primal)</td></tr>
<tr class="memdesc:ga499088981d7a12f5f86c8cac6e8000c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the best primal solution obtained in the current center point in evaluating the function having this <em>function_key</em>.  <a href="#ga499088981d7a12f5f86c8cac6e8000c7">More...</a><br /></td></tr>
<tr class="separator:ga499088981d7a12f5f86c8cac6e8000c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20b777b524d15f9e4efd6cc931766eee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga20b777b524d15f9e4efd6cc931766eee">cb_get_candidate_primal</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, void *function_key, double *primal)</td></tr>
<tr class="memdesc:ga20b777b524d15f9e4efd6cc931766eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the best primal solution returned by the last evaluation of the function having this <em>function_key</em> in the point <a class="el" href="group__cinterface.html#ga61d22658a33503ff35b5972e10cf6651" title="Returns the last point, the &quot;candidate&quot;, at which the function was evaluated in cb_do_descent_step()...">cb_get_candidate()</a>.  <a href="#ga20b777b524d15f9e4efd6cc931766eee">More...</a><br /></td></tr>
<tr class="separator:ga20b777b524d15f9e4efd6cc931766eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e0f7c1a6499fa28d1ee5db96b6ef015"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9e0f7c1a6499fa28d1ee5db96b6ef015">cb_set_max_modelsize</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, void *function_key, int modelsize)</td></tr>
<tr class="memdesc:ga9e0f7c1a6499fa28d1ee5db96b6ef015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum number of subgradients used in forming the cutting model of the function having this <em>function_key</em>.  <a href="#ga9e0f7c1a6499fa28d1ee5db96b6ef015">More...</a><br /></td></tr>
<tr class="separator:ga9e0f7c1a6499fa28d1ee5db96b6ef015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9e6845864cff4362f0401658062461c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab9e6845864cff4362f0401658062461c">cb_set_max_bundlesize</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, void *function_key, int bundlesize)</td></tr>
<tr class="memdesc:gab9e6845864cff4362f0401658062461c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum number of subgradients stored for use in forming the model or determining metric information of the function having this <em>function_key</em>. it must be as least as large as max_modelsize (and is increased to this if not)  <a href="#gab9e6845864cff4362f0401658062461c">More...</a><br /></td></tr>
<tr class="separator:gab9e6845864cff4362f0401658062461c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf987af753c04154797c76bdae54e595"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaaf987af753c04154797c76bdae54e595">cb_set_max_new_subgradients</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, void *function_key, int max_new_subg)</td></tr>
<tr class="memdesc:gaaf987af753c04154797c76bdae54e595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum number of epsilon subgradients that can be returned in one call to the function having this <em>function_key</em>.  <a href="#gaaf987af753c04154797c76bdae54e595">More...</a><br /></td></tr>
<tr class="separator:gaaf987af753c04154797c76bdae54e595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6155b2615f063893969aeddba5525bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac6155b2615f063893969aeddba5525bc">cb_get_bundle_parameters</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, void *function_key, int *max_modelsize, int *max_bundelsize)</td></tr>
<tr class="memdesc:gac6155b2615f063893969aeddba5525bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the two bundle parameters specified in the routines <a class="el" href="group__cinterface.html#ga9e0f7c1a6499fa28d1ee5db96b6ef015" title="Sets the maximum number of subgradients used in forming the cutting model of the function having this...">cb_set_max_modelsize()</a> and <a class="el" href="group__cinterface.html#gab9e6845864cff4362f0401658062461c" title="Sets the maximum number of subgradients stored for use in forming the model or determining metric inf...">cb_set_max_bundlesize()</a>. for the function having this <em>function_key</em>.  <a href="#gac6155b2615f063893969aeddba5525bc">More...</a><br /></td></tr>
<tr class="separator:gac6155b2615f063893969aeddba5525bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga987d2a140fe4660ae228b20bee8320d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga987d2a140fe4660ae228b20bee8320d8">cb_reinit_function_model</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, void *function_key)</td></tr>
<tr class="memdesc:ga987d2a140fe4660ae228b20bee8320d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears cutting model, subgradients and stored function values for the function with this <em>function_key</em>.  <a href="#ga987d2a140fe4660ae228b20bee8320d8">More...</a><br /></td></tr>
<tr class="separator:ga987d2a140fe4660ae228b20bee8320d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42edf299547b8b9c232ea26ee3b3a923"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga42edf299547b8b9c232ea26ee3b3a923">cb_get_last_weight</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p)</td></tr>
<tr class="memdesc:ga42edf299547b8b9c232ea26ee3b3a923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current weight for the quadratic term in the augmented subproblem (may be interpreted as 1./step_size or 1./trustregion-radius).  <a href="#ga42edf299547b8b9c232ea26ee3b3a923">More...</a><br /></td></tr>
<tr class="separator:ga42edf299547b8b9c232ea26ee3b3a923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga412e288c208f049f49024e51198d3e4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga412e288c208f049f49024e51198d3e4b">cb_set_next_weight</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, double weight)</td></tr>
<tr class="memdesc:ga412e288c208f049f49024e51198d3e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the weight (&gt;0) to be used in the quadratic term of the next augmented subproblem (may be interpreted as 1./step_size or 1./trustregion-radius).  <a href="#ga412e288c208f049f49024e51198d3e4b">More...</a><br /></td></tr>
<tr class="separator:ga412e288c208f049f49024e51198d3e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a68aaafcf76054d085266b009f4cd4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga2a68aaafcf76054d085266b009f4cd4c">cb_set_min_weight</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, double min_weight)</td></tr>
<tr class="memdesc:ga2a68aaafcf76054d085266b009f4cd4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a lower bound on the weight for the quadratic term of the augmented subproblem.  <a href="#ga2a68aaafcf76054d085266b009f4cd4c">More...</a><br /></td></tr>
<tr class="separator:ga2a68aaafcf76054d085266b009f4cd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7940fa588317bdd3837bb448871a66e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab7940fa588317bdd3837bb448871a66e">cb_set_max_weight</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, double max_weight)</td></tr>
<tr class="memdesc:gab7940fa588317bdd3837bb448871a66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an upper bound on the weight for the quadratic term of the augmented subproblem.  <a href="#gab7940fa588317bdd3837bb448871a66e">More...</a><br /></td></tr>
<tr class="separator:gab7940fa588317bdd3837bb448871a66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dace07373eaf106efcd057ec7c66722"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4dace07373eaf106efcd057ec7c66722">cb_set_variable_metric</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, int do_variable_metric)</td></tr>
<tr class="memdesc:ga4dace07373eaf106efcd057ec7c66722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a variable metric heuristic or switch it off alltogether. (the variable metric heuristic resets the quadratic term to some diagonal or low rank matrix, switching it off resets the proximal term to the identity)  <a href="#ga4dace07373eaf106efcd057ec7c66722">More...</a><br /></td></tr>
<tr class="separator:ga4dace07373eaf106efcd057ec7c66722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf08ea1cf2327669c3f4dcf455800238"><td class="memItemLeft" align="right" valign="top"><a id="gacf08ea1cf2327669c3f4dcf455800238"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gacf08ea1cf2327669c3f4dcf455800238">cb_get_dim</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p)</td></tr>
<tr class="memdesc:gacf08ea1cf2327669c3f4dcf455800238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current dimension of the design space/argument or -1 if no dimension is set. <br /></td></tr>
<tr class="separator:gacf08ea1cf2327669c3f4dcf455800238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48db88979f8c94b0feca1d62ab4a41b4"><td class="memItemLeft" align="right" valign="top"><a id="ga48db88979f8c94b0feca1d62ab4a41b4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga48db88979f8c94b0feca1d62ab4a41b4">cb_get_n_functions</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p)</td></tr>
<tr class="memdesc:ga48db88979f8c94b0feca1d62ab4a41b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of functions in the problem. <br /></td></tr>
<tr class="separator:ga48db88979f8c94b0feca1d62ab4a41b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7969bf339ee57ce667278104ad9adcf7"><td class="memItemLeft" align="right" valign="top"><a id="ga7969bf339ee57ce667278104ad9adcf7"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7969bf339ee57ce667278104ad9adcf7">cb_get_minus_infinity</a> (void)</td></tr>
<tr class="memdesc:ga7969bf339ee57ce667278104ad9adcf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value "minus infinity", i.e., all bounds &lt;= this value are set to this value and are regarded as minus infinity. <br /></td></tr>
<tr class="separator:ga7969bf339ee57ce667278104ad9adcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7889cf44af8cc62fbffa30f0143e1fb9"><td class="memItemLeft" align="right" valign="top"><a id="ga7889cf44af8cc62fbffa30f0143e1fb9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7889cf44af8cc62fbffa30f0143e1fb9">cb_get_plus_infinity</a> (void)</td></tr>
<tr class="memdesc:ga7889cf44af8cc62fbffa30f0143e1fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value "plus infinity", i.e., all bounds &gt;= this value are set to this value and are regarded as plus infinity. <br /></td></tr>
<tr class="separator:ga7889cf44af8cc62fbffa30f0143e1fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6374cbb172eac48e21c1838a74f4da0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6374cbb172eac48e21c1838a74f4da0b">cb_clear_fail_counts</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p)</td></tr>
<tr class="memdesc:ga6374cbb172eac48e21c1838a74f4da0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">clears all fail counts on numerical function oder model failures, may be useful if this caused premature termination.  <a href="#ga6374cbb172eac48e21c1838a74f4da0b">More...</a><br /></td></tr>
<tr class="separator:ga6374cbb172eac48e21c1838a74f4da0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78da3da3e172d97d3ce16f151c91da8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga78da3da3e172d97d3ce16f151c91da8d">cb_set_eval_limit</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, int eval_limit)</td></tr>
<tr class="memdesc:ga78da3da3e172d97d3ce16f151c91da8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an upper bound on the number of calls to the oracle (use negative numbers for no limit).  <a href="#ga78da3da3e172d97d3ce16f151c91da8d">More...</a><br /></td></tr>
<tr class="separator:ga78da3da3e172d97d3ce16f151c91da8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga875c9bcc1eb3028c633c0b31415dc01c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga875c9bcc1eb3028c633c0b31415dc01c">cb_set_inner_update_limit</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, int update_limit)</td></tr>
<tr class="memdesc:ga875c9bcc1eb3028c633c0b31415dc01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an upper bound on the number of inner updates for the cutting model with primal slacks within one null step (use negative numbers for no limit).  <a href="#ga875c9bcc1eb3028c633c0b31415dc01c">More...</a><br /></td></tr>
<tr class="separator:ga875c9bcc1eb3028c633c0b31415dc01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a51b181c4a0488a950edb196e8984f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4a51b181c4a0488a950edb196e8984f8">cb_set_active_bounds_fixing</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, int allow_fixing)</td></tr>
<tr class="memdesc:ga4a51b181c4a0488a950edb196e8984f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set to true (the default is false), some variables will be fixed automatically to the center value if their bounds are strongly active (i.e., the corresponding multipliers are big).  <a href="#ga4a51b181c4a0488a950edb196e8984f8">More...</a><br /></td></tr>
<tr class="separator:ga4a51b181c4a0488a950edb196e8984f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7eb3329ed2d6e4bcc66178ac067dc87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad7eb3329ed2d6e4bcc66178ac067dc87">cb_get_fixed_active_bounds</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, int *indicator)</td></tr>
<tr class="memdesc:gad7eb3329ed2d6e4bcc66178ac067dc87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the indicator vector of variables temporarily fixed to the center value due to significantly positive multipliers for the box constraints, see <a class="el" href="group__cinterface.html#ga4a51b181c4a0488a950edb196e8984f8" title="If set to true (the default is false), some variables will be fixed automatically to the center value...">cb_set_active_bounds_fixing()</a>.  <a href="#gad7eb3329ed2d6e4bcc66178ac067dc87">More...</a><br /></td></tr>
<tr class="separator:gad7eb3329ed2d6e4bcc66178ac067dc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb3888ddf0640bef9fc5e460fc81a32e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gafb3888ddf0640bef9fc5e460fc81a32e">cb_set_print_level</a> (<a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, int pril)</td></tr>
<tr class="memdesc:gafb3888ddf0640bef9fc5e460fc81a32e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the output level (&lt;0 no output at all, =0 errors and warnings, &gt;0 increasingly detailed information)  <a href="#gafb3888ddf0640bef9fc5e460fc81a32e">More...</a><br /></td></tr>
<tr class="separator:gafb3888ddf0640bef9fc5e460fc81a32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Solve <img class="formulaInl" alt="$min_{y\in\mathbf{R}^m} f_0(y) + f_1(y) + ... + f_k(y)$" src="form_111.png"/> for convex functions f_i, the y-variables may be bounded or box constrained. The most important steps are explained here. Internal details are sketched in <a class="el" href="group__internal__cinterface.html">Internal implementation of the "C" interface</a>. </p>
<p><b>Setting up the Problem, the Functions, and the Main Loop</b></p>
<p>First open a new problem by calling cb_construct_problem(0) [use cb_construct_prolbem(1) in order to employ a minimal bundle solver with just one aggregate and one new subgradient in each iteration; this is an attractive choice, if fast iterations and/or little memory consumption are of special importance]. The returned pointer of type <a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291" title="pointer to a ConicBundle problem ">cb_problemp</a> will be needed for every manipulation of this problem. Once you are done with the problem, however, do not forget to destroy this pointer with <a class="el" href="group__cinterface.html#ga70f97962511ee09f1456e032061d2e30" title="Destructs and frees the problem object. ">cb_destruct_problem()</a>.</p>
<p>Next, set the dimension of the design variables/argument as well as possible box constraints on these by the function <a class="el" href="group__cinterface.html#ga2b579e5fc1a75e5bc3b61ec02c45a527" title="Initializes the problem by setting the design space (the dimension and possible box constraints of th...">cb_init_problem()</a>.</p>
<p>Now set up your functions f_i as functions of type <a class="el" href="group__cinterface.html#ga494501102ced30c7e69f92670fc43d13" title="function oracle; describe your function as a function of this type to pass it to the solver ...">cb_functionp</a>. Via these functions you will supply, for a given argument, the function value and a subgradient (=the gradient if the function is differentiable) to the solver.</p>
<p>The <a class="el" href="group__cinterface.html#ga494501102ced30c7e69f92670fc43d13" title="function oracle; describe your function as a function of this type to pass it to the solver ...">cb_functionp</a> representations have to be added to the solver using the routine <a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description. ">cb_add_function()</a>.</p>
<p>Once all functions are added, the optimization process can be started. If you know a good starting point then set it with <a class="el" href="group__cinterface.html#ga45bdcc8c58aa94a1b8231bf38f1d8097" title="Set the starting point/center that will be used in the next call to cb_do_descent_step(). Each call to this routine causes an immediate evaluation of all oracles. ">cb_set_new_center_point()</a> now, otherwise the method will pick the zero vector or, in the case of box constraints, the point closest to zero as starting point.</p>
<p>Finally, set up a loop that calls cb_do_descent_step() until <a class="el" href="group__cinterface.html#gaa3b07ae3eeadb1e39f92cf054f41abd1" title="Returns the termination code of the bundle algorithm for the latest descent step. ...">cb_termination_code()</a> is nonzero.</p>
<p><b>Setting up the Problem, the Functions, and the Main Loop</b></p>
<p>After the first call to cb_do_descent_step() you can retrieve, at any time, the current objective value by <a class="el" href="group__cinterface.html#ga6c2bc6d66d23d5a335d5694727797a31" title="Returns the objective value resulting from last descent step (initially undefined). ">cb_get_objval()</a> and the argument leading to this value by <a class="el" href="group__cinterface.html#ga14ae01f65c97695217a9144638970eb6" title="Returns the next center point that was produced by the last call to cb_do_descent_step (in some probl...">cb_get_center()</a>. For some screen output, use <a class="el" href="group__cinterface.html#gafb3888ddf0640bef9fc5e460fc81a32e" title="Specifies the output level (&lt;0 no output at all, =0 errors and warnings, &gt;0 increasingly detailed inf...">cb_set_print_level()</a>.</p>
<p><b>Lagrangean Relaxation, Primal Approximations, and Cutting Planes</b></p>
<p>If you are optimizing a Lagrangean relaxation, you might be interested in getting an approximation to your primal optimal solution. This can be done by specifying in each function for each (epsilon) subgradient the corresponding primal vectors that generate it, see <a class="el" href="group__cinterface.html#ga494501102ced30c7e69f92670fc43d13" title="function oracle; describe your function as a function of this type to pass it to the solver ...">cb_functionp</a> and <a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description. ">cb_add_function()</a> as a start. Then for each of your functions, you can retrieve the current primal approximation using <a class="el" href="group__cinterface.html#ga32cd4b02ba0eac656f5970f64daf68c3" title="Returns the current approximate primal solution for the function having this function_key. ">cb_get_approximate_primal()</a>.</p>
<p>If, in addition, you plan to improve your primal relaxation via cutting planes, that are strongly violated by the current primal approximation, you should have a look at <a class="el" href="group__cinterface.html#ga623f0cb78f14b20bf6c58db8f50a5290" title="Append new variables (always in last postions in this order). ">cb_append_variables()</a>, <a class="el" href="group__cinterface.html#gaa68f5a81ff149a7e4ff5ea5b7bef08f0" title="This routine is not needed unless variabls (constraints in Lagrangean relaxation) are added on the fl...">cb_subgextp</a>, <a class="el" href="group__cinterface.html#ga987d2a140fe4660ae228b20bee8320d8" title="Clears cutting model, subgradients and stored function values for the function with this function_key...">cb_reinit_function_model()</a>, <a class="el" href="group__cinterface.html#ga3ef418836d555c0b55bd9f198109e61d" title="Returns the multipliers for the bound constraints on the design variables; in Lagrangean relaxation t...">cb_get_approximate_slacks()</a>, and <a class="el" href="group__cinterface.html#gaa6f318b3a93b7109393194cb9e2fa86d" title="Deletes variables corresponding to the specified indices. ">cb_delete_variables()</a>.</p>
<div class="fragment"><div class="line"><span class="comment">/******************************************************************************/</span></div><div class="line"><span class="comment">/*        Miniature Example in C for Convex Quadratic in Two Variables        */</span> </div><div class="line"><span class="comment">/******************************************************************************/</span></div><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="cb__cinterface_8h.html">cb_cinterface.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="comment">/* f(x)=.5*x^TAx+b^Tx+c with A=[5 1;1 4], b=[-12;-10], c=3 */</span>  </div><div class="line"><span class="keywordtype">int</span> eval_fun( <span class="keywordtype">void</span>* function_key, <span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> relprec, <span class="keywordtype">int</span> max_new_subg,</div><div class="line">              <span class="keywordtype">double</span> *objective_value,</div><div class="line">              <span class="keywordtype">int</span>* new_subg,<span class="keywordtype">double</span> *subgval,<span class="keywordtype">double</span> *subgradient,<span class="keywordtype">double</span> *primal)</div><div class="line">{</div><div class="line">  <span class="comment">/* compute objective */</span></div><div class="line">  *objective_value=.5*(5*x[0]*x[0]+2*x[0]*x[1]+4*x[1]*x[1])-12*x[0]-10*x[1]+3;</div><div class="line">  <span class="comment">/* compute and store one subgradient(=gradient) with two coordinates */</span></div><div class="line">  *new_subg=1;</div><div class="line">  subgval[0]=*objective_value;</div><div class="line">  subgradient[0]=(5*x[0]+x[1])-12;</div><div class="line">  subgradient[1]=(x[0]+4*x[1])-10;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">  <a class="code" href="classCB__CSolver.html">cb_problemp</a> p;</div><div class="line">  <span class="keywordtype">double</span> x[2];</div><div class="line"></div><div class="line">  p=<a class="code" href="group__cinterface.html#ga807cf763dcc577a01ac76814b9c8a2bc">cb_construct_problem</a>(0);   <span class="comment">/* generate new problem */</span></div><div class="line">  <a class="code" href="group__cinterface.html#ga2b579e5fc1a75e5bc3b61ec02c45a527">cb_init_problem</a>(p,2,0,0);    <span class="comment">/* 2 variables, no bounds */</span></div><div class="line">  <a class="code" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc">cb_add_function</a>(p,(<span class="keywordtype">void</span> *)eval_fun,eval_fun,0,0);  <span class="comment">/* no extensions, no primal */</span>    </div><div class="line">  <a class="code" href="group__cinterface.html#gafb3888ddf0640bef9fc5e460fc81a32e">cb_set_print_level</a>(p,1);</div><div class="line"></div><div class="line">  <a class="code" href="group__cinterface.html#ga65b10cf79c9523c122369a37ad4eee67">cb_set_term_relprec</a>(p,1e-8); <span class="comment">/* set realtive precision */</span></div><div class="line"></div><div class="line">  <a class="code" href="group__cinterface.html#ga2e57f869702bc27ce9304f21054700b8">cb_solve</a>(p,0,0);             <span class="comment">/* minimize the function up to termination */</span></div><div class="line"></div><div class="line">  <a class="code" href="group__cinterface.html#gacb69b4a3769e26ce8e72fadb68cf0b6b">cb_print_termination_code</a>(p);</div><div class="line"></div><div class="line">  <a class="code" href="group__cinterface.html#ga14ae01f65c97695217a9144638970eb6">cb_get_center</a>(p,x);          <span class="comment">/* retrieve the computed solution */</span></div><div class="line">  printf(<span class="stringliteral">&quot;x0=%lf, x1=%lf, objval=%lf\n&quot;</span>,x[0],x[1],<a class="code" href="group__cinterface.html#ga6c2bc6d66d23d5a335d5694727797a31">cb_get_objval</a>(p));</div><div class="line"></div><div class="line">  <a class="code" href="group__cinterface.html#ga70f97962511ee09f1456e032061d2e30">cb_destruct_problem</a>(&amp;p);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <h2 class="groupheader">Typedef Documentation</h2>
<a id="ga494501102ced30c7e69f92670fc43d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga494501102ced30c7e69f92670fc43d13">&#9670;&nbsp;</a></span>cb_functionp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* cb_functionp) ( void *function_key, double *arg, double relprec, int max_subg, double *objective_value, int *n_subgrads, double *subg_values, double *subgradients, double *primal)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function oracle; describe your function as a function of this type to pass it to the solver </p>
<p>The oracle interface is used to describe a convex function. The dimension of the argument vector of the function must be set in <a class="el" href="group__cinterface.html#ga2b579e5fc1a75e5bc3b61ec02c45a527" title="Initializes the problem by setting the design space (the dimension and possible box constraints of th...">cb_init_problem()</a>, let it be m in the following.</p>
<p>If the sum of several such functions is to be minimized, it is the task of the user to guarantee that all dimensions match.</p>
<p>In many applications, computing the function value is an iterative process that approaches the true function value from below. The code offers a bound for the function value, above which it is certain that the code will reject the current point. If in the iterative process a lower bound on the function value exceeds this bound, then it is sufficient to return, instead of the true function value and a subgradient, the current lower bound and a vector so that together they describe a supporting hyperplane (an epsilon subgradient, lying completely below the function) to the function at this point.</p>
<p>If the function corresponds to Lagrangean relaxation of a primal maximization problem one may want to generate a primal approximate solution. In this case, set in <a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description. ">cb_add_function()</a> the desired primal dimension. Then the solver will provide memory in primal for returning in the function the generating primal vectos for each subgradient. If the primal dimension is set to zero, primal will be NULL and no aggregation takes place.</p>
<p>If primal aggregation is used then it is possible to implement a primal cutting plane framework. This requires the introduction of new (dual) variables in the design space of the function. In this case a function of type <a class="el" href="group__cinterface.html#gaa68f5a81ff149a7e4ff5ea5b7bef08f0" title="This routine is not needed unless variabls (constraints in Lagrangean relaxation) are added on the fl...">cb_subgextp</a> (see below) should be provided for filling in the missing coordinates in existing subgradients. This function need not be specified even if constraints are added, but then the cutting model of the objective is lost at each addition of constraints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function_key</td><td>void pointer supplied by the user on entering the function. May be useful if multiple copies of the same function are used with parameters</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>(pointer to double array of length m) argument of the function (e.g. the Lagrange multipliers)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relprec</td><td>relative precision requirement for objective values that may lead to descent steps (this precision is not required if it is already certain that the function value will be too poor)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_subg</td><td>at most <em>max_subg</em> epsilon-<em>subgradients</em> and <em>subg_values</em> may be returned, but at least one must be returned!</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">objective_value</td><td>(pointer to a double of the caller)<ul>
<li>on input: value gives the threshold for a null step; you may stop, if a cutting plane yields at least this;</li>
<li>on output: return an upper bound on the true function value within <em>relprec</em> *(abs(objval)+1.), if there is no hyperplane cutting above the threshold specified in objective_value on input. Otherwise the return value should be the max of subg_values.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n_subgrads</td><td>(pointer to an int of the caller) give the number of epsilon-<em>subgradients</em> returned</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">subg_values</td><td>(pointer to double array of length <em>max_subg</em>, memory already provided by caller) store for each epsilon subgradient the value at the argument</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">subgradients</td><td>(pointer to double array of length <em>max_subg</em> * m, memory already provided by caller) Format: s1y1,...,s1ym,s2y1,...,s2ym,... (siyj = coefficient of subgradient i at y-coordinate j)</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">primal</td><td>(pointer to double array, may be NULL or memory of length n*max_subgalready provided by caller) If the function arises from Lagrangean relaxation and a primal approximation is desired then set the primal dimension in <a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description. ">cb_add_function()</a> and return the primal solutions corresponding to the eps-subgradients in the array pointed to by primal. Format: p1x1,..,p1xn,p2x1,...,p2xn,...</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0, all correct</li>
<li>!=0, failure. This does not necessarily terminate the bundle method. Termination is forced only if no new subgradient is returned. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa68f5a81ff149a7e4ff5ea5b7bef08f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa68f5a81ff149a7e4ff5ea5b7bef08f0">&#9670;&nbsp;</a></span>cb_subgextp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* cb_subgextp) ( void *function_key, double *generating_primal, int n_indices, int *variable_indices, double *new_subgradient_values)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This routine is not needed unless variabls (constraints in Lagrangean relaxation) are added on the fly. </p>
<p>The solver calls this routine whenever new variables have been added on the fly in order to extend old subgradients to the new coordinates. If primal data was supplied for the subgradients then <em>generating_primal</em> holds a pointer to this (possibly aggregated) data, otherwise it is NULL.</p>
<p>In the presence of primal data, the new coordinates correspond to the violation of the new primal constraints. These have to be returned in the array <em>new_subgradient_values</em>; more precisely, for i=0 to <em>n_indices-1</em> the element <em>new_subgradient_values</em>[i] has to hold the subgradient information of constraint <em>variable_indices</em>[i];</p>
<p>If generating_primal is NULL, then the routine can only successfully extend the subgradients, if the new coordinates have no influence on the function; then the new subgradient coordinates are all zero and the components of <em>new_subgradient_values</em> have to be initialized to zero.</p>
<p>If you do indeed need this, you have to provide one such function with each evaluation function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function_key</td><td>void pointer supplied by the user on entering the function. May be useful if multiple copies of the same function are used with parameters</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">generating_primal</td><td>(NULL or pointer to double array of primal length n) if not Null it holds the (possibly aggregated) primal solution that generated the subgradient that needs to be extendend</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_indices</td><td>(int) gives the number of indices for which the subgradient value has to be computed</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">variable_indices</td><td>(pointer to int array of length <em>n_indices</em>) for the <em>y</em> variables with indices <em>variable_indices</em>[i], i=0,..,@ n_indices-1 the subgradient coefficient has to be computed</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_subgradient_values</td><td>(pointer to double array of length n_indices provided by caller) store the the subgradient coefficient of <em>y</em> variable with index <em>variable_indices</em>[i] at <em>new_subgradient_values</em>[i] for i=0,..,@ n_indices-1</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success,</li>
<li>1 if extension is impossible </li>
</ul>
</dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga96316b3769d671690ffddf3c0d98e7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96316b3769d671690ffddf3c0d98e7cc">&#9670;&nbsp;</a></span>cb_add_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_add_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>function_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga494501102ced30c7e69f92670fc43d13">cb_functionp</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#gaa68f5a81ff149a7e4ff5ea5b7bef08f0">cb_subgextp</a>&#160;</td>
          <td class="paramname"><em>se</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>primaldim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the function, the sum of which should be minimized, to the problem description. </p>
<p>Each function added must be given a unique <em>function_key</em> (this may be the address of the function [if unique], an index, or some parameter information), <em>f</em> supplies the evaluation function and must not be zero, <em>se</em> can be used to specify a routine for extending subgradients, but it may be NULL. <em>primaldim</em> can be used if an approximate primal solution should be aggregated (In this case storage will be supplied in the call to the evaluation function for storing for each subgradient the generating primal vector). It may be zero if this is not needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem to which the function should be added</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function_key</td><td>(void *) The value of the funciton_key must UNIQUELY identify the function, (it may be the address of the funciton [if unique], or give the address of a struct holding additional user parameters)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>(cb_functionp) The pointer to the function</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">se</td><td>(cb_subgextp) This parameter my be NULL, otherwise the respective function will be called in order to compute coefficients for new subgradient coordinates resulting from added variables.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">primaldim</td><td>(int) May be zero, otherwise in each call to <em>f</em> enough storage will be provided to store a primal generating vector for each subgradient returned. The primal solutions will be aggregated along with the subgradients. This allows to generate approximate primal optimal solutions, e.g., in Lagrangean relaxation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga623f0cb78f14b20bf6c58db8f50a5290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga623f0cb78f14b20bf6c58db8f50a5290">&#9670;&nbsp;</a></span>cb_append_variables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_append_variables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_append</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append new variables (always in last postions in this order). </p>
<p>If 0 is feasible for the new coordinates then this is selected as starting value for the new coordinates; otherwise, the number closest to zero is used. If all new coordinates can be set to zero then it is assumed that for an existing center point the function values need not be recomputed (this is e.g. the case in Lagrangean relaxation; if this is not correct call <a class="el" href="group__cinterface.html#ga987d2a140fe4660ae228b20bee8320d8" title="Clears cutting model, subgradients and stored function values for the function with this function_key...">cb_reinit_function_model()</a> below). Otherwise the old function values will be marked as outdated and will be recomputed at the next call to e.g. cb_do_descent_step().</p>
<dl class="section attention"><dt>Attention</dt><dd>Be sure to update your objective functions so that they can handle the new variables before you call this and any further <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> routines that require function evaluations. Also, these operations may lead to inavailability of certain other data such as subgradients and primal approximations.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_append</td><td>(int) number of variables to append (always in last position in the same order)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lower_bound</td><td>(NULL or pointer to double array of size <em>n_append</em>) If NULL, all appended variables are considered unbounded below, otherwise lowerb[i] gives the minimum feasible value for variable y[i], use <a class="el" href="group__cinterface.html#ga7969bf339ee57ce667278104ad9adcf7" title="Returns the value &quot;minus infinity&quot;, i.e., all bounds &lt;= this value are set to this value and are rega...">cb_get_minus_infinity()</a> for unbounded below.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upper_bound</td><td>(NULL or pointer to double array of size <em>n_append</em>) If NULL, all appended variables are considered unbounded above, otherwise lowerb[i] gives the minimum feasible value for variable y[i], use <a class="el" href="group__cinterface.html#ga7889cf44af8cc62fbffa30f0143e1fb9" title="Returns the value &quot;plus infinity&quot;, i.e., all bounds &gt;= this value are set to this value and are regar...">cb_get_plus_infinity()</a> for unbounded below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga8b839895c52febec613647f425ebb9fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b839895c52febec613647f425ebb9fd">&#9670;&nbsp;</a></span>cb_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cb_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears all data structures and problem information but keeps ouptut settings and algorithmic parameter settings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the cureent problem </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6374cbb172eac48e21c1838a74f4da0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6374cbb172eac48e21c1838a74f4da0b">&#9670;&nbsp;</a></span>cb_clear_fail_counts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cb_clear_fail_counts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>clears all fail counts on numerical function oder model failures, may be useful if this caused premature termination. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga807cf763dcc577a01ac76814b9c8a2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga807cf763dcc577a01ac76814b9c8a2bc">&#9670;&nbsp;</a></span>cb_construct_problem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> cb_construct_problem </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no_bundle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a a new problem object and returns a pointer to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">no_bundle</td><td>if nonzero, then the minimal bundle consisting of just one new and one aggregate gradient is used so that there is no real bundle available and bundle size options are then meaningless.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>==0, construction of problem object failed</li>
<li>!=0, pointer to the problem object </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa6f318b3a93b7109393194cb9e2fa86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6f318b3a93b7109393194cb9e2fa86d">&#9670;&nbsp;</a></span>cb_delete_variables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_delete_variables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_del</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>delete_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>map_to_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes variables corresponding to the specified indices. </p>
<p>The indices of the remaining variables are reassigned so that they are consecutive again, the routine returns in <em>map_to_old</em> a vector giving for each new index of these remaining variables the old coordinate. The memory for <em>map_to_old</em> has to be provided by the caller, who has also to guarantee that it is long enough!</p>
<p>If all of the deleted variables are zero, function values are assumed to remain correct (if this is not so, call <a class="el" href="group__cinterface.html#ga987d2a140fe4660ae228b20bee8320d8" title="Clears cutting model, subgradients and stored function values for the function with this function_key...">cb_reinit_function_model()</a> below) Otherwise the old function values will be marked as outdated and will be recomputed at the next call to e.g. cb_do_descent_step().</p>
<dl class="section attention"><dt>Attention</dt><dd>Be sure to update your objective functions so that they can handle the new variables before you call any further <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> routines that require function evaluations. Also, these operations may lead to inavailability of certain other data such as subgradients and primal approximations.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_del</td><td>(int) number of variables to be deleted</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delete_indices</td><td>(pointer to int array of length n_del) the entries delete_indices[i] with i=0,...,n_del-1 specify the indices of the variables to be deleted</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">map_to_old</td><td>(pointer to int array of length <a class="el" href="group__cinterface.html#gacf08ea1cf2327669c3f4dcf455800238" title="Returns the current dimension of the design space/argument or -1 if no dimension is set...">cb_get_dim()</a>-<em>n_del</em> provided by the caller) after the call element map_to_old[i] gives the old index (before the call) of the variable that now has index position i.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga70f97962511ee09f1456e032061d2e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70f97962511ee09f1456e032061d2e30">&#9670;&nbsp;</a></span>cb_destruct_problem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_destruct_problem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructs and frees the problem object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>(cb_problemp*) address of the main pointer to the problem that should be destructed. the problem pointer will be set to zero upon successful destruction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0, all correct</li>
<li>&gt;0, failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga32cd4b02ba0eac656f5970f64daf68c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32cd4b02ba0eac656f5970f64daf68c3">&#9670;&nbsp;</a></span>cb_get_approximate_primal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_get_approximate_primal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>function_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>primal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current approximate primal solution for the function having this <em>function_key</em>. </p>
<p>The <em>function_key</em> must match the one specified in <a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description. ">cb_add_function()</a>. Likewise, the routine is meaningful only if <em>primaldim</em> was set in <a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description. ">cb_add_function()</a> and primal vectors were returned along with the subgradients in all calls to cb_functionp with this <em>function_key</em>. In this case it returns the current approximate primal solution aggregated alongside with the aggregate subgradient. A primal solution may not be available after addition of constraints, if extension of the aggregate subgradient to the new coordinates failed.</p>
<p>If no primal dimension was set for this function, the routine does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function_key</td><td>(void *) unique identifier as set in <a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description. ">cb_add_function()</a></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">primal</td><td>(pointer to double array of length @ primaldim provided by caller) primal[i] will be filled with the coordinate value i</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga3ef418836d555c0b55bd9f198109e61d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ef418836d555c0b55bd9f198109e61d">&#9670;&nbsp;</a></span>cb_get_approximate_slacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_get_approximate_slacks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>slacks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the multipliers for the bound constraints on the design variables; in Lagrangean relaxation they may be interpreted as primal slacks for inequality constraints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">slacks</td><td>(pointer to double array of length <a class="el" href="group__cinterface.html#gacf08ea1cf2327669c3f4dcf455800238" title="Returns the current dimension of the design space/argument or -1 if no dimension is set...">cb_get_dim()</a> provided by caller) slacks[i] will be filled with the coordinate value i</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac6155b2615f063893969aeddba5525bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6155b2615f063893969aeddba5525bc">&#9670;&nbsp;</a></span>cb_get_bundle_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_get_bundle_parameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>function_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>max_modelsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>max_bundelsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the two bundle parameters specified in the routines <a class="el" href="group__cinterface.html#ga9e0f7c1a6499fa28d1ee5db96b6ef015" title="Sets the maximum number of subgradients used in forming the cutting model of the function having this...">cb_set_max_modelsize()</a> and <a class="el" href="group__cinterface.html#gab9e6845864cff4362f0401658062461c" title="Sets the maximum number of subgradients stored for use in forming the model or determining metric inf...">cb_set_max_bundlesize()</a>. for the function having this <em>function_key</em>. </p>
<p>The <em>function_key</em> must match the one specified in <a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description. ">cb_add_function()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function_key</td><td>(void *) unique identifier as set in <a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description. ">cb_add_function()</a></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_modelsize</td><td>(pointer to int) returns the maximum number of subgradients to be used in forming the cutting model</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_bundelsize</td><td>(pointer to int) returns maximum number of subgradients stored for use in formint the cutting model</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga61d22658a33503ff35b5972e10cf6651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61d22658a33503ff35b5972e10cf6651">&#9670;&nbsp;</a></span>cb_get_candidate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_get_candidate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>candidate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last point, the "candidate", at which the function was evaluated in cb_do_descent_step(). </p>
<p>If this evaluation lead to a descent step, it is the same point as in <a class="el" href="group__cinterface.html#ga14ae01f65c97695217a9144638970eb6" title="Returns the next center point that was produced by the last call to cb_do_descent_step (in some probl...">cb_get_center()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">candidate</td><td>(pointer to double array of length <a class="el" href="group__cinterface.html#gacf08ea1cf2327669c3f4dcf455800238" title="Returns the current dimension of the design space/argument or -1 if no dimension is set...">cb_get_dim()</a> provided by caller) center[i] will be the value of design variable y_i of the point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga20b777b524d15f9e4efd6cc931766eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20b777b524d15f9e4efd6cc931766eee">&#9670;&nbsp;</a></span>cb_get_candidate_primal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_get_candidate_primal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>function_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>primal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the best primal solution returned by the last evaluation of the function having this <em>function_key</em> in the point <a class="el" href="group__cinterface.html#ga61d22658a33503ff35b5972e10cf6651" title="Returns the last point, the &quot;candidate&quot;, at which the function was evaluated in cb_do_descent_step()...">cb_get_candidate()</a>. </p>
<p>The <em>function_key</em> must match the one specified in <a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description. ">cb_add_function()</a>. Likewise, the routine is meaningful only if <em>primaldim</em> was set in <a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description. ">cb_add_function()</a> and primal vectors were returned along with the subgradients in calls to cb_functionp with this <em>function_key</em>. If no primal dimension was set for this function, the routine does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function_key</td><td>(void *) unique identifier as set in <a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description. ">cb_add_function()</a></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">primal</td><td>(pointer to double array of length @ primaldim provided by caller) primal[i] will be filled with the coordinate value i</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga95296a6cd39a49c689bc6179653805a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95296a6cd39a49c689bc6179653805a0">&#9670;&nbsp;</a></span>cb_get_candidate_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cb_get_candidate_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the objective value computed in the last step of do_descent_step(), independent of whether this was a descent step or a null step (initially undefined). </p>
<p>If no problem modification routines were called since then, it is the objective value at the point returned by <a class="el" href="group__cinterface.html#ga61d22658a33503ff35b5972e10cf6651" title="Returns the last point, the &quot;candidate&quot;, at which the function was evaluated in cb_do_descent_step()...">cb_get_candidate()</a>. If this last evaluation led to a descent step, then it is the same value as in get_objval(). </p>

</div>
</div>
<a id="ga14ae01f65c97695217a9144638970eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14ae01f65c97695217a9144638970eb6">&#9670;&nbsp;</a></span>cb_get_center()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_get_center </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>center</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the next center point that was produced by the last call to cb_do_descent_step (in some problem modification routines the center point may be updated immediately, in others the center point will be corrected automatically directly before starting the next descent step and its values may be infeasible till then). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">center</td><td>(pointer to double array of length <a class="el" href="group__cinterface.html#gacf08ea1cf2327669c3f4dcf455800238" title="Returns the current dimension of the design space/argument or -1 if no dimension is set...">cb_get_dim()</a> provided by caller) center[i] will be the value of design variable y_i in the next center point (mostly the result of the latest descent step)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga499088981d7a12f5f86c8cac6e8000c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga499088981d7a12f5f86c8cac6e8000c7">&#9670;&nbsp;</a></span>cb_get_center_primal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_get_center_primal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>function_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>primal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the best primal solution obtained in the current center point in evaluating the function having this <em>function_key</em>. </p>
<p>The <em>function_key</em> must match the one specified in <a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description. ">cb_add_function()</a>. Likewise, the routine is meaningful only if <em>primaldim</em> was set in <a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description. ">cb_add_function()</a> and primal vectors were returned along with the subgradients in calls to cb_functionp with this <em>function_key</em>. If no primal dimension was set for this function, the routine does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function_key</td><td>(void *) unique identifier as set in <a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description. ">cb_add_function()</a></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">primal</td><td>(pointer to double array of length @ primaldim provided by caller) primal[i] will be filled with the coordinate value i</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad7eb3329ed2d6e4bcc66178ac067dc87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7eb3329ed2d6e4bcc66178ac067dc87">&#9670;&nbsp;</a></span>cb_get_fixed_active_bounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_get_fixed_active_bounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>indicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the indicator vector of variables temporarily fixed to the center value due to significantly positive multipliers for the box constraints, see <a class="el" href="group__cinterface.html#ga4a51b181c4a0488a950edb196e8984f8" title="If set to true (the default is false), some variables will be fixed automatically to the center value...">cb_set_active_bounds_fixing()</a>. </p>
<p>Such a fixing indicates that the corresponding variables would like to stay at their bounds. If no variables were fixed, the dimension of the vector is zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indicator</td><td>(pointer to int array of length <a class="el" href="group__cinterface.html#gacf08ea1cf2327669c3f4dcf455800238" title="Returns the current dimension of the design space/argument or -1 if no dimension is set...">cb_get_dim()</a> @ provided by caller) indicator[i] will be 1 if the variable i was fixed to the bound and 0 otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae5043cc3bcf11c4e5df41563da73d524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5043cc3bcf11c4e5df41563da73d524">&#9670;&nbsp;</a></span>cb_get_function_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_get_function_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>function_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the return value of the latest evaluation call to the function with this <em>function_key</em>. </p>
<p>Remember, a unique <em>function_key</em> must be specified in <a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description. ">cb_add_function()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function_key</td><td>(void *) unique identifier as set in <a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description. ">cb_add_function()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return value of latest call to the function having this <em>function_key</em> </dd></dl>

</div>
</div>
<a id="ga42edf299547b8b9c232ea26ee3b3a923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42edf299547b8b9c232ea26ee3b3a923">&#9670;&nbsp;</a></span>cb_get_last_weight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cb_get_last_weight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current weight for the quadratic term in the augmented subproblem (may be interpreted as 1./step_size or 1./trustregion-radius). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double weight value </dd></dl>

</div>
</div>
<a id="ga6c2bc6d66d23d5a335d5694727797a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c2bc6d66d23d5a335d5694727797a31">&#9670;&nbsp;</a></span>cb_get_objval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cb_get_objval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the objective value resulting from last descent step (initially undefined). </p>
<p>If no problem modification routines were called since then, it is the objective value at the point returned by <a class="el" href="group__cinterface.html#ga14ae01f65c97695217a9144638970eb6" title="Returns the next center point that was produced by the last call to cb_do_descent_step (in some probl...">cb_get_center()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double objective value </dd></dl>

</div>
</div>
<a id="ga6726b5f928d838ad359cbb69fdc5e0b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6726b5f928d838ad359cbb69fdc5e0b0">&#9670;&nbsp;</a></span>cb_get_sgnorm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cb_get_sgnorm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns Euclidean norm of the latest aggregate subgradient. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>norm of the latest aggregate subgradient </dd></dl>

</div>
</div>
<a id="ga896e34b83c271271169057668f1c44c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga896e34b83c271271169057668f1c44c7">&#9670;&nbsp;</a></span>cb_get_subgradient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_get_subgradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>subgradient</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the latest aggregate subgradient. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">subgradient</td><td>(pointer to double array of length <a class="el" href="group__cinterface.html#gacf08ea1cf2327669c3f4dcf455800238" title="Returns the current dimension of the design space/argument or -1 if no dimension is set...">cb_get_dim()</a> provided by caller) subgradient[i] will be filled with the coordinate value i</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga2b579e5fc1a75e5bc3b61ec02c45a527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b579e5fc1a75e5bc3b61ec02c45a527">&#9670;&nbsp;</a></span>cb_init_problem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_init_problem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lowerb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>upperb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the problem by setting the design space (the dimension and possible box constraints of the variables) </p>
<p>Clears all data structures and sets the dimension @ m for a new problem. for solving min_{y in R^m} f_0(y) + f_1(y) + ... Box constraints may be specified for y, the functions f_i must be added by <a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description. ">cb_add_function()</a>.</p>
<p>Lower and/or upper bounds must be speicified for all variables or for none of them. To specify no bounds at all, give Null pointers. Otherwise use <a class="el" href="group__cinterface.html#ga7969bf339ee57ce667278104ad9adcf7" title="Returns the value &quot;minus infinity&quot;, i.e., all bounds &lt;= this value are set to this value and are rega...">cb_get_minus_infinity()</a> for unbounded below and <a class="el" href="group__cinterface.html#ga7889cf44af8cc62fbffa30f0143e1fb9" title="Returns the value &quot;plus infinity&quot;, i.e., all bounds &gt;= this value are set to this value and are regar...">cb_get_plus_infinity()</a> for unbounded above. For NULL pointers, unbounded will be used as default for all variables. Specifying bounds selectively is also possible by <a class="el" href="group__cinterface.html#gafc6ea382c7f9352615238d8913f8fbee" title="set lower bound for variable i, use cb_get_minus_infinity() for unbounded from below. ">cb_set_lower_bound()</a> or <a class="el" href="group__cinterface.html#ga490345cc46c2a3cdd32741fe27234ee5" title="set upper bound for variable i, use cb_get_plus_infinity() for unbounded above. ">cb_set_upper_bound()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the current problem</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>(int) the dimension of the argument/design space/the number of Lagrange multipliers</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lowerb</td><td>(either pointer to double array of length <em>m</em> or NULL) If NULL, all variables are considered unbounded below, otherwise lowerb[i] gives the minimum feasible value for variable y[i], use <a class="el" href="group__cinterface.html#ga7969bf339ee57ce667278104ad9adcf7" title="Returns the value &quot;minus infinity&quot;, i.e., all bounds &lt;= this value are set to this value and are rega...">cb_get_minus_infinity()</a> for unbounded below.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upperb</td><td>(either pointer to double array of length <em>m</em> or NULL) If NULL, all variables are considered unbounded above, otherwise upperb[i] gives the maximum feasible value for variable y[i], use <a class="el" href="group__cinterface.html#ga7889cf44af8cc62fbffa30f0143e1fb9" title="Returns the value &quot;plus infinity&quot;, i.e., all bounds &gt;= this value are set to this value and are regar...">cb_get_plus_infinity()</a> for unbounded above.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gacb69b4a3769e26ce8e72fadb68cf0b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb69b4a3769e26ce8e72fadb68cf0b6b">&#9670;&nbsp;</a></span>cb_print_termination_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_print_termination_code </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a text version of termination code, see <a class="el" href="group__cinterface.html#gaa3b07ae3eeadb1e39f92cf054f41abd1" title="Returns the termination code of the bundle algorithm for the latest descent step. ...">cb_termination_code()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga175ef1a2e40596de40cb8e62d451d20e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga175ef1a2e40596de40cb8e62d451d20e">&#9670;&nbsp;</a></span>cb_reassign_variables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_reassign_variables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_assign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>assign_new_from_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reassigns variables to new index positions by mapping to position <em>i</em> the variable that previously had index <em>assign_new_from_old</em>[i]. </p>
<p>Old variables, that are not mapped to any position will be deleted. It is allowed to generate several copies of old variables.</p>
<p>If all of the deleted variables as well as new multiple copies are zero, function values are assumed to remain correct (if this is not so, call <a class="el" href="group__cinterface.html#ga987d2a140fe4660ae228b20bee8320d8" title="Clears cutting model, subgradients and stored function values for the function with this function_key...">cb_reinit_function_model()</a> below). Otherwise the old function values will be marked as outdated and will be recomputed at the next call to e.g. cb_do_descent_step().</p>
<dl class="section attention"><dt>Attention</dt><dd>Be sure to update your objective functions so that they can handle the new variables before you call any further <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> routines that require function evaluations. Also, these operations may lead to inavailability of certain other data such as subgradients and primal approximations.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_assign</td><td>(int) number of variables after reassignment</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">assign_new_from_old</td><td>(pointer to int array of length <em>n_assign</em>) entry assign_new_from_old[i] with i=0,...,<em>n_assign-1</em> specifies the old index of the variable, that has to be copied to index position i.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga987d2a140fe4660ae228b20bee8320d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga987d2a140fe4660ae228b20bee8320d8">&#9670;&nbsp;</a></span>cb_reinit_function_model()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_reinit_function_model </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>function_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears cutting model, subgradients and stored function values for the function with this <em>function_key</em>. </p>
<p>This has to be called whenever the specified function was modified so that the old subgradients and/or primal generators are no longer valid.</p>
<p>The <em>function_key</em> must match the one specified in <a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description. ">cb_add_function()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function_key</td><td>(void *) unique identifier as set in <a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description. ">cb_add_function()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga4a51b181c4a0488a950edb196e8984f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a51b181c4a0488a950edb196e8984f8">&#9670;&nbsp;</a></span>cb_set_active_bounds_fixing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cb_set_active_bounds_fixing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>allow_fixing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If set to true (the default is false), some variables will be fixed automatically to the center value if their bounds are strongly active (i.e., the corresponding multipliers are big). </p>
<p>The coordinates to be fixed are redetermined in each call following a descent step or a change of the function. An indicator vector of the variables fixed in the last call can be obtained via the routine <a class="el" href="group__cinterface.html#gad7eb3329ed2d6e4bcc66178ac067dc87" title="Returns the indicator vector of variables temporarily fixed to the center value due to significantly ...">cb_get_fixed_active_bounds()</a>.</p>
<pre class="fragment"> Setting this value to true might improve the performance
 of the algorithm in some instances but there is no 
 convergence theory. It might be particularly helpful
 within Lagrangian relaxation if a primal cutting plane
 approach is used and non-tight inequalities should be
 eliminated quickly (fixing then indicates large primal 
 slack values). 
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allow_fixing</td><td>(0 or 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad6c1f335e1b8ab61bb854665a03a45f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6c1f335e1b8ab61bb854665a03a45f0">&#9670;&nbsp;</a></span>cb_set_defaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cb_set_defaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets default values for algorithmic parameters that are not function specific (e.g., relative precision, weight and weight bounds for the augmentedproblem, etc.) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the cureent problem </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga78da3da3e172d97d3ce16f151c91da8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78da3da3e172d97d3ce16f151c91da8d">&#9670;&nbsp;</a></span>cb_set_eval_limit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cb_set_eval_limit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eval_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an upper bound on the number of calls to the oracle (use negative numbers for no limit). </p>
<p>If this number is reached, the algorithm will terminate independently of whether the last step was a descent or a null step. A negative number will be interepreted as no limit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eval_limit</td><td>(int) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga875c9bcc1eb3028c633c0b31415dc01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga875c9bcc1eb3028c633c0b31415dc01c">&#9670;&nbsp;</a></span>cb_set_inner_update_limit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cb_set_inner_update_limit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>update_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an upper bound on the number of inner updates for the cutting model with primal slacks within one null step (use negative numbers for no limit). </p>
<p>A negative number will be interepreted as no limit, i.e., the updates will be done till a certain precision of the cutting model is achieved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update_limit</td><td>(int) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafc6ea382c7f9352615238d8913f8fbee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc6ea382c7f9352615238d8913f8fbee">&#9670;&nbsp;</a></span>cb_set_lower_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_set_lower_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lower_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set lower bound for variable i, use <a class="el" href="group__cinterface.html#ga7969bf339ee57ce667278104ad9adcf7" title="Returns the value &quot;minus infinity&quot;, i.e., all bounds &lt;= this value are set to this value and are rega...">cb_get_minus_infinity()</a> for unbounded from below. </p>
<p>The algorithm may have to adapt the center point aftwards. In this case the old function values will be marked as outdated and will be recomputed at the next call to e.g. cb_do_descent_step().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>(int) index of the variable</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lower_bound</td><td>(double) value of the lower bound on variable <em>i</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab9e6845864cff4362f0401658062461c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9e6845864cff4362f0401658062461c">&#9670;&nbsp;</a></span>cb_set_max_bundlesize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_set_max_bundlesize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>function_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bundlesize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum number of subgradients stored for use in forming the model or determining metric information of the function having this <em>function_key</em>. it must be as least as large as max_modelsize (and is increased to this if not) </p>
<p>The <em>function_key</em> must match the one specified in <a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description. ">cb_add_function()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function_key</td><td>(void *) unique identifier as set in <a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description. ">cb_add_function()</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bundlesize</td><td>(int) maximum number of subgradients to be used in forming the cutting model</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9e0f7c1a6499fa28d1ee5db96b6ef015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e0f7c1a6499fa28d1ee5db96b6ef015">&#9670;&nbsp;</a></span>cb_set_max_modelsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_set_max_modelsize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>function_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>modelsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum number of subgradients used in forming the cutting model of the function having this <em>function_key</em>. </p>
<p>The <em>function_key</em> must match the one specified in <a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description. ">cb_add_function()</a>.</p>
<p>Quite often a very small model, e.g., 2, yields very fast iterations and good progress in time (sometimes at the cost of more evaluations). By limited numerical experience, a significant reduction in the number of evaluations can only be expected if the bundle is large enough to wrap the function rather tightly. Quite frequently, unfortunately, this entails that solving the quadratic subproblems is more expensive than function evaluation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function_key</td><td>(void *) unique identifier as set in <a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description. ">cb_add_function()</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">modelsize</td><td>(int) maximum number of subgradients to be used in forming the cutting model</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaaf987af753c04154797c76bdae54e595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf987af753c04154797c76bdae54e595">&#9670;&nbsp;</a></span>cb_set_max_new_subgradients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_set_max_new_subgradients </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>function_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_new_subg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum number of epsilon subgradients that can be returned in one call to the function having this <em>function_key</em>. </p>
<p>The <em>function_key</em> must match the one specified in <a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description. ">cb_add_function()</a>.</p>
<p>The parameter <em>max_new_subg</em> corresponds directly to the parameter <em>max_subg</em> in <a class="el" href="group__cinterface.html#ga494501102ced30c7e69f92670fc43d13" title="function oracle; describe your function as a function of this type to pass it to the solver ...">cb_functionp</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function_key</td><td>(void *) unique identifier as set in <a class="el" href="group__cinterface.html#ga96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description. ">cb_add_function()</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_new_subg</td><td>(int) maximum number of new epsilon subgradients to be returned in an evaluation call to the function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab7940fa588317bdd3837bb448871a66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7940fa588317bdd3837bb448871a66e">&#9670;&nbsp;</a></span>cb_set_max_weight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_set_max_weight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an upper bound on the weight for the quadratic term of the augmented subproblem. </p>
<p>Nonpositive values indicate no bound. The new value shows its effect only at first dynamic change of the weight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_weight</td><td>(double)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga2a68aaafcf76054d085266b009f4cd4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a68aaafcf76054d085266b009f4cd4c">&#9670;&nbsp;</a></span>cb_set_min_weight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_set_min_weight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a lower bound on the weight for the quadratic term of the augmented subproblem. </p>
<p>Nonpositive values indicate no bound. The new value shows its effect only at first dynamic change of the weight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_weight</td><td>(double)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga45bdcc8c58aa94a1b8231bf38f1d8097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45bdcc8c58aa94a1b8231bf38f1d8097">&#9670;&nbsp;</a></span>cb_set_new_center_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_set_new_center_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>center</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the starting point/center that will be used in the next call to cb_do_descent_step(). Each call to this routine causes an immediate evaluation of all oracles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">center</td><td>(pointer to double array of length <a class="el" href="group__cinterface.html#gacf08ea1cf2327669c3f4dcf455800238" title="Returns the current dimension of the design space/argument or -1 if no dimension is set...">cb_get_dim()</a>) center[i] holds the value of design variable y_i</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga412e288c208f049f49024e51198d3e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga412e288c208f049f49024e51198d3e4b">&#9670;&nbsp;</a></span>cb_set_next_weight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_set_next_weight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the weight (&gt;0) to be used in the quadratic term of the next augmented subproblem (may be interpreted as 1./step_size or 1./trustregion-radius). </p>
<p>Independent of whether the weight violates current min- and max-bounds set in <a class="el" href="group__cinterface.html#ga2a68aaafcf76054d085266b009f4cd4c" title="Sets a lower bound on the weight for the quadratic term of the augmented subproblem. ">cb_set_min_weight()</a> and <a class="el" href="group__cinterface.html#gab7940fa588317bdd3837bb448871a66e" title="Sets an upper bound on the weight for the quadratic term of the augmented subproblem. ">cb_set_max_weight()</a>, the next model will be computed for this value. Thereafter, however, it will be updated as usual; in particular, it may be truncated by min and max bounds immediately after the first subproblem.</p>
<p>In order to guarantee a constant weight (e.g. 1 is frequently a reasonable choice if the automatic default heuristic performs poorly), set the min and max bounds to the same value, too.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>(double)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gafb3888ddf0640bef9fc5e460fc81a32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb3888ddf0640bef9fc5e460fc81a32e">&#9670;&nbsp;</a></span>cb_set_print_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cb_set_print_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pril</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the output level (&lt;0 no output at all, =0 errors and warnings, &gt;0 increasingly detailed information) </p>
<p>Output levels:</p><ul>
<li>&lt;0 ... no output, not even errors or warnings</li>
<li>0 ... no output except for errors and warnings</li>
<li>1 ... line summary after each descent step</li>
<li>&gt;1 ... undocumented and increasingly detailed log information. These higher levels should only be used if requested for debugging purposes.</li>
</ul>
<p>Example for level 1:</p>
<pre class="fragment">00:00:00.00 endit  1   1   1   563.    563.  39041.188  39043.162
00:00:00.00 endit  2   2   2   563.    559.  38488.165  38490.200
00:00:00.00 endit  3   3   3   56.3    555.  33014.533  33211.856
00:00:00.00 endit  4   4   4   5.63    517. -14306.459  2738.0343
00:00:00.00 endit  5   5   5   4.04    148. -2692.1131  2.2150883
00:00:00.00 endit  6   6   6   4.01    1.29  1.7908952  2.0000581
00:00:00.00 endit  7   7   7   3.95  0.0213  1.9999387  2.0000000
00:00:00.00 _endit  8   8   8   3.95 2.94e-05  2.0000000  2.0000000

Column 1      2     3   4   5    6       7       8          9
</pre><ul>
<li>Column 1: computation time in hh:mm:ss.dd,</li>
<li>Column 2: "endit" is convenient for grep and stands for "end of iteration". Iterations with <a class="el" href="group__cinterface.html#gaa3b07ae3eeadb1e39f92cf054f41abd1" title="Returns the termination code of the bundle algorithm for the latest descent step. ...">cb_termination_code()</a>!=0 are marked with "_endit".</li>
<li>Column 3: number of descent steps (= calls to cb_do_descent_step())</li>
<li>Column 4: number of descent and null steps. Up to initialization calls and reevaluations, this is the number of evaluation calls to the function oracles from within the bundle method. In the example all calls led to descent steps.</li>
<li>Column 5: number of innermost iterations. It differs from column 5 only in the case of variables with bounds in which case it gives the number of updates of the multipliers for the bounds (or primal slacks in Lagrangean relaxation). Exceedingly high numbers in this column indicate that some variables are constantly at their bounds and it might be possible to improve convergence by deleting them (i.e. set them as constants to this bound and remove the variable).</li>
<li>Column 6: the weight of the quadratic term in the augmented problem.</li>
<li>Column 7: the norm of the aggregate subgradient. If it is small, say below 0.1, then mostly this is good indication that the objective value is close to optimal.</li>
<li>Column 8: the value of the cutting model in the last candidate point. It is always a lower bound on the true function value in this point</li>
<li>Column 9: the objective value in the latest point that led to a descent step, i.e., the point returend by <a class="el" href="group__cinterface.html#ga14ae01f65c97695217a9144638970eb6" title="Returns the next center point that was produced by the last call to cb_do_descent_step (in some probl...">cb_get_center()</a>. Whenever <a class="el" href="group__cinterface.html#gaa3b07ae3eeadb1e39f92cf054f41abd1" title="Returns the termination code of the bundle algorithm for the latest descent step. ...">cb_termination_code()</a> returns 0 this is also the objective value of the latest evaluation call to the function oracles and the value in the center point of the next iteration.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pril</td><td>(int) print level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga65b10cf79c9523c122369a37ad4eee67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65b10cf79c9523c122369a37ad4eee67">&#9670;&nbsp;</a></span>cb_set_term_relprec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_set_term_relprec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>term_relprec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the relative precision requirements for successful termination (default 1e-5). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">term_relprec</td><td>(double) The algorithm stops with termination code 1, if predicted progress for the next step is less than term_relprec times absolute function value plus one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga490345cc46c2a3cdd32741fe27234ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga490345cc46c2a3cdd32741fe27234ee5">&#9670;&nbsp;</a></span>cb_set_upper_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_set_upper_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set upper bound for variable i, use <a class="el" href="group__cinterface.html#ga7889cf44af8cc62fbffa30f0143e1fb9" title="Returns the value &quot;plus infinity&quot;, i.e., all bounds &gt;= this value are set to this value and are regar...">cb_get_plus_infinity()</a> for unbounded above. </p>
<p>The algorithm may have to adapt the center point aftwards. In this case the old function values will be marked as outdated and will be recomputed at the next call to e.g. cb_do_descent_step().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>(int) index of the variable</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upper_bound</td><td>(double) value of the upper bound on variable <em>i</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga4dace07373eaf106efcd057ec7c66722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dace07373eaf106efcd057ec7c66722">&#9670;&nbsp;</a></span>cb_set_variable_metric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_set_variable_metric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>do_variable_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use a variable metric heuristic or switch it off alltogether. (the variable metric heuristic resets the quadratic term to some diagonal or low rank matrix, switching it off resets the proximal term to the identity) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">do_variable_metric</td><td>(int)<ul>
<li>0 switch off the scaling heuristic</li>
<li>1 use a diagonal scaling heuristic</li>
<li>2 use a diagonal scaling heuristic combined with one for the bounds</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga2e57f869702bc27ce9304f21054700b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e57f869702bc27ce9304f21054700b8">&#9670;&nbsp;</a></span>cb_solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxsteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stop_at_descent_steps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>solves or does a prescribed number of </p>
<p>Bundle methods solve a problem by a sequence of so called descent steps that actually bring progress by moving from the current "center point" to a new center with better objective. A descent step may consist of several function evaluations (null steps), that lead to no immediate progress but mainly improve a cutting model of the objective function close to the current center point. A minimizer to the model is accepted as descent step if the function value at this point satisfies a sufficient decrease criterion in comparison to the decrease predicted by the model. Having found a descent step, the next center is automatically shifted to this successful candidate. Termination criteria may stop the process of seeking for a descent step, in which case the current center is kept and the routine termination_code() returns the termination code.</p>
<p>Restarting, after each descent step, the bundle method from scratch with the new center as starting point does not endanger convergence. Therefore, a descent step is the smallest unit, after which user interaction can take place safely. To allow this there is a flag stop_at_descent_steps that will cause the code to return after the next descent step.</p>
<p>If you know what your are doing, you may also use the input parameter maxsteps to force the algorithm to return after at most maxsteps null steps. Calling solve again without any intermediate problem configurations will then simply continue the process where it stopped and convergence is save. During null steps one may not decrease the weight or delete nonzero variables of the center or the current candidate!</p>
<p>In a Lagrangean relaxation cutting plane approach one may want to separate and enlarge the dimension after a certain number of null steps. In this case the code will try to preserve the model, given appropriate subgradient extension routines have been provided. If the model cannot be extended, it has to be discarded (if subgradient extension is not successful this is done automatically), and the algorithm will be restarted from the current center point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxsteps</td><td>(int) use value =0 as default (anything &lt;= serves as infinite upper bound), if maxsteps&gt;0 the code returns after at most so many null steps</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stop_at_descent_steps</td><td>(int) if true(!=0) the code also returns whenever a descent step occured, if false(==0) it only stops after maxsteps or when a termination criterion is met</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa3b07ae3eeadb1e39f92cf054f41abd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3b07ae3eeadb1e39f92cf054f41abd1">&#9670;&nbsp;</a></span>cb_termination_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_termination_code </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the termination code of the bundle algorithm for the latest descent step. </p>
<p>For resetting all counters relevant for termination see <a class="el" href="group__cinterface.html#ga6374cbb172eac48e21c1838a74f4da0b" title="clears all fail counts on numerical function oder model failures, may be useful if this caused premat...">cb_clear_fail_counts()</a> .</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 : Not terminated. (Continue with the next cb_do_descent_step())</li>
<li>1 : Relative precision criterion satisfied. (See <a class="el" href="group__cinterface.html#ga65b10cf79c9523c122369a37ad4eee67" title="Sets the relative precision requirements for successful termination (default 1e-5). ">cb_set_term_relprec()</a>)</li>
<li>2 : Timelimit exceeded. (Currently the C interface does not offer a timelimit.)</li>
<li>4 : Maximum number of function reevaluations exceeded. (Indicates that there is a problem with one of the function oracles that seems to deliver no valid upper bounds on the true function value for descent steps)</li>
<li>8 : Maximum number of quadratic subproblem failures exceeded. (Indicates that the numerical limits of the inner quadratic programming solver are reached, no further progress expected)</li>
<li>16 : maximum number of model evaluation failures exceeded (Indicates that the numerical limits of the setup of the subproblem are reached, no further progress expected)</li>
<li>32 : maximum number of failures to increase the augmented model value exceeded (Indicates that the numerical limits of the interplay between subproblem and quadratic programming solver are reached, no further progress expected)</li>
<li>64 : maximum number of oracle calls (function evaluations) exceeded, see <a class="el" href="group__cinterface.html#ga78da3da3e172d97d3ce16f151c91da8d" title="Sets an upper bound on the number of calls to the oracle (use negative numbers for no limit)...">cb_set_eval_limit()</a></li>
<li>128 : maximum number of oracle failures exceeded. This refers to function evaluations that terminate with insufficient precision but still provide a new approximate subgradient. A failure typically indicates numerical difficulties with the precision requirements. (Currently the interface does not allow to manipulate the limit, it is set to 10) </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
