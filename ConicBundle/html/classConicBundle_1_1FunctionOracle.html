<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ConicBundle: ConicBundle::FunctionOracle Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ConicBundle
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceConicBundle.html">ConicBundle</a></li><li class="navelem"><a class="el" href="classConicBundle_1_1FunctionOracle.html">FunctionOracle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classConicBundle_1_1FunctionOracle-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ConicBundle::FunctionOracle Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__cxxinterface.html">Interface to ConicBundle for the Language C++</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>oracle interface (abstract class). For each of your functions, provide a derived class.  
 <a href="classConicBundle_1_1FunctionOracle.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CBSolver_8hxx_source.html">CBSolver.hxx</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ConicBundle::FunctionOracle:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classConicBundle_1_1FunctionOracle.png" usemap="#ConicBundle::FunctionOracle_map" alt=""/>
  <map id="ConicBundle::FunctionOracle_map" name="ConicBundle::FunctionOracle_map">
<area href="classConicBundle_1_1FunctionObject.html" title="basic function object (abstract class). It serves for using the same interface on distinct oracle typ..." alt="ConicBundle::FunctionObject" shape="rect" coords="0,0,178,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a10d135676ae61d26bb068fadef2526d3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1FunctionOracle.html#a10d135676ae61d26bb068fadef2526d3">evaluate</a> (const double *current_point, double relprec, double &amp;objective_value, std::vector&lt; <a class="el" href="classConicBundle_1_1Minorant.html">Minorant</a> *&gt; &amp;minorants, <a class="el" href="classConicBundle_1_1PrimalExtender.html">PrimalExtender</a> *&amp;primal_extender)=0</td></tr>
<tr class="memdesc:a10d135676ae61d26bb068fadef2526d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the solver. Has to Return function value and at least one (epsilon) subgradient and, possibly for Lagrangean relaxation, some primal data.  <a href="#a10d135676ae61d26bb068fadef2526d3">More...</a><br /></td></tr>
<tr class="separator:a10d135676ae61d26bb068fadef2526d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4901d9882afe1b45440a744404be6f9"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1FunctionOracle.html#af4901d9882afe1b45440a744404be6f9">apply_modification</a> (const <a class="el" href="classConicBundle_1_1OracleModification.html">OracleModification</a> &amp;oracle_modification, const double *new_center, const double *old_center, bool &amp;discard_objective_in_center, bool &amp;discard_model, bool &amp;discard_aggregates, <a class="el" href="classConicBundle_1_1MinorantExtender.html">MinorantExtender</a> *&amp;minorant_extender)</td></tr>
<tr class="memdesc:af4901d9882afe1b45440a744404be6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine need not be implemented unless variables (constraints in Lagrangean relaxation) are added or deleted on the fly.  <a href="#af4901d9882afe1b45440a744404be6f9">More...</a><br /></td></tr>
<tr class="separator:af4901d9882afe1b45440a744404be6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad927d35b78c7717d7f3a602021da04b9"><td class="memItemLeft" align="right" valign="top"><a id="ad927d35b78c7717d7f3a602021da04b9"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1FunctionOracle.html#ad927d35b78c7717d7f3a602021da04b9">check_correctness</a> () const</td></tr>
<tr class="memdesc:ad927d35b78c7717d7f3a602021da04b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">switch on/off some correctness checks on the oracle <br /></td></tr>
<tr class="separator:ad927d35b78c7717d7f3a602021da04b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>oracle interface (abstract class). For each of your functions, provide a derived class. </p>
<p>The oracle interface is used to describe and pass convex objective functions to the <a class="el" href="classConicBundle_1_1CBSolver.html" title="Bundle method solver. ">ConicBundle::CBSolver</a>. The dimension of the argument vector of the function must be set in <a class="el" href="classConicBundle_1_1CBSolver.html#aaaca3b1092a1305a8ddf4f181e1bf256" title="Initializes the problem by setting up the design space (the dimension and possible box constraints of...">ConicBundle::CBSolver::init_problem()</a> and the functions are then added to the solver by <a class="el" href="classConicBundle_1_1CBSolver.html#a76de315bec233bec71b1cf9d2ed3df69" title="Adds a function, typically derived from ConicBundle::FunctionOracle; all functions added must have th...">ConicBundle::CBSolver::add_function()</a>.</p>
<p>If the sum of several such functions is to be minimized it is the task of the user to guarantee, that all dimensions match.</p>
<p>If the function corresponds to Lagrangean relaxation of a primal maximization problem one may want to generate a primal approximate solution. In this case, return in the function <a class="el" href="classConicBundle_1_1FunctionOracle.html#a10d135676ae61d26bb068fadef2526d3" title="Called by the solver. Has to Return function value and at least one (epsilon) subgradient and...">FunctionOracle::evaluate()</a> within the minorant the generating primal objects for each subgradient/minorant. If no primal objects are included, there will be no primal aggregation.</p>
<p>If primal aggregation is used then it is possible to implement a primal cutting plane framework. This requires the introduction of new (dual) variables in the design space of the function. In this case a heap object <a class="el" href="classConicBundle_1_1MinorantExtender.html" title="Interface for extending a Minorant, e.g., in Lagrangian Relaxation of cutting plane approaches...">MinorantExtender</a> must be returend in the call of FunctionOracle::get_minorant_extender(); this must be able to fill in the missing coordinates in existing minorants/subgradients maybe on basis of the associated primal data stored in the minorants. If this feature is not needed, the function may be used as is and need not be reimplemented. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af4901d9882afe1b45440a744404be6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4901d9882afe1b45440a744404be6f9">&#9670;&nbsp;</a></span>apply_modification()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ConicBundle::FunctionOracle::apply_modification </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1OracleModification.html">OracleModification</a> &amp;&#160;</td>
          <td class="paramname"><em>oracle_modification</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>new_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>old_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>discard_objective_in_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>discard_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>discard_aggregates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1MinorantExtender.html">MinorantExtender</a> *&amp;&#160;</td>
          <td class="paramname"><em>minorant_extender</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This routine need not be implemented unless variables (constraints in Lagrangean relaxation) are added or deleted on the fly. </p>
<p>The routine is only called by the solver if the variables indeed get modified. <em>oracle_modification</em> is then used to either transfer user supplied instructions to the oracle on how to modify itself or to inform the oracle about changes the solver was asked to perform on the variables. If available, the solver will also show the effect of these changes on the center point in <em>new_center</em> and <em>old_center</em>; if these are not available then they hold NULL. A user supplied <em>oracle_modification</em> will be checked for consistency with the actual changes in the variables and mismatches will cause failures.</p>
<p>The remaining variables are output variables by which the oracle tells the solver which information has a chance to be preserved in view of these changes. If e.g. the deletion of some nonzero variables invalidates the function value in the new center, the oracle has to set discard_objective_in_center=true. If the entire model cannot be preserved (this includes the aggregates and the function values), the oracle needs to set discard_model=true; If only aggregate minorants cannot be preserved, the oracle needs to set discard_aggregates=true. Whenever new variables were added, the model can only be preserved if the remaining minorants (maybe without aggregates) can be extended for these new variables. In this case the oracle has to supply the appropriate <a class="el" href="classConicBundle_1_1MinorantExtender.html" title="Interface for extending a Minorant, e.g., in Lagrangian Relaxation of cutting plane approaches...">MinorantExtender</a> via <em>minorant_extender</em>. A given minorant_extender will only be applied if new variables were added and indices passed to it then refer to the situation after* the changes (append and map-operation of <a class="el" href="classConicBundle_1_1OracleModification.html" title="Base class for informing oracles (or the solver) about dynamic changes in the number and sorting of t...">OracleModification</a>) were executed on them. If the operation fails for any of the minorants, the entire model will be discarded.</p>
<p>Return value 0 indicates that these actions allow to continue without errors, other return values result in an overall error on these changes. </p>

</div>
</div>
<a id="a10d135676ae61d26bb068fadef2526d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d135676ae61d26bb068fadef2526d3">&#9670;&nbsp;</a></span>evaluate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ConicBundle::FunctionOracle::evaluate </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>current_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>relprec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>objective_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classConicBundle_1_1Minorant.html">Minorant</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>minorants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1PrimalExtender.html">PrimalExtender</a> *&amp;&#160;</td>
          <td class="paramname"><em>primal_extender</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by the solver. Has to Return function value and at least one (epsilon) subgradient and, possibly for Lagrangean relaxation, some primal data. </p>
<p>The evaluation method is the main interface to the bundle solver. The solver calls this method to obtain for the <em>current_point</em> (its dimension is set in <a class="el" href="classConicBundle_1_1CBSolver.html#aaaca3b1092a1305a8ddf4f181e1bf256" title="Initializes the problem by setting up the design space (the dimension and possible box constraints of...">ConicBundle::CBSolver::init_problem()</a>) the <em>objective_value</em> and (epsilon) subgradient information. In any call several epsilon subgradients may be returned in <em>minorants</em> along with their offset, but at least one has to be returend. Each subgradient and offset describes a linear minorant to the convex function and is used by the bundle method to form a cutting model of the convex function.</p>
<p>In many applications, computing the function value is an iterative process that approaches the true function value from below. On input the code offers a bound in <em>objective_value</em> for the function value, above which it is certain that the code will reject the current point. If in the iterative process a lower bound on the function value exceeds this bound, then it is sufficient to return, instead of the true function value and a subgradient, the current lower bound and a vector so that together they describe a supporting hyperplane (i.e. a linear minorant) to the function at this point.</p>
<p>If the function corresponds to Lagrangean relaxation of a primal maximization problem one may want to generate a primal approximate solution. For this purpose the minorants may also hold information on the primal data. If at each call and for each epsilon subgradient the corresponding generating primal object (must be derived from <a class="el" href="classConicBundle_1_1PrimalData.html" title="In Lagrangean relaxation an approximate primal solution can be generated by supplying primal informat...">ConicBundle::PrimalData</a>, e.g., a <a class="el" href="classConicBundle_1_1PrimalDVector.html" title="If in Lagrangean relaxation primal solutions are in the form of a ConicBundle::DVector, then an approximate primal solution can be generated by supplying primal information of this form for each epsilon subgradient within ConicBundle::FunctionOracle::evaluate(). ">ConicBundle::PrimalDVector</a>) is stored, then the code automatically performs the aggregation corresponding to the aggregation of the subgradients on the primal data objects. The primal approximate solution is finally delivered by the methods <a class="el" href="classConicBundle_1_1CBSolver.html#ad171dec64fe06f5478a3ab637c484e4c" title="returns the current approximate primal solution corresponding to the aggregate subgradient of the spe...">ConicBundle::CBSolver::get_approximate_primal()</a> or <a class="el" href="classConicBundle_1_1CBSolver.html#af3c96e5f61e6dc6b8223dd63760cd1ab" title="Returns the primal solution corresponding to the best epsilon subgradient returned in the evaluation ...">ConicBundle::CBSolver::get_center_primal()</a>.</p>
<p>All minorants passed to the solver must be objects allocated on the heap. The ownership of these objects is transferred to the solver and the solver will destroy them eventually, so DO NOT delete them yourself!</p>
<p>If no primal aggregation is desired, simply do not touch <em>primal_data</em> or clear it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">current_point</td><td>(const double*) argument of the function (e.g. the Lagrange multipliers)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relprec</td><td>(double) relative precision requirement for objective values that may lead to descent steps (this precision is not required if it is already certain that the function value will be too poor)</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">objective_value</td><td>(double&amp;)<ul>
<li>on input: value gives the threshold for a null step; you may stop, if a cutting plane yields at least this;</li>
<li>on output: return an upper bound on the true function value within <em>relprec</em> *(abs(objval)+1.), if there is no linear minorant cutting above the threshold specified in objective_value on input. Otherwise the return value should be the max of cut_values.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">minorants</td><td>(std::vector&lt;Minorant*&gt;) for returning linear minorants (subgradients and their offset values). At least one must be returned and the one at index 0 must maximize the value at the current point over all further ones given here. In particular its value at point should be above the threshold or be within relprec *(abs(objval)+1.) of the true objective. Within the minorants primal data may be supplied if this should be aggregated along.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">primal_extender</td><td>(PrimalExtender*&amp;) if primal_data provided in minonrants of previous calls has now to be updated due to changes in the primal problem &ndash; e.g., this may happen in column generation &ndash; one may return a pointer to <a class="el" href="classConicBundle_1_1PrimalExtender.html" title="Interface for extending PrimalData, e.g., in Lagrangian relaxation of column generation approaches...">PrimalExtender</a> object on the heap. This object will be used by <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> to update all its internally stored primal_data objects in its minorants by calling <a class="el" href="classConicBundle_1_1PrimalExtender.html#a13fc586276e23d575b935dbfe12495c0" title="called by ConicBundle to update internal PrimalData objects, has to return 0 on success ...">PrimalExtender::extend</a> on each of these (but not on those supplied by the new minorants). Afterwards <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> deletes primal_extender. If this is not needed, the variable holds 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0, all correct</li>
<li>!=0, failure. This does not necessarily terminate the bundle method. Termination is forced only if no new subgradient is returned. </li>
</ul>
</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="CBSolver_8hxx_source.html">CBSolver.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
