<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ConicBundle: ConicBundle::MatrixFunctionOracle Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ConicBundle
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceConicBundle.html">ConicBundle</a></li><li class="navelem"><a class="el" href="classConicBundle_1_1MatrixFunctionOracle.html">MatrixFunctionOracle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classConicBundle_1_1MatrixFunctionOracle-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ConicBundle::MatrixFunctionOracle Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__cxxmatrixinterface.html">Interface to ConicBundle for the Language C++ using Matrix Classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Oracle interface (abstract class). For each of your functions, provide an instance of a derived class.  
 <a href="classConicBundle_1_1MatrixFunctionOracle.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="MatrixCBSolver_8hxx_source.html">MatrixCBSolver.hxx</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ConicBundle::MatrixFunctionOracle:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classConicBundle_1_1MatrixFunctionOracle.png" usemap="#ConicBundle::MatrixFunctionOracle_map" alt=""/>
  <map id="ConicBundle::MatrixFunctionOracle_map" name="ConicBundle::MatrixFunctionOracle_map">
<area href="classConicBundle_1_1ModifiableOracleObject.html" title="ModifiableOracle provides all oracles with a uniform interface for a modification routine and an on/o..." alt="ConicBundle::ModifiableOracleObject" shape="rect" coords="120,56,351,80"/>
<area href="classConicBundle_1_1FunctionObject.html" title="basic function object (abstract class). It serves for using the same interface on distinct oracle typ..." alt="ConicBundle::FunctionObject" shape="rect" coords="120,0,351,24"/>
<area href="classConicBundle_1_1CFunction.html" title="for the &quot;C&quot; interface this maps c oracles to the standard function oracle with matrix classes ..." alt="ConicBundle::CFunction" shape="rect" coords="0,168,231,192"/>
<area href="classConicBundle_1_1NNCBoxSupportFunction.html" title="general purpose implementation of MatrixFunctionOracle as explained in implemention of MatrixFunction..." alt="ConicBundle::NNCBoxSupportFunction" shape="rect" coords="241,168,472,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5bf180324668e4baaa431edb5ba56993"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixFunctionOracle.html#a5bf180324668e4baaa431edb5ba56993">evaluate</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;current_point, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> relprec, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> &amp;objective_value, std::vector&lt; <a class="el" href="classConicBundle_1_1Minorant.html">Minorant</a> *&gt; &amp;minorants, <a class="el" href="classConicBundle_1_1PrimalExtender.html">PrimalExtender</a> *&amp;primal_extender)=0</td></tr>
<tr class="memdesc:a5bf180324668e4baaa431edb5ba56993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the solver. Has to Return function value and at least one (epsilon) subgradient and, possibly for Lagrangean relaxation, some primal data.  <a href="#a5bf180324668e4baaa431edb5ba56993">More...</a><br /></td></tr>
<tr class="separator:a5bf180324668e4baaa431edb5ba56993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ceb8162aa19ff7122b8cd3c784e4d0"><td class="memItemLeft" align="right" valign="top"><a id="a03ceb8162aa19ff7122b8cd3c784e4d0"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixFunctionOracle.html#a03ceb8162aa19ff7122b8cd3c784e4d0">check_correctness</a> () const</td></tr>
<tr class="memdesc:a03ceb8162aa19ff7122b8cd3c784e4d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">switch on/off some correctnes checks on the oracle <br /></td></tr>
<tr class="separator:a03ceb8162aa19ff7122b8cd3c784e4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classConicBundle_1_1ModifiableOracleObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classConicBundle_1_1ModifiableOracleObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classConicBundle_1_1ModifiableOracleObject.html">ConicBundle::ModifiableOracleObject</a></td></tr>
<tr class="memitem:aabf6cf7095bdac38ab14308b6c199761 inherit pub_methods_classConicBundle_1_1ModifiableOracleObject"><td class="memItemLeft" align="right" valign="top"><a id="aabf6cf7095bdac38ab14308b6c199761"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1ModifiableOracleObject.html#aabf6cf7095bdac38ab14308b6c199761">~ModifiableOracleObject</a> ()</td></tr>
<tr class="memdesc:aabf6cf7095bdac38ab14308b6c199761 inherit pub_methods_classConicBundle_1_1ModifiableOracleObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual destructor <br /></td></tr>
<tr class="separator:aabf6cf7095bdac38ab14308b6c199761 inherit pub_methods_classConicBundle_1_1ModifiableOracleObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f16d78fec3a02cc064003c2b02ddce inherit pub_methods_classConicBundle_1_1ModifiableOracleObject"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1ModifiableOracleObject.html#ab4f16d78fec3a02cc064003c2b02ddce">apply_modification</a> (const <a class="el" href="classConicBundle_1_1OracleModification.html">OracleModification</a> &amp;oracle_modification, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *new_center, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *old_center, bool &amp;discard_objective_in_center, bool &amp;discard_model, bool &amp;discard_aggregates, <a class="el" href="classConicBundle_1_1MinorantExtender.html">MinorantExtender</a> *&amp;minorant_extender)</td></tr>
<tr class="memdesc:ab4f16d78fec3a02cc064003c2b02ddce inherit pub_methods_classConicBundle_1_1ModifiableOracleObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine need not be implemented unless variables (constraints in Lagrangean relaxation) are added or deleted on the fly.  <a href="classConicBundle_1_1ModifiableOracleObject.html#ab4f16d78fec3a02cc064003c2b02ddce">More...</a><br /></td></tr>
<tr class="separator:ab4f16d78fec3a02cc064003c2b02ddce inherit pub_methods_classConicBundle_1_1ModifiableOracleObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Oracle interface (abstract class). For each of your functions, provide an instance of a derived class. </p>
<p>The oracle interface is used to describe and pass convex objective functions to the <a class="el" href="classConicBundle_1_1MatrixCBSolver.html" title="The Full Conic Bundle method solver invoked by ConicBundle::MatrixCBSolver(), it uses a separate cutt...">ConicBundle::MatrixCBSolver</a>. The dimension of the argument vector of the function (or, if an <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html" title="transform a function f(z) to fun_coeff*f(arg_offset+arg_trafo*y)+linear_cost*y+fun_offset (scales the...">ConicBundle::AffineFunctionTransformation</a> is supplied for this function, the dimension of the transformation argument) must be set in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a5129b50d68be01aaa8cb6825058a8f13" title="Initializes the problem by setting up the design space (the dimension and possibly box constraints on...">ConicBundle::MatrixCBSolver::init_problem()</a> and the functions are then added to the solver by <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a3c503663b689ede0f1d004690d622e2f" title="Adds a function, typically derived from ConicBundle::FunctionOracle. If the dimension does not match ...">ConicBundle::MatrixCBSolver::add_function()</a>.</p>
<p>If the sum of several such functions is to be minimized it is the task of the user to guarantee, that all dimensions match, e.g. by using an appropriate <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html" title="transform a function f(z) to fun_coeff*f(arg_offset+arg_trafo*y)+linear_cost*y+fun_offset (scales the...">AffineFunctionTransformation</a> for each.</p>
<p>If the function corresponds to Lagrangean relaxation of a primal maximization problem one may want to generate a primal approximate solution. In this case, return in the function <a class="el" href="classConicBundle_1_1MatrixFunctionOracle.html#a5bf180324668e4baaa431edb5ba56993" title="Called by the solver. Has to Return function value and at least one (epsilon) subgradient and...">evaluate()</a> the generating primal objects within each minorant. If no primal objects are included, there will be no primal aggregation.</p>
<p>If primal aggregation is used then it is possible to implement a primal cutting plane framework. This requires the introduction of new (dual) variables in the design space of the function. In this case the function <a class="el" href="classConicBundle_1_1MinorantExtender.html" title="Interface for extending a Minorant, e.g., in Lagrangian Relaxation of cutting plane approaches...">MinorantExtender</a> returned in <a class="el" href="classConicBundle_1_1ModifiableOracleObject.html#ab4f16d78fec3a02cc064003c2b02ddce" title="This routine need not be implemented unless variables (constraints in Lagrangean relaxation) are adde...">apply_modification()</a> serves the purpose of filling in the missing coordinates in existing subgradients. If this feature is not needed, the function may be used as is and need not be reimplemented. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a5bf180324668e4baaa431edb5ba56993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf180324668e4baaa431edb5ba56993">&#9670;&nbsp;</a></span>evaluate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ConicBundle::MatrixFunctionOracle::evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>current_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a>&#160;</td>
          <td class="paramname"><em>relprec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> &amp;&#160;</td>
          <td class="paramname"><em>objective_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classConicBundle_1_1Minorant.html">Minorant</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>minorants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1PrimalExtender.html">PrimalExtender</a> *&amp;&#160;</td>
          <td class="paramname"><em>primal_extender</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by the solver. Has to Return function value and at least one (epsilon) subgradient and, possibly for Lagrangean relaxation, some primal data. </p>
<p>The evaluation method is the main interface to the bundle solver. The solver calls this method to obtain for the <em>current_point</em> (its dimension is set in <a class="el" href="classConicBundle_1_1CBSolver.html#aaaca3b1092a1305a8ddf4f181e1bf256" title="Initializes the problem by setting up the design space (the dimension and possible box constraints of...">ConicBundle::CBSolver::init_problem()</a> or via a <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html" title="transform a function f(z) to fun_coeff*f(arg_offset+arg_trafo*y)+linear_cost*y+fun_offset (scales the...">AffineFunctionTransformation</a> specified in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a3c503663b689ede0f1d004690d622e2f" title="Adds a function, typically derived from ConicBundle::FunctionOracle. If the dimension does not match ...">MatrixCBSolver::add_function()</a>) the <em>objective_value</em> and (epsilon) subgradient information. In any call several epsilon subgradients may be returned in <em>minorants</em> along with their offset, but at least one has to be returend. Each subgradient and offset describes a linear minorant to the convex function and is used by the bundle method to form a cutting model of the convex function.</p>
<p>In many applications, computing the function value is an iterative process that approaches the true function value from below. On input the code offers a bound in <em>objective_value</em> for the function value, above which it is certain that the code will reject the current point. If in the iterative process a lower bound on the function value exceeds this bound, then it is sufficient to return, instead of the true function value and a subgradient, the current lower bound and a vector so that together they describe a supporting hyperplane (i.e. a linear minorant) to the function at this point.</p>
<p>If the function corresponds to Lagrangean relaxation of a primal maximization problem one may want to generate a primal approximate solution. For this purpose the minorants may also hold information on the primal data. If at each call and for each epsilon subgradient the corresponding generating primal object (must be derived from <a class="el" href="classConicBundle_1_1PrimalData.html" title="In Lagrangean relaxation an approximate primal solution can be generated by supplying primal informat...">ConicBundle::PrimalData</a>, e.g., a <a class="el" href="classConicBundle_1_1PrimalDVector.html" title="If in Lagrangean relaxation primal solutions are in the form of a ConicBundle::DVector, then an approximate primal solution can be generated by supplying primal information of this form for each epsilon subgradient within ConicBundle::FunctionOracle::evaluate(). ">ConicBundle::PrimalDVector</a>) is stored, then the code automatically performs the aggregation corresponding to the aggregation of the subgradients on the primal data objects. The primal approximate solution is finally delivered by the methods <a class="el" href="classConicBundle_1_1CBSolver.html#ad171dec64fe06f5478a3ab637c484e4c" title="returns the current approximate primal solution corresponding to the aggregate subgradient of the spe...">ConicBundle::CBSolver::get_approximate_primal()</a> or <a class="el" href="classConicBundle_1_1CBSolver.html#af3c96e5f61e6dc6b8223dd63760cd1ab" title="Returns the primal solution corresponding to the best epsilon subgradient returned in the evaluation ...">ConicBundle::CBSolver::get_center_primal()</a>.</p>
<p>All minorants passed to the solver must be objects allocated on the heap. The ownership of these objects is transferred to the solver and the solver will destroy them eventually, so DO NOT delete them yourself!</p>
<p>If no primal aggregation is desired, simply do not touch <em>primal_data</em> or clear it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">current_point</td><td>(const Matrix&amp;) argument of the function as a column vector (e.g. the Lagrange multipliers)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relprec</td><td>(double) relative precision requirement for objective values that may lead to descent steps (this precision is not required if it is already certain that the function value will be too poor)</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">objective_value</td><td>(double&amp;)<ul>
<li>on input: value gives the threshold for a null step; you may stop, if a cutting plane yields at least this;</li>
<li>on output: return an upper bound on the true function value within <em>relprec</em> *(abs(objval)+1.), if there is no linear minorant cutting above the threshold specified in objective_value on input. Otherwise the return value should be the max of cut_values.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">minorants</td><td>(std::vector&lt;Minorant*&gt;) for returning linear minorants (subgradients and their offset values). At least one must be returned and the one at index 0 must maximize the value at the current point over all further ones given here. In particular its value at point should be above the threshold or be within relprec *(abs(objval)+1.) of the true objective. Within the minorants primal data may be supplied if this should be aggregated along.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">primal_extender</td><td>(PrimalExtender*&amp;) if primal_data of previous calls has now to be updated due to changes in the primal problem &ndash; e.g., this may happen in column generation &ndash; one may return a pointer to <a class="el" href="classConicBundle_1_1PrimalExtender.html" title="Interface for extending PrimalData, e.g., in Lagrangian relaxation of column generation approaches...">PrimalExtender</a> object on the heap. This object will be used by <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> to update all its internally stored primal_data objects by calling <a class="el" href="classConicBundle_1_1PrimalExtender.html#a13fc586276e23d575b935dbfe12495c0" title="called by ConicBundle to update internal PrimalData objects, has to return 0 on success ...">PrimalExtender::extend</a> on each of these, afterwards <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> deletes primal_extender If this is not needed, the variable holds 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0, all correct</li>
<li>!=0, failure. This does not necessarily terminate the bundle method. Termination is forced only if no new subgradient is returned. </li>
</ul>
</dd></dl>

<p>Implemented in <a class="el" href="group__implemented__matrix__function__oracle.html#ga342cabd317d3490f074f64fde6864aa4">ConicBundle::NNCBoxSupportFunction</a>, and <a class="el" href="classConicBundle_1_1CFunction.html#a23c295fdc146c4e1d240b3ebf2b2d78c">ConicBundle::CFunction</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="MatrixCBSolver_8hxx_source.html">MatrixCBSolver.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
