<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ConicBundle: CH_Matrix_Classes::Symmatrix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ConicBundle
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceCH__Matrix__Classes.html">CH_Matrix_Classes</a></li><li class="navelem"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classCH__Matrix__Classes_1_1Symmatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CH_Matrix_Classes::Symmatrix Class Reference<div class="ingroups"><a class="el" href="group__Symmatrixgroup.html">Symmatrix (dense, real, symmetric, n by n)</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Matrix class of symmetric matrices with real values of type <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type ">Real</a>  
 <a href="classCH__Matrix__Classes_1_1Symmatrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="symmat_8hxx_source.html">symmat.hxx</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CH_Matrix_Classes::Symmatrix:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classCH__Matrix__Classes_1_1Symmatrix.png" usemap="#CH_5FMatrix_5FClasses::Symmatrix_map" alt=""/>
  <map id="CH_5FMatrix_5FClasses::Symmatrix_map" name="CH_5FMatrix_5FClasses::Symmatrix_map">
<area href="classCH__Matrix__Classes_1_1Memarrayuser.html" title="All derived classes share a common Memarray memory manager, which is generated with the first user an..." alt="CH_Matrix_Classes::Memarrayuser" shape="rect" coords="0,0,212,24"/>
<area href="classConicBundle_1_1DensePSCPrimal.html" title="implements a general purpose dense symmetric PSCPrimal based on CH_Matrix_Classes::Symmatrix ..." alt="ConicBundle::DensePSCPrimal" shape="rect" coords="0,112,212,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors, Destructor, and Initialization (Members)</div></td></tr>
<tr class="memitem:a77b76cc41cb98ad78dc90cfdd17e6f1c"><td class="memItemLeft" align="right" valign="top"><a id="a77b76cc41cb98ad78dc90cfdd17e6f1c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a77b76cc41cb98ad78dc90cfdd17e6f1c">Symmatrix</a> ()</td></tr>
<tr class="memdesc:a77b76cc41cb98ad78dc90cfdd17e6f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty matrix <br /></td></tr>
<tr class="separator:a77b76cc41cb98ad78dc90cfdd17e6f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d71af384160bec3cad86aa479b838f"><td class="memItemLeft" align="right" valign="top"><a id="a95d71af384160bec3cad86aa479b838f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a95d71af384160bec3cad86aa479b838f">Symmatrix</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, double d=1.)</td></tr>
<tr class="memdesc:a95d71af384160bec3cad86aa479b838f"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor, *this=d*A <br /></td></tr>
<tr class="separator:a95d71af384160bec3cad86aa479b838f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea95b6f59c5c5012a08088f4208601e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#aeea95b6f59c5c5012a08088f4208601e">Symmatrix</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a081b04bbf1938d34a8bbb7031cdb6be6">nr</a>)</td></tr>
<tr class="memdesc:aeea95b6f59c5c5012a08088f4208601e"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate a matrix of size nr x nr but WITHOUT initializing the memory  <a href="#aeea95b6f59c5c5012a08088f4208601e">More...</a><br /></td></tr>
<tr class="separator:aeea95b6f59c5c5012a08088f4208601e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824fd11cc74b9c3b7b897b42b60ed861"><td class="memItemLeft" align="right" valign="top"><a id="a824fd11cc74b9c3b7b897b42b60ed861"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a824fd11cc74b9c3b7b897b42b60ed861">Symmatrix</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a081b04bbf1938d34a8bbb7031cdb6be6">nr</a>, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:a824fd11cc74b9c3b7b897b42b60ed861"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate a matrix of size nr x nr initializing all elements to the value d <br /></td></tr>
<tr class="separator:a824fd11cc74b9c3b7b897b42b60ed861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb85db9fdccd9219a5acd43f50d8aca"><td class="memItemLeft" align="right" valign="top"><a id="a5bb85db9fdccd9219a5acd43f50d8aca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a5bb85db9fdccd9219a5acd43f50d8aca">Symmatrix</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a081b04bbf1938d34a8bbb7031cdb6be6">nr</a>, const <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> *dp)</td></tr>
<tr class="memdesc:a5bb85db9fdccd9219a5acd43f50d8aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate a matrix of size nr x nr initializing the elements from the (one dimensional) array dp, which must have the elements arranged consecutively in internal order <br /></td></tr>
<tr class="separator:a5bb85db9fdccd9219a5acd43f50d8aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c3e4f1dce24e7c8ed21934cf217748"><td class="memItemLeft" align="right" valign="top"><a id="a56c3e4f1dce24e7c8ed21934cf217748"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~Symmatrix</b> ()</td></tr>
<tr class="separator:a56c3e4f1dce24e7c8ed21934cf217748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea14efca04115bfb34febd3084108ab"><td class="memItemLeft" align="right" valign="top"><a id="a2ea14efca04115bfb34febd3084108ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a2ea14efca04115bfb34febd3084108ab">set_init</a> (bool)</td></tr>
<tr class="memdesc:a2ea14efca04115bfb34febd3084108ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">after external initialization, call matrix.set_init(true) (not needed if CONICBUNDLE_DEBUG is undefined) <br /></td></tr>
<tr class="separator:a2ea14efca04115bfb34febd3084108ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1b27860806b5cd95b420168176f02c"><td class="memItemLeft" align="right" valign="top"><a id="a9f1b27860806b5cd95b420168176f02c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a9f1b27860806b5cd95b420168176f02c">get_init</a> () const</td></tr>
<tr class="memdesc:a9f1b27860806b5cd95b420168176f02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the matrix has been declared initialized (not needed if CONICBUNDLE_DEBUG is undefined) <br /></td></tr>
<tr class="separator:a9f1b27860806b5cd95b420168176f02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c19c09c02b0b048a04e5831bf6e3b2"><td class="memItemLeft" align="right" valign="top"><a id="a83c19c09c02b0b048a04e5831bf6e3b2"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a83c19c09c02b0b048a04e5831bf6e3b2">init</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, double d=1.)</td></tr>
<tr class="memdesc:a83c19c09c02b0b048a04e5831bf6e3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize to *this=A*d <br /></td></tr>
<tr class="separator:a83c19c09c02b0b048a04e5831bf6e3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7690f7cce71d3747e1d1958f55a379cf"><td class="memItemLeft" align="right" valign="top"><a id="a7690f7cce71d3747e1d1958f55a379cf"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a7690f7cce71d3747e1d1958f55a379cf">init</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, double d=1.)</td></tr>
<tr class="memdesc:a7690f7cce71d3747e1d1958f55a379cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize to <em>this=d</em>(A+transpose(A))/2. <br /></td></tr>
<tr class="separator:a7690f7cce71d3747e1d1958f55a379cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456eabc2aa1a16b66f654ba779d9e2de"><td class="memItemLeft" align="right" valign="top"><a id="a456eabc2aa1a16b66f654ba779d9e2de"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a456eabc2aa1a16b66f654ba779d9e2de">init</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A, double d=1.)</td></tr>
<tr class="memdesc:a456eabc2aa1a16b66f654ba779d9e2de"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize to <em>this=d</em>(A+transpose(A))/2. <br /></td></tr>
<tr class="separator:a456eabc2aa1a16b66f654ba779d9e2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad303de883c26020ed2591e2f8a69a35b"><td class="memItemLeft" align="right" valign="top"><a id="ad303de883c26020ed2591e2f8a69a35b"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ad303de883c26020ed2591e2f8a69a35b">init</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>
<tr class="memdesc:ad303de883c26020ed2591e2f8a69a35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize to *this=A*d <br /></td></tr>
<tr class="separator:ad303de883c26020ed2591e2f8a69a35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f002e510774193b59aa326625341993"><td class="memItemLeft" align="right" valign="top"><a id="a3f002e510774193b59aa326625341993"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a3f002e510774193b59aa326625341993">init</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a081b04bbf1938d34a8bbb7031cdb6be6">nr</a>, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:a3f002e510774193b59aa326625341993"><td class="mdescLeft">&#160;</td><td class="mdescRight">intialize *this to a matrix of size nr x nr initializing all elements to the value d <br /></td></tr>
<tr class="separator:a3f002e510774193b59aa326625341993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b0b6d94cb86d8c8a54fae8c00be558"><td class="memItemLeft" align="right" valign="top"><a id="a05b0b6d94cb86d8c8a54fae8c00be558"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a05b0b6d94cb86d8c8a54fae8c00be558">init</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a081b04bbf1938d34a8bbb7031cdb6be6">nr</a>, const <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> *dp)</td></tr>
<tr class="memdesc:a05b0b6d94cb86d8c8a54fae8c00be558"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate a matrix of size nr x nc initializing the elements from the (one dimensional) array dp which must have the elements arranged consecutively in internal order <br /></td></tr>
<tr class="separator:a05b0b6d94cb86d8c8a54fae8c00be558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e3cc5de2659fb4eb213eaca2276626"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a43e3cc5de2659fb4eb213eaca2276626">newsize</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> n)</td></tr>
<tr class="memdesc:a43e3cc5de2659fb4eb213eaca2276626"><td class="mdescLeft">&#160;</td><td class="mdescRight">resize the matrix to nr x nr elements but WITHOUT initializing the memory  <a href="#a43e3cc5de2659fb4eb213eaca2276626">More...</a><br /></td></tr>
<tr class="separator:a43e3cc5de2659fb4eb213eaca2276626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Conversions from other Matrix Classes (Members)</div></td></tr>
<tr class="memitem:a0cb203055486e3fed534b70fe8804349"><td class="memItemLeft" align="right" valign="top"><a id="a0cb203055486e3fed534b70fe8804349"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a0cb203055486e3fed534b70fe8804349">Symmatrix</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;, double d=1.)</td></tr>
<tr class="memdesc:a0cb203055486e3fed534b70fe8804349"><td class="mdescLeft">&#160;</td><td class="mdescRight">(<em>this)=d</em>(A+transpose(A))/2. <br /></td></tr>
<tr class="separator:a0cb203055486e3fed534b70fe8804349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a67f53b1a29a1e92d5837f6acb8447"><td class="memItemLeft" align="right" valign="top"><a id="a21a67f53b1a29a1e92d5837f6acb8447"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a21a67f53b1a29a1e92d5837f6acb8447">Symmatrix</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;, double d=1.)</td></tr>
<tr class="memdesc:a21a67f53b1a29a1e92d5837f6acb8447"><td class="mdescLeft">&#160;</td><td class="mdescRight">(<em>this)=d</em>(A+transpose(A))/2. <br /></td></tr>
<tr class="separator:a21a67f53b1a29a1e92d5837f6acb8447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add96fd2333a8d24327dca0895dc1c942"><td class="memItemLeft" align="right" valign="top"><a id="add96fd2333a8d24327dca0895dc1c942"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#add96fd2333a8d24327dca0895dc1c942">Symmatrix</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>
<tr class="memdesc:add96fd2333a8d24327dca0895dc1c942"><td class="mdescLeft">&#160;</td><td class="mdescRight">(*this)=d*A <br /></td></tr>
<tr class="separator:add96fd2333a8d24327dca0895dc1c942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Size and Type Information (Members)</div></td></tr>
<tr class="memitem:a98558c8ab89aee800993a9da654da765"><td class="memItemLeft" align="right" valign="top"><a id="a98558c8ab89aee800993a9da654da765"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a98558c8ab89aee800993a9da654da765">dim</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> &amp;_nr, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> &amp;_nc) const</td></tr>
<tr class="memdesc:a98558c8ab89aee800993a9da654da765"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of rows in _nr and _nc <br /></td></tr>
<tr class="separator:a98558c8ab89aee800993a9da654da765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a68c7869a0d0b336851b7e814ac10c6"><td class="memItemLeft" align="right" valign="top"><a id="a8a68c7869a0d0b336851b7e814ac10c6"></a>
<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a8a68c7869a0d0b336851b7e814ac10c6">dim</a> () const</td></tr>
<tr class="memdesc:a8a68c7869a0d0b336851b7e814ac10c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the dimension rows * columns when the matrix is regarded as a vector <br /></td></tr>
<tr class="separator:a8a68c7869a0d0b336851b7e814ac10c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6c1a12ebe7ac71ce45c10d38a2cf5f"><td class="memItemLeft" align="right" valign="top"><a id="a3f6c1a12ebe7ac71ce45c10d38a2cf5f"></a>
<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a3f6c1a12ebe7ac71ce45c10d38a2cf5f">rowdim</a> () const</td></tr>
<tr class="memdesc:a3f6c1a12ebe7ac71ce45c10d38a2cf5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the row dimension <br /></td></tr>
<tr class="separator:a3f6c1a12ebe7ac71ce45c10d38a2cf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1f968540b298f2804145e8d11e2b22"><td class="memItemLeft" align="right" valign="top"><a id="a6a1f968540b298f2804145e8d11e2b22"></a>
<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a6a1f968540b298f2804145e8d11e2b22">coldim</a> () const</td></tr>
<tr class="memdesc:a6a1f968540b298f2804145e8d11e2b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the column dimension <br /></td></tr>
<tr class="separator:a6a1f968540b298f2804145e8d11e2b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168cbdea1263ed116b902000a029deda"><td class="memItemLeft" align="right" valign="top"><a id="a168cbdea1263ed116b902000a029deda"></a>
<a class="el" href="group__matop__matrixerror.html#ga204f53041409b9f5efb2f8b41964b6b8">Mtype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a168cbdea1263ed116b902000a029deda">get_mtype</a> () const</td></tr>
<tr class="memdesc:a168cbdea1263ed116b902000a029deda"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the type of the matrix, MTsymmetric <br /></td></tr>
<tr class="separator:a168cbdea1263ed116b902000a029deda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Indexing and Submatrices (Members)</div></td></tr>
<tr class="memitem:a56cd70cbe8966417a95cb24db5c037bf"><td class="memItemLeft" align="right" valign="top"><a id="a56cd70cbe8966417a95cb24db5c037bf"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a56cd70cbe8966417a95cb24db5c037bf">operator()</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> i, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> j)</td></tr>
<tr class="memdesc:a56cd70cbe8966417a95cb24db5c037bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns reference to element (i,j) of the matrix (rowindex i, columnindex j) <br /></td></tr>
<tr class="separator:a56cd70cbe8966417a95cb24db5c037bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde9b4fc98a928c2bff72988512d0c41"><td class="memItemLeft" align="right" valign="top"><a id="afde9b4fc98a928c2bff72988512d0c41"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#afde9b4fc98a928c2bff72988512d0c41">operator()</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> i)</td></tr>
<tr class="memdesc:afde9b4fc98a928c2bff72988512d0c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns reference to element (i) of the matrix if regarded as vector of stacked columns [element (irowdim, i/rowdim)] <br /></td></tr>
<tr class="separator:afde9b4fc98a928c2bff72988512d0c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da2568270652fef0e1ea1991dfdf26c"><td class="memItemLeft" align="right" valign="top"><a id="a3da2568270652fef0e1ea1991dfdf26c"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a3da2568270652fef0e1ea1991dfdf26c">operator()</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> i, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> j) const</td></tr>
<tr class="memdesc:a3da2568270652fef0e1ea1991dfdf26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns value of element (i,j) of the matrix (rowindex i, columnindex j) <br /></td></tr>
<tr class="separator:a3da2568270652fef0e1ea1991dfdf26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd76760742a3474febf33291e7b91e40"><td class="memItemLeft" align="right" valign="top"><a id="acd76760742a3474febf33291e7b91e40"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#acd76760742a3474febf33291e7b91e40">operator()</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> i) const</td></tr>
<tr class="memdesc:acd76760742a3474febf33291e7b91e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns value of element (i) of the matrix if regarded as vector of stacked columns [element (irowdim, i/rowdim)] <br /></td></tr>
<tr class="separator:acd76760742a3474febf33291e7b91e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9657cbfa57f27fcedadf42f66f8568b"><td class="memItemLeft" align="right" valign="top"><a id="ad9657cbfa57f27fcedadf42f66f8568b"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ad9657cbfa57f27fcedadf42f66f8568b">col</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> i) const</td></tr>
<tr class="memdesc:ad9657cbfa57f27fcedadf42f66f8568b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns column i copied to a new <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> <br /></td></tr>
<tr class="separator:ad9657cbfa57f27fcedadf42f66f8568b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d5c8aa351a0f16c7209f1938061325"><td class="memItemLeft" align="right" valign="top"><a id="a37d5c8aa351a0f16c7209f1938061325"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a37d5c8aa351a0f16c7209f1938061325">row</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> i) const</td></tr>
<tr class="memdesc:a37d5c8aa351a0f16c7209f1938061325"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns row i copied to a new <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> <br /></td></tr>
<tr class="separator:a37d5c8aa351a0f16c7209f1938061325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b33dfdc0ab60edc40cda8329206429"><td class="memItemLeft" align="right" valign="top"><a id="a03b33dfdc0ab60edc40cda8329206429"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a03b33dfdc0ab60edc40cda8329206429">cols</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;vec) const</td></tr>
<tr class="memdesc:a03b33dfdc0ab60edc40cda8329206429"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix of size this-&gt;<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a3f6c1a12ebe7ac71ce45c10d38a2cf5f" title="returns the row dimension ">rowdim()</a> x vec.dim(), with column i a copy of column vec(i) of *this <br /></td></tr>
<tr class="separator:a03b33dfdc0ab60edc40cda8329206429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5549858f989e8bdf50d00f00c5532e"><td class="memItemLeft" align="right" valign="top"><a id="a8b5549858f989e8bdf50d00f00c5532e"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a8b5549858f989e8bdf50d00f00c5532e">rows</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;vec) const</td></tr>
<tr class="memdesc:a8b5549858f989e8bdf50d00f00c5532e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix of size vec.dim() x this-&gt;<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a6a1f968540b298f2804145e8d11e2b22" title="returns the column dimension ">coldim()</a>, with row i a copy of row vec(i) of *this <br /></td></tr>
<tr class="separator:a8b5549858f989e8bdf50d00f00c5532e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2033912a039d640df083ee3718d84cb"><td class="memItemLeft" align="right" valign="top"><a id="ac2033912a039d640df083ee3718d84cb"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ac2033912a039d640df083ee3718d84cb">swapij</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> i, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> j)</td></tr>
<tr class="memdesc:ac2033912a039d640df083ee3718d84cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">swaps rows (and columns) i and j <br /></td></tr>
<tr class="separator:ac2033912a039d640df083ee3718d84cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d6985034b11cc42e1ed9b615e42b94"><td class="memItemLeft" align="right" valign="top"><a id="ae1d6985034b11cc42e1ed9b615e42b94"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ae1d6985034b11cc42e1ed9b615e42b94">pivot_permute</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;piv, bool inverse=false)</td></tr>
<tr class="memdesc:ae1d6985034b11cc42e1ed9b615e42b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">for i=0 to rowdim row (and column) i of this matrix is swapped with row piv(j); for inverse=true the inverse permutation is generated <br /></td></tr>
<tr class="separator:ae1d6985034b11cc42e1ed9b615e42b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0882762c079232855dcf68b0f1ce99"><td class="memItemLeft" align="right" valign="top"><a id="a5d0882762c079232855dcf68b0f1ce99"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a5d0882762c079232855dcf68b0f1ce99">principal_submatrix</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;ind, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;S) const</td></tr>
<tr class="memdesc:a5d0882762c079232855dcf68b0f1ce99"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns S and in S the principal submatrix indexed by ind (multiple indices are allowed) <br /></td></tr>
<tr class="separator:a5d0882762c079232855dcf68b0f1ce99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cf499955e551eb1135452c2da98eae"><td class="memItemLeft" align="right" valign="top"><a id="af3cf499955e551eb1135452c2da98eae"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#af3cf499955e551eb1135452c2da98eae">principal_submatrix</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;ind) const</td></tr>
<tr class="memdesc:af3cf499955e551eb1135452c2da98eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the principal submatrix indexed by ind (multiple indices are allowed) <br /></td></tr>
<tr class="separator:af3cf499955e551eb1135452c2da98eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797bc8e1076fdd83e9f7cc5639808074"><td class="memItemLeft" align="right" valign="top"><a id="a797bc8e1076fdd83e9f7cc5639808074"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a797bc8e1076fdd83e9f7cc5639808074">delete_principal_submatrix</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;ind, bool sorted_increasingly=false)</td></tr>
<tr class="memdesc:a797bc8e1076fdd83e9f7cc5639808074"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns this afte deleting the principal submatrix indexed by ind (no repetitions!); <br /></td></tr>
<tr class="separator:a797bc8e1076fdd83e9f7cc5639808074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f4334ab75c2a57afabe07f48ef00fb"><td class="memItemLeft" align="right" valign="top"><a id="a87f4334ab75c2a57afabe07f48ef00fb"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a87f4334ab75c2a57afabe07f48ef00fb">enlarge_below</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> addn)</td></tr>
<tr class="memdesc:a87f4334ab75c2a57afabe07f48ef00fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">increases the order of the matrix by appending storage for further addn rows and columns (marked as not initiliazed if addn&gt;0, no changes if addn&lt;=0) <br /></td></tr>
<tr class="separator:a87f4334ab75c2a57afabe07f48ef00fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7e21fd6d9fec6cde0c6b827c15d9f2"><td class="memItemLeft" align="right" valign="top"><a id="a0d7e21fd6d9fec6cde0c6b827c15d9f2"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a0d7e21fd6d9fec6cde0c6b827c15d9f2">enlarge_below</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> addn, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:a0d7e21fd6d9fec6cde0c6b827c15d9f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">increases the order of the matrix by appending storage for further addn rows and columns initialized to d (no changes if addn&lt;=0); <br /></td></tr>
<tr class="separator:a0d7e21fd6d9fec6cde0c6b827c15d9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f4f625633b10abab2212a70a4e9380"><td class="memItemLeft" align="right" valign="top"><a id="ac7f4f625633b10abab2212a70a4e9380"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ac7f4f625633b10abab2212a70a4e9380">get_store</a> ()</td></tr>
<tr class="memdesc:ac7f4f625633b10abab2212a70a4e9380"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the current address of the internal value array; use cautiously, do not use delete! <br /></td></tr>
<tr class="separator:ac7f4f625633b10abab2212a70a4e9380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2fb45683aaa043d2ff8d3a10f100c2"><td class="memItemLeft" align="right" valign="top"><a id="a1c2fb45683aaa043d2ff8d3a10f100c2"></a>
const <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a1c2fb45683aaa043d2ff8d3a10f100c2">get_store</a> () const</td></tr>
<tr class="memdesc:a1c2fb45683aaa043d2ff8d3a10f100c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the current address of the internal value array; use cautiously! <br /></td></tr>
<tr class="separator:a1c2fb45683aaa043d2ff8d3a10f100c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">BLAS-like Routines (Members)</div></td></tr>
<tr class="memitem:a9165e0218fd158ce056bc70415701fbc"><td class="memItemLeft" align="right" valign="top"><a id="a9165e0218fd158ce056bc70415701fbc"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a9165e0218fd158ce056bc70415701fbc">xeya</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>
<tr class="memdesc:a9165e0218fd158ce056bc70415701fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets *this=d*A and returns *this <br /></td></tr>
<tr class="separator:a9165e0218fd158ce056bc70415701fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0043ad0e3d5fee1827aa27783509c3f9"><td class="memItemLeft" align="right" valign="top"><a id="a0043ad0e3d5fee1827aa27783509c3f9"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a0043ad0e3d5fee1827aa27783509c3f9">xpeya</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>
<tr class="memdesc:a0043ad0e3d5fee1827aa27783509c3f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets *this+=d*A and returns *this <br /></td></tr>
<tr class="separator:a0043ad0e3d5fee1827aa27783509c3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Usual Arithmetic Operators (Members)</div></td></tr>
<tr class="memitem:a8a902c276d40121c0c9fc0d391ecacc3"><td class="memItemLeft" align="right" valign="top"><a id="a8a902c276d40121c0c9fc0d391ecacc3"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="separator:a8a902c276d40121c0c9fc0d391ecacc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890f8623bf0c18dc1871d00a20d18dbe"><td class="memItemLeft" align="right" valign="top"><a id="a890f8623bf0c18dc1871d00a20d18dbe"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="separator:a890f8623bf0c18dc1871d00a20d18dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9810ccd2abfc469cd87edeb10e2f59df"><td class="memItemLeft" align="right" valign="top"><a id="a9810ccd2abfc469cd87edeb10e2f59df"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="separator:a9810ccd2abfc469cd87edeb10e2f59df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a0a0248a4bb0eda3a0b004c28527a4"><td class="memItemLeft" align="right" valign="top"><a id="aa5a0a0248a4bb0eda3a0b004c28527a4"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#aa5a0a0248a4bb0eda3a0b004c28527a4">operator%=</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:aa5a0a0248a4bb0eda3a0b004c28527a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">ATTENTION: this is redefined as the Hadamard product, (*this)(i,j)=(*this)(i,j)*A(i,j) for all i&lt;=j. <br /></td></tr>
<tr class="separator:aa5a0a0248a4bb0eda3a0b004c28527a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821b0417f335be0d7caf845d28e45ed2"><td class="memItemLeft" align="right" valign="top"><a id="a821b0417f335be0d7caf845d28e45ed2"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> () const</td></tr>
<tr class="separator:a821b0417f335be0d7caf845d28e45ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13d0c45c18ffe8a9711a428a4b6099e"><td class="memItemLeft" align="right" valign="top"><a id="ae13d0c45c18ffe8a9711a428a4b6099e"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="separator:ae13d0c45c18ffe8a9711a428a4b6099e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0550a9d8b0e225a1cf4152444249fd73"><td class="memItemLeft" align="right" valign="top"><a id="a0550a9d8b0e225a1cf4152444249fd73"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a0550a9d8b0e225a1cf4152444249fd73">operator/=</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:a0550a9d8b0e225a1cf4152444249fd73"><td class="mdescLeft">&#160;</td><td class="mdescRight">ATTENTION: d is NOT checked for 0. <br /></td></tr>
<tr class="separator:a0550a9d8b0e225a1cf4152444249fd73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cc2f7b715f643ae94f2a59ddd8b757"><td class="memItemLeft" align="right" valign="top"><a id="a16cc2f7b715f643ae94f2a59ddd8b757"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a16cc2f7b715f643ae94f2a59ddd8b757">operator+=</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:a16cc2f7b715f643ae94f2a59ddd8b757"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets (*this)(i,j)+=d for all i&lt;=j <br /></td></tr>
<tr class="separator:a16cc2f7b715f643ae94f2a59ddd8b757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a7b26374103749f4578e4aab7ae94d"><td class="memItemLeft" align="right" valign="top"><a id="af2a7b26374103749f4578e4aab7ae94d"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#af2a7b26374103749f4578e4aab7ae94d">operator-=</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:af2a7b26374103749f4578e4aab7ae94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets (*this)(i,j)-=d for all i&lt;=j <br /></td></tr>
<tr class="separator:af2a7b26374103749f4578e4aab7ae94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c30091f07177dd6d52986e46759d2e"><td class="memItemLeft" align="right" valign="top"><a id="ab4c30091f07177dd6d52986e46759d2e"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ab4c30091f07177dd6d52986e46759d2e">transpose</a> ()</td></tr>
<tr class="memdesc:ab4c30091f07177dd6d52986e46759d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">transposes itself (at almost no cost) <br /></td></tr>
<tr class="separator:ab4c30091f07177dd6d52986e46759d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Connections to other Classes (Members)</div></td></tr>
<tr class="memitem:a5f3a0411121fac1e93e58680abc6ff83"><td class="memItemLeft" align="right" valign="top"><a id="a5f3a0411121fac1e93e58680abc6ff83"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a5f3a0411121fac1e93e58680abc6ff83">xeya</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>
<tr class="memdesc:a5f3a0411121fac1e93e58680abc6ff83"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets <em>this=d</em>(A+transpose(A))/2. and returns *this <br /></td></tr>
<tr class="separator:a5f3a0411121fac1e93e58680abc6ff83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452068cbd3239e4f2bb18574e3a648bd"><td class="memItemLeft" align="right" valign="top"><a id="a452068cbd3239e4f2bb18574e3a648bd"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a452068cbd3239e4f2bb18574e3a648bd">xpeya</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>
<tr class="memdesc:a452068cbd3239e4f2bb18574e3a648bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets <em>this+=d</em>(A+transpose(A))/2. and returns *this <br /></td></tr>
<tr class="separator:a452068cbd3239e4f2bb18574e3a648bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1be980387ba376eeab4af296392961a"><td class="memItemLeft" align="right" valign="top"><a id="ae1be980387ba376eeab4af296392961a"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ae1be980387ba376eeab4af296392961a">xeya</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>
<tr class="memdesc:ae1be980387ba376eeab4af296392961a"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets <em>this=d</em>(A+transpose(A))/2. and returns *this <br /></td></tr>
<tr class="separator:ae1be980387ba376eeab4af296392961a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa404990d1a84004057d84e89496d824d"><td class="memItemLeft" align="right" valign="top"><a id="aa404990d1a84004057d84e89496d824d"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#aa404990d1a84004057d84e89496d824d">xpeya</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>
<tr class="memdesc:aa404990d1a84004057d84e89496d824d"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets <em>this+=d</em>(A+transpose(A))/2. and returns *this <br /></td></tr>
<tr class="separator:aa404990d1a84004057d84e89496d824d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6565a29bfce684469c0e6246645bffaa"><td class="memItemLeft" align="right" valign="top"><a id="a6565a29bfce684469c0e6246645bffaa"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a6565a29bfce684469c0e6246645bffaa">xeya</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>
<tr class="memdesc:a6565a29bfce684469c0e6246645bffaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets *this=d*A and returns *this <br /></td></tr>
<tr class="separator:a6565a29bfce684469c0e6246645bffaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640bf84db5afdd40720721c4de56c6a3"><td class="memItemLeft" align="right" valign="top"><a id="a640bf84db5afdd40720721c4de56c6a3"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a640bf84db5afdd40720721c4de56c6a3">xpeya</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>
<tr class="memdesc:a640bf84db5afdd40720721c4de56c6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets *this+=d*A and returns *this <br /></td></tr>
<tr class="separator:a640bf84db5afdd40720721c4de56c6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73886a1f2878f24478a4c5e0c7c80a1"><td class="memItemLeft" align="right" valign="top"><a id="ae73886a1f2878f24478a4c5e0c7c80a1"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ae73886a1f2878f24478a4c5e0c7c80a1">xetriu_yza</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>
<tr class="memdesc:ae73886a1f2878f24478a4c5e0c7c80a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets *this(i,j), i&lt;=j to the upper triangle of the matrix product d*transpose(A)*B <br /></td></tr>
<tr class="separator:ae73886a1f2878f24478a4c5e0c7c80a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d8b58a0a5e3afb2bee72d6d1ea58ca"><td class="memItemLeft" align="right" valign="top"><a id="ae8d8b58a0a5e3afb2bee72d6d1ea58ca"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ae8d8b58a0a5e3afb2bee72d6d1ea58ca">xpetriu_yza</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>
<tr class="memdesc:ae8d8b58a0a5e3afb2bee72d6d1ea58ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds to *this(i,j), i&lt;=j the upper triangle of the matrix product d*transpose(A)*B <br /></td></tr>
<tr class="separator:ae8d8b58a0a5e3afb2bee72d6d1ea58ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d413776c154f0c74f628f2f962f8f1"><td class="memItemLeft" align="right" valign="top"><a id="a29d413776c154f0c74f628f2f962f8f1"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a29d413776c154f0c74f628f2f962f8f1">xetriu_yza</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>
<tr class="memdesc:a29d413776c154f0c74f628f2f962f8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets *this(i,j), i&lt;=j to the upper triangle of the matrix product d*transpose(A)*B <br /></td></tr>
<tr class="separator:a29d413776c154f0c74f628f2f962f8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0798001c62a2c3721d106e8788c14d"><td class="memItemLeft" align="right" valign="top"><a id="afd0798001c62a2c3721d106e8788c14d"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#afd0798001c62a2c3721d106e8788c14d">xpetriu_yza</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>
<tr class="memdesc:afd0798001c62a2c3721d106e8788c14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds to *this(i,j), i&lt;=j the upper triangle of the matrix product d*transpose(A)*B <br /></td></tr>
<tr class="separator:afd0798001c62a2c3721d106e8788c14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285510a5d10138bba716f5bd26ebcf69"><td class="memItemLeft" align="right" valign="top"><a id="a285510a5d10138bba716f5bd26ebcf69"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A)</td></tr>
<tr class="separator:a285510a5d10138bba716f5bd26ebcf69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c9518db11e830e6de0acaa930bd88b"><td class="memItemLeft" align="right" valign="top"><a id="ad8c9518db11e830e6de0acaa930bd88b"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A)</td></tr>
<tr class="separator:ad8c9518db11e830e6de0acaa930bd88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cf72d53c1975f4f1d4328cbf8d48b4"><td class="memItemLeft" align="right" valign="top"><a id="a06cf72d53c1975f4f1d4328cbf8d48b4"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A)</td></tr>
<tr class="separator:a06cf72d53c1975f4f1d4328cbf8d48b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Numerical Methods (Members)</div></td></tr>
<tr class="memitem:adef3ef237566222b10a915ec9844b4be"><td class="memItemLeft" align="right" valign="top"><a id="adef3ef237566222b10a915ec9844b4be"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#adef3ef237566222b10a915ec9844b4be">shift_diag</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> s)</td></tr>
<tr class="memdesc:adef3ef237566222b10a915ec9844b4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">shifts the diagonal by s, i.e., (*this)(i,i)+=s for all i <br /></td></tr>
<tr class="separator:adef3ef237566222b10a915ec9844b4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a593f9d762471bb12e35fa45c861a0e"><td class="memItemLeft" align="right" valign="top"><a id="a3a593f9d762471bb12e35fa45c861a0e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a3a593f9d762471bb12e35fa45c861a0e">LDLfactor</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> tol=1e-10)</td></tr>
<tr class="memdesc:a3a593f9d762471bb12e35fa45c861a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes LDLfactorization (implemented only for positive definite matrices so far, no pivoting), (*this) is overwritten by the factorization; returns 1 if diagonal elements go below tol <br /></td></tr>
<tr class="separator:a3a593f9d762471bb12e35fa45c861a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc900585cf59d94b3b1803b05749217"><td class="memItemLeft" align="right" valign="top"><a id="a4fc900585cf59d94b3b1803b05749217"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a4fc900585cf59d94b3b1803b05749217">LDLsolve</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;x) const</td></tr>
<tr class="memdesc:a4fc900585cf59d94b3b1803b05749217"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes, after LDLfactor was executed succesfully, the solution to (*old_this)x=rhs; rhs is overwritten by the solution; always returns 0; NOTE: there is NO check against division by zero <br /></td></tr>
<tr class="separator:a4fc900585cf59d94b3b1803b05749217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1206c96cc4489816ad5c9c442d71b7"><td class="memItemLeft" align="right" valign="top"><a id="acc1206c96cc4489816ad5c9c442d71b7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#acc1206c96cc4489816ad5c9c442d71b7">LDLinverse</a> (<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;S) const</td></tr>
<tr class="memdesc:acc1206c96cc4489816ad5c9c442d71b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes, after LDLfactor was executed succesfully, the inverse to (*old_this) and stores it in S (numerically not too wise); always returns 0; NOTE: there is NO check against division by zero <br /></td></tr>
<tr class="separator:acc1206c96cc4489816ad5c9c442d71b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92dd5fe3e0e7555b770c44a527360cf"><td class="memItemLeft" align="right" valign="top"><a id="ab92dd5fe3e0e7555b770c44a527360cf"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ab92dd5fe3e0e7555b770c44a527360cf">Chol_factor</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> tol=1e-10)</td></tr>
<tr class="memdesc:ab92dd5fe3e0e7555b770c44a527360cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the Cholesky factorization, for positive definite matrices only, (*this) is overwritten by the factorization; there is no pivoting; returns 1 if diagonal elements go below tol <br /></td></tr>
<tr class="separator:ab92dd5fe3e0e7555b770c44a527360cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e430d0963d1277d08f735e97f529cf"><td class="memItemLeft" align="right" valign="top"><a id="aa0e430d0963d1277d08f735e97f529cf"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#aa0e430d0963d1277d08f735e97f529cf">Chol_solve</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;x) const</td></tr>
<tr class="memdesc:aa0e430d0963d1277d08f735e97f529cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes, after Chol_factor was executed succesfully, the solution to (*old_this)x=rhs; rhs is overwritten by the solution; always returns 0; NOTE: there is NO check against division by zero <br /></td></tr>
<tr class="separator:aa0e430d0963d1277d08f735e97f529cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293958cef7d61e6f952ca94e94ff567e"><td class="memItemLeft" align="right" valign="top"><a id="a293958cef7d61e6f952ca94e94ff567e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a293958cef7d61e6f952ca94e94ff567e">Chol_inverse</a> (<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;S) const</td></tr>
<tr class="memdesc:a293958cef7d61e6f952ca94e94ff567e"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes, after Chol_factor was executed succesfully, the inverse to (*old_this) and stores it in S (numerically not too wise); always returns 0; NOTE: there is NO check against division by zero <br /></td></tr>
<tr class="separator:a293958cef7d61e6f952ca94e94ff567e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd1c5742edda4fb745d53d8487c2614"><td class="memItemLeft" align="right" valign="top"><a id="abbd1c5742edda4fb745d53d8487c2614"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#abbd1c5742edda4fb745d53d8487c2614">Chol_Lsolve</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;rhs) const</td></tr>
<tr class="memdesc:abbd1c5742edda4fb745d53d8487c2614"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes, after Chol_factor into LL^T was executed succesfully, the solution to Lx=rhs; rhs is overwritten by the solution; always returns 0; NOTE: there is NO check against division by zero <br /></td></tr>
<tr class="separator:abbd1c5742edda4fb745d53d8487c2614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c123d04d3299251e9921cbd83ed8df1"><td class="memItemLeft" align="right" valign="top"><a id="a9c123d04d3299251e9921cbd83ed8df1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a9c123d04d3299251e9921cbd83ed8df1">Chol_Ltsolve</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a9c123d04d3299251e9921cbd83ed8df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes, after Chol_factor into LL^T was executed succesfully, the solution to L^Tx=rhs; rhs is overwritten by the solution; always returns 0; NOTE: there is NO check against division by zero <br /></td></tr>
<tr class="separator:a9c123d04d3299251e9921cbd83ed8df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5188e5172499d13e0e90c785b0f5a935"><td class="memItemLeft" align="right" valign="top"><a id="a5188e5172499d13e0e90c785b0f5a935"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a5188e5172499d13e0e90c785b0f5a935">Chol_scaleLi</a> (<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;S) const</td></tr>
<tr class="memdesc:a5188e5172499d13e0e90c785b0f5a935"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes, after Chol_factor into LL^T was executed succesfully, L^{-1}SL^{-T} overwriting S <br /></td></tr>
<tr class="separator:a5188e5172499d13e0e90c785b0f5a935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5612f5f5226ee8a49311cf5875c8332"><td class="memItemLeft" align="right" valign="top"><a id="af5612f5f5226ee8a49311cf5875c8332"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#af5612f5f5226ee8a49311cf5875c8332">Chol_scaleLt</a> (<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;S) const</td></tr>
<tr class="memdesc:af5612f5f5226ee8a49311cf5875c8332"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes, after Chol_factor into LL^T was executed succesfully, L^TSL overwriting S <br /></td></tr>
<tr class="separator:af5612f5f5226ee8a49311cf5875c8332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330dea5c0298174ccb46c4bf308b8eee"><td class="memItemLeft" align="right" valign="top"><a id="a330dea5c0298174ccb46c4bf308b8eee"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a330dea5c0298174ccb46c4bf308b8eee">Chol_Lmult</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a330dea5c0298174ccb46c4bf308b8eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes, after Chol_factor into LL^T was executed succesfully, L*rhs, overwriting rhs by the result; always returns 0; <br /></td></tr>
<tr class="separator:a330dea5c0298174ccb46c4bf308b8eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf15f8d3f92fd4946eeb004ef7aa8d06"><td class="memItemLeft" align="right" valign="top"><a id="acf15f8d3f92fd4946eeb004ef7aa8d06"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#acf15f8d3f92fd4946eeb004ef7aa8d06">Chol_Ltmult</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;rhs) const</td></tr>
<tr class="memdesc:acf15f8d3f92fd4946eeb004ef7aa8d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes, after Chol_factor into LL^T was executed succesfully, L^Trhs, overwriting rhs by the result; always returns 0; <br /></td></tr>
<tr class="separator:acf15f8d3f92fd4946eeb004ef7aa8d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816869a81b60664ccdbad8553e4f3239"><td class="memItemLeft" align="right" valign="top"><a id="a816869a81b60664ccdbad8553e4f3239"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a816869a81b60664ccdbad8553e4f3239">Chol_factor</a> (<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;piv, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> tol=1e-10)</td></tr>
<tr class="memdesc:a816869a81b60664ccdbad8553e4f3239"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the Cholesky factorization with pivoting, for positive semidefinite matrices only, (*this) is overwritten by the factorization; on termination piv.dim() is the number of positive pivots&gt;=tol; returns 1 if negative diagonal element is encountered during computations, 0 otherwise. <br /></td></tr>
<tr class="separator:a816869a81b60664ccdbad8553e4f3239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55a9a61e98213258dd65a3b8e8f20a3"><td class="memItemLeft" align="right" valign="top"><a id="ae55a9a61e98213258dd65a3b8e8f20a3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ae55a9a61e98213258dd65a3b8e8f20a3">Chol_solve</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;x, const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;piv) const</td></tr>
<tr class="memdesc:ae55a9a61e98213258dd65a3b8e8f20a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes, after <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a816869a81b60664ccdbad8553e4f3239" title="computes the Cholesky factorization with pivoting, for positive semidefinite matrices only...">Chol_factor(Indexmatrix&amp;,Real)</a> with pivoting was executed succesfully, the solution to (*old_this)*x=rhs(piv); rhs is overwritten by the solution arranged in original unpermuted order; always returns 0; NOTE: there is NO check against division by zero <br /></td></tr>
<tr class="separator:ae55a9a61e98213258dd65a3b8e8f20a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a47c0ce3f11f1f78b548b2f65b96ef"><td class="memItemLeft" align="right" valign="top"><a id="ab1a47c0ce3f11f1f78b548b2f65b96ef"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ab1a47c0ce3f11f1f78b548b2f65b96ef">Chol_inverse</a> (<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;S, const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;piv) const</td></tr>
<tr class="memdesc:ab1a47c0ce3f11f1f78b548b2f65b96ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes, after <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a816869a81b60664ccdbad8553e4f3239" title="computes the Cholesky factorization with pivoting, for positive semidefinite matrices only...">Chol_factor(Indexmatrix&amp;,Real)</a> with pivoting was executed succesfully, the inverse to (*old_this) and stores it in S (the pivoting permutation is undone in S); NOTE: there is NO check against division by zero <br /></td></tr>
<tr class="separator:ab1a47c0ce3f11f1f78b548b2f65b96ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fb6aa3cbd4d484fb3325e0072afec2"><td class="memItemLeft" align="right" valign="top"><a id="a36fb6aa3cbd4d484fb3325e0072afec2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a36fb6aa3cbd4d484fb3325e0072afec2">Aasen_factor</a> (<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;piv)</td></tr>
<tr class="memdesc:a36fb6aa3cbd4d484fb3325e0072afec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes Aasen factorization LTL^T with pivoting, where L is unit lower triangular with first colum e_1 and T is tridiagonal; (*this) is overwritten by the factorization, with column i of L being stored in column i-1 of (*this); always returns 0; <br /></td></tr>
<tr class="separator:a36fb6aa3cbd4d484fb3325e0072afec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b541a9bf23dbfcac2264004930e793"><td class="memItemLeft" align="right" valign="top"><a id="a12b541a9bf23dbfcac2264004930e793"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a12b541a9bf23dbfcac2264004930e793">Aasen_Lsolve</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;x) const</td></tr>
<tr class="memdesc:a12b541a9bf23dbfcac2264004930e793"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes, after Aasen_factor into LTL^T was executed, the solution to Lx=rhs; rhs is overwritten by the solution; always returns 0; <br /></td></tr>
<tr class="separator:a12b541a9bf23dbfcac2264004930e793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75e2b1740e26ffe45e85a3ae9644b1d"><td class="memItemLeft" align="right" valign="top"><a id="ac75e2b1740e26ffe45e85a3ae9644b1d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ac75e2b1740e26ffe45e85a3ae9644b1d">Aasen_Ltsolve</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;x) const</td></tr>
<tr class="memdesc:ac75e2b1740e26ffe45e85a3ae9644b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes, after Aasen_factor into LTL^T was executed, the solution to L^Tx=rhs; rhs is overwritten by the solution; always returns 0; <br /></td></tr>
<tr class="separator:ac75e2b1740e26ffe45e85a3ae9644b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ff8f45271d287387e07628fd7bb65f"><td class="memItemLeft" align="right" valign="top"><a id="aa3ff8f45271d287387e07628fd7bb65f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#aa3ff8f45271d287387e07628fd7bb65f">Aasen_tridiagsolve</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;x) const</td></tr>
<tr class="memdesc:aa3ff8f45271d287387e07628fd7bb65f"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes, after Aasen_factor into LTL^T was executed, the solution to Tx=rhs; rhs is overwritten by the solution;if the solution fails due to division by zero (=system not solvable) the return value is -(rowindex+1) where this occured in the backsolve <br /></td></tr>
<tr class="separator:aa3ff8f45271d287387e07628fd7bb65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac161b8b30a6eb0fb4f736c7df278702e"><td class="memItemLeft" align="right" valign="top"><a id="ac161b8b30a6eb0fb4f736c7df278702e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ac161b8b30a6eb0fb4f736c7df278702e">Aasen_solve</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;x, const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;piv) const</td></tr>
<tr class="memdesc:ac161b8b30a6eb0fb4f736c7df278702e"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes, after Aasen_factor into LTL^T was executed, the solution to (*old_this)x=rhs; rhs is overwritten by the solution; if the solution fails due to division by zero (=system not solvable) the return value is -(rowindex+1) where this occured in the backsolve <br /></td></tr>
<tr class="separator:ac161b8b30a6eb0fb4f736c7df278702e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4f028178c8e3c67718ddf813135d04"><td class="memItemLeft" align="right" valign="top"><a id="a9d4f028178c8e3c67718ddf813135d04"></a>
<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a9d4f028178c8e3c67718ddf813135d04">eig</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;P, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;d, bool sort_non_decreasingly=true) const</td></tr>
<tr class="memdesc:a9d4f028178c8e3c67718ddf813135d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes an eigenvalue decomposition P*Diag(d)*tranpose(P)=(*this) by symmetric QR; returns 0 on success, <br /></td></tr>
<tr class="separator:a9d4f028178c8e3c67718ddf813135d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Input, Output (Members)</div></td></tr>
<tr class="memitem:a624bb5169edbd58d71a4d75feb03d7ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a624bb5169edbd58d71a4d75feb03d7ee">display</a> (std::ostream &amp;out, int precision=0, int width=0, int screenwidth=0) const</td></tr>
<tr class="memdesc:a624bb5169edbd58d71a4d75feb03d7ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">displays a matrix in a pretty way for bounded screen widths; for variables of value zero default values are used.  <a href="#a624bb5169edbd58d71a4d75feb03d7ee">More...</a><br /></td></tr>
<tr class="separator:a624bb5169edbd58d71a4d75feb03d7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781cc9ac99619b6e9c0794fb8b56575a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a781cc9ac99619b6e9c0794fb8b56575a">mfile_output</a> (std::ostream &amp;out, int precision=16, int width=0) const</td></tr>
<tr class="memdesc:a781cc9ac99619b6e9c0794fb8b56575a"><td class="mdescLeft">&#160;</td><td class="mdescRight">outputs a matrix A in the format "[ A(0,1) ... A(0,nc-1)\n ... A(nr-1,nc-1)];\n" so that it can be read e.g. by octave as an m-file  <a href="#a781cc9ac99619b6e9c0794fb8b56575a">More...</a><br /></td></tr>
<tr class="separator:a781cc9ac99619b6e9c0794fb8b56575a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a5ceaaffaa26c44edc08e5277d6359abf"><td class="memItemLeft" align="right" valign="top"><a id="a5ceaaffaa26c44edc08e5277d6359abf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a5ceaaffaa26c44edc08e5277d6359abf">init_to_zero</a> ()</td></tr>
<tr class="memdesc:a5ceaaffaa26c44edc08e5277d6359abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize the matrix to a 0x0 matrix without storage <br /></td></tr>
<tr class="separator:a5ceaaffaa26c44edc08e5277d6359abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3062426305821d1d48dbad4ece29661"><td class="memItemLeft" align="right" valign="top"><a id="aa3062426305821d1d48dbad4ece29661"></a>
<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#aa3062426305821d1d48dbad4ece29661">tred2</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> nm, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> n, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> *a, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> *d, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> *e, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> *z) const</td></tr>
<tr class="memdesc:aa3062426305821d1d48dbad4ece29661"><td class="mdescLeft">&#160;</td><td class="mdescRight">a subroutine needed internally for eigenvalue computations (eigval.cxx) <br /></td></tr>
<tr class="separator:aa3062426305821d1d48dbad4ece29661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb0104fb4cfee63a52dda82d436cd3d"><td class="memItemLeft" align="right" valign="top"><a id="a6cb0104fb4cfee63a52dda82d436cd3d"></a>
<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a6cb0104fb4cfee63a52dda82d436cd3d">imtql2</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> nm, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> n, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> *d, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> *e, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> *z) const</td></tr>
<tr class="memdesc:a6cb0104fb4cfee63a52dda82d436cd3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">a subroutine needed internally for eigenvalue computations (eigval.cxx) <br /></td></tr>
<tr class="separator:a6cb0104fb4cfee63a52dda82d436cd3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a600d00a9c6e6e4486300944551d438e4"><td class="memItemLeft" align="right" valign="top"><a id="a600d00a9c6e6e4486300944551d438e4"></a>
<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a600d00a9c6e6e4486300944551d438e4">mem_dim</a></td></tr>
<tr class="memdesc:a600d00a9c6e6e4486300944551d438e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">amount of memory currently allocated <br /></td></tr>
<tr class="separator:a600d00a9c6e6e4486300944551d438e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081b04bbf1938d34a8bbb7031cdb6be6"><td class="memItemLeft" align="right" valign="top"><a id="a081b04bbf1938d34a8bbb7031cdb6be6"></a>
<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a081b04bbf1938d34a8bbb7031cdb6be6">nr</a></td></tr>
<tr class="memdesc:a081b04bbf1938d34a8bbb7031cdb6be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of rows = number of columns <br /></td></tr>
<tr class="separator:a081b04bbf1938d34a8bbb7031cdb6be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1429349326c49e60a47cfa2070c085"><td class="memItemLeft" align="right" valign="top"><a id="aaf1429349326c49e60a47cfa2070c085"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#aaf1429349326c49e60a47cfa2070c085">m</a></td></tr>
<tr class="memdesc:aaf1429349326c49e60a47cfa2070c085"><td class="mdescLeft">&#160;</td><td class="mdescRight">lower triangle stored columnwise (a11,a21,...,anr1,a22,.....) <br /></td></tr>
<tr class="separator:aaf1429349326c49e60a47cfa2070c085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafc192f6e4048c941ff9e1cb3d081d2"><td class="memItemLeft" align="right" valign="top"><a id="adafc192f6e4048c941ff9e1cb3d081d2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#adafc192f6e4048c941ff9e1cb3d081d2">is_init</a></td></tr>
<tr class="memdesc:adafc192f6e4048c941ff9e1cb3d081d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag whether memory is initialized, it is only used if CONICBUNDLE_DEBUG is defined <br /></td></tr>
<tr class="separator:adafc192f6e4048c941ff9e1cb3d081d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a1f17224f65d28e864c99e408223d93ab"><td class="memItemLeft" align="right" valign="top"><a id="a1f17224f65d28e864c99e408223d93ab"></a>
static const <a class="el" href="group__matop__matrixerror.html#ga204f53041409b9f5efb2f8b41964b6b8">Mtype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a1f17224f65d28e864c99e408223d93ab">mtype</a></td></tr>
<tr class="memdesc:a1f17224f65d28e864c99e408223d93ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">used for <a class="el" href="classCH__Matrix__Classes_1_1MatrixError.html" title="Such an object is generated and passed to MEmessage(), whenever an error occurs. It holds some output...">MatrixError</a> templates (runtime type information was not yet existing) <br /></td></tr>
<tr class="separator:a1f17224f65d28e864c99e408223d93ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a34913a9261681f734171a6da06bd56fe"><td class="memItemLeft" align="right" valign="top"><a id="a34913a9261681f734171a6da06bd56fe"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Matrix</b></td></tr>
<tr class="separator:a34913a9261681f734171a6da06bd56fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9878c2d3402557fd5b3be83caa175b7d"><td class="memItemLeft" align="right" valign="top"><a id="a9878c2d3402557fd5b3be83caa175b7d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Sparsesym</b></td></tr>
<tr class="separator:a9878c2d3402557fd5b3be83caa175b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f868ef6a0082bb276b5683b8b21529"><td class="memItemLeft" align="right" valign="top"><a id="a49f868ef6a0082bb276b5683b8b21529"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Sparsemat</b></td></tr>
<tr class="separator:a49f868ef6a0082bb276b5683b8b21529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Indexing and Submatrices (Friends)</div></td></tr>
<tr class="memitem:a08631d1ff2282cc4276e7bf4523cbd0c"><td class="memItemLeft" align="right" valign="top"><a id="a08631d1ff2282cc4276e7bf4523cbd0c"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a08631d1ff2282cc4276e7bf4523cbd0c">diag</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:a08631d1ff2282cc4276e7bf4523cbd0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector v consisting of the elements v(i)=(*this)(i,i), 0&lt;=i&lt;row dimension <br /></td></tr>
<tr class="separator:a08631d1ff2282cc4276e7bf4523cbd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d630bb4d7adf30301456b754300a810"><td class="memItemLeft" align="right" valign="top"><a id="a1d630bb4d7adf30301456b754300a810"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a1d630bb4d7adf30301456b754300a810">Diag</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a1d630bb4d7adf30301456b754300a810"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a symmetric diagonal matrix S of order A.dim() with vec(A) on the diagonal, i.e., S(i,i)=A(i) for all i and S(i,j)=0 for i!=j <br /></td></tr>
<tr class="separator:a1d630bb4d7adf30301456b754300a810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4273fb88315e1c5b863f36ddcde9c452"><td class="memItemLeft" align="right" valign="top"><a id="a4273fb88315e1c5b863f36ddcde9c452"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a4273fb88315e1c5b863f36ddcde9c452">swap</a> (<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:a4273fb88315e1c5b863f36ddcde9c452"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap the content of the two matrices A and B (involves no copying) <br /></td></tr>
<tr class="separator:a4273fb88315e1c5b863f36ddcde9c452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">BLAS-like Routines (Friends)</div></td></tr>
<tr class="memitem:a1b5f18c63000398c229270874d8f608c"><td class="memItemLeft" align="right" valign="top"><a id="a1b5f18c63000398c229270874d8f608c"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a1b5f18c63000398c229270874d8f608c">rankadd</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta, int trans)</td></tr>
<tr class="memdesc:a1b5f18c63000398c229270874d8f608c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha* A*A^T, where A may be transposed. If beta==0. then C is initiliazed to the correct size. <br /></td></tr>
<tr class="separator:a1b5f18c63000398c229270874d8f608c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e27846ddc677944743efefaef890cb"><td class="memItemLeft" align="right" valign="top"><a id="a06e27846ddc677944743efefaef890cb"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a06e27846ddc677944743efefaef890cb">scaledrankadd</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;D, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta, int trans)</td></tr>
<tr class="memdesc:a06e27846ddc677944743efefaef890cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha* A*D*A^T, where D is a vector representing a diagonal matrix and A may be transposed; if beta==0. then C is initialized to the correct size <br /></td></tr>
<tr class="separator:a06e27846ddc677944743efefaef890cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671d171e8ca6fd52307490c769b9de10"><td class="memItemLeft" align="right" valign="top"><a id="a671d171e8ca6fd52307490c769b9de10"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a671d171e8ca6fd52307490c769b9de10">rank2add</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta, int trans)</td></tr>
<tr class="memdesc:a671d171e8ca6fd52307490c769b9de10"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*(A*B^T+B*A^T)/2 [or for transposed (A^T*B+B^T*A)/2]. If beta==0. then C is initiliazed to the correct size. <br /></td></tr>
<tr class="separator:a671d171e8ca6fd52307490c769b9de10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a35593307c000c033a43d8d61a0f507"><td class="memItemLeft" align="right" valign="top"><a id="a7a35593307c000c033a43d8d61a0f507"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a7a35593307c000c033a43d8d61a0f507">xbpeya</a> (<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;x, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;y, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta)</td></tr>
<tr class="memdesc:a7a35593307c000c033a43d8d61a0f507"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns x= alpha*y+beta*x; if beta==0. then x is initialized to the correct size <br /></td></tr>
<tr class="separator:a7a35593307c000c033a43d8d61a0f507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3addcd18e782e16b54e010d438c555"><td class="memItemLeft" align="right" valign="top"><a id="a0d3addcd18e782e16b54e010d438c555"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a0d3addcd18e782e16b54e010d438c555">xeyapzb</a> (<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;x, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;y, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;z, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta)</td></tr>
<tr class="memdesc:a0d3addcd18e782e16b54e010d438c555"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns x= alpha*y+beta*z; x is initialized to the correct size <br /></td></tr>
<tr class="separator:a0d3addcd18e782e16b54e010d438c555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda3741bc893cb65271501b3a71bce79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#afda3741bc893cb65271501b3a71bce79">genmult</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta, int btrans)</td></tr>
<tr class="memdesc:afda3741bc893cb65271501b3a71bce79"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where B may be transposed; C must not be equal to B; if beta==0. then C is initialized to the correct size  <a href="#afda3741bc893cb65271501b3a71bce79">More...</a><br /></td></tr>
<tr class="separator:afda3741bc893cb65271501b3a71bce79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeed2991f0ec4a0460cf33dfc9209aa1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#afeed2991f0ec4a0460cf33dfc9209aa1">genmult</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta, int atrans)</td></tr>
<tr class="memdesc:afeed2991f0ec4a0460cf33dfc9209aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A may be transposed; C must not be equal to A; if beta==0. then C is initialized to the correct size  <a href="#afeed2991f0ec4a0460cf33dfc9209aa1">More...</a><br /></td></tr>
<tr class="separator:afeed2991f0ec4a0460cf33dfc9209aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Usual Arithmetic Operators (Friends)</div></td></tr>
<tr class="memitem:a9c37cc81136194be67d4adf7a6de7e26"><td class="memItemLeft" align="right" valign="top"><a id="a9c37cc81136194be67d4adf7a6de7e26"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a9c37cc81136194be67d4adf7a6de7e26">operator*</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:a9c37cc81136194be67d4adf7a6de7e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A*B <br /></td></tr>
<tr class="separator:a9c37cc81136194be67d4adf7a6de7e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a576744decb911ce5c872416316882"><td class="memItemLeft" align="right" valign="top"><a id="a68a576744decb911ce5c872416316882"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a68a576744decb911ce5c872416316882">operator%</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:a68a576744decb911ce5c872416316882"><td class="mdescLeft">&#160;</td><td class="mdescRight">ATTENTION: this is redefined as the Hadamard product and sets (i,j)=A(i,j)*B(i,j) for all i&lt;=j. <br /></td></tr>
<tr class="separator:a68a576744decb911ce5c872416316882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370ea444b856b3a90dafc12e76245794"><td class="memItemLeft" align="right" valign="top"><a id="a370ea444b856b3a90dafc12e76245794"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a370ea444b856b3a90dafc12e76245794">operator+</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:a370ea444b856b3a90dafc12e76245794"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A+B <br /></td></tr>
<tr class="separator:a370ea444b856b3a90dafc12e76245794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad435f8472eeb894dd3459a2678cf5184"><td class="memItemLeft" align="right" valign="top"><a id="ad435f8472eeb894dd3459a2678cf5184"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ad435f8472eeb894dd3459a2678cf5184">operator-</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:ad435f8472eeb894dd3459a2678cf5184"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A-B <br /></td></tr>
<tr class="separator:ad435f8472eeb894dd3459a2678cf5184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657f28e27afb57e0dee0abd249a60989"><td class="memItemLeft" align="right" valign="top"><a id="a657f28e27afb57e0dee0abd249a60989"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a657f28e27afb57e0dee0abd249a60989">operator*</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:a657f28e27afb57e0dee0abd249a60989"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A*B <br /></td></tr>
<tr class="separator:a657f28e27afb57e0dee0abd249a60989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bd05e45383a3bc969e392775bd66d4"><td class="memItemLeft" align="right" valign="top"><a id="a95bd05e45383a3bc969e392775bd66d4"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a95bd05e45383a3bc969e392775bd66d4">operator*</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:a95bd05e45383a3bc969e392775bd66d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A*B <br /></td></tr>
<tr class="separator:a95bd05e45383a3bc969e392775bd66d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c9d5ee5e6f5c7eac83355c446574d0"><td class="memItemLeft" align="right" valign="top"><a id="ad2c9d5ee5e6f5c7eac83355c446574d0"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ad2c9d5ee5e6f5c7eac83355c446574d0">operator+</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:ad2c9d5ee5e6f5c7eac83355c446574d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A+B <br /></td></tr>
<tr class="separator:ad2c9d5ee5e6f5c7eac83355c446574d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8beec55f783526027275429847c514e9"><td class="memItemLeft" align="right" valign="top"><a id="a8beec55f783526027275429847c514e9"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a8beec55f783526027275429847c514e9">operator+</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:a8beec55f783526027275429847c514e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A+B <br /></td></tr>
<tr class="separator:a8beec55f783526027275429847c514e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1702c7a379d804c2b23b1ccf90b878"><td class="memItemLeft" align="right" valign="top"><a id="a1a1702c7a379d804c2b23b1ccf90b878"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a1a1702c7a379d804c2b23b1ccf90b878">operator-</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:a1a1702c7a379d804c2b23b1ccf90b878"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A-B <br /></td></tr>
<tr class="separator:a1a1702c7a379d804c2b23b1ccf90b878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac641660c567e4398205b4d5b31089b"><td class="memItemLeft" align="right" valign="top"><a id="a7ac641660c567e4398205b4d5b31089b"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a7ac641660c567e4398205b4d5b31089b">operator-</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:a7ac641660c567e4398205b4d5b31089b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A-B <br /></td></tr>
<tr class="separator:a7ac641660c567e4398205b4d5b31089b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48f4e8e2a0a85428c9eff8367526811"><td class="memItemLeft" align="right" valign="top"><a id="ad48f4e8e2a0a85428c9eff8367526811"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ad48f4e8e2a0a85428c9eff8367526811">operator*</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:ad48f4e8e2a0a85428c9eff8367526811"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> that equals A*d <br /></td></tr>
<tr class="separator:ad48f4e8e2a0a85428c9eff8367526811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa5090c10545913a01403f204c0de09"><td class="memItemLeft" align="right" valign="top"><a id="adaa5090c10545913a01403f204c0de09"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#adaa5090c10545913a01403f204c0de09">operator*</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:adaa5090c10545913a01403f204c0de09"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> that equals A*d <br /></td></tr>
<tr class="separator:adaa5090c10545913a01403f204c0de09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d69c2993966b64bc3cf19d85f073e28"><td class="memItemLeft" align="right" valign="top"><a id="a5d69c2993966b64bc3cf19d85f073e28"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a5d69c2993966b64bc3cf19d85f073e28">operator/</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:a5d69c2993966b64bc3cf19d85f073e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> that equals A/d; ATTENTION: no check against division by zero <br /></td></tr>
<tr class="separator:a5d69c2993966b64bc3cf19d85f073e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a32387a962736098b3a442d7e5f65a"><td class="memItemLeft" align="right" valign="top"><a id="a43a32387a962736098b3a442d7e5f65a"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a43a32387a962736098b3a442d7e5f65a">operator+</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:a43a32387a962736098b3a442d7e5f65a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns (i,j)=A(i,j)+d for all i&lt;=j <br /></td></tr>
<tr class="separator:a43a32387a962736098b3a442d7e5f65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d570b64196b8d57dc8fcdffd9d6e4c"><td class="memItemLeft" align="right" valign="top"><a id="a46d570b64196b8d57dc8fcdffd9d6e4c"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a46d570b64196b8d57dc8fcdffd9d6e4c">operator+</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:a46d570b64196b8d57dc8fcdffd9d6e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns (i,j)=A(i,j)+d for all i&lt;=j <br /></td></tr>
<tr class="separator:a46d570b64196b8d57dc8fcdffd9d6e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0188f39a48eb15ea09b389572ed91141"><td class="memItemLeft" align="right" valign="top"><a id="a0188f39a48eb15ea09b389572ed91141"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a0188f39a48eb15ea09b389572ed91141">operator-</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:a0188f39a48eb15ea09b389572ed91141"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns (i,j)=A(i,j)-d for all i&lt;=j <br /></td></tr>
<tr class="separator:a0188f39a48eb15ea09b389572ed91141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c91ea2552a4a769cdd73d9d05ee6d6e"><td class="memItemLeft" align="right" valign="top"><a id="a5c91ea2552a4a769cdd73d9d05ee6d6e"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a5c91ea2552a4a769cdd73d9d05ee6d6e">operator-</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:a5c91ea2552a4a769cdd73d9d05ee6d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns (i,j)=d-A(i,j) for all i&lt;=j <br /></td></tr>
<tr class="separator:a5c91ea2552a4a769cdd73d9d05ee6d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f980b595982f10fd0857023a5f77fb"><td class="memItemLeft" align="right" valign="top"><a id="a45f980b595982f10fd0857023a5f77fb"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a45f980b595982f10fd0857023a5f77fb">transpose</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:a45f980b595982f10fd0857023a5f77fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">(drop it or use a constructor instead) <br /></td></tr>
<tr class="separator:a45f980b595982f10fd0857023a5f77fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Connections to other Classes (Friends)</div></td></tr>
<tr class="memitem:a67bb862c8509eca6a170c27957ec129f"><td class="memItemLeft" align="right" valign="top"><a id="a67bb862c8509eca6a170c27957ec129f"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a67bb862c8509eca6a170c27957ec129f">genmult</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta, int btrans)</td></tr>
<tr class="memdesc:a67bb862c8509eca6a170c27957ec129f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where B may be transposed; if beta==0. then C is initialized to the correct size <br /></td></tr>
<tr class="separator:a67bb862c8509eca6a170c27957ec129f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27901660155c5cddb4e103f782d34d13"><td class="memItemLeft" align="right" valign="top"><a id="a27901660155c5cddb4e103f782d34d13"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a27901660155c5cddb4e103f782d34d13">genmult</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta, int atrans)</td></tr>
<tr class="memdesc:a27901660155c5cddb4e103f782d34d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A may be transposed; if beta==0. then C is initialized to the correct size <br /></td></tr>
<tr class="separator:a27901660155c5cddb4e103f782d34d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f9d29484cff6d072dda972ef662c21"><td class="memItemLeft" align="right" valign="top"><a id="a34f9d29484cff6d072dda972ef662c21"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a34f9d29484cff6d072dda972ef662c21">rankadd</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta, int trans)</td></tr>
<tr class="memdesc:a34f9d29484cff6d072dda972ef662c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha* A*A^T, where A may be transposed; if beta==0. then C is initialized to the correct size <br /></td></tr>
<tr class="separator:a34f9d29484cff6d072dda972ef662c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27d9836fd9a0468fffe8412b92f76b9"><td class="memItemLeft" align="right" valign="top"><a id="af27d9836fd9a0468fffe8412b92f76b9"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#af27d9836fd9a0468fffe8412b92f76b9">scaledrankadd</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;D, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta, int trans)</td></tr>
<tr class="memdesc:af27d9836fd9a0468fffe8412b92f76b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha* A*D*A^T, where D is a vector representing a diagonal matrix and A may be transposed; if beta==0. then C is initialized to the correct size <br /></td></tr>
<tr class="separator:af27d9836fd9a0468fffe8412b92f76b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cdfe1ef5851ea538ca986ee698d5f5"><td class="memItemLeft" align="right" valign="top"><a id="ad8cdfe1ef5851ea538ca986ee698d5f5"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ad8cdfe1ef5851ea538ca986ee698d5f5">rank2add</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta, int trans)</td></tr>
<tr class="memdesc:ad8cdfe1ef5851ea538ca986ee698d5f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*(A*B^T+B*A^T)/2 [or for transposed (A^T*B+B^T*A)/2]. If beta==0. then C is initiliazed to the correct size. <br /></td></tr>
<tr class="separator:ad8cdfe1ef5851ea538ca986ee698d5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Elementwise Operations (Friends)</div></td></tr>
<tr class="memitem:add07bc055dbc2e1e5034218370512881"><td class="memItemLeft" align="right" valign="top"><a id="add07bc055dbc2e1e5034218370512881"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#add07bc055dbc2e1e5034218370512881">abs</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:add07bc055dbc2e1e5034218370512881"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> with elements abs(A(i,j)) <br /></td></tr>
<tr class="separator:add07bc055dbc2e1e5034218370512881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparisons, Max, Min, Sort, Find (Friends)</div></td></tr>
<tr class="memitem:a6a61be50f9dda7c6e29fe7317b9c49a0"><td class="memItemLeft" align="right" valign="top"><a id="a6a61be50f9dda7c6e29fe7317b9c49a0"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a6a61be50f9dda7c6e29fe7317b9c49a0">minrows</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:a6a61be50f9dda7c6e29fe7317b9c49a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a row vector holding in each column the minimum over all rows in this column <br /></td></tr>
<tr class="separator:a6a61be50f9dda7c6e29fe7317b9c49a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b459f99d09e50b7b8e59fbcd60cc8c"><td class="memItemLeft" align="right" valign="top"><a id="aa3b459f99d09e50b7b8e59fbcd60cc8c"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#aa3b459f99d09e50b7b8e59fbcd60cc8c">mincols</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:aa3b459f99d09e50b7b8e59fbcd60cc8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector holding in each row the minimum over all columns in this row <br /></td></tr>
<tr class="separator:aa3b459f99d09e50b7b8e59fbcd60cc8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539bccf2eb3d3dbd603668e4230c0224"><td class="memItemLeft" align="right" valign="top"><a id="a539bccf2eb3d3dbd603668e4230c0224"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a539bccf2eb3d3dbd603668e4230c0224">min</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:a539bccf2eb3d3dbd603668e4230c0224"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the minimum value over all elements of the matrix <br /></td></tr>
<tr class="separator:a539bccf2eb3d3dbd603668e4230c0224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60952a4f89bade715bf5df4836fb5d1d"><td class="memItemLeft" align="right" valign="top"><a id="a60952a4f89bade715bf5df4836fb5d1d"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a60952a4f89bade715bf5df4836fb5d1d">maxrows</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:a60952a4f89bade715bf5df4836fb5d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a row vector holding in each column the maximum over all rows in this column <br /></td></tr>
<tr class="separator:a60952a4f89bade715bf5df4836fb5d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30f3d9f5957dc380c8c28763f61ea39"><td class="memItemLeft" align="right" valign="top"><a id="ab30f3d9f5957dc380c8c28763f61ea39"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ab30f3d9f5957dc380c8c28763f61ea39">maxcols</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:ab30f3d9f5957dc380c8c28763f61ea39"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector holding in each row the maximum over all columns in this row <br /></td></tr>
<tr class="separator:ab30f3d9f5957dc380c8c28763f61ea39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e63e3515c052846682e1f460454c6c"><td class="memItemLeft" align="right" valign="top"><a id="a02e63e3515c052846682e1f460454c6c"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a02e63e3515c052846682e1f460454c6c">max</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:a02e63e3515c052846682e1f460454c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the maximum value over all elements of the matrix <br /></td></tr>
<tr class="separator:a02e63e3515c052846682e1f460454c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Input, Output (Friends)</div></td></tr>
<tr class="memitem:a1d97c2e957cf41b29eb0aa835d7b909a"><td class="memItemLeft" align="right" valign="top"><a id="a1d97c2e957cf41b29eb0aa835d7b909a"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a1d97c2e957cf41b29eb0aa835d7b909a">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:a1d97c2e957cf41b29eb0aa835d7b909a"><td class="mdescLeft">&#160;</td><td class="mdescRight">output format (nr and nc are <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd" title="all integer numbers in calculations and indexing are of this type ">Integer</a> values, all others <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type ">Real</a> values): <br />
 nr nc \n A(1,1) A(1,2) ... A(1,nc) \n A(2,1) ... A(nr,nc) \n <br /></td></tr>
<tr class="separator:a1d97c2e957cf41b29eb0aa835d7b909a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01d338d4c1259d47a5fa6bcd13a4ea0"><td class="memItemLeft" align="right" valign="top"><a id="ad01d338d4c1259d47a5fa6bcd13a4ea0"></a>
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ad01d338d4c1259d47a5fa6bcd13a4ea0">operator&gt;&gt;</a> (std::istream &amp;i, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:ad01d338d4c1259d47a5fa6bcd13a4ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">input format (nr and nc are <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd" title="all integer numbers in calculations and indexing are of this type ">Integer</a> values, all others <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type ">Real</a> values): <br />
 nr nc \n A(1,1) A(1,2) ... A(1,nc) \n A(2,1) ... A(nr,nc) \n <br /></td></tr>
<tr class="separator:ad01d338d4c1259d47a5fa6bcd13a4ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Numerical Methods (Friends)</h2></td></tr>
<tr class="memitem:aa79b38c111b29d22811c6cfa805b81e5"><td class="memItemLeft" align="right" valign="top"><a id="aa79b38c111b29d22811c6cfa805b81e5"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#aa79b38c111b29d22811c6cfa805b81e5">trace</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:aa79b38c111b29d22811c6cfa805b81e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the sum of the diagonal elements A(i,i) over all i <br /></td></tr>
<tr class="separator:aa79b38c111b29d22811c6cfa805b81e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f9ab5cf82f474ceb7a945f5ce104da"><td class="memItemLeft" align="right" valign="top"><a id="ae2f9ab5cf82f474ceb7a945f5ce104da"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ae2f9ab5cf82f474ceb7a945f5ce104da">ip</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:ae2f9ab5cf82f474ceb7a945f5ce104da"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j <br /></td></tr>
<tr class="separator:ae2f9ab5cf82f474ceb7a945f5ce104da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94a253ae83cb857da974e63802512ca"><td class="memItemLeft" align="right" valign="top"><a id="ad94a253ae83cb857da974e63802512ca"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ad94a253ae83cb857da974e63802512ca">ip</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:ad94a253ae83cb857da974e63802512ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j <br /></td></tr>
<tr class="separator:ad94a253ae83cb857da974e63802512ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3347e9e818cb647222904bd64332b3"><td class="memItemLeft" align="right" valign="top"><a id="aac3347e9e818cb647222904bd64332b3"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#aac3347e9e818cb647222904bd64332b3">ip</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:aac3347e9e818cb647222904bd64332b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j <br /></td></tr>
<tr class="separator:aac3347e9e818cb647222904bd64332b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad57c5351a4bb87122495dfa7051b1c8"><td class="memItemLeft" align="right" valign="top"><a id="aad57c5351a4bb87122495dfa7051b1c8"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#aad57c5351a4bb87122495dfa7051b1c8">norm2</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:aad57c5351a4bb87122495dfa7051b1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the Frobenius norm of A, i.e., the square root of the sum of A(i,j)*A(i,j) over all i,j <br /></td></tr>
<tr class="separator:aad57c5351a4bb87122495dfa7051b1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59fa8f9c3755d268074239665811ef3"><td class="memItemLeft" align="right" valign="top"><a id="ae59fa8f9c3755d268074239665811ef3"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ae59fa8f9c3755d268074239665811ef3">sumrows</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:ae59fa8f9c3755d268074239665811ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a row vector holding the sum over all rows, i.e., (1 1 ... 1)*A <br /></td></tr>
<tr class="separator:ae59fa8f9c3755d268074239665811ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7a0b88dcb2fb86e9cca7fd97fd946e"><td class="memItemLeft" align="right" valign="top"><a id="aee7a0b88dcb2fb86e9cca7fd97fd946e"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#aee7a0b88dcb2fb86e9cca7fd97fd946e">sumcols</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:aee7a0b88dcb2fb86e9cca7fd97fd946e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector holding the sum over all columns, i.e., A*(1 1 ... 1)^T <br /></td></tr>
<tr class="separator:aee7a0b88dcb2fb86e9cca7fd97fd946e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe9d3feb6915a3967d27cb2ff654c86"><td class="memItemLeft" align="right" valign="top"><a id="a7fe9d3feb6915a3967d27cb2ff654c86"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a7fe9d3feb6915a3967d27cb2ff654c86">sum</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:a7fe9d3feb6915a3967d27cb2ff654c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the sum over all elements of A, i.e., (1 1 ... 1)*A*(1 1 ... 1)^T <br /></td></tr>
<tr class="separator:a7fe9d3feb6915a3967d27cb2ff654c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5247356616e20c33053b23ab9a5d1337"><td class="memItemLeft" align="right" valign="top"><a id="a5247356616e20c33053b23ab9a5d1337"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a5247356616e20c33053b23ab9a5d1337">svec</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;v, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> a, bool add, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> startindex_vec, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> startindex_A, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> blockdim)</td></tr>
<tr class="memdesc:a5247356616e20c33053b23ab9a5d1337"><td class="mdescLeft">&#160;</td><td class="mdescRight">the symmetric vec operator stacks the lower triangle of A to a n*(n+1)/2 vector with the same norm2 as A; here it sets svec(A)=[a11,sqrt(2)a12,...,sqrt(2)a1n,a22,...,sqrt(2)a(n-1,n),ann]', multiplies it by a and sets or adds (if add==true) it to v starting from startindex_vec possibly restricted to the subblock of order blockdim (whenever &gt;=0, else blockdim is set to A.rowdim()-startindex_A) starting from startindex_A (must be &gt;=0); if add==false and startindex_vec&lt;0 then vec is also reinitialzed to the appropriate size <br /></td></tr>
<tr class="separator:a5247356616e20c33053b23ab9a5d1337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb3c073c9d4a628b2a0144ee9285ee6"><td class="memItemLeft" align="right" valign="top"><a id="a3bb3c073c9d4a628b2a0144ee9285ee6"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a3bb3c073c9d4a628b2a0144ee9285ee6">svec</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:a3bb3c073c9d4a628b2a0144ee9285ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">the symmetric vec operator, stacks the lower triangle of A to a n*(n+1)/2 vector with the same norm2 as A; i.e., it returns svec(A)=[a11,sqrt(2)a12,...,sqrt(2)a1n,a22,...,sqrt(2)a(n-1,n),ann]' <br /></td></tr>
<tr class="separator:a3bb3c073c9d4a628b2a0144ee9285ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f021117b22b41def5e9ee4f100a5103"><td class="memItemLeft" align="right" valign="top"><a id="a8f021117b22b41def5e9ee4f100a5103"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a8f021117b22b41def5e9ee4f100a5103">sveci</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;v, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> a, bool add, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> startindex_vec, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> startindex_A, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> blockdim)</td></tr>
<tr class="memdesc:a8f021117b22b41def5e9ee4f100a5103"><td class="mdescLeft">&#160;</td><td class="mdescRight">the inverse operator to svec, extracts from v at startindex_vec (&gt;=0) the symmetric matrix of blockdim adding its mutliple by a into A starting at startindex_A; if add==false and startindex_A&lt;0 A is initialized to the size of blockdim; if the latter is also negative then v.dim()-startindex_vec must match an exact order and matrix A is initialized to this size. In all other cases the size of the symmetric matrix determines the missing parameters and vec.dim-startindex_vec <br /></td></tr>
<tr class="separator:a8f021117b22b41def5e9ee4f100a5103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd597b7466289d65e96fbde2aeeea8ad"><td class="memItemLeft" align="right" valign="top"><a id="afd597b7466289d65e96fbde2aeeea8ad"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#afd597b7466289d65e96fbde2aeeea8ad">skron</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha, bool add, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> startindex_S)</td></tr>
<tr class="memdesc:afd597b7466289d65e96fbde2aeeea8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">the symmetric Kronecker product, defined via (A skron B)svec(C)=(BCA'+ACB')/2; sets or adds (if add==true) the symmetric matrix a*(A skron B) into S starting at startindex_S; if add==false and startindex_S&lt;0, S is initialzed to the correct size <br /></td></tr>
<tr class="separator:afd597b7466289d65e96fbde2aeeea8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18de4822bdd94945ac9f20acc9afaec5"><td class="memItemLeft" align="right" valign="top"><a id="a18de4822bdd94945ac9f20acc9afaec5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a18de4822bdd94945ac9f20acc9afaec5">skron</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;S, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> a, bool add, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> startindex_S)</td></tr>
<tr class="memdesc:a18de4822bdd94945ac9f20acc9afaec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">def symmetric Kronecker product (A skron B)svec(C)=(BCA'+ACB')/2; sets S=alpha*(A skron B) or S*=... (if add==true) possibly shifted to the block starting at startindex_S; if add==false and startindex_S&lt;0, S is initialzed to the correct size <br /></td></tr>
<tr class="separator:a18de4822bdd94945ac9f20acc9afaec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ad2b5af688d5d76df831ae11cdf94b"><td class="memItemLeft" align="right" valign="top"><a id="aa5ad2b5af688d5d76df831ae11cdf94b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#aa5ad2b5af688d5d76df831ae11cdf94b">symscale</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;S, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> a, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> b, int btrans)</td></tr>
<tr class="memdesc:aa5ad2b5af688d5d76df831ae11cdf94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets S=beta*S+alpha*B'*A*B for symmatrix A and matrix B <br /></td></tr>
<tr class="separator:aa5ad2b5af688d5d76df831ae11cdf94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3d164936ff2ae5926210e1faf2ca6e"><td class="memItemLeft" align="right" valign="top"><a id="a3f3d164936ff2ae5926210e1faf2ca6e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>init_svec</b> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a081b04bbf1938d34a8bbb7031cdb6be6">nr</a>, const <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> *dp, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incr=1, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>
<tr class="separator:a3f3d164936ff2ae5926210e1faf2ca6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36ef49b1654c0b8eecea890af12e008"><td class="memItemLeft" align="right" valign="top"><a id="ab36ef49b1654c0b8eecea890af12e008"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>store_svec</b> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> *dp, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incr=1, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.) const</td></tr>
<tr class="separator:ab36ef49b1654c0b8eecea890af12e008"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classCH__Matrix__Classes_1_1Memarrayuser"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classCH__Matrix__Classes_1_1Memarrayuser')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classCH__Matrix__Classes_1_1Memarrayuser.html">CH_Matrix_Classes::Memarrayuser</a></td></tr>
<tr class="memitem:aa07653db7172e93896a5ba1d6964dd58 inherit pro_methods_classCH__Matrix__Classes_1_1Memarrayuser"><td class="memItemLeft" align="right" valign="top"><a id="aa07653db7172e93896a5ba1d6964dd58"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Memarrayuser.html#aa07653db7172e93896a5ba1d6964dd58">Memarrayuser</a> ()</td></tr>
<tr class="memdesc:aa07653db7172e93896a5ba1d6964dd58 inherit pro_methods_classCH__Matrix__Classes_1_1Memarrayuser"><td class="mdescLeft">&#160;</td><td class="mdescRight">if <a class="el" href="classCH__Matrix__Classes_1_1Memarrayuser.html#a3f22e1efed76a4b0caa25e6bea7910a0" title="pointer to common memory manager for all Memarrayusers, instantiated in memarray.cxx ...">memarray</a> is NULL, then a new <a class="el" href="classCH__Matrix__Classes_1_1Memarray.html" title="A simple memory manager for frequent allocation and deallocation of arrays of roughly the same size...">Memarray</a> is generated. In any case the number of users of the <a class="el" href="classCH__Matrix__Classes_1_1Memarray.html" title="A simple memory manager for frequent allocation and deallocation of arrays of roughly the same size...">Memarray</a> is incremented <br /></td></tr>
<tr class="separator:aa07653db7172e93896a5ba1d6964dd58 inherit pro_methods_classCH__Matrix__Classes_1_1Memarrayuser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628b6725c99a8d5eb0702a4c969ace67 inherit pro_methods_classCH__Matrix__Classes_1_1Memarrayuser"><td class="memItemLeft" align="right" valign="top"><a id="a628b6725c99a8d5eb0702a4c969ace67"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Memarrayuser.html#a628b6725c99a8d5eb0702a4c969ace67">~Memarrayuser</a> ()</td></tr>
<tr class="memdesc:a628b6725c99a8d5eb0702a4c969ace67 inherit pro_methods_classCH__Matrix__Classes_1_1Memarrayuser"><td class="mdescLeft">&#160;</td><td class="mdescRight">the number of users is decremented and the <a class="el" href="classCH__Matrix__Classes_1_1Memarray.html" title="A simple memory manager for frequent allocation and deallocation of arrays of roughly the same size...">Memarray</a> memory manager is destructed, if the number is zero. <br /></td></tr>
<tr class="separator:a628b6725c99a8d5eb0702a4c969ace67 inherit pro_methods_classCH__Matrix__Classes_1_1Memarrayuser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classCH__Matrix__Classes_1_1Memarrayuser"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classCH__Matrix__Classes_1_1Memarrayuser')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classCH__Matrix__Classes_1_1Memarrayuser.html">CH_Matrix_Classes::Memarrayuser</a></td></tr>
<tr class="memitem:a3f22e1efed76a4b0caa25e6bea7910a0 inherit pro_static_attribs_classCH__Matrix__Classes_1_1Memarrayuser"><td class="memItemLeft" align="right" valign="top"><a id="a3f22e1efed76a4b0caa25e6bea7910a0"></a>
static <a class="el" href="classCH__Matrix__Classes_1_1Memarray.html">Memarray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Memarrayuser.html#a3f22e1efed76a4b0caa25e6bea7910a0">memarray</a></td></tr>
<tr class="memdesc:a3f22e1efed76a4b0caa25e6bea7910a0 inherit pro_static_attribs_classCH__Matrix__Classes_1_1Memarrayuser"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to common memory manager for all Memarrayusers, instantiated in memarray.cxx <br /></td></tr>
<tr class="separator:a3f22e1efed76a4b0caa25e6bea7910a0 inherit pro_static_attribs_classCH__Matrix__Classes_1_1Memarrayuser"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Matrix class of symmetric matrices with real values of type <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type ">Real</a> </p>
<p>Internally a symmetric matrix of size nr x nr is stored in a one dimensional array of <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type ">Real</a> variables, the elements of the lower triangle are arranged in columnwise order (a11,a21,...,anr1,a22,a32,...).</p>
<p>Any matrix element can be indexed by (i,j) or directly by the one dimensional index (i+j*nr). The latter view directly corresponds to the vec() operator often used in the linear algebra literature, i.e., the matrix is transformed to a vector by stacking the columns on top of each other.</p>
<p>NOTE: Any change of A(i,j) also changes A(j,i) as both variables are identical! </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aeea95b6f59c5c5012a08088f4208601e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea95b6f59c5c5012a08088f4208601e">&#9670;&nbsp;</a></span>Symmatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CH_Matrix_Classes::Symmatrix::Symmatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>&#160;</td>
          <td class="paramname"><em>nr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>generate a matrix of size nr x nr but WITHOUT initializing the memory </p>
<p>If initializing the memory externally and CONICBUNDLE_DEBUG is defined, please use <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a2ea14efca04115bfb34febd3084108ab" title="after external initialization, call matrix.set_init(true) (not needed if CONICBUNDLE_DEBUG is undefin...">set_init()</a> via matrix.set_init(true) in order to avoid warnings concerning improper initialization </p>

<p class="reference">References <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a5ceaaffaa26c44edc08e5277d6359abf">init_to_zero()</a>, and <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a43e3cc5de2659fb4eb213eaca2276626">newsize()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a624bb5169edbd58d71a4d75feb03d7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624bb5169edbd58d71a4d75feb03d7ee">&#9670;&nbsp;</a></span>display()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CH_Matrix_Classes::Symmatrix::display </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>screenwidth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>displays a matrix in a pretty way for bounded screen widths; for variables of value zero default values are used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>output stream </td></tr>
    <tr><td class="paramname">precision</td><td>number of most significant digits, default=4 </td></tr>
    <tr><td class="paramname">width</td><td>field width, default = precision+6 </td></tr>
    <tr><td class="paramname">screenwidth</td><td>maximum number of characters in one output line, default = 80 </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classConicBundle_1_1CMsymdense.html#a80097809059a845b94ab70e71428632c">ConicBundle::CMsymdense::display()</a>, and <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ab4c30091f07177dd6d52986e46759d2e">transpose()</a>.</p>

</div>
</div>
<a id="a781cc9ac99619b6e9c0794fb8b56575a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781cc9ac99619b6e9c0794fb8b56575a">&#9670;&nbsp;</a></span>mfile_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CH_Matrix_Classes::Symmatrix::mfile_output </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>outputs a matrix A in the format "[ A(0,1) ... A(0,nc-1)\n ... A(nr-1,nc-1)];\n" so that it can be read e.g. by octave as an m-file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>output stream </td></tr>
    <tr><td class="paramname">precision</td><td>number of most significant digits, default=16 </td></tr>
    <tr><td class="paramname">width</td><td>field width, default = precision+6 </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ab4c30091f07177dd6d52986e46759d2e">transpose()</a>.</p>

</div>
</div>
<a id="a43e3cc5de2659fb4eb213eaca2276626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e3cc5de2659fb4eb213eaca2276626">&#9670;&nbsp;</a></span>newsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CH_Matrix_Classes::Symmatrix::newsize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>resize the matrix to nr x nr elements but WITHOUT initializing the memory </p>
<p>If initializing the memory externally and CONICBUNDLE_DEBUG is defined, please use <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a2ea14efca04115bfb34febd3084108ab" title="after external initialization, call matrix.set_init(true) (not needed if CONICBUNDLE_DEBUG is undefin...">set_init()</a> via matrix.set_init(true) in order to avoid warnings concerning improper initialization </p>

<p class="reference">Referenced by <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a9f1b27860806b5cd95b420168176f02c">get_init()</a>, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a3f002e510774193b59aa326625341993">init()</a>, <a class="el" href="classConicBundle_1_1UQPSolver.html#a477cafa4ab5ed3ce0c147a4ef2e4f011">ConicBundle::UQPSolver::init_size()</a>, <a class="el" href="classConicBundle_1_1CMsingleton.html#a8a3236413c67495f66ba5d567a80cf70">ConicBundle::CMsingleton::project()</a>, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#aeea95b6f59c5c5012a08088f4208601e">Symmatrix()</a>, and <a class="el" href="namespaceCH__Matrix__Classes.html#af7b9987ec91dc9c6cbc16bb3f27fda34">CH_Matrix_Classes::xeyapzb()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="afda3741bc893cb65271501b3a71bce79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda3741bc893cb65271501b3a71bce79">&#9670;&nbsp;</a></span>genmult <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&amp; genmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>btrans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns C=beta*C+alpha*A*B, where B may be transposed; C must not be equal to B; if beta==0. then C is initialized to the correct size </p>
<p>returns C=beta*C+alpha*A*B, where B may be transposed; C must not be equal to B; if beta==0. then C is initialized to the correct size </p>

<p class="reference">Referenced by <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a1c2fb45683aaa043d2ff8d3a10f100c2">get_store()</a>, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html#af6ccddb4ba5879a0286497a3b4d9c9b6">CH_Matrix_Classes::Matrix::init()</a>, <a class="el" href="namespaceCH__Matrix__Classes.html#a0ecdc3e003bf111b5516a1488a41e7c2">CH_Matrix_Classes::operator*()</a>, and <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ab4c30091f07177dd6d52986e46759d2e">transpose()</a>.</p>

</div>
</div>
<a id="afeed2991f0ec4a0460cf33dfc9209aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeed2991f0ec4a0460cf33dfc9209aa1">&#9670;&nbsp;</a></span>genmult <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&amp; genmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>atrans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns C=beta*C+alpha*A*B, where A may be transposed; C must not be equal to A; if beta==0. then C is initialized to the correct size </p>
<p>returns C=beta*C+alpha*A*B, where A may be transposed; C must not be equal to A; if beta==0. then C is initialized to the correct size </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="symmat_8hxx_source.html">symmat.hxx</a></li>
<li><a class="el" href="sparssym_8hxx_source.html">sparssym.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
