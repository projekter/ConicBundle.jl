<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ConicBundle: Interface to ConicBundle for the Language C++ using Matrix Classes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ConicBundle
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Interface to ConicBundle for the Language C++ using Matrix Classes</div>  </div>
</div><!--header-->
<div class="contents">

<p>Solve <img class="formulaInl" alt="$min_{y\in\mathbf{R}^m} f_0(y) + f_1(y) + ... + f_k(y)$" src="form_111.png"/> for convex functions f_i, the y-variables may be free, bounded, box constrained, or linearly constrained. The most important steps are the following.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1PrimalMatrix.html">ConicBundle::PrimalMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If in Lagrangean relaxation primal solutions are in the form of a real vector or, more generally a matrix, then an approximate primal solution can be generated by supplying primal information of this form for each epsilon subgradient within <a class="el" href="classConicBundle_1_1MatrixFunctionOracle.html#a5bf180324668e4baaa431edb5ba56993" title="Called by the solver. Has to Return function value and at least one (epsilon) subgradient and...">ConicBundle::MatrixFunctionOracle::evaluate()</a>.  <a href="classConicBundle_1_1PrimalMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixMinorant.html">ConicBundle::MatrixMinorant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classConicBundle_1_1Minorant.html" title="this is used to describe affine minorants of convex functions that will be used for generating cuttin...">Minorant</a> interface supporting Matrix classes; simple constructros for subgradients given by column vectors in form of a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">CH_Matrix_Classes::Matrix</a> or a <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html" title="Matrix class of sparse matrices with real values of type Real ">CH_Matrix_Classes::Sparsemat</a>.  <a href="classConicBundle_1_1MatrixMinorant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1ModifiableOracleObject.html">ConicBundle::ModifiableOracleObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ModifiableOracle provides all oracles with a uniform interface for a modification routine and an on/off switch for internal correctness checks.  <a href="classConicBundle_1_1ModifiableOracleObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixFunctionOracle.html">ConicBundle::MatrixFunctionOracle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Oracle interface (abstract class). For each of your functions, provide an instance of a derived class.  <a href="classConicBundle_1_1MatrixFunctionOracle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html">ConicBundle::MatrixCBSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Full Conic Bundle method solver invoked by <a class="el" href="classConicBundle_1_1MatrixCBSolver.html" title="The Full Conic Bundle method solver invoked by ConicBundle::MatrixCBSolver(), it uses a separate cutt...">ConicBundle::MatrixCBSolver()</a>, it uses a separate cutting model for each function.  <a href="classConicBundle_1_1MatrixCBSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html">ConicBundle::AffineFunctionTransformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">transform a function f(z) to fun_coeff*f(arg_offset+arg_trafo*y)+linear_cost*y+fun_offset (scales the value, substitutes argument z=c+Ay, and adds an affine term b'y+d)  <a href="classConicBundle_1_1AffineFunctionTransformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Solve <img class="formulaInl" alt="$min_{y\in\mathbf{R}^m} f_0(y) + f_1(y) + ... + f_k(y)$" src="form_111.png"/> for convex functions f_i, the y-variables may be free, bounded, box constrained, or linearly constrained. The most important steps are the following. </p>
<p>Before starting, note that this interface relies on several classes defined in <a class="el" href="namespaceCH__Matrix__Classes.html" title="Matrix Classes and Linear Algebra. See Matrix Classes (namespace CH_Matrix_Classes) for a quick intro...">CH_Matrix_Classes</a>, in particular on <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">CH_Matrix_Classes::Matrix</a> and <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html" title="Matrix class for integral values of type Integer ">CH_Matrix_Classes::Indexmatrix</a>. The full functionality of <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> is only available with these classes. If you prefer an interface without having to use these, please use the <a class="el" href="group__cxxinterface.html">Interface to ConicBundle for the Language C++</a>. We now give a short overview of the most important steps in using the <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> solver.</p>
<p><b>Setting up the Problem, the Functions, and the Main Loop</b></p>
<p>First create a new problem/solver <a class="el" href="classConicBundle_1_1MatrixCBSolver.html" title="The Full Conic Bundle method solver invoked by ConicBundle::MatrixCBSolver(), it uses a separate cutt...">ConicBundle::MatrixCBSolver</a>, let us call it solver for brevity.</p>
<p>Next call <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a5129b50d68be01aaa8cb6825058a8f13" title="Initializes the problem by setting up the design space (the dimension and possibly box constraints on...">ConicBundle::MatrixCBSolver::init_problem()</a> to set the dimension of the design variables/argument space, possibly together with box constraints, starting values and and linear cost terms. In prinicple, further linear constraints could be installed using <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a7fbdae68564966efb65943793cbd55b8" title="append  as linear constraints on the groundset variables .  has append_n_rows new rows with coefficie...">ConicBundle::MatrixCBSolver::append_constraints()</a> but this should be avoided whenever possible (additional constraints may entail a significant loss in efficiency in the internal quadratic subproblems. Also note that even simple bounds require a lot more work when using general variable metric approaches.</p>
<p>Now set up each of your functions f_i as a <a class="el" href="classConicBundle_1_1MatrixFunctionOracle.html" title="Oracle interface (abstract class). For each of your functions, provide an instance of a derived class...">ConicBundle::MatrixFunctionOracle</a> (see <a class="el" href="cbsolver.html">The Internal Conic Bundle Solver</a> for specialized oracle classes). The solver will call the routine <a class="el" href="classConicBundle_1_1MatrixFunctionOracle.html#a5bf180324668e4baaa431edb5ba56993" title="Called by the solver. Has to Return function value and at least one (epsilon) subgradient and...">ConicBundle::MatrixFunctionOracle::evaluate()</a>, and via this you have to supply, for a given argument, a function value and an affine <a class="el" href="classConicBundle_1_1Minorant.html" title="this is used to describe affine minorants of convex functions that will be used for generating cuttin...">ConicBundle::Minorant</a> (you might want to use the constructors provided in <a class="el" href="classConicBundle_1_1MatrixMinorant.html" title="Minorant interface supporting Matrix classes; simple constructros for subgradients given by column ve...">MatrixMinorant</a> instead). A <a class="el" href="classConicBundle_1_1Minorant.html" title="this is used to describe affine minorants of convex functions that will be used for generating cuttin...">Minorant</a> is described by its function value and (epsilon) subgradient (=the gradient if the function is differentiable). In the oracle this function evaluate() is the only function that you definitely have to provide, see the miniature example below.</p>
<p>The function oracles have to be added to the solver using the routine <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a3c503663b689ede0f1d004690d622e2f" title="Adds a function, typically derived from ConicBundle::FunctionOracle. If the dimension does not match ...">ConicBundle::MatrixCBSolver::add_function()</a>. In adding a function <img class="formulaInl" alt="$f$" src="form_5.png"/> you may (but need not) specify a multiplicative factor <img class="formulaInl" alt="$\gamma$" src="form_122.png"/> (==1. by default) for <img class="formulaInl" alt="$f$" src="form_5.png"/> and whether the function serves as an ObjectiveFunction (the solver uses the value <img class="formulaInl" alt="$\gamma f(y)$" src="form_123.png"/> directly), as a ConstantPenaltyFunction (the solver uses the value <img class="formulaInl" alt="$\gamma\max\{0,f(y)\}$" src="form_124.png"/>) or as an AdaptivePenatlyFunction (the solver uses the value <img class="formulaInl" alt="$\gamma\max\{0,f(y)\}$" src="form_124.png"/> but may further increase <img class="formulaInl" alt="$\gamma$" src="form_122.png"/> until the value indeed goes to zero). If your function works just on a subset/subspace of the variables, it may be worth to specify the function on its own original space and use a <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html" title="transform a function f(z) to fun_coeff*f(arg_offset+arg_trafo*y)+linear_cost*y+fun_offset (scales the...">ConicBundle::AffineFunctionTransformation</a> on the argument, so that the solver uses, e.g. <img class="formulaInl" alt="$ \gamma\cdot(\delta+b^Ty+\rho\cdot f(c+Ay))$" src="form_125.png"/>.</p>
<p>Once all functions are added, the optimization process can be started. If you know a good starting point (and have not already supplied it in init_problem()) then set it with <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#ac7f0864cfbc01e3f9c057234069423ba" title="Set the starting point/center that will be used in the next call to solve(). Each call to this routin...">ConicBundle::MatrixCBSolver::set_new_center_point()</a> now, otherwise the method will pick the zero vector or, in the case of box constraints, the point closest to zero as starting point.</p>
<p>Finally, call <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a2dbe46bc6b34684ea4895f8527e3c493" title="solves or does a prescribed number of iterations ">ConicBundle::MatrixCBSolver::solve()</a> and retrieve <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a67e4eaa9ce3bd66f52387ccaa59908de" title="Returns the termination code of the bundle algorithm for the latest descent step. ...">ConicBundle::MatrixCBSolver::termination_code()</a> for getting the reason for termination. Via parameters in solve() you may also tell the solver to return after each descent step or also after a maximum number of null steps. This then only interrupts computations and calling solve() again continues as if there was not break at all.</p>
<p><b>Retrieving Some Solution Information</b></p>
<p>Whenever the solver returns form solve() you can retrieve the current objective value by <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#abadd5d33331ac8f52bb435a11d04a802" title="Returns the objective value resulting from last descent step (initially undefined). If no problem modification routines were called since then, it is the objective value at the point returned by get_center(). ">ConicBundle::MatrixCBSolver::get_objval()</a> and the argument leading to this value by <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a40b4df10fa42d417881ec55fad3616cd" title="Returns the next center point that was produced by the latest call to solve (in some problem modifica...">ConicBundle::MatrixCBSolver::get_center()</a>. For some screen output, use <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a370c6ee0dd593962cbb39927a56d6bce" title="Specifies the output level (out==NULL: no output at all, out!=NULL and level=0: errors and warnings...">ConicBundle::MatrixCBSolver::set_out()</a>.</p>
<p><b>Lagrangean Relaxation, Primal Approximations, and Cutting Planes</b></p>
<p>If you are optimizing the Lagrange multipliers of a Lagrangean relaxation, you might be interested in getting an approximation to your primal optimal solution. This can be done by specifying in each function for each minorant/(epsilon) subgradient the corresponding primal vectors that generate it, see <a class="el" href="classConicBundle_1_1PrimalData.html" title="In Lagrangean relaxation an approximate primal solution can be generated by supplying primal informat...">PrimalData</a> (with implementation <a class="el" href="classConicBundle_1_1PrimalMatrix.html" title="If in Lagrangean relaxation primal solutions are in the form of a real vector or, more generally a ma...">PrimalMatrix</a>) in <a class="el" href="classConicBundle_1_1Minorant.html" title="this is used to describe affine minorants of convex functions that will be used for generating cuttin...">ConicBundle::Minorant</a> as a start. Then for each of your functions, you can retrieve the current primal approximation using <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#af4b7d14796c16870dca8b563846be351" title="returns the current approximate primal solution corresponding to the aggregate subgradient of the spe...">ConicBundle::MatrixCBSolver::get_approximate_primal()</a>.</p>
<p>If you are just relaxing linear constraints on your variables, an elegant alternative is to use an <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html" title="transform a function f(z) to fun_coeff*f(arg_offset+arg_trafo*y)+linear_cost*y+fun_offset (scales the...">AffineFunctionTransformation</a> as follows. For concreteness, assume you want to minimize <img class="formulaInl" alt="$f(y)=\max_{x\in\mathcal{X}}[h(x)+(b-Bx)^Ty]$" src="form_126.png"/> where <img class="formulaInl" alt="$\mathcal{X}\subset\mathbf{R}^n$" src="form_127.png"/> is some compact set for which the inner max is easy to compute for any <img class="formulaInl" alt="$y$" src="form_64.png"/>. Now, it might actually be better to implement the function <img class="formulaInl" alt="$\bar f(\bar c)=\max_{x\in\mathcal{X}}[h(x)+\bar c^Tx]$" src="form_128.png"/> and use it with the <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html" title="transform a function f(z) to fun_coeff*f(arg_offset+arg_trafo*y)+linear_cost*y+fun_offset (scales the...">AffineFunctionTransformation</a> <img class="formulaInl" alt="$ b^Ty+ \bar f(-B^Ty)$" src="form_129.png"/> (so <img class="formulaInl" alt="$A=-B^T$" src="form_130.png"/>). Then if <img class="formulaInl" alt="$\bar x$" src="form_131.png"/> is the maximizer for a given <img class="formulaInl" alt="$\bar c=-B^Ty$" src="form_132.png"/>, the corresponding minorant to be returned by the oracle of <img class="formulaInl" alt="$\bar f$" src="form_133.png"/> is described by the offset <img class="formulaInl" alt="$h(\bar x)$" src="form_134.png"/> with the corresponding subgradient being just <img class="formulaInl" alt="$\bar x$" src="form_131.png"/> itself. So in this case the primal data is the minorant itself and there is no need to provide it separately. For the case that <img class="formulaInl" alt="$\mathcal{X}$" src="form_135.png"/> is a box domain, see <a class="el" href="group__box__oracle.html">box oracle with special purpose cutting model</a> for a tuned model. A slightly different possibility is offered by the example <a class="el" href="group__implemented__matrix__function__oracle.html">implemention of MatrixFunctionOracle (NNCBoxSupportFunction)</a> with an <a class="el" href="classConicBundle_1_1NNCBoxSupportFunction.html" title="general purpose implementation of MatrixFunctionOracle as explained in implemention of MatrixFunction...">NNCBoxSupportFunction</a>, but this is likely a lot less efficient.</p>
<p>In addition, you might plan to improve your primal relaxation via cutting planes if they are strongly violated by the current primal approximation. This requires introducing new multipliers for the ground set and typically also changes the dimension of your function <img class="formulaInl" alt="$f$" src="form_5.png"/> on the fly, unless you are in the situation of <img class="formulaInl" alt="$\bar f$" src="form_133.png"/> above, where only the <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html" title="transform a function f(z) to fun_coeff*f(arg_offset+arg_trafo*y)+linear_cost*y+fun_offset (scales the...">AffineFunctionTransformation</a> changes. In any case you will need <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#ae94677e63dc7736099a77acaad553a3f" title="Append new variables (always in last postions in this order). ">ConicBundle::MatrixCBSolver::append_variables()</a>. There you have to provide for your function either a corresponding derived implementation of the base class <a class="el" href="classConicBundle_1_1OracleModification.html" title="Base class for informing oracles (or the solver) about dynamic changes in the number and sorting of t...">ConicBundle::OracleModification</a> or, in the case of <img class="formulaInl" alt="$\bar f$" src="form_133.png"/> above, just a corresponding <a class="el" href="classConicBundle_1_1AFTModification.html" title="collects modifications for an AffineFunctionTransformation for the scaling and offset constants as we...">ConicBundle::AFTModification</a> for your transformation. In the latter case this is all you need to provide, because <img class="formulaInl" alt="$\bar f$" src="form_133.png"/> is not changed at all, but in the general case of a general <img class="formulaInl" alt="$f$" src="form_5.png"/> you will also need to implement the oracle's subroutine <a class="el" href="classConicBundle_1_1ModifiableOracleObject.html#ab4f16d78fec3a02cc064003c2b02ddce" title="This routine need not be implemented unless variables (constraints in Lagrangean relaxation) are adde...">MatrixFunctionOracle::apply_modification()</a> which will be called by the solver with your modification data so that the function adapts according to this data. In most cases adapting the class <a class="el" href="classConicBundle_1_1Modification.html" title="base class for collecting and organizing a sequence of changes to linear data so that it can be carri...">ConicBundle::Modification</a> like in <a class="el" href="classConicBundle_1_1LPGroundsetModification.html" title="Collects modifications for the linearly constrained LPGroundset for appending, deleting or reassignin...">ConicBundle::LPGroundsetModification</a> will allow to do all you need with minimal work.</p>
<p>Typically, when changing the dimension, the cutting model of the bundle method is lost. This is no problem in the case of <img class="formulaInl" alt="$\bar f$" src="form_133.png"/> above if the newly added multipliers are zero initially, because then the minorants with transformation can and will be regenerated automatically from the unchanged minorants <img class="formulaInl" alt="$\bar x$" src="form_131.png"/>. In the case of general <img class="formulaInl" alt="$f$" src="form_5.png"/>, if you provided primal data with your minorants, you may also know how to extend your minorants on newly appended coordinates. If you know how to do this, then you can provide a <a class="el" href="classConicBundle_1_1MinorantExtender.html" title="Interface for extending a Minorant, e.g., in Lagrangian Relaxation of cutting plane approaches...">ConicBundle::MinorantExtender</a> when the solver calls <a class="el" href="classConicBundle_1_1ModifiableOracleObject.html#ab4f16d78fec3a02cc064003c2b02ddce" title="This routine need not be implemented unless variables (constraints in Lagrangean relaxation) are adde...">MatrixFunctionOracle::apply_modification()</a>. The <a class="el" href="classConicBundle_1_1MinorantExtender.html" title="Interface for extending a Minorant, e.g., in Lagrangian Relaxation of cutting plane approaches...">MinorantExtender</a> will be applied to all minorants of the model and if this succeeds the model is not lost. A rich example implementation (with a separate cutting model) of all these features is provided by the <a class="el" href="classConicBundle_1_1PSCAffineFunction.html" title="general purpose implementation of PSCOracle as explained in implemention of a PSCOracle (PSCAffineFun...">PSCAffineFunction</a> implementation of the <a class="el" href="classConicBundle_1_1PSCOracle.html" title="Oracle interface for minimization of the maximum eigenvalue of an affine matrix function or...">PSCOracle</a> for solving the duals to primal semidefinite programs with nonempty bounded feasible sets, see <a class="el" href="group__abstract__psc__oracle.html">abstract positive semidefinite cone oracle</a> and <a class="el" href="group__implemented__psc__oracle.html">implemention of a PSCOracle (PSCAffineFunction)</a>.</p>
<p>If you want to get rid of primal constraints/dual variables, have a look at <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a5229f01c537d914a60b896bf01e550d5" title="If set to true (the default is false), variables may be fixed automatically to active bounds if these...">ConicBundle::MatrixCBSolver::set_active_bounds_fixing()</a>, <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a8715eb8a6c956d314a108c8fd29636f7" title="Returns NULL or (iff active bound fixing is turned on in set_active_bounds_fixing()) the indicator ve...">ConicBundle::MatrixCBSolver::get_fixed_active_bounds()</a>, maybe also at <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a1a5cb1975f8e70693c76711ba3211237" title="Returns the multipliers for the box constraints on the design variables; in Lagrangean relaxation the...">ConicBundle::MatrixCBSolver::get_approximate_slacks()</a> and then use <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a6396522aada2447cf05b5e699adbd0f7" title="Deletes variables corresponding to the specified indices. ">ConicBundle::MatrixCBSolver::delete_variables()</a>. This may again need to be accompanied by OracleModifcation implementations and corresponding actions in your oracle.</p>
<div class="fragment"><div class="line"><span class="comment">//******************************************************************************</span></div><div class="line"><span class="comment">//*       Miniature Example in C++ for Convex Quadratic in Two Variables       * </span></div><div class="line"><span class="comment">//******************************************************************************</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="MatrixCBSolver_8hxx.html">MatrixCBSolver.hxx</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>std;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceConicBundle.html">ConicBundle</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceCH__Matrix__Classes.html">CH_Matrix_Classes</a>;</div><div class="line"></div><div class="line"><span class="comment">// f(x)=.5*x^TAx+b^Tx+c with A=[5 1;1 4], b=[-12;-10], c=3 </span></div><div class="line"><span class="keyword">class </span>QFunction: <span class="keyword">public</span> <a class="code" href="classConicBundle_1_1MatrixFunctionOracle.html">MatrixFunctionOracle</a></div><div class="line">{</div><div class="line">  <a class="code" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> A,b;</div><div class="line">  <span class="keywordtype">double</span> c;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  QFunction()</div><div class="line">  {</div><div class="line">    A.<a class="code" href="classCH__Matrix__Classes_1_1Matrix.html#acfcef0fcd8efde1329aadfd2c137a9d7">init</a>(2,2,0.);  A(0,0) = 5;  A(1,1) = 4;  A(0,1) = A(1,0) = 1.;</div><div class="line">    b.<a class="code" href="classCH__Matrix__Classes_1_1Matrix.html#acfcef0fcd8efde1329aadfd2c137a9d7">init</a>(2,1,0.);  b(0) = -12;  b(1) = -10;</div><div class="line">    c=3;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> evaluate(<span class="keyword">const</span> <a class="code" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&amp; x, </div><div class="line">               <span class="keywordtype">double</span> <span class="comment">/* relprec */</span>, </div><div class="line">               <span class="keywordtype">double</span>&amp; objective_value,</div><div class="line">               vector&lt;Minorant*&gt;&amp; minorants,</div><div class="line">               <a class="code" href="classConicBundle_1_1PrimalExtender.html">PrimalExtender</a>*&amp;)</div><div class="line">  {</div><div class="line">    <span class="comment">/* compute objective as inner product of x with A*x+b plus c */</span></div><div class="line">    objective_value= .5*<a class="code" href="namespaceCH__Matrix__Classes.html#af4fa805785a8e3572f072ef87046e3a4">ip</a>(x,A*x)+<a class="code" href="namespaceCH__Matrix__Classes.html#af4fa805785a8e3572f072ef87046e3a4">ip</a>(x,b)+c;</div><div class="line">    <span class="comment">/* compute and store one subgradient(=gradient) with two coordinates */</span></div><div class="line">    minorants.push_back(<span class="keyword">new</span> <a class="code" href="classConicBundle_1_1MatrixMinorant.html">MatrixMinorant</a>(objective_value,A*x+b));</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">  QFunction fun;                          </div><div class="line"></div><div class="line">  <a class="code" href="classConicBundle_1_1MatrixCBSolver.html">MatrixCBSolver</a> solver(&amp;cout,1);       <span class="comment">// initilialize solver with basic output</span></div><div class="line">  solver.<a class="code" href="classConicBundle_1_1MatrixCBSolver.html#a5129b50d68be01aaa8cb6825058a8f13">init_problem</a>(2);               <span class="comment">// 2 variables, no bounds</span></div><div class="line">  solver.<a class="code" href="classConicBundle_1_1MatrixCBSolver.html#a3c503663b689ede0f1d004690d622e2f">add_function</a>(fun);             </div><div class="line"></div><div class="line">  solver.<a class="code" href="classConicBundle_1_1MatrixCBSolver.html#abede1e498b73162f2b7e74f958df5bc0">set_term_relprec</a>(1e-8);        <span class="comment">// set relative precision</span></div><div class="line"> </div><div class="line">  solver.<a class="code" href="classConicBundle_1_1MatrixCBSolver.html#a2dbe46bc6b34684ea4895f8527e3c493">solve</a>();                       <span class="comment">// minimize the function</span></div><div class="line"></div><div class="line">  solver.<a class="code" href="classConicBundle_1_1MatrixCBSolver.html#a3a2fd1cb66cdd565a81879de422e45db">print_termination_code</a>(cout);    </div><div class="line"></div><div class="line">  cout&lt;&lt;<span class="stringliteral">&quot; objval=&quot;</span>&lt;&lt;solver.<a class="code" href="classConicBundle_1_1MatrixCBSolver.html#abadd5d33331ac8f52bb435a11d04a802">get_objval</a>()&lt;&lt;<span class="stringliteral">&quot;\n optimizer: &quot;</span>;</div><div class="line">  <a class="code" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> x;</div><div class="line">  solver.<a class="code" href="classConicBundle_1_1MatrixCBSolver.html#a40b4df10fa42d417881ec55fad3616cd">get_center</a>(x);                 <span class="comment">// retrieve the computed solution</span></div><div class="line">  x.<a class="code" href="classCH__Matrix__Classes_1_1Matrix.html#a9e05d6bb5eec6950acf5bb689277a48d">display</a>(cout);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
