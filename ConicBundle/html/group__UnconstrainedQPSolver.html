<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ConicBundle: Internal QP Solver for unconstrained groundsets</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ConicBundle
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Internal QP Solver for unconstrained groundsets</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1UQPSolver.html">ConicBundle::UQPSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">unconstrained QP solver combining the properties of a <a class="el" href="classConicBundle_1_1QPModelDataPointer.html" title="abstract interface for automatically generating and retrieving the qp blocks with the model data that...">QPModelDataPointer</a> and <a class="el" href="classConicBundle_1_1QPSolverObject.html" title="abstract interface for a QPSolver ">QPSolverObject</a>  <a href="classConicBundle_1_1UQPSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1UQPModelBlockObject.html">ConicBundle::UQPModelBlockObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract interface for model blocks in the unconstrained <a class="el" href="classConicBundle_1_1UQPSolver.html" title="unconstrained QP solver combining the properties of a QPModelDataPointer and QPSolverObject ...">UQPSolver</a>  <a href="classConicBundle_1_1UQPModelBlockObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1UQPModelBlock.html">ConicBundle::UQPModelBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">combines and provides basic functionalities of <a class="el" href="classConicBundle_1_1QPModelDataObject.html" title="abstract interface declaring the uniform outer appearance of general cutting models produced by the v...">QPModelDataObject</a> and <a class="el" href="classConicBundle_1_1UQPModelBlockObject.html" title="abstract interface for model blocks in the unconstrained UQPSolver ">UQPModelBlockObject</a>, but is still abstract  <a href="classConicBundle_1_1UQPModelBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1UQPSumModelBlock.html">ConicBundle::UQPSumModelBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implements a (virtual) cutting model being built of a (possibly recursive) sum of <a class="el" href="classConicBundle_1_1UQPModelBlock.html" title="combines and provides basic functionalities of QPModelDataObject and UQPModelBlockObject, but is still abstract ">UQPModelBlock</a> cutting model instances for <a class="el" href="classConicBundle_1_1UQPSolver.html" title="unconstrained QP solver combining the properties of a QPModelDataPointer and QPSolverObject ...">UQPSolver</a>  <a href="classConicBundle_1_1UQPSumModelBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1UQPConeModelBlock.html">ConicBundle::UQPConeModelBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implements a <a class="el" href="classConicBundle_1_1UQPModelBlock.html" title="combines and provides basic functionalities of QPModelDataObject and UQPModelBlockObject, but is still abstract ">UQPModelBlock</a> for conic cutting models in <a class="el" href="classConicBundle_1_1UQPSolver.html" title="unconstrained QP solver combining the properties of a QPModelDataPointer and QPSolverObject ...">UQPSolver</a>  <a href="classConicBundle_1_1UQPConeModelBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>If the groundset (see e.g. <a class="el" href="classConicBundle_1_1UnconstrainedGroundset.html" title="implements an unconstrained groundset ">UnconstrainedGroundset</a>) of the convex optimization problem is unconstrained or if it only involves box constraints (as a special case of an <a class="el" href="classConicBundle_1_1LPGroundset.html" title="represents a polyhedral feasible ground set by affine constraints as in Linear Programming with speci...">LPGroundset</a>) towgether with a diagonal proximal term (eg <a class="el" href="classConicBundle_1_1BundleIdProx.html" title="implements the abstract interface ConicBundle::BundleProxObject for  with H=weight*I, giving rise to a pure augmented model without scaling ">BundleIdProx</a> or <a class="el" href="classConicBundle_1_1BundleDiagonalTrustRegionProx.html" title="implements the abstract interface ConicBundle::BundleProxObject for  with H=D+weight*I, where D is a diagonal matrix, giving rise to an augmented model with diagonal scaling ">BundleDiagonalTrustRegionProx</a>) an unconstrained QP solver suffices to determine the next candidate as the solution of the bundle subproblem. Because <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> is designed to handle also nonpolyhedral cutting models arising from support functions over the second order cone and positive semidefinite cone the general solver is an intererior point method. More precisely, it implements a primal dual predictor corrector method.</p>
<p>The main visible object and managing core of the solver is <a class="el" href="classConicBundle_1_1UQPSolver.html" title="unconstrained QP solver combining the properties of a QPModelDataPointer and QPSolverObject ...">UQPSolver</a>. It serves as an interface for <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> as it implements a <a class="el" href="classConicBundle_1_1QPSolverObject.html" title="abstract interface for a QPSolver ">QPSolverObject</a> (for finding the next candidate via solving the quadratic bundle subproblem) and a QPDataPointer (for collection the cutting model information).</p>
<p>The cutting models are realized by two implemtented classes derived from <a class="el" href="classConicBundle_1_1UQPModelBlock.html" title="combines and provides basic functionalities of QPModelDataObject and UQPModelBlockObject, but is still abstract ">UQPModelBlock</a> which brings together the abstract classes <a class="el" href="classConicBundle_1_1QPModelDataObject.html" title="abstract interface declaring the uniform outer appearance of general cutting models produced by the v...">QPModelDataObject</a> (interface for the cutting models of <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a>) and <a class="el" href="classConicBundle_1_1UQPModelBlockObject.html" title="abstract interface for model blocks in the unconstrained UQPSolver ">UQPModelBlockObject</a> (interface for the interior point solver):</p>
<ul>
<li><a class="el" href="classConicBundle_1_1UQPConeModelBlock.html" title="implements a UQPModelBlock for conic cutting models in UQPSolver ">UQPConeModelBlock</a> : it allows to describe any of the cutting models employed by the classes <a class="el" href="classConicBundle_1_1NNCModel.html" title="implements (as a derived class of SumBlockModel) a standard cutting plane model for a MatrixFunctionO...">NNCModel</a>, <a class="el" href="classConicBundle_1_1SOCModel.html" title="implements (as a derived class of ConeModel) a cutting model for a SOCOracle ">SOCModel</a>, <a class="el" href="classConicBundle_1_1PSCModel.html" title="implements (as a derived class of ConeModel) a cutting model for a PSCOracle ">PSCModel</a>, <a class="el" href="classConicBundle_1_1BoxModel.html" title="implements (as a derived class of ConeModel) a standard cutting plane model for a MatrixBoxOracle ...">BoxModel</a></li>
<li><a class="el" href="classConicBundle_1_1UQPSumModelBlock.html" title="implements a (virtual) cutting model being built of a (possibly recursive) sum of UQPModelBlock cutti...">UQPSumModelBlock</a> : it forms the sum of several <a class="el" href="classConicBundle_1_1UQPModelBlock.html" title="combines and provides basic functionalities of QPModelDataObject and UQPModelBlockObject, but is still abstract ">UQPModelBlock</a> instances as required in <a class="el" href="classConicBundle_1_1SumModel.html" title="gives a SumBlockModel interface to a sum of (possibly AffineFunctionTransformation transformed) SumBl...">SumModel</a></li>
</ul>
<p>The efficiency of the <a class="el" href="classConicBundle_1_1UQPSolver.html" title="unconstrained QP solver combining the properties of a QPModelDataPointer and QPSolverObject ...">UQPSolver</a> in comparison to the full <a class="el" href="classConicBundle_1_1QPSolver.html" title="QPSolver is the access point for ConicBundle to the internal constrained QP Solver, see Internal QP Solver for linearly constrained groundsets. ">QPSolver</a> relies on first eliminating the unconstrained design variables (a kind of Schur complement step in the full KKT system of the saddle point prpboem) and solving the bundle subproblem in terms of the model variables only. Quite often the computation of the QP cost terms for this reduced problem is the most costly operation. How to do this efficiently depends mostly on the proximal term used. Therefore the routines for computing the reduced QP cost terms for the <a class="el" href="classConicBundle_1_1UQPSolver.html" title="unconstrained QP solver combining the properties of a QPModelDataPointer and QPSolverObject ...">UQPSolver</a> are implemented directly within each ProxObject by the routine <a class="el" href="classConicBundle_1_1BundleProxObject.html#a2e3f0860d763b9f6d627ff0443954c2f" title="Compute the dual QP costs Q, d, and the constant offset to the bundle subproblem. ...">BundleProxObject::compute_QP_costs()</a>, which is called inside <a class="el" href="classConicBundle_1_1UQPSolver.html#a2121e93430bb58c1a045f4551e261945" title="see QPSolverObject::QPsolve() and Internal QP Solver for unconstrained groundsets ...">UQPSolver::QPsolve()</a> for getting the quadratic cost terms.</p>
<p>When some of the convex functions are used with a FunctionTask in AdaptivePenaltyFunction, a change in the penalty term only affects the right hand side of the trace constraint in the models. It does not affect the unconstrained QP cost terms and if the cutting model is not changed otherwise they need not be recomputed. Thus, resolving for adpated penalty terms is particularly efficient and the <a class="el" href="classConicBundle_1_1BundleSolver.html" title="This is the internal bundle solver managing descent/null steps with inner updates for approximating t...">BundleSolver</a> then calls <a class="el" href="classConicBundle_1_1UQPSolver.html#ad19f0472d222bc243b4225477211dde9" title="resolve the QP for the same cost function as last time with slightly modified feasible set ...">UQPSolver::resolve()</a> instead of <a class="el" href="classConicBundle_1_1UQPSolver.html#a2121e93430bb58c1a045f4551e261945" title="see QPSolverObject::QPsolve() and Internal QP Solver for unconstrained groundsets ...">UQPSolver::QPsolve()</a>.</p>
<p>A major challenge is handling box constraints with an unconstrained solver, because the candidate may have to be pushed back into the feasible set thereby losing optimality with respect to the model representation. How to resolve this via potentially several repeated unconstrained solves with updated groundset aggregates in a Gauss-Seidl fashion is described by Helmberg and Kiwiel. It works best, if the optimal groundset aggregate pushing the candidate into the feasible set can be determined by explicit computations as in the case of a diagonal prox term (it also works for more general groundsets but then requires solving a separate QP over the groundset). If the model quality of the current model aggregate is poor for this corrected candidate, the <a class="el" href="classConicBundle_1_1BundleSolver.html" title="This is the internal bundle solver managing descent/null steps with inner updates for approximating t...">BundleSolver</a> may decide to recompute the subproblem with the corrected groundset aggregate. The latter only enters the cost terms of the QP. Doing the update of these costs efficiently is again important. This happens in <a class="el" href="classConicBundle_1_1BundleProxObject.html#a1eb6da18e3c06e80b5d193b64c180c26" title="computes the update of the dual QP cost terms d and offset returned by compute_QP_costs() for changes...">BundleProxObject::update_QP_costs()</a>, which is called by <a class="el" href="classConicBundle_1_1UQPSolver.html#a647809c4177d89959b51c5b900685dfe" title="see QPSolverObject::QPupdate() and Internal QP Solver for unconstrained groundsets ...">UQPSolver::QPupdate()</a> which itself is called when the <a class="el" href="classConicBundle_1_1BundleSolver.html" title="This is the internal bundle solver managing descent/null steps with inner updates for approximating t...">BundleSolver</a> decides to recompute the bundel subproblem for the same cutting model with corrected groundset aggregate.</p>
<p>A feature that is particularly easy to handle in solving box constrained variants by the unconstrained approach is the fixing of some variables to the bounds. It simply means that in computing the unconstrained QP costs these variables may be considered to be constant values. So while the list of fixed values is passed through the interface of the <a class="el" href="classConicBundle_1_1UQPSolver.html" title="unconstrained QP solver combining the properties of a QPModelDataPointer and QPSolverObject ...">UQPSolver</a> it actually doesn't have to worry about it other than passing it on to the <a class="el" href="classConicBundle_1_1BundleProxObject.html" title="abstract interface that allows to use different -norms  with a positive definite matrix  in the proxi...">BundleProxObject</a> which then takes care of this infomation in computing the QP costs. </p>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
