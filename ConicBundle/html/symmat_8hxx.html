<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ConicBundle: symmat.hxx File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ConicBundle
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d60f6684020cb105011de41729268593.html">Matrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">symmat.hxx File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header declaring the class <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">CH_Matrix_Classes::Symmatrix</a> for symmetric matrices with Real elements.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="matrix_8hxx_source.html">matrix.hxx</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sparsmat_8hxx_source.html">sparsmat.hxx</a>&quot;</code><br />
</div>
<p><a href="symmat_8hxx_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">CH_Matrix_Classes::Symmatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix class of symmetric matrices with real values of type <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type ">Real</a>  <a href="classCH__Matrix__Classes_1_1Symmatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceCH__Matrix__Classes"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html">CH_Matrix_Classes</a></td></tr>
<tr class="memdesc:namespaceCH__Matrix__Classes"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> Classes and Linear Algebra. See <a class="el" href="matrixclasses.html">Matrix Classes (namespace CH_Matrix_Classes)</a> for a quick introduction. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aab3b493fa4a3efe6ff814d5fec936080"><td class="memItemLeft" align="right" valign="top"><a id="aab3b493fa4a3efe6ff814d5fec936080"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aab3b493fa4a3efe6ff814d5fec936080">CH_Matrix_Classes::diag</a> (const Symmatrix &amp;A)</td></tr>
<tr class="memdesc:aab3b493fa4a3efe6ff814d5fec936080"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector v consisting of the elements v(i)=(*this)(i,i), 0&lt;=i&lt;row dimension <br /></td></tr>
<tr class="separator:aab3b493fa4a3efe6ff814d5fec936080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66468aff7f5d83bf306396293b5a7ac0"><td class="memItemLeft" align="right" valign="top"><a id="a66468aff7f5d83bf306396293b5a7ac0"></a>
Symmatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a66468aff7f5d83bf306396293b5a7ac0">CH_Matrix_Classes::Diag</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:a66468aff7f5d83bf306396293b5a7ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a symmetric diagonal matrix S of order A.dim() with vec(A) on the diagonal, i.e., S(i,i)=A(i) for all i and S(i,j)=0 for i!=j <br /></td></tr>
<tr class="separator:a66468aff7f5d83bf306396293b5a7ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc379f9a6f5446df004d655c25671a2"><td class="memItemLeft" align="right" valign="top"><a id="addc379f9a6f5446df004d655c25671a2"></a>
Symmatrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#addc379f9a6f5446df004d655c25671a2">CH_Matrix_Classes::rankadd</a> (const Matrix &amp;A, Symmatrix &amp;C, Real alpha=1., Real beta=0., int trans=0)</td></tr>
<tr class="memdesc:addc379f9a6f5446df004d655c25671a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha* A*A^T, where A may be transposed. If beta==0. then C is initiliazed to the correct size. <br /></td></tr>
<tr class="separator:addc379f9a6f5446df004d655c25671a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a86adaed0bb3a0f00210ca14423888a"><td class="memItemLeft" align="right" valign="top"><a id="a7a86adaed0bb3a0f00210ca14423888a"></a>
Symmatrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a7a86adaed0bb3a0f00210ca14423888a">CH_Matrix_Classes::scaledrankadd</a> (const Matrix &amp;A, const Matrix &amp;D, Symmatrix &amp;C, Real alpha=1., Real beta=0., int trans=0)</td></tr>
<tr class="memdesc:a7a86adaed0bb3a0f00210ca14423888a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha* A*D*A^T, where D is a vector representing a diagonal matrix and A may be transposed; if beta==0. then C is initialized to the correct size <br /></td></tr>
<tr class="separator:a7a86adaed0bb3a0f00210ca14423888a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777a3bf467256cc36ecbe9e0c108326a"><td class="memItemLeft" align="right" valign="top"><a id="a777a3bf467256cc36ecbe9e0c108326a"></a>
Symmatrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a777a3bf467256cc36ecbe9e0c108326a">CH_Matrix_Classes::rank2add</a> (const Matrix &amp;A, const Matrix &amp;B, Symmatrix &amp;C, Real alpha=1., Real beta=0., int trans=0)</td></tr>
<tr class="memdesc:a777a3bf467256cc36ecbe9e0c108326a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*(A*B^T+B*A^T)/2 [or for transposed (A^T*B+B^T*A)/2]. If beta==0. then C is initiliazed to the correct size. <br /></td></tr>
<tr class="separator:a777a3bf467256cc36ecbe9e0c108326a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ab94ea579cabe95893801fea392d0a"><td class="memItemLeft" align="right" valign="top">Matrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a13ab94ea579cabe95893801fea392d0a">CH_Matrix_Classes::genmult</a> (const Symmatrix &amp;A, const Matrix &amp;B, Matrix &amp;C, Real alpha, Real beta, int btrans)</td></tr>
<tr class="memdesc:a13ab94ea579cabe95893801fea392d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size  <a href="namespaceCH__Matrix__Classes.html#a13ab94ea579cabe95893801fea392d0a">More...</a><br /></td></tr>
<tr class="separator:a13ab94ea579cabe95893801fea392d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6fda2aa4b4e5d7061129b05e5b3930"><td class="memItemLeft" align="right" valign="top">Matrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a0a6fda2aa4b4e5d7061129b05e5b3930">CH_Matrix_Classes::genmult</a> (const Matrix &amp;A, const Symmatrix &amp;B, Matrix &amp;C, Real alpha, Real beta, int atrans)</td></tr>
<tr class="memdesc:a0a6fda2aa4b4e5d7061129b05e5b3930"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size  <a href="namespaceCH__Matrix__Classes.html#a0a6fda2aa4b4e5d7061129b05e5b3930">More...</a><br /></td></tr>
<tr class="separator:a0a6fda2aa4b4e5d7061129b05e5b3930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb874bcdf2644fff97ca3bf35d234361"><td class="memItemLeft" align="right" valign="top"><a id="afb874bcdf2644fff97ca3bf35d234361"></a>
Matrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#afb874bcdf2644fff97ca3bf35d234361">CH_Matrix_Classes::genmult</a> (const Symmatrix &amp;A, const Sparsemat &amp;B, Matrix &amp;C, Real alpha=1., Real beta=0., int btrans=0)</td></tr>
<tr class="memdesc:afb874bcdf2644fff97ca3bf35d234361"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where B may be transposed; if beta==0. then C is initialized to the correct size <br /></td></tr>
<tr class="separator:afb874bcdf2644fff97ca3bf35d234361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3030c38169abace48e33c6b687bc883"><td class="memItemLeft" align="right" valign="top"><a id="af3030c38169abace48e33c6b687bc883"></a>
Matrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#af3030c38169abace48e33c6b687bc883">CH_Matrix_Classes::genmult</a> (const Sparsemat &amp;A, const Symmatrix &amp;B, Matrix &amp;C, Real alpha=1., Real beta=0., int atrans=0)</td></tr>
<tr class="memdesc:af3030c38169abace48e33c6b687bc883"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A may be transposed; if beta==0. then C is initialized to the correct size <br /></td></tr>
<tr class="separator:af3030c38169abace48e33c6b687bc883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836246d700cb0e6eed72e68a860cd124"><td class="memItemLeft" align="right" valign="top"><a id="a836246d700cb0e6eed72e68a860cd124"></a>
Symmatrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a836246d700cb0e6eed72e68a860cd124">CH_Matrix_Classes::rankadd</a> (const Sparsemat &amp;A, Symmatrix &amp;C, Real alpha=1., Real beta=0., int trans=0)</td></tr>
<tr class="memdesc:a836246d700cb0e6eed72e68a860cd124"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha* A*A^T, where A may be transposed; if beta==0. then C is initialized to the correct size <br /></td></tr>
<tr class="separator:a836246d700cb0e6eed72e68a860cd124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3c8aca933463eb973f279ee1667d9f"><td class="memItemLeft" align="right" valign="top"><a id="a8f3c8aca933463eb973f279ee1667d9f"></a>
Symmatrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a8f3c8aca933463eb973f279ee1667d9f">CH_Matrix_Classes::scaledrankadd</a> (const Sparsemat &amp;A, const Matrix &amp;D, Symmatrix &amp;C, Real alpha=1., Real beta=0., int trans=0)</td></tr>
<tr class="memdesc:a8f3c8aca933463eb973f279ee1667d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha* A*D*A^T, where D is a vector representing a diagonal matrix and A may be transposed; if beta==0. then C is initialized to the correct size <br /></td></tr>
<tr class="separator:a8f3c8aca933463eb973f279ee1667d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d41b3c1f3043c6a6a689d2cb38d031"><td class="memItemLeft" align="right" valign="top"><a id="a25d41b3c1f3043c6a6a689d2cb38d031"></a>
Symmatrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a25d41b3c1f3043c6a6a689d2cb38d031">CH_Matrix_Classes::rank2add</a> (const Sparsemat &amp;A, const Matrix &amp;B, Symmatrix &amp;C, Real alpha=1., Real beta=0., int trans=0)</td></tr>
<tr class="memdesc:a25d41b3c1f3043c6a6a689d2cb38d031"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*(A*B^T+B*A^T)/2 [or for transposed (A^T*B+B^T*A)/2]. If beta==0. then C is initiliazed to the correct size. <br /></td></tr>
<tr class="separator:a25d41b3c1f3043c6a6a689d2cb38d031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80d416505e193feebeee2985e98a25f"><td class="memItemLeft" align="right" valign="top"><a id="ac80d416505e193feebeee2985e98a25f"></a>
Symmatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ac80d416505e193feebeee2985e98a25f">CH_Matrix_Classes::abs</a> (const Symmatrix &amp;A)</td></tr>
<tr class="memdesc:ac80d416505e193feebeee2985e98a25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> with elements abs(A(i,j)) <br /></td></tr>
<tr class="separator:ac80d416505e193feebeee2985e98a25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdfbed23574a9387c3d5cd44cdbb59e"><td class="memItemLeft" align="right" valign="top"><a id="a0cdfbed23574a9387c3d5cd44cdbb59e"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a0cdfbed23574a9387c3d5cd44cdbb59e">CH_Matrix_Classes::trace</a> (const Symmatrix &amp;A)</td></tr>
<tr class="memdesc:a0cdfbed23574a9387c3d5cd44cdbb59e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the sum of the diagonal elements A(i,i) over all i <br /></td></tr>
<tr class="separator:a0cdfbed23574a9387c3d5cd44cdbb59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab858b0e9900bfb4c573c9d02ea124ffa"><td class="memItemLeft" align="right" valign="top"><a id="ab858b0e9900bfb4c573c9d02ea124ffa"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ab858b0e9900bfb4c573c9d02ea124ffa">CH_Matrix_Classes::ip</a> (const Symmatrix &amp;A, const Symmatrix &amp;B)</td></tr>
<tr class="memdesc:ab858b0e9900bfb4c573c9d02ea124ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j <br /></td></tr>
<tr class="separator:ab858b0e9900bfb4c573c9d02ea124ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9f9292af33925304a31812316c62c4"><td class="memItemLeft" align="right" valign="top"><a id="a0a9f9292af33925304a31812316c62c4"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a0a9f9292af33925304a31812316c62c4">CH_Matrix_Classes::ip</a> (const Matrix &amp;A, const Symmatrix &amp;B)</td></tr>
<tr class="memdesc:a0a9f9292af33925304a31812316c62c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j <br /></td></tr>
<tr class="separator:a0a9f9292af33925304a31812316c62c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b63bf8bd489e649b1c0916ede3a5424"><td class="memItemLeft" align="right" valign="top"><a id="a9b63bf8bd489e649b1c0916ede3a5424"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a9b63bf8bd489e649b1c0916ede3a5424">CH_Matrix_Classes::ip</a> (const Symmatrix &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:a9b63bf8bd489e649b1c0916ede3a5424"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j <br /></td></tr>
<tr class="separator:a9b63bf8bd489e649b1c0916ede3a5424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a480e2ba3a7d7a3c20a936e6ad9e25"><td class="memItemLeft" align="right" valign="top"><a id="a96a480e2ba3a7d7a3c20a936e6ad9e25"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a96a480e2ba3a7d7a3c20a936e6ad9e25">CH_Matrix_Classes::sumrows</a> (const Symmatrix &amp;A)</td></tr>
<tr class="memdesc:a96a480e2ba3a7d7a3c20a936e6ad9e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a row vector holding the sum over all rows, i.e., (1 1 ... 1)*A <br /></td></tr>
<tr class="separator:a96a480e2ba3a7d7a3c20a936e6ad9e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1c1584a5182ec612462c847d596ee3"><td class="memItemLeft" align="right" valign="top"><a id="abe1c1584a5182ec612462c847d596ee3"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#abe1c1584a5182ec612462c847d596ee3">CH_Matrix_Classes::sumcols</a> (const Symmatrix &amp;A)</td></tr>
<tr class="memdesc:abe1c1584a5182ec612462c847d596ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector holding the sum over all columns, i.e., A*(1 1 ... 1)^T <br /></td></tr>
<tr class="separator:abe1c1584a5182ec612462c847d596ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f1a51705d03e09b50921abf1c62194"><td class="memItemLeft" align="right" valign="top"><a id="a26f1a51705d03e09b50921abf1c62194"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a26f1a51705d03e09b50921abf1c62194">CH_Matrix_Classes::sum</a> (const Symmatrix &amp;A)</td></tr>
<tr class="memdesc:a26f1a51705d03e09b50921abf1c62194"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the sum over all elements of A, i.e., (1 1 ... 1)*A*(1 1 ... 1)^T <br /></td></tr>
<tr class="separator:a26f1a51705d03e09b50921abf1c62194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b18f8ae12e90afe1f4229a66ee205b"><td class="memItemLeft" align="right" valign="top"><a id="ab4b18f8ae12e90afe1f4229a66ee205b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ab4b18f8ae12e90afe1f4229a66ee205b">CH_Matrix_Classes::svec</a> (const Symmatrix &amp;A, Matrix &amp;sv, Real a=1., bool add=false, Integer startindex_vec=-1, Integer startindex_A=0, Integer blockdim=-1)</td></tr>
<tr class="memdesc:ab4b18f8ae12e90afe1f4229a66ee205b"><td class="mdescLeft">&#160;</td><td class="mdescRight">the symmetric vec operator stacks the lower triangle of A to a n*(n+1)/2 vector with the same norm2 as A; here it sets svec(A)=[a11,sqrt(2)a12,...,sqrt(2)a1n,a22,...,sqrt(2)a(n-1,n),ann]', multiplies it by a and sets or adds (if add==true) it to v starting from startindex_vec possibly restricted to the subblock of order blockdim (whenever &gt;=0, else blockdim is set to A.rowdim()-startindex_A) starting from startindex_A (must be &gt;=0); if add==false and startindex_vec&lt;0 then vec is also reinitialzed to the appropriate size <br /></td></tr>
<tr class="separator:ab4b18f8ae12e90afe1f4229a66ee205b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2fcd40e920d4010e116c573c57be9e"><td class="memItemLeft" align="right" valign="top"><a id="a1b2fcd40e920d4010e116c573c57be9e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a1b2fcd40e920d4010e116c573c57be9e">CH_Matrix_Classes::sveci</a> (const Matrix &amp;sv, Symmatrix &amp;A, Real a=1., bool add=false, Integer startindex_vec=0, Integer startindex_A=-1, Integer blockdim=-1)</td></tr>
<tr class="memdesc:a1b2fcd40e920d4010e116c573c57be9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">the inverse operator to svec, extracts from v at startindex_vec (&gt;=0) the symmetric matrix of blockdim adding its mutliple by a into A starting at startindex_A; if add==false and startindex_A&lt;0 A is initialized to the size of blockdim; if the latter is also negative then v.dim()-startindex_vec must match an exact order and matrix A is initialized to this size. In all other cases the size of the symmetric matrix determines the missing parameters and vec.dim-startindex_vec <br /></td></tr>
<tr class="separator:a1b2fcd40e920d4010e116c573c57be9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22fa549265303d13eea7f009acb26c8"><td class="memItemLeft" align="right" valign="top"><a id="ae22fa549265303d13eea7f009acb26c8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ae22fa549265303d13eea7f009acb26c8">CH_Matrix_Classes::skron</a> (const Symmatrix &amp;A, const Symmatrix &amp;B, Symmatrix &amp;S, Real alpha=1., bool add=false, Integer startindex_S=-1)</td></tr>
<tr class="memdesc:ae22fa549265303d13eea7f009acb26c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">def symmetric Kronecker product (A skron B)svec(C)=(BCA'+ACB')/2; sets S=alpha*(A skron B) or S*=... (if add==true) possibly shifted to the block starting at startindex_S; if add==false and startindex_S&lt;0, S is initialzed to the correct size <br /></td></tr>
<tr class="separator:ae22fa549265303d13eea7f009acb26c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b1f60db853604089780f641d79fb92"><td class="memItemLeft" align="right" valign="top"><a id="a22b1f60db853604089780f641d79fb92"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a22b1f60db853604089780f641d79fb92">CH_Matrix_Classes::symscale</a> (const Symmatrix &amp;A, const Matrix &amp;B, Symmatrix &amp;S, Real alpha=1., Real beta=0., int btrans=0)</td></tr>
<tr class="memdesc:a22b1f60db853604089780f641d79fb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets S=beta*S+alpha*B'*A*B for symmatrix A and matrix B <br /></td></tr>
<tr class="separator:a22b1f60db853604089780f641d79fb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e86f97935882ce2c85c8bea07db03b"><td class="memItemLeft" align="right" valign="top"><a id="ac2e86f97935882ce2c85c8bea07db03b"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ac2e86f97935882ce2c85c8bea07db03b">CH_Matrix_Classes::minrows</a> (const Symmatrix &amp;A)</td></tr>
<tr class="memdesc:ac2e86f97935882ce2c85c8bea07db03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a row vector holding in each column the minimum over all rows in this column <br /></td></tr>
<tr class="separator:ac2e86f97935882ce2c85c8bea07db03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d6936691bbcefc84e305c0d2506fae"><td class="memItemLeft" align="right" valign="top"><a id="ae8d6936691bbcefc84e305c0d2506fae"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ae8d6936691bbcefc84e305c0d2506fae">CH_Matrix_Classes::mincols</a> (const Symmatrix &amp;A)</td></tr>
<tr class="memdesc:ae8d6936691bbcefc84e305c0d2506fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector holding in each row the minimum over all columns in this row <br /></td></tr>
<tr class="separator:ae8d6936691bbcefc84e305c0d2506fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbed2690b967b1710ef1810c0391aee"><td class="memItemLeft" align="right" valign="top"><a id="a2bbed2690b967b1710ef1810c0391aee"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a2bbed2690b967b1710ef1810c0391aee">CH_Matrix_Classes::min</a> (const Symmatrix &amp;A)</td></tr>
<tr class="memdesc:a2bbed2690b967b1710ef1810c0391aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the minimum value over all elements of the matrix <br /></td></tr>
<tr class="separator:a2bbed2690b967b1710ef1810c0391aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3614266b0adfaed5e4ef25ab9251de3a"><td class="memItemLeft" align="right" valign="top"><a id="a3614266b0adfaed5e4ef25ab9251de3a"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a3614266b0adfaed5e4ef25ab9251de3a">CH_Matrix_Classes::maxrows</a> (const Symmatrix &amp;A)</td></tr>
<tr class="memdesc:a3614266b0adfaed5e4ef25ab9251de3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a row vector holding in each column the maximum over all rows in this column <br /></td></tr>
<tr class="separator:a3614266b0adfaed5e4ef25ab9251de3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc737dab700eef83f9d7d15f48b63ed"><td class="memItemLeft" align="right" valign="top"><a id="a6dc737dab700eef83f9d7d15f48b63ed"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a6dc737dab700eef83f9d7d15f48b63ed">CH_Matrix_Classes::maxcols</a> (const Symmatrix &amp;A)</td></tr>
<tr class="memdesc:a6dc737dab700eef83f9d7d15f48b63ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector holding in each row the maximum over all columns in this row <br /></td></tr>
<tr class="separator:a6dc737dab700eef83f9d7d15f48b63ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d3f543a9a8f98c53d473652e32d7a8"><td class="memItemLeft" align="right" valign="top"><a id="ab2d3f543a9a8f98c53d473652e32d7a8"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ab2d3f543a9a8f98c53d473652e32d7a8">CH_Matrix_Classes::max</a> (const Symmatrix &amp;A)</td></tr>
<tr class="memdesc:ab2d3f543a9a8f98c53d473652e32d7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the maximum value over all elements of the matrix <br /></td></tr>
<tr class="separator:ab2d3f543a9a8f98c53d473652e32d7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aed6b21f73325b4315ec15035b89676"><td class="memItemLeft" align="right" valign="top"><a id="a8aed6b21f73325b4315ec15035b89676"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a8aed6b21f73325b4315ec15035b89676">CH_Matrix_Classes::operator&lt;&lt;</a> (std::ostream &amp;o, const Symmatrix &amp;A)</td></tr>
<tr class="memdesc:a8aed6b21f73325b4315ec15035b89676"><td class="mdescLeft">&#160;</td><td class="mdescRight">output format (nr and nc are <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd" title="all integer numbers in calculations and indexing are of this type ">Integer</a> values, all others <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type ">Real</a> values): <br />
 nr nc \n A(1,1) A(1,2) ... A(1,nc) \n A(2,1) ... A(nr,nc) \n <br /></td></tr>
<tr class="separator:a8aed6b21f73325b4315ec15035b89676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fad02e37ef26186b11caf416b9a5fe"><td class="memItemLeft" align="right" valign="top"><a id="a61fad02e37ef26186b11caf416b9a5fe"></a>
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a61fad02e37ef26186b11caf416b9a5fe">CH_Matrix_Classes::operator&gt;&gt;</a> (std::istream &amp;i, Symmatrix &amp;A)</td></tr>
<tr class="memdesc:a61fad02e37ef26186b11caf416b9a5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">input format (nr and nc are <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd" title="all integer numbers in calculations and indexing are of this type ">Integer</a> values, all others <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type ">Real</a> values): <br />
 nr nc \n A(1,1) A(1,2) ... A(1,nc) \n A(2,1) ... A(nr,nc) \n <br /></td></tr>
<tr class="separator:a61fad02e37ef26186b11caf416b9a5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f496066644b9e2916bd0aa30b18b9ed"><td class="memItemLeft" align="right" valign="top"><a id="a7f496066644b9e2916bd0aa30b18b9ed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a7f496066644b9e2916bd0aa30b18b9ed">CH_Matrix_Classes::swap</a> (Symmatrix &amp;A, Symmatrix &amp;B)</td></tr>
<tr class="memdesc:a7f496066644b9e2916bd0aa30b18b9ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap the content of the two matrices A and B (involves no copying) <br /></td></tr>
<tr class="separator:a7f496066644b9e2916bd0aa30b18b9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5bd36e93862df08d94e617b3da117f"><td class="memItemLeft" align="right" valign="top"><a id="a5a5bd36e93862df08d94e617b3da117f"></a>
Symmatrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a5a5bd36e93862df08d94e617b3da117f">CH_Matrix_Classes::xbpeya</a> (Symmatrix &amp;x, const Symmatrix &amp;y, Real alpha=1., Real beta=0.)</td></tr>
<tr class="memdesc:a5a5bd36e93862df08d94e617b3da117f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns x= alpha*y+beta*x; if beta==0. then x is initialized to the correct size <br /></td></tr>
<tr class="separator:a5a5bd36e93862df08d94e617b3da117f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b9987ec91dc9c6cbc16bb3f27fda34"><td class="memItemLeft" align="right" valign="top"><a id="af7b9987ec91dc9c6cbc16bb3f27fda34"></a>
Symmatrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#af7b9987ec91dc9c6cbc16bb3f27fda34">CH_Matrix_Classes::xeyapzb</a> (Symmatrix &amp;x, const Symmatrix &amp;y, const Symmatrix &amp;z, Real alpha=1., Real beta=1.)</td></tr>
<tr class="memdesc:af7b9987ec91dc9c6cbc16bb3f27fda34"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns x= alpha*y+beta*z; x is initialized to the correct size <br /></td></tr>
<tr class="separator:af7b9987ec91dc9c6cbc16bb3f27fda34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecdc3e003bf111b5516a1488a41e7c2"><td class="memItemLeft" align="right" valign="top"><a id="a0ecdc3e003bf111b5516a1488a41e7c2"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a0ecdc3e003bf111b5516a1488a41e7c2">CH_Matrix_Classes::operator*</a> (const Symmatrix &amp;A, const Symmatrix &amp;B)</td></tr>
<tr class="memdesc:a0ecdc3e003bf111b5516a1488a41e7c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A*B <br /></td></tr>
<tr class="separator:a0ecdc3e003bf111b5516a1488a41e7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75384021f7932a11f3807669ed80f561"><td class="memItemLeft" align="right" valign="top">Symmatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a75384021f7932a11f3807669ed80f561">CH_Matrix_Classes::operator%</a> (const Symmatrix &amp;A, const Symmatrix &amp;B)</td></tr>
<tr class="memdesc:a75384021f7932a11f3807669ed80f561"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals AB (where % is overloaded as elementwise multiplication)  <a href="namespaceCH__Matrix__Classes.html#a75384021f7932a11f3807669ed80f561">More...</a><br /></td></tr>
<tr class="separator:a75384021f7932a11f3807669ed80f561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1474ccc2daa5b055adea4a771f80fb99"><td class="memItemLeft" align="right" valign="top"><a id="a1474ccc2daa5b055adea4a771f80fb99"></a>
Symmatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a1474ccc2daa5b055adea4a771f80fb99">CH_Matrix_Classes::operator+</a> (const Symmatrix &amp;A, const Symmatrix &amp;B)</td></tr>
<tr class="memdesc:a1474ccc2daa5b055adea4a771f80fb99"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A+B <br /></td></tr>
<tr class="separator:a1474ccc2daa5b055adea4a771f80fb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ecae51a5135a8ad6811f5b83c3100d"><td class="memItemLeft" align="right" valign="top"><a id="a04ecae51a5135a8ad6811f5b83c3100d"></a>
Symmatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a04ecae51a5135a8ad6811f5b83c3100d">CH_Matrix_Classes::operator-</a> (const Symmatrix &amp;A, const Symmatrix &amp;B)</td></tr>
<tr class="memdesc:a04ecae51a5135a8ad6811f5b83c3100d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A-B <br /></td></tr>
<tr class="separator:a04ecae51a5135a8ad6811f5b83c3100d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f562909af8af7270e3a9f71fcee608e"><td class="memItemLeft" align="right" valign="top"><a id="a7f562909af8af7270e3a9f71fcee608e"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a7f562909af8af7270e3a9f71fcee608e">CH_Matrix_Classes::operator*</a> (const Symmatrix &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:a7f562909af8af7270e3a9f71fcee608e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A*B <br /></td></tr>
<tr class="separator:a7f562909af8af7270e3a9f71fcee608e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa618c4840a835b48c7b6567b8b8b0443"><td class="memItemLeft" align="right" valign="top"><a id="aa618c4840a835b48c7b6567b8b8b0443"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aa618c4840a835b48c7b6567b8b8b0443">CH_Matrix_Classes::operator*</a> (const Matrix &amp;A, const Symmatrix &amp;B)</td></tr>
<tr class="memdesc:aa618c4840a835b48c7b6567b8b8b0443"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A*B <br /></td></tr>
<tr class="separator:aa618c4840a835b48c7b6567b8b8b0443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8105819501583f5e0f73715a7c8519"><td class="memItemLeft" align="right" valign="top"><a id="a2a8105819501583f5e0f73715a7c8519"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a2a8105819501583f5e0f73715a7c8519">CH_Matrix_Classes::operator+</a> (const Symmatrix &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:a2a8105819501583f5e0f73715a7c8519"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A+B <br /></td></tr>
<tr class="separator:a2a8105819501583f5e0f73715a7c8519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e8774a7dfde5295e813efe2f5a09af"><td class="memItemLeft" align="right" valign="top"><a id="ac2e8774a7dfde5295e813efe2f5a09af"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ac2e8774a7dfde5295e813efe2f5a09af">CH_Matrix_Classes::operator+</a> (const Matrix &amp;A, const Symmatrix &amp;B)</td></tr>
<tr class="memdesc:ac2e8774a7dfde5295e813efe2f5a09af"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A+B <br /></td></tr>
<tr class="separator:ac2e8774a7dfde5295e813efe2f5a09af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1488d490f99806467fdba6df61128497"><td class="memItemLeft" align="right" valign="top"><a id="a1488d490f99806467fdba6df61128497"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a1488d490f99806467fdba6df61128497">CH_Matrix_Classes::operator-</a> (const Symmatrix &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:a1488d490f99806467fdba6df61128497"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A-B <br /></td></tr>
<tr class="separator:a1488d490f99806467fdba6df61128497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34a2c2962fa829f2a5e8ecf8ab61daa"><td class="memItemLeft" align="right" valign="top"><a id="aa34a2c2962fa829f2a5e8ecf8ab61daa"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aa34a2c2962fa829f2a5e8ecf8ab61daa">CH_Matrix_Classes::operator-</a> (const Matrix &amp;A, const Symmatrix &amp;B)</td></tr>
<tr class="memdesc:aa34a2c2962fa829f2a5e8ecf8ab61daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A-B <br /></td></tr>
<tr class="separator:aa34a2c2962fa829f2a5e8ecf8ab61daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d632b48a0449de2968d74bea886bb5e"><td class="memItemLeft" align="right" valign="top"><a id="a5d632b48a0449de2968d74bea886bb5e"></a>
Symmatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a5d632b48a0449de2968d74bea886bb5e">CH_Matrix_Classes::operator*</a> (const Symmatrix &amp;A, Real d)</td></tr>
<tr class="memdesc:a5d632b48a0449de2968d74bea886bb5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> that equals A*d <br /></td></tr>
<tr class="separator:a5d632b48a0449de2968d74bea886bb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae275f5de7ad15d5d6507064ea4979f9a"><td class="memItemLeft" align="right" valign="top"><a id="ae275f5de7ad15d5d6507064ea4979f9a"></a>
Symmatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ae275f5de7ad15d5d6507064ea4979f9a">CH_Matrix_Classes::operator*</a> (Real d, const Symmatrix &amp;A)</td></tr>
<tr class="memdesc:ae275f5de7ad15d5d6507064ea4979f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> that equals A*d <br /></td></tr>
<tr class="separator:ae275f5de7ad15d5d6507064ea4979f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8dc947c5b20130d3c1815c18b9a17b"><td class="memItemLeft" align="right" valign="top"><a id="a4b8dc947c5b20130d3c1815c18b9a17b"></a>
Symmatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a4b8dc947c5b20130d3c1815c18b9a17b">CH_Matrix_Classes::operator/</a> (const Symmatrix &amp;A, Real d)</td></tr>
<tr class="memdesc:a4b8dc947c5b20130d3c1815c18b9a17b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> that equals A/d; ATTENTION: no check against division by zero <br /></td></tr>
<tr class="separator:a4b8dc947c5b20130d3c1815c18b9a17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d5af24a0341639f0e326951f50707e"><td class="memItemLeft" align="right" valign="top">Symmatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#af6d5af24a0341639f0e326951f50707e">CH_Matrix_Classes::operator+</a> (const Symmatrix &amp;A, Real d)</td></tr>
<tr class="memdesc:af6d5af24a0341639f0e326951f50707e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> that equals A+d (d is added to each element)  <a href="namespaceCH__Matrix__Classes.html#af6d5af24a0341639f0e326951f50707e">More...</a><br /></td></tr>
<tr class="separator:af6d5af24a0341639f0e326951f50707e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71861033ab9ab93a83fded17ae0ea669"><td class="memItemLeft" align="right" valign="top">Symmatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a71861033ab9ab93a83fded17ae0ea669">CH_Matrix_Classes::operator+</a> (Real d, const Symmatrix &amp;A)</td></tr>
<tr class="memdesc:a71861033ab9ab93a83fded17ae0ea669"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> that equals A+d (d is added to each element)  <a href="namespaceCH__Matrix__Classes.html#a71861033ab9ab93a83fded17ae0ea669">More...</a><br /></td></tr>
<tr class="separator:a71861033ab9ab93a83fded17ae0ea669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad23869576e96b9fad346cf2cc1b2c2"><td class="memItemLeft" align="right" valign="top">Symmatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a9ad23869576e96b9fad346cf2cc1b2c2">CH_Matrix_Classes::operator-</a> (const Symmatrix &amp;A, Real d)</td></tr>
<tr class="memdesc:a9ad23869576e96b9fad346cf2cc1b2c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> that equals A-d (d is subtracted from each element)  <a href="namespaceCH__Matrix__Classes.html#a9ad23869576e96b9fad346cf2cc1b2c2">More...</a><br /></td></tr>
<tr class="separator:a9ad23869576e96b9fad346cf2cc1b2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d2b3ac69a6abc0973b77b486d55572"><td class="memItemLeft" align="right" valign="top">Symmatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ab2d2b3ac69a6abc0973b77b486d55572">CH_Matrix_Classes::operator-</a> (Real d, const Symmatrix &amp;A)</td></tr>
<tr class="memdesc:ab2d2b3ac69a6abc0973b77b486d55572"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> that equals d-A (each element subtracted from d)  <a href="namespaceCH__Matrix__Classes.html#ab2d2b3ac69a6abc0973b77b486d55572">More...</a><br /></td></tr>
<tr class="separator:ab2d2b3ac69a6abc0973b77b486d55572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f4e35f5d1dffdc6b0c7a3272581e4a"><td class="memItemLeft" align="right" valign="top"><a id="ad8f4e35f5d1dffdc6b0c7a3272581e4a"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ad8f4e35f5d1dffdc6b0c7a3272581e4a">CH_Matrix_Classes::svec</a> (const Symmatrix &amp;A)</td></tr>
<tr class="memdesc:ad8f4e35f5d1dffdc6b0c7a3272581e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">the symmetric vec operator, stacks the lower triangle of A to a n*(n+1)/2 vector with the same norm2 as A; i.e., it returns svec(A)=[a11,sqrt(2)a12,...,sqrt(2)a1n,a22,...,sqrt(2)a(n-1,n),ann]' <br /></td></tr>
<tr class="separator:ad8f4e35f5d1dffdc6b0c7a3272581e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76617a0fc2dcbda0853de1bdab5eb441"><td class="memItemLeft" align="right" valign="top"><a id="a76617a0fc2dcbda0853de1bdab5eb441"></a>
Symmatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a76617a0fc2dcbda0853de1bdab5eb441">CH_Matrix_Classes::skron</a> (const Symmatrix &amp;A, const Symmatrix &amp;B, Real alpha=1., bool add=false, Integer startindex_S=-1)</td></tr>
<tr class="memdesc:a76617a0fc2dcbda0853de1bdab5eb441"><td class="mdescLeft">&#160;</td><td class="mdescRight">the symmetric Kronecker product, defined via (A skron B)svec(C)=(BCA'+ACB')/2; sets or adds (if add==true) the symmetric matrix a*(A skron B) into S starting at startindex_S; if add==false and startindex_S&lt;0, S is initialzed to the correct size <br /></td></tr>
<tr class="separator:a76617a0fc2dcbda0853de1bdab5eb441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0350e6d0ab16eae95e4a3c91194ec48a"><td class="memItemLeft" align="right" valign="top"><a id="a0350e6d0ab16eae95e4a3c91194ec48a"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a0350e6d0ab16eae95e4a3c91194ec48a">CH_Matrix_Classes::norm2</a> (const Symmatrix &amp;A)</td></tr>
<tr class="memdesc:a0350e6d0ab16eae95e4a3c91194ec48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the Frobenius norm of A, i.e., the square root of the sum of A(i,j)*A(i,j) over all i,j <br /></td></tr>
<tr class="separator:a0350e6d0ab16eae95e4a3c91194ec48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e2eba5715c21f2b26dd72ea87aceea"><td class="memItemLeft" align="right" valign="top">Symmatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ab7e2eba5715c21f2b26dd72ea87aceea">CH_Matrix_Classes::transpose</a> (const Symmatrix &amp;A)</td></tr>
<tr class="memdesc:ab7e2eba5715c21f2b26dd72ea87aceea"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a copy of A (drop it or use a constructor instead)  <a href="namespaceCH__Matrix__Classes.html#ab7e2eba5715c21f2b26dd72ea87aceea">More...</a><br /></td></tr>
<tr class="separator:ab7e2eba5715c21f2b26dd72ea87aceea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header declaring the class <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">CH_Matrix_Classes::Symmatrix</a> for symmetric matrices with Real elements. </p>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2005-03-01 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Christoph Helmberg </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
