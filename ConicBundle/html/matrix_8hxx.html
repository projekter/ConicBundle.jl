<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ConicBundle: matrix.hxx File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ConicBundle
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d60f6684020cb105011de41729268593.html">Matrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">matrix.hxx File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header declaring the classes <a class="el" href="classCH__Matrix__Classes_1_1Realrange.html" title="allows to specify a range of real values via (from, to, step,tol) meaning {x=from+i*step:x in(from-to...">CH_Matrix_Classes::Realrange</a> and <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">CH_Matrix_Classes::Matrix</a> having Real elements.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;math.h&gt;</code><br />
<code>#include &quot;<a class="el" href="indexmat_8hxx_source.html">indexmat.hxx</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="symmat_8hxx_source.html">symmat.hxx</a>&quot;</code><br />
</div>
<p><a href="matrix_8hxx_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Realrange.html">CH_Matrix_Classes::Realrange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">allows to specify a range of real values via (from, to, step,tol) meaning {x=from+i*step:x in(from-tol,to+tol),i in {0,1,2,...}}  <a href="classCH__Matrix__Classes_1_1Realrange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix class for real values of type <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type ">Real</a>  <a href="classCH__Matrix__Classes_1_1Matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceCH__Matrix__Classes"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html">CH_Matrix_Classes</a></td></tr>
<tr class="memdesc:namespaceCH__Matrix__Classes"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> Classes and Linear Algebra. See <a class="el" href="matrixclasses.html">Matrix Classes (namespace CH_Matrix_Classes)</a> for a quick introduction. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af3d9765b28c0376d11a5913aa75b1c55"><td class="memItemLeft" align="right" valign="top"><a id="af3d9765b28c0376d11a5913aa75b1c55"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#af3d9765b28c0376d11a5913aa75b1c55">CH_Matrix_Classes::diag</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:af3d9765b28c0376d11a5913aa75b1c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector v consisting of the elements v(i)=(*this)(i,i), 0&lt;=i&lt;min(row dimension,column dimension) <br /></td></tr>
<tr class="separator:af3d9765b28c0376d11a5913aa75b1c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0128b5a3bb05dde961b3eeac8f71e35"><td class="memItemLeft" align="right" valign="top"><a id="aa0128b5a3bb05dde961b3eeac8f71e35"></a>
Matrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aa0128b5a3bb05dde961b3eeac8f71e35">CH_Matrix_Classes::xbpeya</a> (Matrix &amp;x, const Matrix &amp;y, Real alpha=1., Real beta=0., int ytrans=0)</td></tr>
<tr class="memdesc:aa0128b5a3bb05dde961b3eeac8f71e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns x= alpha*y+beta*x, where y may be transposed (ytrans=1); if beta==0. then x is initialized to the correct size <br /></td></tr>
<tr class="separator:aa0128b5a3bb05dde961b3eeac8f71e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade57ef6c7b70fe997727aa99a51999a5"><td class="memItemLeft" align="right" valign="top"><a id="ade57ef6c7b70fe997727aa99a51999a5"></a>
Matrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ade57ef6c7b70fe997727aa99a51999a5">CH_Matrix_Classes::xeyapzb</a> (Matrix &amp;x, const Matrix &amp;y, const Matrix &amp;z, Real alpha=1., Real beta=1.)</td></tr>
<tr class="memdesc:ade57ef6c7b70fe997727aa99a51999a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns x= alpha*y+beta*z; x is initialized to the correct size <br /></td></tr>
<tr class="separator:ade57ef6c7b70fe997727aa99a51999a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7320c2695bc4c821b844ef62d71ad5dd"><td class="memItemLeft" align="right" valign="top"><a id="a7320c2695bc4c821b844ef62d71ad5dd"></a>
Matrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a7320c2695bc4c821b844ef62d71ad5dd">CH_Matrix_Classes::genmult</a> (const Matrix &amp;A, const Matrix &amp;B, Matrix &amp;C, Real alpha=1., Real beta=0., int atrans=0, int btrans=0)</td></tr>
<tr class="memdesc:a7320c2695bc4c821b844ef62d71ad5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size <br /></td></tr>
<tr class="separator:a7320c2695bc4c821b844ef62d71ad5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9728f3ce40773225ffab67a2bcf0a5e"><td class="memItemLeft" align="right" valign="top"><a id="ad9728f3ce40773225ffab67a2bcf0a5e"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ad9728f3ce40773225ffab67a2bcf0a5e">CH_Matrix_Classes::transpose</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:ad9728f3ce40773225ffab67a2bcf0a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a transposed matrix of A <br /></td></tr>
<tr class="separator:ad9728f3ce40773225ffab67a2bcf0a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0933965fd86b7a6a5d0674be919485"><td class="memItemLeft" align="right" valign="top"><a id="a9a0933965fd86b7a6a5d0674be919485"></a>
std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a9a0933965fd86b7a6a5d0674be919485">CH_Matrix_Classes::assign</a> (std::vector&lt; double &gt; &amp;vec, const Matrix &amp;A)</td></tr>
<tr class="memdesc:a9a0933965fd86b7a6a5d0674be919485"><td class="mdescLeft">&#160;</td><td class="mdescRight">interpret A as a vector and copy it to a std::vector&lt;double&gt; which is also returned <br /></td></tr>
<tr class="separator:a9a0933965fd86b7a6a5d0674be919485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ab94ea579cabe95893801fea392d0a"><td class="memItemLeft" align="right" valign="top">Matrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a13ab94ea579cabe95893801fea392d0a">CH_Matrix_Classes::genmult</a> (const Symmatrix &amp;A, const Matrix &amp;B, Matrix &amp;C, Real alpha, Real beta, int btrans)</td></tr>
<tr class="memdesc:a13ab94ea579cabe95893801fea392d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size  <a href="namespaceCH__Matrix__Classes.html#a13ab94ea579cabe95893801fea392d0a">More...</a><br /></td></tr>
<tr class="separator:a13ab94ea579cabe95893801fea392d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6fda2aa4b4e5d7061129b05e5b3930"><td class="memItemLeft" align="right" valign="top">Matrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a0a6fda2aa4b4e5d7061129b05e5b3930">CH_Matrix_Classes::genmult</a> (const Matrix &amp;A, const Symmatrix &amp;B, Matrix &amp;C, Real alpha, Real beta, int atrans)</td></tr>
<tr class="memdesc:a0a6fda2aa4b4e5d7061129b05e5b3930"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size  <a href="namespaceCH__Matrix__Classes.html#a0a6fda2aa4b4e5d7061129b05e5b3930">More...</a><br /></td></tr>
<tr class="separator:a0a6fda2aa4b4e5d7061129b05e5b3930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4407f0eefd61492afee5071dd36da2"><td class="memItemLeft" align="right" valign="top">Matrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a8d4407f0eefd61492afee5071dd36da2">CH_Matrix_Classes::genmult</a> (const Sparsesym &amp;A, const Matrix &amp;B, Matrix &amp;C, Real alpha, Real beta, int btrans)</td></tr>
<tr class="memdesc:a8d4407f0eefd61492afee5071dd36da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size  <a href="namespaceCH__Matrix__Classes.html#a8d4407f0eefd61492afee5071dd36da2">More...</a><br /></td></tr>
<tr class="separator:a8d4407f0eefd61492afee5071dd36da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8b19d132b924f83b0913ba420743f9"><td class="memItemLeft" align="right" valign="top">Matrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a6c8b19d132b924f83b0913ba420743f9">CH_Matrix_Classes::genmult</a> (const Matrix &amp;A, const Sparsesym &amp;B, Matrix &amp;C, Real alpha, Real beta, int atrans)</td></tr>
<tr class="memdesc:a6c8b19d132b924f83b0913ba420743f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size  <a href="namespaceCH__Matrix__Classes.html#a6c8b19d132b924f83b0913ba420743f9">More...</a><br /></td></tr>
<tr class="separator:a6c8b19d132b924f83b0913ba420743f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429a75bdaccb90fe8ff90d83c928bcff"><td class="memItemLeft" align="right" valign="top"><a id="a429a75bdaccb90fe8ff90d83c928bcff"></a>
Matrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a429a75bdaccb90fe8ff90d83c928bcff">CH_Matrix_Classes::genmult</a> (const Sparsemat &amp;A, const Matrix &amp;B, Matrix &amp;C, Real alpha, Real beta, int atrans, int btrans)</td></tr>
<tr class="memdesc:a429a75bdaccb90fe8ff90d83c928bcff"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size <br /></td></tr>
<tr class="separator:a429a75bdaccb90fe8ff90d83c928bcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492d5b7d1338acb6d15d83d6aee208c2"><td class="memItemLeft" align="right" valign="top"><a id="a492d5b7d1338acb6d15d83d6aee208c2"></a>
Matrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a492d5b7d1338acb6d15d83d6aee208c2">CH_Matrix_Classes::genmult</a> (const Matrix &amp;A, const Sparsemat &amp;B, Matrix &amp;C, Real alpha, Real beta, int atrans, int btrans)</td></tr>
<tr class="memdesc:a492d5b7d1338acb6d15d83d6aee208c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size <br /></td></tr>
<tr class="separator:a492d5b7d1338acb6d15d83d6aee208c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2fe7f986bf81b0bb7b16ebde2e130c"><td class="memItemLeft" align="right" valign="top"><a id="aef2fe7f986bf81b0bb7b16ebde2e130c"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aef2fe7f986bf81b0bb7b16ebde2e130c">CH_Matrix_Classes::abs</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:aef2fe7f986bf81b0bb7b16ebde2e130c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix with elements (i,j)=abs((*this)(i,j)) for all i,j <br /></td></tr>
<tr class="separator:aef2fe7f986bf81b0bb7b16ebde2e130c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1263fd8238d4851a57e0a3b24f69507e"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a1263fd8238d4851a57e0a3b24f69507e">CH_Matrix_Classes::trace</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:a1263fd8238d4851a57e0a3b24f69507e"><td class="mdescLeft">&#160;</td><td class="mdescRight">=sum(diag(A))  <a href="namespaceCH__Matrix__Classes.html#a1263fd8238d4851a57e0a3b24f69507e">More...</a><br /></td></tr>
<tr class="separator:a1263fd8238d4851a57e0a3b24f69507e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12c03eb581bf0337768dbfba77790d9"><td class="memItemLeft" align="right" valign="top"><a id="ab12c03eb581bf0337768dbfba77790d9"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ab12c03eb581bf0337768dbfba77790d9">CH_Matrix_Classes::normDsquared</a> (const Matrix &amp;A, const Matrix &amp;d, int atrans=0, int dinv=0)</td></tr>
<tr class="memdesc:ab12c03eb581bf0337768dbfba77790d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns trace(A^TDA)=|A|^2_D with D=Diag(d). A may be transposed, D may be inverted but there is no check for division by zero <br /></td></tr>
<tr class="separator:ab12c03eb581bf0337768dbfba77790d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff4a63fee40253f0a39365b5841d035"><td class="memItemLeft" align="right" valign="top"><a id="a7ff4a63fee40253f0a39365b5841d035"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a7ff4a63fee40253f0a39365b5841d035">CH_Matrix_Classes::sumrows</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:a7ff4a63fee40253f0a39365b5841d035"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a row vector holding the sum over all rows, i.e., (1 1 ... 1)*A <br /></td></tr>
<tr class="separator:a7ff4a63fee40253f0a39365b5841d035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39780a1c4e0fc5171214d1e03e83d7a"><td class="memItemLeft" align="right" valign="top"><a id="ad39780a1c4e0fc5171214d1e03e83d7a"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ad39780a1c4e0fc5171214d1e03e83d7a">CH_Matrix_Classes::sumcols</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:ad39780a1c4e0fc5171214d1e03e83d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector holding the sum over all columns, i.e., A*(1 1 ... 1)^T <br /></td></tr>
<tr class="separator:ad39780a1c4e0fc5171214d1e03e83d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98799872c9ecba180dfef64c9fed6c3d"><td class="memItemLeft" align="right" valign="top"><a id="a98799872c9ecba180dfef64c9fed6c3d"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a98799872c9ecba180dfef64c9fed6c3d">CH_Matrix_Classes::sum</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:a98799872c9ecba180dfef64c9fed6c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the sum over all elements of A, i.e., (1 1 ... 1)*A*(1 1 ... 1)^T <br /></td></tr>
<tr class="separator:a98799872c9ecba180dfef64c9fed6c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff1249ede11a65b43dd0b2d218e4657"><td class="memItemLeft" align="right" valign="top"><a id="a4ff1249ede11a65b43dd0b2d218e4657"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a4ff1249ede11a65b43dd0b2d218e4657">CH_Matrix_Classes::house</a> (const Matrix &amp;x, Integer i=0, Integer j=0, Real tol=1e-10)</td></tr>
<tr class="memdesc:a4ff1249ede11a65b43dd0b2d218e4657"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the Householder vector of size A.rowdim() for the subcolumn A(i:A.rowdim(),j) <br /></td></tr>
<tr class="separator:a4ff1249ede11a65b43dd0b2d218e4657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e58e04b7b203630b9f0437cc1a7c02"><td class="memItemLeft" align="right" valign="top"><a id="a80e58e04b7b203630b9f0437cc1a7c02"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a80e58e04b7b203630b9f0437cc1a7c02">CH_Matrix_Classes::rowhouse</a> (Matrix &amp;A, const Matrix &amp;v, Integer i=0, Integer j=0)</td></tr>
<tr class="memdesc:a80e58e04b7b203630b9f0437cc1a7c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Housholder pre-multiplication of A with Householder vector v; the first nonzero of v is index i, the multplication is applied to all columns of A with index &gt;=j; always returns 0. <br /></td></tr>
<tr class="separator:a80e58e04b7b203630b9f0437cc1a7c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67360ae946daa9c7b5a7454667ebfc30"><td class="memItemLeft" align="right" valign="top"><a id="a67360ae946daa9c7b5a7454667ebfc30"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a67360ae946daa9c7b5a7454667ebfc30">CH_Matrix_Classes::colhouse</a> (Matrix &amp;A, const Matrix &amp;v, Integer i=0, Integer j=0)</td></tr>
<tr class="memdesc:a67360ae946daa9c7b5a7454667ebfc30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Housholder post-multiplication of A with Householder vector v; the first nonzero of v is index i, the multplication is applied to all rows of A with index &gt;=j; always returns 0. <br /></td></tr>
<tr class="separator:a67360ae946daa9c7b5a7454667ebfc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3c215b9186077749da97b4dce3594c"><td class="memItemLeft" align="right" valign="top"><a id="a4e3c215b9186077749da97b4dce3594c"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a4e3c215b9186077749da97b4dce3594c">CH_Matrix_Classes::operator&lt;</a> (const Matrix &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:a4e3c215b9186077749da97b4dce3594c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(A(i,j)&lt;B(i,j)) for all i,j <br /></td></tr>
<tr class="separator:a4e3c215b9186077749da97b4dce3594c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254d2dc386c18c3c6b4e92722d8b836c"><td class="memItemLeft" align="right" valign="top"><a id="a254d2dc386c18c3c6b4e92722d8b836c"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a254d2dc386c18c3c6b4e92722d8b836c">CH_Matrix_Classes::operator&lt;=</a> (const Matrix &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:a254d2dc386c18c3c6b4e92722d8b836c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(A(i,j)&lt;=B(i,j)) for all i,j <br /></td></tr>
<tr class="separator:a254d2dc386c18c3c6b4e92722d8b836c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3853ab964a6873bf4065507bc67b59d"><td class="memItemLeft" align="right" valign="top"><a id="ae3853ab964a6873bf4065507bc67b59d"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ae3853ab964a6873bf4065507bc67b59d">CH_Matrix_Classes::operator==</a> (const Matrix &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:ae3853ab964a6873bf4065507bc67b59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(A(i,j)==B(i,j)) for all i,j <br /></td></tr>
<tr class="separator:ae3853ab964a6873bf4065507bc67b59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f13f424a27ad7ee64f567de4c109dde"><td class="memItemLeft" align="right" valign="top"><a id="a3f13f424a27ad7ee64f567de4c109dde"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a3f13f424a27ad7ee64f567de4c109dde">CH_Matrix_Classes::operator!=</a> (const Matrix &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:a3f13f424a27ad7ee64f567de4c109dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(A(i,j)!=B(i,j)) for all i,j <br /></td></tr>
<tr class="separator:a3f13f424a27ad7ee64f567de4c109dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec43fb1b5fac750a79c43ff19afed350"><td class="memItemLeft" align="right" valign="top"><a id="aec43fb1b5fac750a79c43ff19afed350"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aec43fb1b5fac750a79c43ff19afed350">CH_Matrix_Classes::operator&lt;</a> (const Matrix &amp;A, Real d)</td></tr>
<tr class="memdesc:aec43fb1b5fac750a79c43ff19afed350"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(A(i,j)&lt;d) for all i,j <br /></td></tr>
<tr class="separator:aec43fb1b5fac750a79c43ff19afed350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce6b57c4d432913746615237bd662a0"><td class="memItemLeft" align="right" valign="top"><a id="a4ce6b57c4d432913746615237bd662a0"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a4ce6b57c4d432913746615237bd662a0">CH_Matrix_Classes::operator&gt;</a> (const Matrix &amp;A, Real d)</td></tr>
<tr class="memdesc:a4ce6b57c4d432913746615237bd662a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(A(i,j)&gt;d) for all i,j <br /></td></tr>
<tr class="separator:a4ce6b57c4d432913746615237bd662a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c6cd2648ba62fc747586fbff31dd3c"><td class="memItemLeft" align="right" valign="top"><a id="a40c6cd2648ba62fc747586fbff31dd3c"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a40c6cd2648ba62fc747586fbff31dd3c">CH_Matrix_Classes::operator&lt;=</a> (const Matrix &amp;A, Real d)</td></tr>
<tr class="memdesc:a40c6cd2648ba62fc747586fbff31dd3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(A(i,j)&lt;=d) for all i,j <br /></td></tr>
<tr class="separator:a40c6cd2648ba62fc747586fbff31dd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae098c17b6d566cc9b1e050c073a848ea"><td class="memItemLeft" align="right" valign="top"><a id="ae098c17b6d566cc9b1e050c073a848ea"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ae098c17b6d566cc9b1e050c073a848ea">CH_Matrix_Classes::operator&gt;=</a> (const Matrix &amp;A, Real d)</td></tr>
<tr class="memdesc:ae098c17b6d566cc9b1e050c073a848ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(A(i,j)&gt;=d) for all i,j <br /></td></tr>
<tr class="separator:ae098c17b6d566cc9b1e050c073a848ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78e1073170d1f5ff17d45c9574c8a5f"><td class="memItemLeft" align="right" valign="top"><a id="af78e1073170d1f5ff17d45c9574c8a5f"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#af78e1073170d1f5ff17d45c9574c8a5f">CH_Matrix_Classes::operator==</a> (const Matrix &amp;A, Real d)</td></tr>
<tr class="memdesc:af78e1073170d1f5ff17d45c9574c8a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(A(i,j)==d) for all i,j <br /></td></tr>
<tr class="separator:af78e1073170d1f5ff17d45c9574c8a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf57a9b23afc6c622b036260e132876"><td class="memItemLeft" align="right" valign="top"><a id="a4bf57a9b23afc6c622b036260e132876"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a4bf57a9b23afc6c622b036260e132876">CH_Matrix_Classes::operator!=</a> (const Matrix &amp;A, Real d)</td></tr>
<tr class="memdesc:a4bf57a9b23afc6c622b036260e132876"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(A(i,j)!=d) for all i,j <br /></td></tr>
<tr class="separator:a4bf57a9b23afc6c622b036260e132876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac404adc58d3fd51a429fd46db7b7a685"><td class="memItemLeft" align="right" valign="top"><a id="ac404adc58d3fd51a429fd46db7b7a685"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ac404adc58d3fd51a429fd46db7b7a685">CH_Matrix_Classes::minrows</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:ac404adc58d3fd51a429fd46db7b7a685"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a row vector holding in each column the minimum over all rows in this column <br /></td></tr>
<tr class="separator:ac404adc58d3fd51a429fd46db7b7a685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4818150a81b0cfd2841892e8563eada8"><td class="memItemLeft" align="right" valign="top"><a id="a4818150a81b0cfd2841892e8563eada8"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a4818150a81b0cfd2841892e8563eada8">CH_Matrix_Classes::mincols</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:a4818150a81b0cfd2841892e8563eada8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector holding in each row the minimum over all columns in this row <br /></td></tr>
<tr class="separator:a4818150a81b0cfd2841892e8563eada8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8876ba181d8ab7f5c9f7eee1fb3ff05"><td class="memItemLeft" align="right" valign="top"><a id="ac8876ba181d8ab7f5c9f7eee1fb3ff05"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ac8876ba181d8ab7f5c9f7eee1fb3ff05">CH_Matrix_Classes::min</a> (const Matrix &amp;A, Integer *iindex=0, Integer *jindex=0)</td></tr>
<tr class="memdesc:ac8876ba181d8ab7f5c9f7eee1fb3ff05"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the minimum value over all elements of the matrix <br /></td></tr>
<tr class="separator:ac8876ba181d8ab7f5c9f7eee1fb3ff05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a8016c62f0caa1d695279d894057e9"><td class="memItemLeft" align="right" valign="top"><a id="a00a8016c62f0caa1d695279d894057e9"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a00a8016c62f0caa1d695279d894057e9">CH_Matrix_Classes::maxrows</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:a00a8016c62f0caa1d695279d894057e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a row vector holding in each column the maximum over all rows in this column <br /></td></tr>
<tr class="separator:a00a8016c62f0caa1d695279d894057e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9aca7c21d76ebbe834e4559d68c6c0"><td class="memItemLeft" align="right" valign="top"><a id="a1f9aca7c21d76ebbe834e4559d68c6c0"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a1f9aca7c21d76ebbe834e4559d68c6c0">CH_Matrix_Classes::maxcols</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:a1f9aca7c21d76ebbe834e4559d68c6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector holding in each row the maximum over all columns in this row <br /></td></tr>
<tr class="separator:a1f9aca7c21d76ebbe834e4559d68c6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68088532b5a594c459670de9cc6c7cd"><td class="memItemLeft" align="right" valign="top"><a id="ac68088532b5a594c459670de9cc6c7cd"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ac68088532b5a594c459670de9cc6c7cd">CH_Matrix_Classes::max</a> (const Matrix &amp;A, Integer *iindex=0, Integer *jindex=0)</td></tr>
<tr class="memdesc:ac68088532b5a594c459670de9cc6c7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the maximum value over all elements of the matrix <br /></td></tr>
<tr class="separator:ac68088532b5a594c459670de9cc6c7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761997c0961ea6d2873178c2ce6b5e9f"><td class="memItemLeft" align="right" valign="top"><a id="a761997c0961ea6d2873178c2ce6b5e9f"></a>
Indexmatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a761997c0961ea6d2873178c2ce6b5e9f">CH_Matrix_Classes::sortindex</a> (const Matrix &amp;vec, bool nondecreasing=true)</td></tr>
<tr class="memdesc:a761997c0961ea6d2873178c2ce6b5e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html" title="Matrix class for integral values of type Integer ">Indexmatrix</a> ind so that vec(ind(0))&lt;=vec(ind(1))&lt;=...&lt;=vec(ind(vec.dim()-1)) (vec may be rectangular, set nondecreasing=false for opposite order) <br /></td></tr>
<tr class="separator:a761997c0961ea6d2873178c2ce6b5e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa3b439a59998cfb4c7256396a0f8e2"><td class="memItemLeft" align="right" valign="top"><a id="aeaa3b439a59998cfb4c7256396a0f8e2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aeaa3b439a59998cfb4c7256396a0f8e2">CH_Matrix_Classes::sortindex</a> (const Matrix &amp;vec, Indexmatrix &amp;ind, bool nondecreasing=true)</td></tr>
<tr class="memdesc:aeaa3b439a59998cfb4c7256396a0f8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets ind so that vec(ind(0))&lt;=vec(ind(1))&lt;=...&lt;=vec(ind(vec.dim()-1)) (vec may be rectangular, set nondecreasing=false for opposite order) <br /></td></tr>
<tr class="separator:aeaa3b439a59998cfb4c7256396a0f8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910719fc8a489e075552a563ef536d61"><td class="memItemLeft" align="right" valign="top"><a id="a910719fc8a489e075552a563ef536d61"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a910719fc8a489e075552a563ef536d61">CH_Matrix_Classes::operator&lt;&lt;</a> (std::ostream &amp;o, const Matrix &amp;v)</td></tr>
<tr class="memdesc:a910719fc8a489e075552a563ef536d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">output format (nr and nc are <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd" title="all integer numbers in calculations and indexing are of this type ">Integer</a> values, all others <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type ">Real</a> values): <br />
 nr nc \n A(1,1) A(1,2) ... A(1,nc) \n A(2,1) ... A(nr,nc) \n <br /></td></tr>
<tr class="separator:a910719fc8a489e075552a563ef536d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebf3c4731f299c57eb910f4d82a988b"><td class="memItemLeft" align="right" valign="top"><a id="a3ebf3c4731f299c57eb910f4d82a988b"></a>
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a3ebf3c4731f299c57eb910f4d82a988b">CH_Matrix_Classes::operator&gt;&gt;</a> (std::istream &amp;i, Matrix &amp;v)</td></tr>
<tr class="memdesc:a3ebf3c4731f299c57eb910f4d82a988b"><td class="mdescLeft">&#160;</td><td class="mdescRight">input format (nr and nc are <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd" title="all integer numbers in calculations and indexing are of this type ">Integer</a> values, all others <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type ">Real</a> values): <br />
 nr nc \n A(1,1) A(1,2) ... A(1,nc) \n A(2,1) ... A(nr,nc) \n <br /></td></tr>
<tr class="separator:a3ebf3c4731f299c57eb910f4d82a988b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fa805785a8e3572f072ef87046e3a4"><td class="memItemLeft" align="right" valign="top"><a id="af4fa805785a8e3572f072ef87046e3a4"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#af4fa805785a8e3572f072ef87046e3a4">CH_Matrix_Classes::ip</a> (const Matrix &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:af4fa805785a8e3572f072ef87046e3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j <br /></td></tr>
<tr class="separator:af4fa805785a8e3572f072ef87046e3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d922d61a7c98f7325d4c9cc2edad85d"><td class="memItemLeft" align="right" valign="top"><a id="a2d922d61a7c98f7325d4c9cc2edad85d"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a2d922d61a7c98f7325d4c9cc2edad85d">CH_Matrix_Classes::colip</a> (const Matrix &amp;A, Integer j, const Matrix *scaling=0)</td></tr>
<tr class="memdesc:a2d922d61a7c98f7325d4c9cc2edad85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the squared Frobenius norm of column j of A, i.e., the sum of A(i,j)*A(i,j) over all i with possibly (if scaling!=0) each term i multiplied by (*scaling)(i) <br /></td></tr>
<tr class="separator:a2d922d61a7c98f7325d4c9cc2edad85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae914563dedfab8334960060d8279ee8e"><td class="memItemLeft" align="right" valign="top"><a id="ae914563dedfab8334960060d8279ee8e"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ae914563dedfab8334960060d8279ee8e">CH_Matrix_Classes::rowip</a> (const Matrix &amp;A, Integer i, const Matrix *scaling=0)</td></tr>
<tr class="memdesc:ae914563dedfab8334960060d8279ee8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the squared Frobenius norm of row i of A, i.e., the sum of A(i,j)*A(i,j) over all j with possibly (if scaling!=0) each term j multiplied by (*scaling)(j) <br /></td></tr>
<tr class="separator:ae914563dedfab8334960060d8279ee8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08089e8dd9b58c4c298ec9369ff0efd"><td class="memItemLeft" align="right" valign="top"><a id="ad08089e8dd9b58c4c298ec9369ff0efd"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ad08089e8dd9b58c4c298ec9369ff0efd">CH_Matrix_Classes::colsip</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:ad08089e8dd9b58c4c298ec9369ff0efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the column vector of the squared Frobenius norm of all columns j of A, i.e., the sum of A(i,j)*A(i,j) over all i for each j <br /></td></tr>
<tr class="separator:ad08089e8dd9b58c4c298ec9369ff0efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61fcebc3d037d7b65d34f5e42d3f358"><td class="memItemLeft" align="right" valign="top"><a id="af61fcebc3d037d7b65d34f5e42d3f358"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#af61fcebc3d037d7b65d34f5e42d3f358">CH_Matrix_Classes::rowsip</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:af61fcebc3d037d7b65d34f5e42d3f358"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the row vector of the squared Frobenius norm of all rowd i of A, i.e., the sum of A(i,j)*A(i,j) over all j for each i <br /></td></tr>
<tr class="separator:af61fcebc3d037d7b65d34f5e42d3f358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed7811322a356cde32a04ee672908a8"><td class="memItemLeft" align="right" valign="top"><a id="a3ed7811322a356cde32a04ee672908a8"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a3ed7811322a356cde32a04ee672908a8">CH_Matrix_Classes::norm2</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:a3ed7811322a356cde32a04ee672908a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the Frobenius norm of A, i.e., the square root of the sum of A(i,j)*A(i,j) over all i,j <br /></td></tr>
<tr class="separator:a3ed7811322a356cde32a04ee672908a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab6c8636a39ffacb9a1f60b5e8a05e9"><td class="memItemLeft" align="right" valign="top"><a id="a0ab6c8636a39ffacb9a1f60b5e8a05e9"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a0ab6c8636a39ffacb9a1f60b5e8a05e9">CH_Matrix_Classes::operator*</a> (const Matrix &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:a0ab6c8636a39ffacb9a1f60b5e8a05e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> equal to A*B <br /></td></tr>
<tr class="separator:a0ab6c8636a39ffacb9a1f60b5e8a05e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e2d5bb07635285685e5d675112ea07"><td class="memItemLeft" align="right" valign="top"><a id="a07e2d5bb07635285685e5d675112ea07"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a07e2d5bb07635285685e5d675112ea07">CH_Matrix_Classes::operator+</a> (const Matrix &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:a07e2d5bb07635285685e5d675112ea07"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> equal to A+B <br /></td></tr>
<tr class="separator:a07e2d5bb07635285685e5d675112ea07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7f5c8470cfe3d3b3ddd1ca94de295e"><td class="memItemLeft" align="right" valign="top"><a id="a1f7f5c8470cfe3d3b3ddd1ca94de295e"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a1f7f5c8470cfe3d3b3ddd1ca94de295e">CH_Matrix_Classes::operator-</a> (const Matrix &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:a1f7f5c8470cfe3d3b3ddd1ca94de295e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> equal to A-B <br /></td></tr>
<tr class="separator:a1f7f5c8470cfe3d3b3ddd1ca94de295e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e0a5c93e3b7a521f64a5829f88bd2e"><td class="memItemLeft" align="right" valign="top"><a id="aa7e0a5c93e3b7a521f64a5829f88bd2e"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aa7e0a5c93e3b7a521f64a5829f88bd2e">CH_Matrix_Classes::operator%</a> (const Matrix &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:aa7e0a5c93e3b7a521f64a5829f88bd2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">ATTENTION: this is redefined as the Hadamard product, C(i,j)=A(i,j)*B(i,j) for all i,j. <br /></td></tr>
<tr class="separator:aa7e0a5c93e3b7a521f64a5829f88bd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a59b8daa2548614553c7dfdfd67dd64"><td class="memItemLeft" align="right" valign="top"><a id="a8a59b8daa2548614553c7dfdfd67dd64"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a8a59b8daa2548614553c7dfdfd67dd64">CH_Matrix_Classes::operator/</a> (const Matrix &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:a8a59b8daa2548614553c7dfdfd67dd64"><td class="mdescLeft">&#160;</td><td class="mdescRight">ATTENTION: this is redefined to act componentwise without checking for zeros, C(i,j)=A(i,j)/B(i,j) for all i,j. <br /></td></tr>
<tr class="separator:a8a59b8daa2548614553c7dfdfd67dd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51cb732f9c2608c62bf77eee2f7ce8b3"><td class="memItemLeft" align="right" valign="top"><a id="a51cb732f9c2608c62bf77eee2f7ce8b3"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a51cb732f9c2608c62bf77eee2f7ce8b3">CH_Matrix_Classes::operator*</a> (const Matrix &amp;A, Real d)</td></tr>
<tr class="memdesc:a51cb732f9c2608c62bf77eee2f7ce8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> equal to A*d <br /></td></tr>
<tr class="separator:a51cb732f9c2608c62bf77eee2f7ce8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde7b3071dc700f1c35fe9042b2d40a4"><td class="memItemLeft" align="right" valign="top"><a id="adde7b3071dc700f1c35fe9042b2d40a4"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#adde7b3071dc700f1c35fe9042b2d40a4">CH_Matrix_Classes::operator*</a> (Real d, const Matrix &amp;A)</td></tr>
<tr class="memdesc:adde7b3071dc700f1c35fe9042b2d40a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> equal to d*A <br /></td></tr>
<tr class="separator:adde7b3071dc700f1c35fe9042b2d40a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b939cce2e7144bff22742fbcd96ab26"><td class="memItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a1b939cce2e7144bff22742fbcd96ab26">CH_Matrix_Classes::operator/</a> (const Matrix &amp;A, Real d)</td></tr>
<tr class="memdesc:a1b939cce2e7144bff22742fbcd96ab26"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> equal to A/d; ATTENTION: d is NOT checked for 0  <a href="namespaceCH__Matrix__Classes.html#a1b939cce2e7144bff22742fbcd96ab26">More...</a><br /></td></tr>
<tr class="separator:a1b939cce2e7144bff22742fbcd96ab26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd5488d328f1dea59ca987206c5f747"><td class="memItemLeft" align="right" valign="top"><a id="accd5488d328f1dea59ca987206c5f747"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#accd5488d328f1dea59ca987206c5f747">CH_Matrix_Classes::operator+</a> (const Matrix &amp;A, Real d)</td></tr>
<tr class="memdesc:accd5488d328f1dea59ca987206c5f747"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns (i,j)=A(i,j)+d for all i,j <br /></td></tr>
<tr class="separator:accd5488d328f1dea59ca987206c5f747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9361b0549535dd94e48d3b5352bbd4d9"><td class="memItemLeft" align="right" valign="top"><a id="a9361b0549535dd94e48d3b5352bbd4d9"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a9361b0549535dd94e48d3b5352bbd4d9">CH_Matrix_Classes::operator+</a> (Real d, const Matrix &amp;A)</td></tr>
<tr class="memdesc:a9361b0549535dd94e48d3b5352bbd4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns (i,j)=A(i,j)+d for all i,j <br /></td></tr>
<tr class="separator:a9361b0549535dd94e48d3b5352bbd4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb93fbfd511dfe7b0df58d8e2a8ec6db"><td class="memItemLeft" align="right" valign="top"><a id="aeb93fbfd511dfe7b0df58d8e2a8ec6db"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aeb93fbfd511dfe7b0df58d8e2a8ec6db">CH_Matrix_Classes::operator-</a> (const Matrix &amp;A, Real d)</td></tr>
<tr class="memdesc:aeb93fbfd511dfe7b0df58d8e2a8ec6db"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns (i,j)=A(i,j)-d for all i,j <br /></td></tr>
<tr class="separator:aeb93fbfd511dfe7b0df58d8e2a8ec6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f76951c39da0dcba768a26301335f4c"><td class="memItemLeft" align="right" valign="top"><a id="a5f76951c39da0dcba768a26301335f4c"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a5f76951c39da0dcba768a26301335f4c">CH_Matrix_Classes::operator-</a> (Real d, const Matrix &amp;A)</td></tr>
<tr class="memdesc:a5f76951c39da0dcba768a26301335f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns (i,j)=d-A(i,j) for all i,j <br /></td></tr>
<tr class="separator:a5f76951c39da0dcba768a26301335f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef8e887706cb7e70ecbe578de73bd51"><td class="memItemLeft" align="right" valign="top"><a id="a0ef8e887706cb7e70ecbe578de73bd51"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a0ef8e887706cb7e70ecbe578de73bd51">CH_Matrix_Classes::QR_factor</a> (const Matrix &amp;A, Matrix &amp;Q, Matrix &amp;R, Real tol)</td></tr>
<tr class="memdesc:a0ef8e887706cb7e70ecbe578de73bd51"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes a Householder QR factorization of A and outputs Q and R leaving A unchanged; always returns 0 <br /></td></tr>
<tr class="separator:a0ef8e887706cb7e70ecbe578de73bd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a5ff081efc33bfd7cba0c766ecc58d"><td class="memItemLeft" align="right" valign="top"><a id="a01a5ff081efc33bfd7cba0c766ecc58d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a01a5ff081efc33bfd7cba0c766ecc58d">CH_Matrix_Classes::QR_factor</a> (const Matrix &amp;A, Matrix &amp;Q, Matrix &amp;R, Indexmatrix &amp;piv, Real tol)</td></tr>
<tr class="memdesc:a01a5ff081efc33bfd7cba0c766ecc58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes a Householder QR factorization of A with pivating. It outputs Q, R, and the pivoting permuation in piv; returns the rank of A <br /></td></tr>
<tr class="separator:a01a5ff081efc33bfd7cba0c766ecc58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653e878070b51404c087e6c8d5bb58e9"><td class="memItemLeft" align="right" valign="top"><a id="a653e878070b51404c087e6c8d5bb58e9"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a653e878070b51404c087e6c8d5bb58e9">CH_Matrix_Classes::triu</a> (const Matrix &amp;A, Integer i=0)</td></tr>
<tr class="memdesc:a653e878070b51404c087e6c8d5bb58e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">retuns a matrix that keeps the upper triangle of A starting with diagonal d, i.e., (i,j)=A(i,j) for 0&lt;=i&lt;row dimension, max(0,i+d)&lt;=j&lt;column dimension, and sets (i,j)=0 otherwise <br /></td></tr>
<tr class="separator:a653e878070b51404c087e6c8d5bb58e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c1e9fe138fa0e122de1c84b158d108"><td class="memItemLeft" align="right" valign="top"><a id="a09c1e9fe138fa0e122de1c84b158d108"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a09c1e9fe138fa0e122de1c84b158d108">CH_Matrix_Classes::tril</a> (const Matrix &amp;A, Integer i=0)</td></tr>
<tr class="memdesc:a09c1e9fe138fa0e122de1c84b158d108"><td class="mdescLeft">&#160;</td><td class="mdescRight">retuns a matrix that keeps the lower triangle of A starting with diagonal d, i.e., (i,j)=A(i,j) for 0&lt;=i&lt;row dimension, 0&lt;=j&lt;min(i+d+1,column dimension), and sets (i,j)=0 otherwise <br /></td></tr>
<tr class="separator:a09c1e9fe138fa0e122de1c84b158d108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d4d2e6159ae8d646142ed44829a52b"><td class="memItemLeft" align="right" valign="top"><a id="ab6d4d2e6159ae8d646142ed44829a52b"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ab6d4d2e6159ae8d646142ed44829a52b">CH_Matrix_Classes::concat_right</a> (const Matrix &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:ab6d4d2e6159ae8d646142ed44829a52b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a new matrix [A, B], i.e., it concats matrices A and B rowwise; A or B may be a 0x0 matrix <br /></td></tr>
<tr class="separator:ab6d4d2e6159ae8d646142ed44829a52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77a7182d21dc8e34ae05bfdbe233048"><td class="memItemLeft" align="right" valign="top"><a id="aa77a7182d21dc8e34ae05bfdbe233048"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aa77a7182d21dc8e34ae05bfdbe233048">CH_Matrix_Classes::concat_below</a> (const Matrix &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:aa77a7182d21dc8e34ae05bfdbe233048"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a bew matrix [A; B], i.e., it concats matrices A and B columnwise; A or B may be a 0x0 matrix <br /></td></tr>
<tr class="separator:aa77a7182d21dc8e34ae05bfdbe233048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c675590f1624b466c71e5f09a110193"><td class="memItemLeft" align="right" valign="top"><a id="a3c675590f1624b466c71e5f09a110193"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a3c675590f1624b466c71e5f09a110193">CH_Matrix_Classes::swap</a> (Matrix &amp;A, Matrix &amp;B)</td></tr>
<tr class="memdesc:a3c675590f1624b466c71e5f09a110193"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap the content of the two matrices A and B (involves no copying) <br /></td></tr>
<tr class="separator:a3c675590f1624b466c71e5f09a110193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd23fc827db091ea01b6b531b8b573b"><td class="memItemLeft" align="right" valign="top"><a id="adbd23fc827db091ea01b6b531b8b573b"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#adbd23fc827db091ea01b6b531b8b573b">CH_Matrix_Classes::rand</a> (Integer rows, Integer cols, <a class="el" href="classCH__Tools_1_1GB__rand.html">CH_Tools::GB_rand</a> *random_generator=0)</td></tr>
<tr class="memdesc:adbd23fc827db091ea01b6b531b8b573b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a nr x nc matrix with (i,j) assigned a random number uniformly from [0,1] for all i,j <br /></td></tr>
<tr class="separator:adbd23fc827db091ea01b6b531b8b573b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683da07e407e22966282ad71a8f7795d"><td class="memItemLeft" align="right" valign="top"><a id="a683da07e407e22966282ad71a8f7795d"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a683da07e407e22966282ad71a8f7795d">CH_Matrix_Classes::inv</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:a683da07e407e22966282ad71a8f7795d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix with elements (i,j)=1./((*this)(i,j)) for all i,j; ATTENTION: no check for division by zero <br /></td></tr>
<tr class="separator:a683da07e407e22966282ad71a8f7795d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2eaef698f0c1146c9bd3354fd247e9"><td class="memItemLeft" align="right" valign="top"><a id="a6b2eaef698f0c1146c9bd3354fd247e9"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a6b2eaef698f0c1146c9bd3354fd247e9">CH_Matrix_Classes::sqrt</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:a6b2eaef698f0c1146c9bd3354fd247e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix with elements (i,j)=sqrt((*this)(i,j)) for all i,j <br /></td></tr>
<tr class="separator:a6b2eaef698f0c1146c9bd3354fd247e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e62842c5eb1808e7df7bb3b2100657"><td class="memItemLeft" align="right" valign="top"><a id="ac0e62842c5eb1808e7df7bb3b2100657"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ac0e62842c5eb1808e7df7bb3b2100657">CH_Matrix_Classes::sqr</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:ac0e62842c5eb1808e7df7bb3b2100657"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix with elements (i,j)=sqr((*this)(i,j)) for all i,j <br /></td></tr>
<tr class="separator:ac0e62842c5eb1808e7df7bb3b2100657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7180499e4c6aa221348e958835dae2b"><td class="memItemLeft" align="right" valign="top"><a id="ad7180499e4c6aa221348e958835dae2b"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ad7180499e4c6aa221348e958835dae2b">CH_Matrix_Classes::sign</a> (const Matrix &amp;A, Real tol=1e-12)</td></tr>
<tr class="memdesc:ad7180499e4c6aa221348e958835dae2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix with elements (i,j)=sign((*this)(i,j)) for all i,j using <a class="el" href="group__mymath.html#ga517be5dca03231ad5111eeaf7bdf5070" title="return the signum of a double a with tolerance (1. for a&gt;tol,-1. for a&lt;-tol,0. otherwise) ...">sign(double,double)</a> <br /></td></tr>
<tr class="separator:ad7180499e4c6aa221348e958835dae2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24dd53c8a2f3816b972f8abbdd32655c"><td class="memItemLeft" align="right" valign="top"><a id="a24dd53c8a2f3816b972f8abbdd32655c"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a24dd53c8a2f3816b972f8abbdd32655c">CH_Matrix_Classes::floor</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:a24dd53c8a2f3816b972f8abbdd32655c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix with elements (i,j)=floor((*this)(i,j)) for all i,j <br /></td></tr>
<tr class="separator:a24dd53c8a2f3816b972f8abbdd32655c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f06d3ad675d578e9a929ff96a3d1a61"><td class="memItemLeft" align="right" valign="top"><a id="a3f06d3ad675d578e9a929ff96a3d1a61"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a3f06d3ad675d578e9a929ff96a3d1a61">CH_Matrix_Classes::ceil</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:a3f06d3ad675d578e9a929ff96a3d1a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix with elements (i,j)=ceil((*this)(i,j)) for all i,j <br /></td></tr>
<tr class="separator:a3f06d3ad675d578e9a929ff96a3d1a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9963541cf8629f070f95549aefbb7aaf"><td class="memItemLeft" align="right" valign="top"><a id="a9963541cf8629f070f95549aefbb7aaf"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a9963541cf8629f070f95549aefbb7aaf">CH_Matrix_Classes::rint</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:a9963541cf8629f070f95549aefbb7aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix with elements (i,j)=rint((*this)(i,j)) for all i,j <br /></td></tr>
<tr class="separator:a9963541cf8629f070f95549aefbb7aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab57f8e4e21114a3e07095873509f263"><td class="memItemLeft" align="right" valign="top"><a id="aab57f8e4e21114a3e07095873509f263"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aab57f8e4e21114a3e07095873509f263">CH_Matrix_Classes::round</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:aab57f8e4e21114a3e07095873509f263"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix with elements (i,j)=round((*this)(i,j)) for all i,j <br /></td></tr>
<tr class="separator:aab57f8e4e21114a3e07095873509f263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880e83eb4bcfb178499ab1dce5350b50"><td class="memItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a880e83eb4bcfb178499ab1dce5350b50">CH_Matrix_Classes::operator&gt;</a> (const Matrix &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:a880e83eb4bcfb178499ab1dce5350b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(A(i,j)&gt;d) for all i,j  <a href="namespaceCH__Matrix__Classes.html#a880e83eb4bcfb178499ab1dce5350b50">More...</a><br /></td></tr>
<tr class="separator:a880e83eb4bcfb178499ab1dce5350b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab296276d96d420c797f8ad827f7c88ba"><td class="memItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ab296276d96d420c797f8ad827f7c88ba">CH_Matrix_Classes::operator&gt;=</a> (const Matrix &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:ab296276d96d420c797f8ad827f7c88ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(A(i,j)&gt;=d) for all i,j  <a href="namespaceCH__Matrix__Classes.html#ab296276d96d420c797f8ad827f7c88ba">More...</a><br /></td></tr>
<tr class="separator:ab296276d96d420c797f8ad827f7c88ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d10d965acc3350b325a2d102ee077a"><td class="memItemLeft" align="right" valign="top"><a id="aa8d10d965acc3350b325a2d102ee077a"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aa8d10d965acc3350b325a2d102ee077a">CH_Matrix_Classes::operator&lt;</a> (Real d, const Matrix &amp;A)</td></tr>
<tr class="memdesc:aa8d10d965acc3350b325a2d102ee077a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(d&lt;A(i,j)) for all i,j <br /></td></tr>
<tr class="separator:aa8d10d965acc3350b325a2d102ee077a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90745439e8f1baead5681b1581d614b9"><td class="memItemLeft" align="right" valign="top"><a id="a90745439e8f1baead5681b1581d614b9"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a90745439e8f1baead5681b1581d614b9">CH_Matrix_Classes::operator&gt;</a> (Real d, const Matrix &amp;A)</td></tr>
<tr class="memdesc:a90745439e8f1baead5681b1581d614b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(d&gt;A(i,j)) for all i,j <br /></td></tr>
<tr class="separator:a90745439e8f1baead5681b1581d614b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80c9d78354b72afc9070ec516e56db3"><td class="memItemLeft" align="right" valign="top"><a id="ac80c9d78354b72afc9070ec516e56db3"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ac80c9d78354b72afc9070ec516e56db3">CH_Matrix_Classes::operator&lt;=</a> (Real d, const Matrix &amp;A)</td></tr>
<tr class="memdesc:ac80c9d78354b72afc9070ec516e56db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(d&lt;=A(i,j)) for all i,j <br /></td></tr>
<tr class="separator:ac80c9d78354b72afc9070ec516e56db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02fce7916d444e6dd384f576fd86e64"><td class="memItemLeft" align="right" valign="top"><a id="ae02fce7916d444e6dd384f576fd86e64"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ae02fce7916d444e6dd384f576fd86e64">CH_Matrix_Classes::operator&gt;=</a> (Real d, const Matrix &amp;A)</td></tr>
<tr class="memdesc:ae02fce7916d444e6dd384f576fd86e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(d&gt;=A(i,j)) for all i,j <br /></td></tr>
<tr class="separator:ae02fce7916d444e6dd384f576fd86e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699deeca0f401b8fa7c3019b7baf9033"><td class="memItemLeft" align="right" valign="top"><a id="a699deeca0f401b8fa7c3019b7baf9033"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a699deeca0f401b8fa7c3019b7baf9033">CH_Matrix_Classes::operator==</a> (Real d, const Matrix &amp;A)</td></tr>
<tr class="memdesc:a699deeca0f401b8fa7c3019b7baf9033"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(d==A(i,j)) for all i,j <br /></td></tr>
<tr class="separator:a699deeca0f401b8fa7c3019b7baf9033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c89f6f77515bcfaf7c33f8967c9c4c4"><td class="memItemLeft" align="right" valign="top"><a id="a1c89f6f77515bcfaf7c33f8967c9c4c4"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a1c89f6f77515bcfaf7c33f8967c9c4c4">CH_Matrix_Classes::operator!=</a> (Real d, const Matrix &amp;A)</td></tr>
<tr class="memdesc:a1c89f6f77515bcfaf7c33f8967c9c4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(d!=A(i,j)) for all i,j <br /></td></tr>
<tr class="separator:a1c89f6f77515bcfaf7c33f8967c9c4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e663420a97baca6422221a23be9a2a"><td class="memItemLeft" align="right" valign="top"><a id="aa8e663420a97baca6422221a23be9a2a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aa8e663420a97baca6422221a23be9a2a">CH_Matrix_Classes::equal</a> (const Matrix &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:aa8e663420a97baca6422221a23be9a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if both matrices have the same size and the same elements <br /></td></tr>
<tr class="separator:aa8e663420a97baca6422221a23be9a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18be44877952230406e1856624383256"><td class="memItemLeft" align="right" valign="top"><a id="a18be44877952230406e1856624383256"></a>
Indexmatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a18be44877952230406e1856624383256">CH_Matrix_Classes::find</a> (const Matrix &amp;A, Real tol=1e-10)</td></tr>
<tr class="memdesc:a18be44877952230406e1856624383256"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html" title="Matrix class for integral values of type Integer ">Indexmatrix</a> ind so that A(ind(i)) 0&lt;=i&lt;ind.dim() runs through all nonzero elements with abs(A(j))&gt;tol <br /></td></tr>
<tr class="separator:a18be44877952230406e1856624383256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31efb2bffc8a51f197512ddca00e641d"><td class="memItemLeft" align="right" valign="top"><a id="a31efb2bffc8a51f197512ddca00e641d"></a>
Indexmatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a31efb2bffc8a51f197512ddca00e641d">CH_Matrix_Classes::find_number</a> (const Matrix &amp;A, Real num=0., Real tol=1e-10)</td></tr>
<tr class="memdesc:a31efb2bffc8a51f197512ddca00e641d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html" title="Matrix class for integral values of type Integer ">Indexmatrix</a> ind so that A(ind(i)) 0&lt;=i&lt;ind.dim() runs through all elements of A having value num, i.e., abs(A(j)-num)&lt;tol <br /></td></tr>
<tr class="separator:a31efb2bffc8a51f197512ddca00e641d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header declaring the classes <a class="el" href="classCH__Matrix__Classes_1_1Realrange.html" title="allows to specify a range of real values via (from, to, step,tol) meaning {x=from+i*step:x in(from-to...">CH_Matrix_Classes::Realrange</a> and <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">CH_Matrix_Classes::Matrix</a> having Real elements. </p>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2005-03-01 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Christoph Helmberg </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
