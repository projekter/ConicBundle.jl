<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ConicBundle: ConicBundle::MatrixCBSolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ConicBundle
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceConicBundle.html">ConicBundle</a></li><li class="navelem"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html">MatrixCBSolver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classConicBundle_1_1MatrixCBSolver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ConicBundle::MatrixCBSolver Class Reference<div class="ingroups"><a class="el" href="group__cxxmatrixinterface.html">Interface to ConicBundle for the Language C++ using Matrix Classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The Full Conic Bundle method solver invoked by <a class="el" href="classConicBundle_1_1MatrixCBSolver.html" title="The Full Conic Bundle method solver invoked by ConicBundle::MatrixCBSolver(), it uses a separate cutt...">ConicBundle::MatrixCBSolver()</a>, it uses a separate cutting model for each function.  
 <a href="classConicBundle_1_1MatrixCBSolver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="MatrixCBSolver_8hxx_source.html">MatrixCBSolver.hxx</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ConicBundle::MatrixCBSolver:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classConicBundle_1_1MatrixCBSolver.png" usemap="#ConicBundle::MatrixCBSolver_map" alt=""/>
  <map id="ConicBundle::MatrixCBSolver_map" name="ConicBundle::MatrixCBSolver_map">
<area href="classConicBundle_1_1CBout.html" title="base class for uniform use of WARNINGS and ERRORS (at some point in time) " alt="ConicBundle::CBout" shape="rect" coords="0,0,179,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa2b364da07edb313e376637982f7c0b9"><td class="memItemLeft" align="right" valign="top"><a id="aa2b364da07edb313e376637982f7c0b9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#aa2b364da07edb313e376637982f7c0b9">MatrixCBSolver</a> (std::ostream *<a class="el" href="classConicBundle_1_1CBout.html#a1125693307dcbd83770e4569bf99ba19">out</a>=0, int <a class="el" href="classConicBundle_1_1CBout.html#a5ce873e4d4d6b00096d822fa65fd4d7a">print_level</a>=0)</td></tr>
<tr class="memdesc:aa2b364da07edb313e376637982f7c0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor allows to set output level options from start (see also <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a370c6ee0dd593962cbb39927a56d6bce" title="Specifies the output level (out==NULL: no output at all, out!=NULL and level=0: errors and warnings...">set_out()</a>) <br /></td></tr>
<tr class="separator:aa2b364da07edb313e376637982f7c0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f951adb6fda8aad962725638dd5206"><td class="memItemLeft" align="right" valign="top"><a id="ad5f951adb6fda8aad962725638dd5206"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#ad5f951adb6fda8aad962725638dd5206">MatrixCBSolver</a> (const <a class="el" href="classConicBundle_1_1CBout.html">CBout</a> *cb, int incr=0)</td></tr>
<tr class="memdesc:ad5f951adb6fda8aad962725638dd5206"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for setting output options depending on existing <a class="el" href="classConicBundle_1_1CBout.html" title="base class for uniform use of WARNINGS and ERRORS (at some point in time) ">CBout</a> objects <br /></td></tr>
<tr class="separator:ad5f951adb6fda8aad962725638dd5206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Initialization</div></td></tr>
<tr class="memitem:a072fcd8a7e415926d1ce6b0e54114dca"><td class="memItemLeft" align="right" valign="top"><a id="a072fcd8a7e415926d1ce6b0e54114dca"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a072fcd8a7e415926d1ce6b0e54114dca">clear</a> ()</td></tr>
<tr class="memdesc:a072fcd8a7e415926d1ce6b0e54114dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all data structures and problem information but keeps ouptut settings and algorithmic parameter settings. <br /></td></tr>
<tr class="separator:a072fcd8a7e415926d1ce6b0e54114dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06984f1f190dd1f0db07d17bf5a89d54"><td class="memItemLeft" align="right" valign="top"><a id="a06984f1f190dd1f0db07d17bf5a89d54"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a06984f1f190dd1f0db07d17bf5a89d54">set_defaults</a> ()</td></tr>
<tr class="memdesc:a06984f1f190dd1f0db07d17bf5a89d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets default values for algorithmic parameters that are not function specific (e.g., relative precision, weight and weight bounds for the augmentedproblem, etc.) <br /></td></tr>
<tr class="separator:a06984f1f190dd1f0db07d17bf5a89d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5129b50d68be01aaa8cb6825058a8f13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a5129b50d68be01aaa8cb6825058a8f13">init_problem</a> (int dim, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *lbounds=0, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *ubounds=0, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *startval=0, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *costs=0, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> offset=0.)</td></tr>
<tr class="memdesc:a5129b50d68be01aaa8cb6825058a8f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the problem by setting up the design space (the dimension and possibly box constraints on the variables)  <a href="#a5129b50d68be01aaa8cb6825058a8f13">More...</a><br /></td></tr>
<tr class="separator:a5129b50d68be01aaa8cb6825058a8f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c503663b689ede0f1d004690d622e2f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a3c503663b689ede0f1d004690d622e2f">add_function</a> (<a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> fun_factor=1., <a class="el" href="group__cxxinterface.html#gad70e60e1e38a03d09f1e9b10b68bb0f2">FunctionTask</a> fun_task=ObjectiveFunction, <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html">AffineFunctionTransformation</a> *aft=0, bool argument_list_may_change_dynamically=false)</td></tr>
<tr class="memdesc:a3c503663b689ede0f1d004690d622e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a function, typically derived from <a class="el" href="classConicBundle_1_1FunctionOracle.html" title="oracle interface (abstract class). For each of your functions, provide a derived class. ">ConicBundle::FunctionOracle</a>. If the dimension does not match the current one, specify an affine function transformation to map the current ground set to the argument of the function.  <a href="#a3c503663b689ede0f1d004690d622e2f">More...</a><br /></td></tr>
<tr class="separator:a3c503663b689ede0f1d004690d622e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c58b9c760b4efab9a59e9cca03f0a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a19c58b9c760b4efab9a59e9cca03f0a7">set_lower_bound</a> (int i, double lb)</td></tr>
<tr class="memdesc:a19c58b9c760b4efab9a59e9cca03f0a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets lower bound for variable i, use <a class="el" href="group__cxxinterface.html#gae58492af3631a196b0edb8a8ebcda567" title="serves as the value &quot;plus infinity&quot;, i.e., all bounds &gt;= this value are set to this value and are reg...">ConicBundle::CB_minus_infinity</a> for unbounded from below.  <a href="#a19c58b9c760b4efab9a59e9cca03f0a7">More...</a><br /></td></tr>
<tr class="separator:a19c58b9c760b4efab9a59e9cca03f0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10bd1df5d2d7114c96f7cae063385109"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a10bd1df5d2d7114c96f7cae063385109">set_upper_bound</a> (int i, double ub)</td></tr>
<tr class="memdesc:a10bd1df5d2d7114c96f7cae063385109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets upper bound for variable i, use <a class="el" href="group__cxxinterface.html#ga15948e7611155f822fc0331bcbb4a111" title="serves as the value &quot;minus infinity&quot;, i.e., all bounds &lt;= this value are set to this value and are re...">ConicBundle::CB_plus_infinity</a> for unbounded from below.  <a href="#a10bd1df5d2d7114c96f7cae063385109">More...</a><br /></td></tr>
<tr class="separator:a10bd1df5d2d7114c96f7cae063385109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94677e63dc7736099a77acaad553a3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#ae94677e63dc7736099a77acaad553a3f">append_variables</a> (int n_append, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *lbounds=0, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *ubounds=0, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">CH_Matrix_Classes::Sparsemat</a> *constraint_columns=0, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *startval=0, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *costs=0, const <a class="el" href="namespaceConicBundle.html#ad078c3e597a104edaccd983cddf6a134">FunObjModMap</a> *affected_functions_with_modifications=0)</td></tr>
<tr class="memdesc:ae94677e63dc7736099a77acaad553a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append new variables (always in last postions in this order).  <a href="#ae94677e63dc7736099a77acaad553a3f">More...</a><br /></td></tr>
<tr class="separator:ae94677e63dc7736099a77acaad553a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6396522aada2447cf05b5e699adbd0f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a6396522aada2447cf05b5e699adbd0f7">delete_variables</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> &amp;delete_indices, <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> &amp;map_to_old, const <a class="el" href="namespaceConicBundle.html#ad078c3e597a104edaccd983cddf6a134">FunObjModMap</a> *affected_functions_with_modifications=0)</td></tr>
<tr class="memdesc:a6396522aada2447cf05b5e699adbd0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes variables corresponding to the specified indices.  <a href="#a6396522aada2447cf05b5e699adbd0f7">More...</a><br /></td></tr>
<tr class="separator:a6396522aada2447cf05b5e699adbd0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70afdaf44c7f80f69beafb1e1335ab8c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a70afdaf44c7f80f69beafb1e1335ab8c">reassign_variables</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> &amp;assign_new_from_old, const <a class="el" href="namespaceConicBundle.html#ad078c3e597a104edaccd983cddf6a134">FunObjModMap</a> *affected_functions_with_modifications=0)</td></tr>
<tr class="memdesc:a70afdaf44c7f80f69beafb1e1335ab8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reassigns variables to new index positions by mapping to position <em>i</em> the variable that previously had index <em>assign_new_from_old</em>[i].  <a href="#a70afdaf44c7f80f69beafb1e1335ab8c">More...</a><br /></td></tr>
<tr class="separator:a70afdaf44c7f80f69beafb1e1335ab8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fbdae68564966efb65943793cbd55b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a7fbdae68564966efb65943793cbd55b8">append_constraints</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> append_n_rows, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">CH_Matrix_Classes::Sparsemat</a> *append_rows=0, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *append_rhslb=0, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *append_rhsub=0)</td></tr>
<tr class="memdesc:a7fbdae68564966efb65943793cbd55b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">append <img class="formulaInl" alt="$rhslb\le Ay \le rhsub$" src="form_136.png"/> as linear constraints on the groundset variables <img class="formulaInl" alt="$y$" src="form_64.png"/>. <img class="formulaInl" alt="$A$" src="form_137.png"/> has <em>append_n_rows</em> new rows with coefficients given in append_rows (if NULL, use default value), lower bounds append_rhslb (if NULL use default) and upper bounds append_rhsub (if NULL use default)  <a href="#a7fbdae68564966efb65943793cbd55b8">More...</a><br /></td></tr>
<tr class="separator:a7fbdae68564966efb65943793cbd55b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic algorithmic routines and parameters</div></td></tr>
<tr class="memitem:a2dbe46bc6b34684ea4895f8527e3c493"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a2dbe46bc6b34684ea4895f8527e3c493">solve</a> (int maxsteps=0, bool stop_at_descent_steps=false)</td></tr>
<tr class="memdesc:a2dbe46bc6b34684ea4895f8527e3c493"><td class="mdescLeft">&#160;</td><td class="mdescRight">solves or does a prescribed number of iterations  <a href="#a2dbe46bc6b34684ea4895f8527e3c493">More...</a><br /></td></tr>
<tr class="separator:a2dbe46bc6b34684ea4895f8527e3c493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e4eaa9ce3bd66f52387ccaa59908de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a67e4eaa9ce3bd66f52387ccaa59908de">termination_code</a> () const</td></tr>
<tr class="memdesc:a67e4eaa9ce3bd66f52387ccaa59908de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the termination code of the bundle algorithm for the latest descent step.  <a href="#a67e4eaa9ce3bd66f52387ccaa59908de">More...</a><br /></td></tr>
<tr class="separator:a67e4eaa9ce3bd66f52387ccaa59908de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2fd1cb66cdd565a81879de422e45db"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a3a2fd1cb66cdd565a81879de422e45db">print_termination_code</a> (std::ostream &amp;<a class="el" href="classConicBundle_1_1CBout.html#a1125693307dcbd83770e4569bf99ba19">out</a>)</td></tr>
<tr class="memdesc:a3a2fd1cb66cdd565a81879de422e45db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a text version of termination code, see <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a67e4eaa9ce3bd66f52387ccaa59908de" title="Returns the termination code of the bundle algorithm for the latest descent step. ...">termination_code()</a>.  <a href="#a3a2fd1cb66cdd565a81879de422e45db">More...</a><br /></td></tr>
<tr class="separator:a3a2fd1cb66cdd565a81879de422e45db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abadd5d33331ac8f52bb435a11d04a802"><td class="memItemLeft" align="right" valign="top"><a id="abadd5d33331ac8f52bb435a11d04a802"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#abadd5d33331ac8f52bb435a11d04a802">get_objval</a> () const</td></tr>
<tr class="memdesc:abadd5d33331ac8f52bb435a11d04a802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the objective value resulting from last descent step (initially undefined). If no problem modification routines were called since then, it is the objective value at the point returned by <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a40b4df10fa42d417881ec55fad3616cd" title="Returns the next center point that was produced by the latest call to solve (in some problem modifica...">get_center()</a>. <br /></td></tr>
<tr class="separator:abadd5d33331ac8f52bb435a11d04a802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b4df10fa42d417881ec55fad3616cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a40b4df10fa42d417881ec55fad3616cd">get_center</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;center) const</td></tr>
<tr class="memdesc:a40b4df10fa42d417881ec55fad3616cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next center point that was produced by the latest call to solve (in some problem modification routines the center point may be updated immediately, in others the center point will be corrected automatically directly before starting the next descent step and its values may be infeasible till then).  <a href="#a40b4df10fa42d417881ec55fad3616cd">More...</a><br /></td></tr>
<tr class="separator:a40b4df10fa42d417881ec55fad3616cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6de12039608fd5b939232e901313191"><td class="memItemLeft" align="right" valign="top"><a id="ac6de12039608fd5b939232e901313191"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#ac6de12039608fd5b939232e901313191">get_sgnorm</a> () const</td></tr>
<tr class="memdesc:ac6de12039608fd5b939232e901313191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Euclidean norm of the latest aggregate subgradient. <br /></td></tr>
<tr class="separator:ac6de12039608fd5b939232e901313191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd6f3f086d74c501363141c7ed1589d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a2fd6f3f086d74c501363141c7ed1589d">get_subgradient</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;subgradient) const</td></tr>
<tr class="memdesc:a2fd6f3f086d74c501363141c7ed1589d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the latest aggregate subgradient (of the entire problem with groundset as provided by the solver)  <a href="#a2fd6f3f086d74c501363141c7ed1589d">More...</a><br /></td></tr>
<tr class="separator:a2fd6f3f086d74c501363141c7ed1589d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54695aaaf7bf36f94eddffbbe6830743"><td class="memItemLeft" align="right" valign="top"><a id="a54695aaaf7bf36f94eddffbbe6830743"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a54695aaaf7bf36f94eddffbbe6830743">get_cutval</a> () const</td></tr>
<tr class="memdesc:a54695aaaf7bf36f94eddffbbe6830743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cutting model value resulting from last call to <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a2dbe46bc6b34684ea4895f8527e3c493" title="solves or does a prescribed number of iterations ">solve()</a> (initially undefined). <br /></td></tr>
<tr class="separator:a54695aaaf7bf36f94eddffbbe6830743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ced32fd45dc87f1fb652694b95cfec0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a0ced32fd45dc87f1fb652694b95cfec0">get_candidate_value</a> () const</td></tr>
<tr class="memdesc:a0ced32fd45dc87f1fb652694b95cfec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the objective value computed in the last step of <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a2dbe46bc6b34684ea4895f8527e3c493" title="solves or does a prescribed number of iterations ">solve()</a>, independent of whether this was a descent step or a null step (initially undefined).  <a href="#a0ced32fd45dc87f1fb652694b95cfec0">More...</a><br /></td></tr>
<tr class="separator:a0ced32fd45dc87f1fb652694b95cfec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b54517bd8cf0560496780f1e8e1f466"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a2b54517bd8cf0560496780f1e8e1f466">get_candidate</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;center) const</td></tr>
<tr class="memdesc:a2b54517bd8cf0560496780f1e8e1f466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last point, the "candidate", at which the function was evaluated in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a2dbe46bc6b34684ea4895f8527e3c493" title="solves or does a prescribed number of iterations ">solve()</a>.  <a href="#a2b54517bd8cf0560496780f1e8e1f466">More...</a><br /></td></tr>
<tr class="separator:a2b54517bd8cf0560496780f1e8e1f466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Advanced algorithmic routines and parameters</div></td></tr>
<tr class="memitem:abede1e498b73162f2b7e74f958df5bc0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#abede1e498b73162f2b7e74f958df5bc0">set_term_relprec</a> (const double term_relprec)</td></tr>
<tr class="memdesc:abede1e498b73162f2b7e74f958df5bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the relative precision requirements for successful termination (default 1e-5).  <a href="#abede1e498b73162f2b7e74f958df5bc0">More...</a><br /></td></tr>
<tr class="separator:abede1e498b73162f2b7e74f958df5bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f0864cfbc01e3f9c057234069423ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#ac7f0864cfbc01e3f9c057234069423ba">set_new_center_point</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;center_point)</td></tr>
<tr class="memdesc:ac7f0864cfbc01e3f9c057234069423ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the starting point/center that will be used in the next call to <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a2dbe46bc6b34684ea4895f8527e3c493" title="solves or does a prescribed number of iterations ">solve()</a>. Each call to this routine causes an immediate evaluation of all oracles.  <a href="#ac7f0864cfbc01e3f9c057234069423ba">More...</a><br /></td></tr>
<tr class="separator:ac7f0864cfbc01e3f9c057234069423ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d58a627cf433ab421d41f290db15b0f"><td class="memItemLeft" align="right" valign="top"><a id="a2d58a627cf433ab421d41f290db15b0f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a2d58a627cf433ab421d41f290db15b0f">get_function_status</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function) const</td></tr>
<tr class="memdesc:a2d58a627cf433ab421d41f290db15b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the return value of the latest evaluation call to this <em>function</em>. <br /></td></tr>
<tr class="separator:a2d58a627cf433ab421d41f290db15b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5cb1975f8e70693c76711ba3211237"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a1a5cb1975f8e70693c76711ba3211237">get_approximate_slacks</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;) const</td></tr>
<tr class="memdesc:a1a5cb1975f8e70693c76711ba3211237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the multipliers for the box constraints on the design variables; in Lagrangean relaxation they may be interpreted as primal slacks for inequality constraints.  <a href="#a1a5cb1975f8e70693c76711ba3211237">More...</a><br /></td></tr>
<tr class="separator:a1a5cb1975f8e70693c76711ba3211237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b7d14796c16870dca8b563846be351"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#af4b7d14796c16870dca8b563846be351">get_approximate_primal</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function) const</td></tr>
<tr class="memdesc:af4b7d14796c16870dca8b563846be351"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the current approximate primal solution corresponding to the aggregate subgradient of the specified <em>function</em>.  <a href="#af4b7d14796c16870dca8b563846be351">More...</a><br /></td></tr>
<tr class="separator:af4b7d14796c16870dca8b563846be351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab235825803483082634a30604b11d730"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#ab235825803483082634a30604b11d730">get_center_primal</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function) const</td></tr>
<tr class="memdesc:ab235825803483082634a30604b11d730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the primal solution corresponding to the best epsilon subgradient returned in the evaluation of the specified <em>function</em> at the current center point. If no primal data is availalbe, the function returns NULL.  <a href="#ab235825803483082634a30604b11d730">More...</a><br /></td></tr>
<tr class="separator:ab235825803483082634a30604b11d730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc35e4d2b6da750e0b3ef4d557382bd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a9dc35e4d2b6da750e0b3ef4d557382bd">get_candidate_primal</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function) const</td></tr>
<tr class="memdesc:a9dc35e4d2b6da750e0b3ef4d557382bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the primal solution corresponding to the best epsilon subgradient returned in the evaluation of the specified <em>function</em> at the point get_candidate. If no primal data is availalbe, the function returns NULL.  <a href="#a9dc35e4d2b6da750e0b3ef4d557382bd">More...</a><br /></td></tr>
<tr class="separator:a9dc35e4d2b6da750e0b3ef4d557382bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2774c490b9a290bacfdfa60c07c0809c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a2774c490b9a290bacfdfa60c07c0809c">set_sumbundle</a> (bool use_sumbundle, int n_local_models=-1, const <a class="el" href="classConicBundle_1_1BundleParameters.html">BundleParameters</a> *bundle_parameters=0, int strategy=1)</td></tr>
<tr class="memdesc:a2774c490b9a290bacfdfa60c07c0809c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts/ends the use of a common <a class="el" href="classConicBundle_1_1SumBundle.html" title="class for use with SumBlockModel and BundlData for storing and managing a common bundle describing (p...">SumBundle</a> of the given bundle_size with a heuristic rule for selecting up to n_local_models in each bundle iteration.  <a href="#a2774c490b9a290bacfdfa60c07c0809c">More...</a><br /></td></tr>
<tr class="separator:a2774c490b9a290bacfdfa60c07c0809c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d75ed655c21685940158905beef39d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#ae9d75ed655c21685940158905beef39d">set_max_modelsize</a> (int max_modelsize, const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> *function=0)</td></tr>
<tr class="memdesc:ae9d75ed655c21685940158905beef39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum number of subgradients used in forming the cutting model of the specified <em>function</em>.  <a href="#ae9d75ed655c21685940158905beef39d">More...</a><br /></td></tr>
<tr class="separator:ae9d75ed655c21685940158905beef39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7999e132e8805b3f502e032a5ca7789f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a7999e132e8805b3f502e032a5ca7789f">set_max_bundlesize</a> (int max_bundlesize, const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> *function=0)</td></tr>
<tr class="memdesc:a7999e132e8805b3f502e032a5ca7789f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum number of subgradients stored for use in forming the model or determining scaling information, it must be as least as large as max_modelsize (and is increased to this if not)  <a href="#a7999e132e8805b3f502e032a5ca7789f">More...</a><br /></td></tr>
<tr class="separator:a7999e132e8805b3f502e032a5ca7789f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a880b17fbf8146a5347532f6491874"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a84a880b17fbf8146a5347532f6491874">set_bundle_parameters</a> (const <a class="el" href="classConicBundle_1_1BundleParameters.html">BundleParameters</a> &amp;params, const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> *function=0)</td></tr>
<tr class="memdesc:a84a880b17fbf8146a5347532f6491874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum bundlesize and the maximum number of new subgradients added in a bundle update of the cutting model for the specified <em>function</em>. The meaning of this routine may differ from standard for predefined special functions with special bundle types.  <a href="#a84a880b17fbf8146a5347532f6491874">More...</a><br /></td></tr>
<tr class="separator:a84a880b17fbf8146a5347532f6491874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe69e8bb6dea059f2e82637c368cb9e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classConicBundle_1_1BundleParameters.html">BundleParameters</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a1fe69e8bb6dea059f2e82637c368cb9e">get_bundle_parameters</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> *function=0) const</td></tr>
<tr class="memdesc:a1fe69e8bb6dea059f2e82637c368cb9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves current bundle parameters (not the actual size in use!) as set for the cutting model of the specified <em>function</em>.  <a href="#a1fe69e8bb6dea059f2e82637c368cb9e">More...</a><br /></td></tr>
<tr class="separator:a1fe69e8bb6dea059f2e82637c368cb9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f7db55ed7f890ea2bff768132aa98a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a22f7db55ed7f890ea2bff768132aa98a">set_sumbundle_parameters</a> (const <a class="el" href="classConicBundle_1_1SumBundleParametersObject.html">SumBundleParametersObject</a> &amp;params, const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> *function=0)</td></tr>
<tr class="memdesc:a22f7db55ed7f890ea2bff768132aa98a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the behavior of the model (of the specified function) concerning requests to join or start a <a class="el" href="classConicBundle_1_1SumBundle.html" title="class for use with SumBlockModel and BundlData for storing and managing a common bundle describing (p...">SumBundle</a> that subsumes several models instead of providing a separate model for each funciton.  <a href="#a22f7db55ed7f890ea2bff768132aa98a">More...</a><br /></td></tr>
<tr class="separator:a22f7db55ed7f890ea2bff768132aa98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ddbbdc191a5d213536626c2de77807"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classConicBundle_1_1BundleData.html">BundleData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a94ddbbdc191a5d213536626c2de77807">get_bundle_data</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> *function=0) const</td></tr>
<tr class="memdesc:a94ddbbdc191a5d213536626c2de77807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all current bundle data of the cutting model of the specified <em>function</em>.  <a href="#a94ddbbdc191a5d213536626c2de77807">More...</a><br /></td></tr>
<tr class="separator:a94ddbbdc191a5d213536626c2de77807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bbc394d1c05f92597eec01c0f45b516"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a6bbc394d1c05f92597eec01c0f45b516">reinit_function_model</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> *function=0)</td></tr>
<tr class="memdesc:a6bbc394d1c05f92597eec01c0f45b516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears cutting model, subgradients and stored function values for the specified <em>function</em> (but only for the given one, not recursively)  <a href="#a6bbc394d1c05f92597eec01c0f45b516">More...</a><br /></td></tr>
<tr class="separator:a6bbc394d1c05f92597eec01c0f45b516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ccd3f15e30b2b8cca374ade4fc67db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#ac9ccd3f15e30b2b8cca374ade4fc67db">clear_aggregates</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> *function=0)</td></tr>
<tr class="memdesc:ac9ccd3f15e30b2b8cca374ade4fc67db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the aggregate parts of the cutting model of this <em>function</em> (but only for the given one, not recursively)  <a href="#ac9ccd3f15e30b2b8cca374ade4fc67db">More...</a><br /></td></tr>
<tr class="separator:ac9ccd3f15e30b2b8cca374ade4fc67db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd691c7cb860f7f52c39ea3a28b5b63"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a6bd691c7cb860f7f52c39ea3a28b5b63">call_primal_extender</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function, <a class="el" href="classConicBundle_1_1PrimalExtender.html">PrimalExtender</a> &amp;primal_extender)</td></tr>
<tr class="memdesc:a6bd691c7cb860f7f52c39ea3a28b5b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asks <em>function</em> to call <em>primal_extender</em> for each of its primal objects (see also <a class="el" href="classConicBundle_1_1FunctionOracle.html#a10d135676ae61d26bb068fadef2526d3" title="Called by the solver. Has to Return function value and at least one (epsilon) subgradient and...">FunctionOracle::evaluate()</a> )  <a href="#a6bd691c7cb860f7f52c39ea3a28b5b63">More...</a><br /></td></tr>
<tr class="separator:a6bd691c7cb860f7f52c39ea3a28b5b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab7e7af4f9be53e6cd6b01d319e2c68"><td class="memItemLeft" align="right" valign="top"><a id="a8ab7e7af4f9be53e6cd6b01d319e2c68"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a8ab7e7af4f9be53e6cd6b01d319e2c68">get_last_weight</a> () const</td></tr>
<tr class="memdesc:a8ab7e7af4f9be53e6cd6b01d319e2c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current weight for the quadratic term in the augmented subproblem (may be interpreted as 1./step_size or 1./trustregion-radius). <br /></td></tr>
<tr class="separator:a8ab7e7af4f9be53e6cd6b01d319e2c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24a172ff592bd25fcafe18c7d6f8175"><td class="memItemLeft" align="right" valign="top"><a id="af24a172ff592bd25fcafe18c7d6f8175"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#af24a172ff592bd25fcafe18c7d6f8175">get_next_weight</a> () const</td></tr>
<tr class="memdesc:af24a172ff592bd25fcafe18c7d6f8175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next weight for the quadratic term in the augmented subproblem suggested by the internal weight updating heuristic. <br /></td></tr>
<tr class="separator:af24a172ff592bd25fcafe18c7d6f8175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa42c46986ad62af21555340346dcf4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#acaa42c46986ad62af21555340346dcf4">set_next_weight</a> (const double weight)</td></tr>
<tr class="memdesc:acaa42c46986ad62af21555340346dcf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the weight (&gt;0) to be used in the quadratic term of the next augmented subproblem (may be interpreted as 1./step_size or 1./trustregion-radius).  <a href="#acaa42c46986ad62af21555340346dcf4">More...</a><br /></td></tr>
<tr class="separator:acaa42c46986ad62af21555340346dcf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f10280eeddb360806951729b076e026"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a6f10280eeddb360806951729b076e026">set_min_weight</a> (const double min_weight)</td></tr>
<tr class="memdesc:a6f10280eeddb360806951729b076e026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a lower bound on the weight for the quadratic term of the augmented subproblem.  <a href="#a6f10280eeddb360806951729b076e026">More...</a><br /></td></tr>
<tr class="separator:a6f10280eeddb360806951729b076e026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2d01b507839451c91d6574c02113c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#abd2d01b507839451c91d6574c02113c2">set_max_weight</a> (const double max_weight)</td></tr>
<tr class="memdesc:abd2d01b507839451c91d6574c02113c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an upper bound on the weight for the quadratic term of the augmented subproblem.  <a href="#abd2d01b507839451c91d6574c02113c2">More...</a><br /></td></tr>
<tr class="separator:abd2d01b507839451c91d6574c02113c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbddabcaa82723cbde924707efef9b60"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#afbddabcaa82723cbde924707efef9b60">set_weight_update</a> (<a class="el" href="classConicBundle_1_1BundleWeight.html">BundleWeight</a> *bw)</td></tr>
<tr class="memdesc:afbddabcaa82723cbde924707efef9b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the internal update routine for choosing the weight used in the proximal term; input NULL reinstalls the default routine.  <a href="#afbddabcaa82723cbde924707efef9b60">More...</a><br /></td></tr>
<tr class="separator:afbddabcaa82723cbde924707efef9b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba280fdc2eca4c836412118910ebd2c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#aba280fdc2eca4c836412118910ebd2c1">adjust_multiplier</a> (void)</td></tr>
<tr class="memdesc:aba280fdc2eca4c836412118910ebd2c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts on all conic functions the penalty parameter for conic violations to twice the trace of the primal approximation.  <a href="#aba280fdc2eca4c836412118910ebd2c1">More...</a><br /></td></tr>
<tr class="separator:aba280fdc2eca4c836412118910ebd2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650641f5e6dbaa711f3ac3441aa121b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a650641f5e6dbaa711f3ac3441aa121b4">set_variable_metric</a> (int do_variable_metric)</td></tr>
<tr class="memdesc:a650641f5e6dbaa711f3ac3441aa121b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a variable metric heuristic or switch off general metrics alltogether. (variable metric resets the quadratic term e.g. to some diagonal matrix, switching it off resets the quadratic term to the identity times the weight)  <a href="#a650641f5e6dbaa711f3ac3441aa121b4">More...</a><br /></td></tr>
<tr class="separator:a650641f5e6dbaa711f3ac3441aa121b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca9ca6eb41bb842f12f693292913416"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a1ca9ca6eb41bb842f12f693292913416">set_prox</a> (<a class="el" href="classConicBundle_1_1BundleProxObject.html">BundleProxObject</a> *proxp)</td></tr>
<tr class="memdesc:a1ca9ca6eb41bb842f12f693292913416"><td class="mdescLeft">&#160;</td><td class="mdescRight">For variable metric install the <a class="el" href="classConicBundle_1_1BundleProxObject.html" title="abstract interface that allows to use different -norms  with a positive definite matrix  in the proxi...">BundleProxObject</a> pointed to; the object is passed to the solver who will delete it on termination or when replaced.  <a href="#a1ca9ca6eb41bb842f12f693292913416">More...</a><br /></td></tr>
<tr class="separator:a1ca9ca6eb41bb842f12f693292913416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5229f01c537d914a60b896bf01e550d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a5229f01c537d914a60b896bf01e550d5">set_active_bounds_fixing</a> (bool allow_fixing)</td></tr>
<tr class="memdesc:a5229f01c537d914a60b896bf01e550d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set to true (the default is false), variables may be fixed automatically to active bounds if these are strongly active (i.e., the corresponding multipliers are big) and the center values are also right on these bounds already.  <a href="#a5229f01c537d914a60b896bf01e550d5">More...</a><br /></td></tr>
<tr class="separator:a5229f01c537d914a60b896bf01e550d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eeac5ece21d05a387eea9f755b15bff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a9eeac5ece21d05a387eea9f755b15bff">clear_fail_counts</a> (void)</td></tr>
<tr class="memdesc:a9eeac5ece21d05a387eea9f755b15bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">clears all fail counts on numerical function oder model failures, may be useful if this caused premature termination.  <a href="#a9eeac5ece21d05a387eea9f755b15bff">More...</a><br /></td></tr>
<tr class="separator:a9eeac5ece21d05a387eea9f755b15bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a8da56a2730b8d08b48aaff486c6bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a85a8da56a2730b8d08b48aaff486c6bb">set_eval_limit</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> eval_limit)</td></tr>
<tr class="memdesc:a85a8da56a2730b8d08b48aaff486c6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an upper bound on the number of calls to the oracle (use negative numbers for no limit).  <a href="#a85a8da56a2730b8d08b48aaff486c6bb">More...</a><br /></td></tr>
<tr class="separator:a85a8da56a2730b8d08b48aaff486c6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b3c9fd487084ef3cba0477f583f776"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a16b3c9fd487084ef3cba0477f583f776">set_inner_update_limit</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> update_limit)</td></tr>
<tr class="memdesc:a16b3c9fd487084ef3cba0477f583f776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an upper bound on the number of inner updates for the cutting model with primal slacks within one null step (use negative numbers for no limit).  <a href="#a16b3c9fd487084ef3cba0477f583f776">More...</a><br /></td></tr>
<tr class="separator:a16b3c9fd487084ef3cba0477f583f776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f72743121e2fbd6f21eceda5295e9cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a8f72743121e2fbd6f21eceda5295e9cf">set_time_limit</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> time_limit)</td></tr>
<tr class="memdesc:a8f72743121e2fbd6f21eceda5295e9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an upper bound on the number of seconds (user time, use negative numbers for no limit)  <a href="#a8f72743121e2fbd6f21eceda5295e9cf">More...</a><br /></td></tr>
<tr class="separator:a8f72743121e2fbd6f21eceda5295e9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6ef966489f651db44a60f037d3c754"><td class="memItemLeft" align="right" valign="top"><a id="a3a6ef966489f651db44a60f037d3c754"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>set_qp_solver</b> (<a class="el" href="classConicBundle_1_1QPSolverParametersObject.html">QPSolverParametersObject</a> *qpparams, <a class="el" href="classConicBundle_1_1QPSolverObject.html">QPSolverObject</a> *newqpsolver=0)</td></tr>
<tr class="separator:a3a6ef966489f651db44a60f037d3c754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Look up basic paramaters (dimension, number of functions, ...)</div></td></tr>
<tr class="memitem:a9a7539b7da68fa4c0093005fe41ea73f"><td class="memItemLeft" align="right" valign="top"><a id="a9a7539b7da68fa4c0093005fe41ea73f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a9a7539b7da68fa4c0093005fe41ea73f">get_dim</a> () const</td></tr>
<tr class="memdesc:a9a7539b7da68fa4c0093005fe41ea73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current dimension of the design space/argument or -1 if no dimension is set. <br /></td></tr>
<tr class="separator:a9a7539b7da68fa4c0093005fe41ea73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebc1f964e4156f1bcd3e70c423b8b6d"><td class="memItemLeft" align="right" valign="top"><a id="acebc1f964e4156f1bcd3e70c423b8b6d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#acebc1f964e4156f1bcd3e70c423b8b6d">get_n_functions</a> () const</td></tr>
<tr class="memdesc:acebc1f964e4156f1bcd3e70c423b8b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of functions in the problem. <br /></td></tr>
<tr class="separator:acebc1f964e4156f1bcd3e70c423b8b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5d7e50de0aa272f11792366200d5be"><td class="memItemLeft" align="right" valign="top"><a id="a6a5d7e50de0aa272f11792366200d5be"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a6a5d7e50de0aa272f11792366200d5be">get_n_oracle_calls</a> () const</td></tr>
<tr class="memdesc:a6a5d7e50de0aa272f11792366200d5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of function evaluations. <br /></td></tr>
<tr class="separator:a6a5d7e50de0aa272f11792366200d5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6486d0af0a7a48a65b3c584f113090"><td class="memItemLeft" align="right" valign="top"><a id="a0a6486d0af0a7a48a65b3c584f113090"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a0a6486d0af0a7a48a65b3c584f113090">get_n_descent_steps</a> () const</td></tr>
<tr class="memdesc:a0a6486d0af0a7a48a65b3c584f113090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of function descent setps. <br /></td></tr>
<tr class="separator:a0a6486d0af0a7a48a65b3c584f113090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ad12198429ebd0e9ab11981600d427"><td class="memItemLeft" align="right" valign="top"><a id="ab4ad12198429ebd0e9ab11981600d427"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#ab4ad12198429ebd0e9ab11981600d427">get_n_inner_iterations</a> () const</td></tr>
<tr class="memdesc:ab4ad12198429ebd0e9ab11981600d427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of inner iterations of the bundle method. <br /></td></tr>
<tr class="separator:ab4ad12198429ebd0e9ab11981600d427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe45cb3d7f3cf5a80228b3cca35d029"><td class="memItemLeft" align="right" valign="top"><a id="a2fe45cb3d7f3cf5a80228b3cca35d029"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a2fe45cb3d7f3cf5a80228b3cca35d029">get_n_inner_updates</a> () const</td></tr>
<tr class="memdesc:a2fe45cb3d7f3cf5a80228b3cca35d029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of inner multiplier updates for the box constraints. <br /></td></tr>
<tr class="separator:a2fe45cb3d7f3cf5a80228b3cca35d029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af393b1adabcb36675959e2e3db8e69d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#af393b1adabcb36675959e2e3db8e69d3">get_descent_step</a> () const</td></tr>
<tr class="memdesc:af393b1adabcb36675959e2e3db8e69d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the last evaluation of the last call to <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a2dbe46bc6b34684ea4895f8527e3c493" title="solves or does a prescribed number of iterations ">solve()</a> resulted in a descent step  <a href="#af393b1adabcb36675959e2e3db8e69d3">More...</a><br /></td></tr>
<tr class="separator:af393b1adabcb36675959e2e3db8e69d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8399102676d5acb8acd1e0b0fdc391"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a4c8399102676d5acb8acd1e0b0fdc391">get_null_step</a> () const</td></tr>
<tr class="memdesc:a4c8399102676d5acb8acd1e0b0fdc391"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the last evaluation of the last call to <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a2dbe46bc6b34684ea4895f8527e3c493" title="solves or does a prescribed number of iterations ">solve()</a> resulted in a null step  <a href="#a4c8399102676d5acb8acd1e0b0fdc391">More...</a><br /></td></tr>
<tr class="separator:a4c8399102676d5acb8acd1e0b0fdc391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11166930279daa14e6a0a5d2832f49c3"><td class="memItemLeft" align="right" valign="top"><a id="a11166930279daa14e6a0a5d2832f49c3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a11166930279daa14e6a0a5d2832f49c3">get_costs</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;costs) const</td></tr>
<tr class="memdesc:a11166930279daa14e6a0a5d2832f49c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a linear cost vector was specified, costs will hold these values, otherwise the vector is initialized to zero (for the current dimension) <br /></td></tr>
<tr class="separator:a11166930279daa14e6a0a5d2832f49c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2ba88ad94a2e59289c4c5cab5a8d12"><td class="memItemLeft" align="right" valign="top"><a id="abc2ba88ad94a2e59289c4c5cab5a8d12"></a>
const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#abc2ba88ad94a2e59289c4c5cab5a8d12">get_lbounds</a> () const</td></tr>
<tr class="memdesc:abc2ba88ad94a2e59289c4c5cab5a8d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the vector of lower bounds or null if there is no such vector. <br /></td></tr>
<tr class="separator:abc2ba88ad94a2e59289c4c5cab5a8d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e0bee0494f3f514646c5686a0ca0e9"><td class="memItemLeft" align="right" valign="top"><a id="a66e0bee0494f3f514646c5686a0ca0e9"></a>
const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a66e0bee0494f3f514646c5686a0ca0e9">get_ubounds</a> () const</td></tr>
<tr class="memdesc:a66e0bee0494f3f514646c5686a0ca0e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the vector of upper bounds or null if there is no such vector. <br /></td></tr>
<tr class="separator:a66e0bee0494f3f514646c5686a0ca0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8715eb8a6c956d314a108c8fd29636f7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a8715eb8a6c956d314a108c8fd29636f7">get_fixed_active_bounds</a> () const</td></tr>
<tr class="memdesc:a8715eb8a6c956d314a108c8fd29636f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns NULL or (iff active bound fixing is turned on in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a5229f01c537d914a60b896bf01e550d5" title="If set to true (the default is false), variables may be fixed automatically to active bounds if these...">set_active_bounds_fixing()</a>) the indicator vector of variables temporarily fixed to the center value due to significantly positive multipliers for the box constraints.  <a href="#a8715eb8a6c956d314a108c8fd29636f7">More...</a><br /></td></tr>
<tr class="separator:a8715eb8a6c956d314a108c8fd29636f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5c242978519a877da4da3c2c77b613"><td class="memItemLeft" align="right" valign="top"><a id="aba5c242978519a877da4da3c2c77b613"></a>
<a class="el" href="classConicBundle_1_1BundleProxObject.html">BundleProxObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#aba5c242978519a877da4da3c2c77b613">get_prox</a> () const</td></tr>
<tr class="memdesc:aba5c242978519a877da4da3c2c77b613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pointer to the current prox term of the bundle solver. <br /></td></tr>
<tr class="separator:aba5c242978519a877da4da3c2c77b613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff83f401c1b3366a0a0a4c0f7730b358"><td class="memItemLeft" align="right" valign="top"><a id="aff83f401c1b3366a0a0a4c0f7730b358"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#aff83f401c1b3366a0a0a4c0f7730b358">pending_oracle_modification</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> &amp;old_dim, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> &amp;new_dim, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> &amp;append_dim, const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> *&amp;map_to_old, const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> *&amp;deleted_indices, const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> *&amp;new_indices, const <a class="el" href="classConicBundle_1_1OracleModification.html">OracleModification</a> *&amp;oracle_modification) const</td></tr>
<tr class="memdesc:aff83f401c1b3366a0a0a4c0f7730b358"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if for function some modifications are pending, the arguments give information on these <br /></td></tr>
<tr class="separator:aff83f401c1b3366a0a0a4c0f7730b358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Output</div></td></tr>
<tr class="memitem:a370c6ee0dd593962cbb39927a56d6bce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a370c6ee0dd593962cbb39927a56d6bce">set_out</a> (std::ostream *<a class="el" href="classConicBundle_1_1CBout.html#a1125693307dcbd83770e4569bf99ba19">out</a>=0, int <a class="el" href="classConicBundle_1_1CBout.html#a5ce873e4d4d6b00096d822fa65fd4d7a">print_level</a>=1)</td></tr>
<tr class="memdesc:a370c6ee0dd593962cbb39927a56d6bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the output level (out==NULL: no output at all, out!=NULL and level=0: errors and warnings, level&gt;0 increasingly detailed information)  <a href="#a370c6ee0dd593962cbb39927a56d6bce">More...</a><br /></td></tr>
<tr class="separator:a370c6ee0dd593962cbb39927a56d6bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb79c795b9d8beaaa8fc4f1245602f16"><td class="memItemLeft" align="right" valign="top"><a id="abb79c795b9d8beaaa8fc4f1245602f16"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#abb79c795b9d8beaaa8fc4f1245602f16">print_line_summary</a> (std::ostream &amp;<a class="el" href="classConicBundle_1_1CBout.html#a1125693307dcbd83770e4569bf99ba19">out</a>) const</td></tr>
<tr class="memdesc:abb79c795b9d8beaaa8fc4f1245602f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">print a one line summary of important evaluation data <br /></td></tr>
<tr class="separator:abb79c795b9d8beaaa8fc4f1245602f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900c0affc8438cecc2a39d2b8f0e248c"><td class="memItemLeft" align="right" valign="top"><a id="a900c0affc8438cecc2a39d2b8f0e248c"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a900c0affc8438cecc2a39d2b8f0e248c">print_statistics</a> (std::ostream &amp;<a class="el" href="classConicBundle_1_1CBout.html#a1125693307dcbd83770e4569bf99ba19">out</a>) const</td></tr>
<tr class="memdesc:a900c0affc8438cecc2a39d2b8f0e248c"><td class="mdescLeft">&#160;</td><td class="mdescRight">print a cryptic summary of computation times of important components <br /></td></tr>
<tr class="separator:a900c0affc8438cecc2a39d2b8f0e248c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classConicBundle_1_1CBout"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classConicBundle_1_1CBout')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classConicBundle_1_1CBout.html">ConicBundle::CBout</a></td></tr>
<tr class="memitem:adac4530f6a6e43d48833a16aa26358e2 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#adac4530f6a6e43d48833a16aa26358e2">set_cbout</a> (const <a class="el" href="classConicBundle_1_1CBout.html">CBout</a> *cb, int incr=-1)</td></tr>
<tr class="memdesc:adac4530f6a6e43d48833a16aa26358e2 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the output level relative to the given <a class="el" href="classConicBundle_1_1CBout.html" title="base class for uniform use of WARNINGS and ERRORS (at some point in time) ">CBout</a> class.  <a href="classConicBundle_1_1CBout.html#adac4530f6a6e43d48833a16aa26358e2">More...</a><br /></td></tr>
<tr class="separator:adac4530f6a6e43d48833a16aa26358e2 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07122b66dbab4e1e411c807079fda6b0 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="a07122b66dbab4e1e411c807079fda6b0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#a07122b66dbab4e1e411c807079fda6b0">clear_cbout</a> ()</td></tr>
<tr class="memdesc:a07122b66dbab4e1e411c807079fda6b0 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset to default settings (out=0,print_level=1) <br /></td></tr>
<tr class="separator:a07122b66dbab4e1e411c807079fda6b0 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e96394f860c57d18c7c1d096c21cf9 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="aa9e96394f860c57d18c7c1d096c21cf9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#aa9e96394f860c57d18c7c1d096c21cf9">CBout</a> (const <a class="el" href="classConicBundle_1_1CBout.html">CBout</a> *cb=0, int incr=-1)</td></tr>
<tr class="memdesc:aa9e96394f860c57d18c7c1d096c21cf9 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">calls set_cbout <br /></td></tr>
<tr class="separator:aa9e96394f860c57d18c7c1d096c21cf9 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24445af38af55dfbd25bfe3055a53d17 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="a24445af38af55dfbd25bfe3055a53d17"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#a24445af38af55dfbd25bfe3055a53d17">CBout</a> (std::ostream *outp, int pl=1)</td></tr>
<tr class="memdesc:a24445af38af55dfbd25bfe3055a53d17 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize correspondingly <br /></td></tr>
<tr class="separator:a24445af38af55dfbd25bfe3055a53d17 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4defbb041e13bf58221e54bba4554335 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="a4defbb041e13bf58221e54bba4554335"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#a4defbb041e13bf58221e54bba4554335">CBout</a> (const <a class="el" href="classConicBundle_1_1CBout.html">CBout</a> &amp;cb, int incr=0)</td></tr>
<tr class="memdesc:a4defbb041e13bf58221e54bba4554335 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor <br /></td></tr>
<tr class="separator:a4defbb041e13bf58221e54bba4554335 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04ddacb98b92a196319a2483774d4f4 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="ab04ddacb98b92a196319a2483774d4f4"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#ab04ddacb98b92a196319a2483774d4f4">cb_out</a> (int pl=-1) const</td></tr>
<tr class="memdesc:ab04ddacb98b92a196319a2483774d4f4 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if out!=0 and (pl&lt;print_level), pl&lt;0 should be used for WARNINGS and ERRORS only, pl==0 for usual output. <br /></td></tr>
<tr class="separator:ab04ddacb98b92a196319a2483774d4f4 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55dcbb4c6fff8dc3485f9dd3cb309af8 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="a55dcbb4c6fff8dc3485f9dd3cb309af8"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#a55dcbb4c6fff8dc3485f9dd3cb309af8">get_out</a> () const</td></tr>
<tr class="memdesc:a55dcbb4c6fff8dc3485f9dd3cb309af8 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="classConicBundle_1_1CBout.html#ab04ddacb98b92a196319a2483774d4f4" title="Returns true if out!=0 and (pl&lt;print_level), pl&lt;0 should be used for WARNINGS and ERRORS only...">cb_out()</a> returned true, this returns the output stream, but it will abort if called with out==0. <br /></td></tr>
<tr class="separator:a55dcbb4c6fff8dc3485f9dd3cb309af8 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b55664bdf89963b87c94e7fa69b8fd1 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="a6b55664bdf89963b87c94e7fa69b8fd1"></a>
std::ostream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#a6b55664bdf89963b87c94e7fa69b8fd1">get_out_ptr</a> () const</td></tr>
<tr class="memdesc:a6b55664bdf89963b87c94e7fa69b8fd1 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the pointer to the output stream <br /></td></tr>
<tr class="separator:a6b55664bdf89963b87c94e7fa69b8fd1 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88e5f8f443a40c6cb506e2c808525a3 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="ad88e5f8f443a40c6cb506e2c808525a3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#ad88e5f8f443a40c6cb506e2c808525a3">get_print_level</a> () const</td></tr>
<tr class="memdesc:ad88e5f8f443a40c6cb506e2c808525a3 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the print_level <br /></td></tr>
<tr class="separator:ad88e5f8f443a40c6cb506e2c808525a3 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dda97ab7acdfab7e95b89a25cc9541c inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="a5dda97ab7acdfab7e95b89a25cc9541c"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#a5dda97ab7acdfab7e95b89a25cc9541c">mfile_data</a> (std::ostream &amp;<a class="el" href="classConicBundle_1_1CBout.html#a1125693307dcbd83770e4569bf99ba19">out</a>) const</td></tr>
<tr class="memdesc:a5dda97ab7acdfab7e95b89a25cc9541c inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">writes problem data to the given outstream <br /></td></tr>
<tr class="separator:a5dda97ab7acdfab7e95b89a25cc9541c inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ad96ab317e16fadfbdd808172953632a6"><td class="memItemLeft" align="right" valign="top"><a id="ad96ab317e16fadfbdd808172953632a6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#ad96ab317e16fadfbdd808172953632a6">MatrixCBSolver</a> (const <a class="el" href="classConicBundle_1_1MatrixCBSolver.html">MatrixCBSolver</a> &amp;)</td></tr>
<tr class="memdesc:ad96ab317e16fadfbdd808172953632a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">not available, blocked deliberately <br /></td></tr>
<tr class="separator:ad96ab317e16fadfbdd808172953632a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040b1936e9120871df5b9c924072a343"><td class="memItemLeft" align="right" valign="top"><a id="a040b1936e9120871df5b9c924072a343"></a>
<a class="el" href="classConicBundle_1_1MatrixCBSolver.html">MatrixCBSolver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a040b1936e9120871df5b9c924072a343">operator=</a> (const <a class="el" href="classConicBundle_1_1MatrixCBSolver.html">MatrixCBSolver</a> &amp;)</td></tr>
<tr class="memdesc:a040b1936e9120871df5b9c924072a343"><td class="mdescLeft">&#160;</td><td class="mdescRight">not available, blocked deliberately <br /></td></tr>
<tr class="separator:a040b1936e9120871df5b9c924072a343"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a8accfb200e2d4aca3eec01fb6316d1eb"><td class="memItemLeft" align="right" valign="top"><a id="a8accfb200e2d4aca3eec01fb6316d1eb"></a>
MatrixCBSolverData *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a8accfb200e2d4aca3eec01fb6316d1eb">data_</a></td></tr>
<tr class="memdesc:a8accfb200e2d4aca3eec01fb6316d1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to internal solver data <br /></td></tr>
<tr class="separator:a8accfb200e2d4aca3eec01fb6316d1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Full Conic Bundle method solver invoked by <a class="el" href="classConicBundle_1_1MatrixCBSolver.html" title="The Full Conic Bundle method solver invoked by ConicBundle::MatrixCBSolver(), it uses a separate cutt...">ConicBundle::MatrixCBSolver()</a>, it uses a separate cutting model for each function. </p>
<p>Minimizes the sum of convex functions that are given via <a class="el" href="classConicBundle_1_1MatrixFunctionOracle.html" title="Oracle interface (abstract class). For each of your functions, provide an instance of a derived class...">ConicBundle::MatrixFunctionOracle</a> interfaces, see <a class="el" href="group__cxxmatrixinterface.html">the text explaining the C++ interface for Matrix Classes</a> for a quick overview.</p>
<p>It provides special support for Lagrangean relaxation by generating primal approximate solutions if such information is provided in the function oracles.</p>
<p>Based on these primal approximations it is also possible to implement cutting plane schemes. Routines for adding and deleting corresponding dual variables as well as a framework for extending subgradients in order not to loose the cutting model are available. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a3c503663b689ede0f1d004690d622e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c503663b689ede0f1d004690d622e2f">&#9670;&nbsp;</a></span>add_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::add_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a>&#160;</td>
          <td class="paramname"><em>fun_factor</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cxxinterface.html#gad70e60e1e38a03d09f1e9b10b68bb0f2">FunctionTask</a>&#160;</td>
          <td class="paramname"><em>fun_task</em> = <code>ObjectiveFunction</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html">AffineFunctionTransformation</a> *&#160;</td>
          <td class="paramname"><em>aft</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>argument_list_may_change_dynamically</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a function, typically derived from <a class="el" href="classConicBundle_1_1FunctionOracle.html" title="oracle interface (abstract class). For each of your functions, provide a derived class. ">ConicBundle::FunctionOracle</a>. If the dimension does not match the current one, specify an affine function transformation to map the current ground set to the argument of the function. </p>
<p>Besides the standard <a class="el" href="classConicBundle_1_1MatrixFunctionOracle.html" title="Oracle interface (abstract class). For each of your functions, provide an instance of a derived class...">ConicBundle::MatrixFunctionOracle</a> the interface only accepts a few other prespecified derivations of the class <a class="el" href="classConicBundle_1_1FunctionObject.html" title="basic function object (abstract class). It serves for using the same interface on distinct oracle typ...">FunctionObject</a> that come along with the <a class="el" href="namespaceCH__Matrix__Classes.html" title="Matrix Classes and Linear Algebra. See Matrix Classes (namespace CH_Matrix_Classes) for a quick intro...">CH_Matrix_Classes</a> interface (e.g. for semidefinite and second order cones). Functions not derived from these will fail to be added and return a value !=0.</p>
<p>The <em>fun_factor</em> allows to specify a scaling factor for the function. <em>fun_factor</em> must be a strictly positive number.</p>
<p>The <a class="el" href="group__cxxinterface.html#gad70e60e1e38a03d09f1e9b10b68bb0f2" title="Each function  represented by a FunctionModel is equipped with a function_factor  (it defaults to 1...">ConicBundle::FunctionTask</a> <em>fun_task</em> specifies whether the function is to be used as a an ObjectiveFunction, a ConstantPenaltyFunction with <em>fun_factor</em> as maximum penalty factor, or as an AdaptivePenaltyFunction with <em>fun_factor</em> at initial penalty guess that might be increased or decreased over time.</p>
<p>The <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html" title="transform a function f(z) to fun_coeff*f(arg_offset+arg_trafo*y)+linear_cost*y+fun_offset (scales the...">AffineFunctionTransformation</a> <em>aft</em> may be used to modify the argument and give an additional affine term (linear term plus offset). For adding an affine term there are several other possibilities, e.g. in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a5129b50d68be01aaa8cb6825058a8f13" title="Initializes the problem by setting up the design space (the dimension and possibly box constraints on...">init_problem()</a>, so there is no need to do so here. If, however, an existing function implementation requires only some subset of the variables, it is more convenient to supply a corresponding <em>aft</em> instead of reimplementing the function.</p>
<p><em>argument_list_may_change_dynamically</em> sets a flag on how to treat the function arguments when variables are added or deleted. If the arguments may not change, any changes in the variables are mapped to an adaptation of an internal <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html" title="transform a function f(z) to fun_coeff*f(arg_offset+arg_trafo*y)+linear_cost*y+fun_offset (scales the...">AffineFunctionTransformation</a> so that the function does not notice the changes in the variables. If arguments may change, the function oracle should be a <a class="el" href="classConicBundle_1_1ModifiableOracleObject.html" title="ModifiableOracle provides all oracles with a uniform interface for a modification routine and an on/o...">ModifiableOracleObject</a> and react accordingly to the changes in its <a class="el" href="classConicBundle_1_1ModifiableOracleObject.html#ab4f16d78fec3a02cc064003c2b02ddce" title="This routine need not be implemented unless variables (constraints in Lagrangean relaxation) are adde...">ModifiableOracleObject::apply_modification()</a> routine.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aba280fdc2eca4c836412118910ebd2c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba280fdc2eca4c836412118910ebd2c1">&#9670;&nbsp;</a></span>adjust_multiplier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::adjust_multiplier </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjusts on all conic functions the penalty parameter for conic violations to twice the trace of the primal approximation. </p>
<p>This routine is only needed for conic function objects such as the nonnegative cone, the second order cone and the semidefinite cone if no good upper bound on the trace of feasible points is known and has to be determined automatically.</p>
<p>If after some time, the trace values settle, the upper bounds on the trace may be way to high and can then be reset with this call.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7fbdae68564966efb65943793cbd55b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fbdae68564966efb65943793cbd55b8">&#9670;&nbsp;</a></span>append_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::append_constraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a>&#160;</td>
          <td class="paramname"><em>append_n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">CH_Matrix_Classes::Sparsemat</a> *&#160;</td>
          <td class="paramname"><em>append_rows</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *&#160;</td>
          <td class="paramname"><em>append_rhslb</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *&#160;</td>
          <td class="paramname"><em>append_rhsub</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>append <img class="formulaInl" alt="$rhslb\le Ay \le rhsub$" src="form_136.png"/> as linear constraints on the groundset variables <img class="formulaInl" alt="$y$" src="form_64.png"/>. <img class="formulaInl" alt="$A$" src="form_137.png"/> has <em>append_n_rows</em> new rows with coefficients given in append_rows (if NULL, use default value), lower bounds append_rhslb (if NULL use default) and upper bounds append_rhsub (if NULL use default) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">append_n_rows</td><td>(Integer) (nonnegative) number of rows to be appended as linear constraints on the ground set</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">append_rows</td><td>(Sparsemat*) describes the coefficients of the linear constraints; the number of rows must match append_n_rows, the number of columns must match the current dimension of the groundset; if NULL, all coefficients are considered zero.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">append_rhslb</td><td>(Matrix*) specifies lower bounds on the values of the constraints; the number of rows must match append_n_rows; if NULL, all coefficients are considered CB_minus_infinity.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">append_rhsub</td><td>(Matrix*) specifies upper bound on the values of the constraints; the number of rows must match append_n_rows; if NULL, all coefficients are considered CB_plus_infinity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae94677e63dc7736099a77acaad553a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94677e63dc7736099a77acaad553a3f">&#9670;&nbsp;</a></span>append_variables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::append_variables </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_append</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *&#160;</td>
          <td class="paramname"><em>lbounds</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *&#160;</td>
          <td class="paramname"><em>ubounds</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">CH_Matrix_Classes::Sparsemat</a> *&#160;</td>
          <td class="paramname"><em>constraint_columns</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *&#160;</td>
          <td class="paramname"><em>startval</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *&#160;</td>
          <td class="paramname"><em>costs</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceConicBundle.html#ad078c3e597a104edaccd983cddf6a134">FunObjModMap</a> *&#160;</td>
          <td class="paramname"><em>affected_functions_with_modifications</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append new variables (always in last postions in this order). </p>
<dl class="section attention"><dt>Attention</dt><dd>Be sure to include a desription of required changes to your functions via <em>affected_functions_with_modifications</em> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n_append</td><td>(int) number of variables to append (always in last position in the same order)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lbounds</td><td>(const Matrix*) If NULL, all appended variables are considered unbounded below, otherwise lbounds[i] gives the minimum feasible value for variable y[i], use <a class="el" href="group__cxxinterface.html#gae58492af3631a196b0edb8a8ebcda567" title="serves as the value &quot;plus infinity&quot;, i.e., all bounds &gt;= this value are set to this value and are reg...">ConicBundle::CB_minus_infinity</a> for unbounded below.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ubounds</td><td>(const Matrix*) If NULL, all appended variables are considered unbounded above, otherwise ubounds[i] gives the maximum feasible value for variable y[i], use <a class="el" href="group__cxxinterface.html#ga15948e7611155f822fc0331bcbb4a111" title="serves as the value &quot;minus infinity&quot;, i.e., all bounds &lt;= this value are set to this value and are re...">ConicBundle::CB_plus_infinity</a> for unbounded above.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constraint_columns</td><td>(const Sparsemat*) This must be NULL unless <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a7fbdae68564966efb65943793cbd55b8" title="append  as linear constraints on the groundset variables .  has append_n_rows new rows with coefficie...">append_constraints()</a> has been used before for specifying linear constraints on the ground set; if there are constraints, NULL is interpreted as appending zero columns to the constraints, otherwise the the number of rows of the Sparsemant has to match the current number of linear constraints and the number of columns the must equal n_append.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startval</td><td>(const Matrix*) If NULL, the starting values are obtained by projecting zero onto the feasible set given by the lower and upper bounds resulting from the arguments before</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">costs</td><td>(const Matrix*) Use this in order to specify linear costs on the variables in addition to the functions (may be convenient in Lagrangean relaxation for the right hand side of coupling contsraints); NULL is equivalent to costs zero.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">affected_functions_with_modifications</td><td>(const FunObjModMap*) If NULL, default actions are performed on all functions. In particular, those admitting dynamic argument changes will get the new variables appended at the end of their argument vector and (eventually) their apply_modification() routines will be called informing them about the groundset changes; for those not admitting changes in their arguments, their corresponding (possibly newly created) affine function transformation will be set up to ignore the new arguments. If !=NULL, for the listed functions (and their parents up to the root function) the default appending action is performed unless their <a class="el" href="classConicBundle_1_1FunctionObjectModification.html" title="abstract interface for informing the bundle model routines about changes in the oracle function and...">FunctionObjectModification</a> entry gives explicit modification instructions which are then applied instead. For all functions NOT listed in the map and not having modified offsprings their corresponding aft will be set up to ignore the new variables.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6bd691c7cb860f7f52c39ea3a28b5b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd691c7cb860f7f52c39ea3a28b5b63">&#9670;&nbsp;</a></span>call_primal_extender()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::call_primal_extender </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1PrimalExtender.html">PrimalExtender</a> &amp;&#160;</td>
          <td class="paramname"><em>primal_extender</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asks <em>function</em> to call <em>primal_extender</em> for each of its primal objects (see also <a class="el" href="classConicBundle_1_1FunctionOracle.html#a10d135676ae61d26bb068fadef2526d3" title="Called by the solver. Has to Return function value and at least one (epsilon) subgradient and...">FunctionOracle::evaluate()</a> ) </p>
<p>If the function is the Lagrangian dual of a primal problem and primal_data returned previous calls to the oracle has now to be updated due to changes in the primal problem &ndash; e.g., this may happen in column generation &ndash; the call causes updates of all internally stored primal_data objects by calling <a class="el" href="classConicBundle_1_1PrimalExtender.html#a13fc586276e23d575b935dbfe12495c0" title="called by ConicBundle to update internal PrimalData objects, has to return 0 on success ...">PrimalExtender::extend</a> on each of these.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>(const <a class="el" href="classConicBundle_1_1FunctionObject.html" title="basic function object (abstract class). It serves for using the same interface on distinct oracle typ...">FunctionObject</a>&amp;) the function added in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a3c503663b689ede0f1d004690d622e2f" title="Adds a function, typically derived from ConicBundle::FunctionOracle. If the dimension does not match ...">add_function()</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">primal_extender</td><td>(<a class="el" href="classConicBundle_1_1PrimalExtender.html" title="Interface for extending PrimalData, e.g., in Lagrangian relaxation of column generation approaches...">PrimalExtender</a>&amp;) the object holding the extension function for primal_data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>1 if for this function it is not possible to use a primal_extender</li>
<li>2 if the primal_extender would be applicable but there is no primal_data </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac9ccd3f15e30b2b8cca374ade4fc67db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ccd3f15e30b2b8cca374ade4fc67db">&#9670;&nbsp;</a></span>clear_aggregates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::clear_aggregates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> *&#160;</td>
          <td class="paramname"><em>function</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the aggregate parts of the cutting model of this <em>function</em> (but only for the given one, not recursively) </p>
<p>There should be no need to call this if the modification routines of this interface were used correctly. If, however, the oracle is modified by other means outside this interface, this has to be called whenever the specified function was modified so that the old aggregate subgradients and/or primal generators are no longer valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>(const <a class="el" href="classConicBundle_1_1FunctionObject.html" title="basic function object (abstract class). It serves for using the same interface on distinct oracle typ...">FunctionObject</a>&amp;) the function added in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a3c503663b689ede0f1d004690d622e2f" title="Adds a function, typically derived from ConicBundle::FunctionOracle. If the dimension does not match ...">add_function()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9eeac5ece21d05a387eea9f755b15bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eeac5ece21d05a387eea9f755b15bff">&#9670;&nbsp;</a></span>clear_fail_counts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConicBundle::MatrixCBSolver::clear_fail_counts </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>clears all fail counts on numerical function oder model failures, may be useful if this caused premature termination. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6396522aada2447cf05b5e699adbd0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6396522aada2447cf05b5e699adbd0f7">&#9670;&nbsp;</a></span>delete_variables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::delete_variables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>delete_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>map_to_old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceConicBundle.html#ad078c3e597a104edaccd983cddf6a134">FunObjModMap</a> *&#160;</td>
          <td class="paramname"><em>affected_functions_with_modifications</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes variables corresponding to the specified indices. </p>
<p>The indices of the remaining variables are reassigned so that they are consecutive again, the routine returns in <em>map_to_old</em> a vector giving for each new index of these remaining variables the old coordinate.</p>
<dl class="section attention"><dt>Attention</dt><dd>Be sure to include a desription of required changes to your functions via <em>affected_functions_with_modifications</em> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delete_indices</td><td>(const Indexmatrix&amp;) the entries delete_indices[i] specify the indices of the variables to be deleted</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">map_to_old</td><td>(Indexmatrix&amp;) after the call, element map_to_old[i] gives the old index (before the call) of the variable that now has index position i.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">affected_functions_with_modifications</td><td>(const FunObjModMap*) If NULL, default actions are performed on all functions. In particular, for those admitting dynamic argument changes all those variables will be deleted whose row in a corresponding updated affine function transformation (so after deletion of the columns of the incoming variables) corresponds to the zero map (i.e., offset and matrix row are both zero), furthermore identity transformations will be preserved. For those not admitting changes in their arguments, their corresponding (possibly newly created) affine function transformation will only get the columns deleted, but there will be no row deleltions. If !=NULL, for the listed functions (and their parents up to the root function) the default deletion action is performed unless their <a class="el" href="classConicBundle_1_1FunctionObjectModification.html" title="abstract interface for informing the bundle model routines about changes in the oracle function and...">FunctionObjectModification</a> entry gives explicit modification instructions which are then applied instead. For all functions NOT listed in the map and not having modified offsprings their corresponding aft will be set up to keep the arguments unchanged.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af4b7d14796c16870dca8b563846be351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b7d14796c16870dca8b563846be351">&#9670;&nbsp;</a></span>get_approximate_primal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a>* ConicBundle::MatrixCBSolver::get_approximate_primal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the current approximate primal solution corresponding to the aggregate subgradient of the specified <em>function</em>. </p>
<p><a class="el" href="classConicBundle_1_1PrimalData.html" title="In Lagrangean relaxation an approximate primal solution can be generated by supplying primal informat...">PrimalData</a> solutions must have been supplied in all previous calls to evaluate; In this case it returns the current approximate primal solution aggregated alongside with the aggregate subgradient. A primal solution may not be available after addition of constraints, if extension of the aggregate subgradient to the new coordinates failed. If no primal data is availalbe, the function returns NULL.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>pointer to the primal data of the aggregate of this function object</li>
<li>0 if no primal is available </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1a5cb1975f8e70693c76711ba3211237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5cb1975f8e70693c76711ba3211237">&#9670;&nbsp;</a></span>get_approximate_slacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::get_approximate_slacks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the multipliers for the box constraints on the design variables; in Lagrangean relaxation they may be interpreted as primal slacks for inequality constraints. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a94ddbbdc191a5d213536626c2de77807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ddbbdc191a5d213536626c2de77807">&#9670;&nbsp;</a></span>get_bundle_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classConicBundle_1_1BundleData.html">BundleData</a>* ConicBundle::MatrixCBSolver::get_bundle_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> *&#160;</td>
          <td class="paramname"><em>function</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all current bundle data of the cutting model of the specified <em>function</em>. </p>
<p>This may differ for predefined special functions with derived classes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>if the aggregate subgradient of a particular function is desired, provide the pointer here, otherwise this referrs to the root function (if there is only one function to be optimized over, this is this single function, otherwise it is the sum of functions)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1fe69e8bb6dea059f2e82637c368cb9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe69e8bb6dea059f2e82637c368cb9e">&#9670;&nbsp;</a></span>get_bundle_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classConicBundle_1_1BundleParameters.html">BundleParameters</a>* ConicBundle::MatrixCBSolver::get_bundle_parameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> *&#160;</td>
          <td class="paramname"><em>function</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves current bundle parameters (not the actual size in use!) as set for the cutting model of the specified <em>function</em>. </p>
<p>This may differ for predefined special functions with derived BundleParameter classes.</p>
<p>If the code is asked to optimize over the sum of several functions, it usually does this with a separate model for each function. If there are too many function for this, it may be worth to consider using the <a class="el" href="classConicBundle_1_1SumBundle.html" title="class for use with SumBlockModel and BundlData for storing and managing a common bundle describing (p...">SumBundle</a> features. For this see also <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a22f7db55ed7f890ea2bff768132aa98a" title="Specifies the behavior of the model (of the specified function) concerning requests to join or start ...">set_sumbundle_parameters()</a>. If the root function is a sum of functions, passing a <a class="el" href="classConicBundle_1_1SumModelParametersObject.html" title="abstract interface for SumModel for the models selection routine when using SumBundle and SumBundleHa...">SumModelParametersObject</a> here allows to specify how many local models should be kept by <a class="el" href="classConicBundle_1_1SumModelParametersObject.html#a13c245450c162acba0d83e7c728da570" title="returns the value of the variable ">SumModelParametersObject::set_max_local_models()</a> and how these should be selected. A possible implementation for this is given in <a class="el" href="classConicBundle_1_1SumModelParameters.html" title="specifies the suggestion procedure for including models in a joint SumBundle model of SumModel ...">SumModelParameters</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>if the aggregate subgradient of a particular function is desired, provide the pointer here, otherwise this referrs to the root function (if there is only one function to be optimized over, this is this single function, otherwise it is the sum of functions)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2b54517bd8cf0560496780f1e8e1f466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b54517bd8cf0560496780f1e8e1f466">&#9670;&nbsp;</a></span>get_candidate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::get_candidate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last point, the "candidate", at which the function was evaluated in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a2dbe46bc6b34684ea4895f8527e3c493" title="solves or does a prescribed number of iterations ">solve()</a>. </p>
<p>If this evaluation lead to a descent step, it is the same point as in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a40b4df10fa42d417881ec55fad3616cd" title="Returns the next center point that was produced by the latest call to solve (in some problem modifica...">get_center()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9dc35e4d2b6da750e0b3ef4d557382bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc35e4d2b6da750e0b3ef4d557382bd">&#9670;&nbsp;</a></span>get_candidate_primal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a>* ConicBundle::MatrixCBSolver::get_candidate_primal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the primal solution corresponding to the best epsilon subgradient returned in the evaluation of the specified <em>function</em> at the point get_candidate. If no primal data is availalbe, the function returns NULL. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>pointer to the primal data of the minorant returned on evaluation of this function object at the current candidate</li>
<li>0 if no primal is available </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0ced32fd45dc87f1fb652694b95cfec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ced32fd45dc87f1fb652694b95cfec0">&#9670;&nbsp;</a></span>get_candidate_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ConicBundle::MatrixCBSolver::get_candidate_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the objective value computed in the last step of <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a2dbe46bc6b34684ea4895f8527e3c493" title="solves or does a prescribed number of iterations ">solve()</a>, independent of whether this was a descent step or a null step (initially undefined). </p>
<p>If no problem modification routines were called since then, it is the objective value at the point returned by <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a2b54517bd8cf0560496780f1e8e1f466" title="Returns the last point, the &quot;candidate&quot;, at which the function was evaluated in solve(). ">get_candidate()</a>. If this last evaluation led to a descent step, then it is the same value as in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#abadd5d33331ac8f52bb435a11d04a802" title="Returns the objective value resulting from last descent step (initially undefined). If no problem modification routines were called since then, it is the objective value at the point returned by get_center(). ">get_objval()</a>. </p>

</div>
</div>
<a id="a40b4df10fa42d417881ec55fad3616cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b4df10fa42d417881ec55fad3616cd">&#9670;&nbsp;</a></span>get_center()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::get_center </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the next center point that was produced by the latest call to solve (in some problem modification routines the center point may be updated immediately, in others the center point will be corrected automatically directly before starting the next descent step and its values may be infeasible till then). </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab235825803483082634a30604b11d730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab235825803483082634a30604b11d730">&#9670;&nbsp;</a></span>get_center_primal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a>* ConicBundle::MatrixCBSolver::get_center_primal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the primal solution corresponding to the best epsilon subgradient returned in the evaluation of the specified <em>function</em> at the current center point. If no primal data is availalbe, the function returns NULL. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>pointer to the primal data of the minorant returned on evaluation of this function object at the current center</li>
<li>0 if no primal is available </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af393b1adabcb36675959e2e3db8e69d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af393b1adabcb36675959e2e3db8e69d3">&#9670;&nbsp;</a></span>get_descent_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ConicBundle::MatrixCBSolver::get_descent_step </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if the last evaluation of the last call to <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a2dbe46bc6b34684ea4895f8527e3c493" title="solves or does a prescribed number of iterations ">solve()</a> resulted in a descent step </p>
<p>Mind: if there was no (succesdful) evaluation, neither <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#af393b1adabcb36675959e2e3db8e69d3" title="returns true if the last evaluation of the last call to solve() resulted in a descent step ...">get_descent_step()</a> nor <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a4c8399102676d5acb8acd1e0b0fdc391" title="returns true if the last evaluation of the last call to solve() resulted in a null step ...">get_null_step()</a> will return true; </p>

</div>
</div>
<a id="a8715eb8a6c956d314a108c8fd29636f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8715eb8a6c956d314a108c8fd29636f7">&#9670;&nbsp;</a></span>get_fixed_active_bounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a>* ConicBundle::MatrixCBSolver::get_fixed_active_bounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns NULL or (iff active bound fixing is turned on in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a5229f01c537d914a60b896bf01e550d5" title="If set to true (the default is false), variables may be fixed automatically to active bounds if these...">set_active_bounds_fixing()</a>) the indicator vector of variables temporarily fixed to the center value due to significantly positive multipliers for the box constraints. </p>
<p>A variable gets fixed to the bound only if the center is already a the bound and in some iteration the dual variables to the bound constraint indicate that the bound is strongly active also for the candidate. Of course this migh just hold for one candidate and there is no guarantee that the bound is also strongly active in an optimal solution. Thus, this mainly a heuristic to eliminate less important variables quickly from entering the subproblem. </p>

</div>
</div>
<a id="a4c8399102676d5acb8acd1e0b0fdc391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8399102676d5acb8acd1e0b0fdc391">&#9670;&nbsp;</a></span>get_null_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ConicBundle::MatrixCBSolver::get_null_step </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if the last evaluation of the last call to <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a2dbe46bc6b34684ea4895f8527e3c493" title="solves or does a prescribed number of iterations ">solve()</a> resulted in a null step </p>
<p>Mind: if there was no (successful) evaluation, neither <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#af393b1adabcb36675959e2e3db8e69d3" title="returns true if the last evaluation of the last call to solve() resulted in a descent step ...">get_descent_step()</a> nor <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a4c8399102676d5acb8acd1e0b0fdc391" title="returns true if the last evaluation of the last call to solve() resulted in a null step ...">get_null_step()</a> will return true; </p>

</div>
</div>
<a id="a2fd6f3f086d74c501363141c7ed1589d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd6f3f086d74c501363141c7ed1589d">&#9670;&nbsp;</a></span>get_subgradient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::get_subgradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>subgradient</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the latest aggregate subgradient (of the entire problem with groundset as provided by the solver) </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5129b50d68be01aaa8cb6825058a8f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5129b50d68be01aaa8cb6825058a8f13">&#9670;&nbsp;</a></span>init_problem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::init_problem </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *&#160;</td>
          <td class="paramname"><em>lbounds</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *&#160;</td>
          <td class="paramname"><em>ubounds</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *&#160;</td>
          <td class="paramname"><em>startval</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *&#160;</td>
          <td class="paramname"><em>costs</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the problem by setting up the design space (the dimension and possibly box constraints on the variables) </p>
<p>Clears all data structures and sets the dimension @ m for a new problem. for solving min_{y in R^m} f_0(y) + f_1(y) + ... Box constraints may be specified for y. (The functions f_i must be added by <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a3c503663b689ede0f1d004690d622e2f" title="Adds a function, typically derived from ConicBundle::FunctionOracle. If the dimension does not match ...">add_function()</a>).</p>
<p>Lower and/or upper bounds must be speicified for all variables or for none of them. To specify no bounds at all, give Null pointers. Otherwise use <a class="el" href="group__cxxinterface.html#gae58492af3631a196b0edb8a8ebcda567" title="serves as the value &quot;plus infinity&quot;, i.e., all bounds &gt;= this value are set to this value and are reg...">ConicBundle::CB_minus_infinity</a> for unbounded below and <a class="el" href="group__cxxinterface.html#ga15948e7611155f822fc0331bcbb4a111" title="serves as the value &quot;minus infinity&quot;, i.e., all bounds &lt;= this value are set to this value and are re...">ConicBundle::CB_plus_infinity</a> for unbounded above. For NULL pointers, unbounded will be used as default for all variables. Specifying bounds selectively is also possible by <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a19c58b9c760b4efab9a59e9cca03f0a7" title="Sets lower bound for variable i, use ConicBundle::CB_minus_infinity for unbounded from below...">set_lower_bound()</a> or <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a10bd1df5d2d7114c96f7cae063385109" title="Sets upper bound for variable i, use ConicBundle::CB_plus_infinity for unbounded from below...">set_upper_bound()</a>. For further constraints see <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a7fbdae68564966efb65943793cbd55b8" title="append  as linear constraints on the groundset variables .  has append_n_rows new rows with coefficie...">append_constraints()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>(int) the dimension of the argument/design space/the number of Lagrange multipliers</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lbounds</td><td>(const Matrix*) If NULL, all variables are considered unbounded below, otherwise lbounds[i] gives the minimum feasible value for variable y[i], use <a class="el" href="group__cxxinterface.html#gae58492af3631a196b0edb8a8ebcda567" title="serves as the value &quot;plus infinity&quot;, i.e., all bounds &gt;= this value are set to this value and are reg...">ConicBundle::CB_minus_infinity</a> for unbounded below.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ubounds</td><td>(const Matrix*) If NULL, all variables are considered unbounded above, otherwise ubounds[i] gives the maximum feasible value for variable y[i], use <a class="el" href="group__cxxinterface.html#ga15948e7611155f822fc0331bcbb4a111" title="serves as the value &quot;minus infinity&quot;, i.e., all bounds &lt;= this value are set to this value and are re...">ConicBundle::CB_plus_infinity</a> for unbounded above.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startval</td><td>(const Matrix*) If NULL, the starting values are obtained by projecting zero onto the feasible set given by the lower and upper bounds resulting from the arguments before</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">costs</td><td>(const Matrix*) Use this in order to specify linear costs on the variables in addition to the functions (may be convenient in Lagrangean relaxation for the right hand side of coupling contsraints); NULL is equivalent to costs zero.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>(Real) Use this in order to specify linear costs on the variables in addition to the functions (may be convenient in Lagrangean relaxation for the right hand side of coupling contsraints); NULL is equivalent to costs zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a3a2fd1cb66cdd565a81879de422e45db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2fd1cb66cdd565a81879de422e45db">&#9670;&nbsp;</a></span>print_termination_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; ConicBundle::MatrixCBSolver::print_termination_code </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a text version of termination code, see <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a67e4eaa9ce3bd66f52387ccaa59908de" title="Returns the termination code of the bundle algorithm for the latest descent step. ...">termination_code()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a70afdaf44c7f80f69beafb1e1335ab8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70afdaf44c7f80f69beafb1e1335ab8c">&#9670;&nbsp;</a></span>reassign_variables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::reassign_variables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>assign_new_from_old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceConicBundle.html#ad078c3e597a104edaccd983cddf6a134">FunObjModMap</a> *&#160;</td>
          <td class="paramname"><em>affected_functions_with_modifications</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reassigns variables to new index positions by mapping to position <em>i</em> the variable that previously had index <em>assign_new_from_old</em>[i]. </p>
<p>Old variables, that are not mapped to any position will be deleted. It is not allowed to generate several copies of old variables.</p>
<dl class="section attention"><dt>Attention</dt><dd>Be sure to include a desription of required changes to your functions via <em>affected_functions_with_modifications</em> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">assign_new_from_old</td><td>(const IVector&amp;) entry assign_new_from_old[i] specifies the old index of the variable, that has to be copied to index position i.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">affected_functions_with_modifications</td><td>(const FunObjModMap*) If NULL, default actions are performed on all functions. In particular, for those admitting dynamic argument changes all those variables will be deleted whose row in a corresponding updated affine function transformation (so after mapping the columns of the incoming variables) correspond to the zero map (i.e., offset and matrix row are both zero); furthermore, if the transformation was the identity to start with, this will be preserved by mapping the arguments in the same way. For those not admitting changes in their arguments, their corresponding (possibly newly created) affine function transformation will only get the columns mapped, but there will be no row deleltions. If !=NULL, for the listed functions (and their parents up to the root function) the default deletion action is performed unless their <a class="el" href="classConicBundle_1_1FunctionObjectModification.html" title="abstract interface for informing the bundle model routines about changes in the oracle function and...">FunctionObjectModification</a> entry gives explicit modification instructions which are then applied instead. For all functions NOT listed in the map and not having modified offsprings their corresponding aft will be set up to keep the arguments unchanged.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6bbc394d1c05f92597eec01c0f45b516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bbc394d1c05f92597eec01c0f45b516">&#9670;&nbsp;</a></span>reinit_function_model()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::reinit_function_model </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> *&#160;</td>
          <td class="paramname"><em>function</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears cutting model, subgradients and stored function values for the specified <em>function</em> (but only for the given one, not recursively) </p>
<p>There should be no need to call this if the modification routines of this interface were used correctly. If, however, the oracle is modified by other means outside this interface, this has to be called whenever the specified function was modified so that the old subgradients and/or primal generators are no longer valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>if the aggregate subgradient of a particular function is desired, provide the pointer here, otherwise this referrs to the root function (if there is only one function to be optimized over, this is this single function, otherwise it is the sum of functions)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5229f01c537d914a60b896bf01e550d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5229f01c537d914a60b896bf01e550d5">&#9670;&nbsp;</a></span>set_active_bounds_fixing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConicBundle::MatrixCBSolver::set_active_bounds_fixing </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_fixing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If set to true (the default is false), variables may be fixed automatically to active bounds if these are strongly active (i.e., the corresponding multipliers are big) and the center values are also right on these bounds already. </p>
<p>The coordinates to be fixed are redetermined in each call following a descent step or a change of the function. An indicator vector of the variables fixed during the last call can be obtained via the routine <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a8715eb8a6c956d314a108c8fd29636f7" title="Returns NULL or (iff active bound fixing is turned on in set_active_bounds_fixing()) the indicator ve...">get_fixed_active_bounds()</a>.</p>
<p>Setting this value to true might improve the performance of the algorithm in some instances but there is no convergence theory. It might be particularly helpful within Lagrangian relaxation if a primal cutting plane approach is used and non-tight inequalities should be eliminated quickly (fixing then indicates large primal slack values as these are the dual variables to the bounds on the Lagrange mulitpliers). Furthermore, if the value of a variable is fixed to zero, the variable can typically be deleted without affecting the validity of the current cutting model and function values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allow_fixing</td><td>(bool)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a84a880b17fbf8146a5347532f6491874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a880b17fbf8146a5347532f6491874">&#9670;&nbsp;</a></span>set_bundle_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_bundle_parameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1BundleParameters.html">BundleParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> *&#160;</td>
          <td class="paramname"><em>function</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum bundlesize and the maximum number of new subgradients added in a bundle update of the cutting model for the specified <em>function</em>. The meaning of this routine may differ from standard for predefined special functions with special bundle types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>(const <a class="el" href="classConicBundle_1_1BundleParameters.html" title="Serves for specifying parameters regarding the construction of cutting models. ">BundleParameters</a>&amp;) some update parameters for the cutting model, see e.g. <a class="el" href="classConicBundle_1_1BundleParameters.html" title="Serves for specifying parameters regarding the construction of cutting models. ">ConicBundle::BundleParameters</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>if the aggregate subgradient of a particular function is desired, provide the pointer here, otherwise this referrs to the root function (if there is only one function to be optimized over, this is this single function, otherwise it is the sum of functions)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a85a8da56a2730b8d08b48aaff486c6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a8da56a2730b8d08b48aaff486c6bb">&#9670;&nbsp;</a></span>set_eval_limit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConicBundle::MatrixCBSolver::set_eval_limit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a>&#160;</td>
          <td class="paramname"><em>eval_limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an upper bound on the number of calls to the oracle (use negative numbers for no limit). </p>
<p>If this number is reached, the algorithm will terminate independently of whether the last step was a descent or a null step. A negative number will be interepreted as no limit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eval_limit</td><td>(Integer)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a16b3c9fd487084ef3cba0477f583f776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b3c9fd487084ef3cba0477f583f776">&#9670;&nbsp;</a></span>set_inner_update_limit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConicBundle::MatrixCBSolver::set_inner_update_limit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a>&#160;</td>
          <td class="paramname"><em>update_limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an upper bound on the number of inner updates for the cutting model with primal slacks within one null step (use negative numbers for no limit). </p>
<p>A negative number will be interepreted as no limit, i.e., the updates will be done till a certain precision of the cutting model is achieved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">update_limit</td><td>(Integer)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a19c58b9c760b4efab9a59e9cca03f0a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c58b9c760b4efab9a59e9cca03f0a7">&#9670;&nbsp;</a></span>set_lower_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_lower_bound </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets lower bound for variable i, use <a class="el" href="group__cxxinterface.html#gae58492af3631a196b0edb8a8ebcda567" title="serves as the value &quot;plus infinity&quot;, i.e., all bounds &gt;= this value are set to this value and are reg...">ConicBundle::CB_minus_infinity</a> for unbounded from below. </p>
<p>The algorithm may have to adapt the center point aftwards. In this case the old function values will be marked as outdated and will be recomputed at the next call to e.g. <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a2dbe46bc6b34684ea4895f8527e3c493" title="solves or does a prescribed number of iterations ">solve()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7999e132e8805b3f502e032a5ca7789f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7999e132e8805b3f502e032a5ca7789f">&#9670;&nbsp;</a></span>set_max_bundlesize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_max_bundlesize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_bundlesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> *&#160;</td>
          <td class="paramname"><em>function</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum number of subgradients stored for use in forming the model or determining scaling information, it must be as least as large as max_modelsize (and is increased to this if not) </p>
<p>The meaning of this routine may differ from standard for predefined special functions with special bundle types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_bundlesize</td><td>(int) maximum number of subgradients stored for use in forming the model</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>if the aggregate subgradient of a particular function is desired, provide the pointer here, otherwise this referrs to the root function (if there is only one function to be optimized over, this is this single function, otherwise it is the sum of functions)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae9d75ed655c21685940158905beef39d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d75ed655c21685940158905beef39d">&#9670;&nbsp;</a></span>set_max_modelsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_max_modelsize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_modelsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> *&#160;</td>
          <td class="paramname"><em>function</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum number of subgradients used in forming the cutting model of the specified <em>function</em>. </p>
<p>Quite often a very small model, e.g., 2, yields very fast iterations and good progress in time (sometimes at the cost of more evaluations). By limited numerical experience, a significant reduction in the number of evaluations can only be expected if the bundle is large enough to wrap the function rather tightly. Quite frequently, unfortunately, this entails that solving the quadratic subproblems is more expensive than function evaluation.</p>
<p>The meaning of this routine may differ from standard for predefined special functions with special bundle types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_modelsize</td><td>(int) maximum number of subgradients to be used in forming the cutting model</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>if the aggregate subgradient of a particular function is desired, provide the pointer here, otherwise this referrs to the root function (if there is only one function to be optimized over, this is this single function, otherwise it is the sum of functions)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="abd2d01b507839451c91d6574c02113c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd2d01b507839451c91d6574c02113c2">&#9670;&nbsp;</a></span>set_max_weight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_max_weight </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>max_weight</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an upper bound on the weight for the quadratic term of the augmented subproblem. </p>
<p>Nonpositive values indicate no bound. The new value shows its effect only at first dynamic change of the weight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_weight</td><td>(double)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6f10280eeddb360806951729b076e026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f10280eeddb360806951729b076e026">&#9670;&nbsp;</a></span>set_min_weight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_min_weight </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>min_weight</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a lower bound on the weight for the quadratic term of the augmented subproblem. </p>
<p>Nonpositive values indicate no bound. The new value shows its effect only at first dynamic change of the weight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">min_weight</td><td>(double)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac7f0864cfbc01e3f9c057234069423ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f0864cfbc01e3f9c057234069423ba">&#9670;&nbsp;</a></span>set_new_center_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_new_center_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>center_point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the starting point/center that will be used in the next call to <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a2dbe46bc6b34684ea4895f8527e3c493" title="solves or does a prescribed number of iterations ">solve()</a>. Each call to this routine causes an immediate evaluation of all oracles. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="acaa42c46986ad62af21555340346dcf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa42c46986ad62af21555340346dcf4">&#9670;&nbsp;</a></span>set_next_weight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_next_weight </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>weight</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the weight (&gt;0) to be used in the quadratic term of the next augmented subproblem (may be interpreted as 1./step_size or 1./trustregion-radius). </p>
<p>Independent of whether the weight violates current min- and max-bounds set in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a6f10280eeddb360806951729b076e026" title="Sets a lower bound on the weight for the quadratic term of the augmented subproblem. ">set_min_weight()</a> and <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#abd2d01b507839451c91d6574c02113c2" title="Sets an upper bound on the weight for the quadratic term of the augmented subproblem. ">set_max_weight()</a>, the next model will be computed for this value. Thereafter, however, it will be updated as usual; in particular, it may be truncated by min and max bounds immediately after the first subproblem.</p>
<p>In order to guarantee a constant weight (e.g. 1 is frequently a reasonable choice if the automatic default heuristic performs poorly), set the min and max bounds to the same value, too.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>(double)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a370c6ee0dd593962cbb39927a56d6bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370c6ee0dd593962cbb39927a56d6bce">&#9670;&nbsp;</a></span>set_out()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConicBundle::MatrixCBSolver::set_out </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>out</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>print_level</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies the output level (out==NULL: no output at all, out!=NULL and level=0: errors and warnings, level&gt;0 increasingly detailed information) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>(std::ostream*) direct all output to (*out). If out==NULL, there will be no output at all.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">print_level</td><td>(int)</td></tr>
  </table>
  </dd>
</dl>
<p>Output levels for print_level:</p><ul>
<li>0 ... no output except for errors and warnings</li>
<li>1 ... line summary after each descent step</li>
<li>&gt;1 ... undocumented and increasingly detailed log information. These higher levels should only be used if requested for debugging purposes.</li>
</ul>
<p>Example for level 1:</p>
<pre class="fragment">00:00:00.00 endit  1   1   1   563.    563.  39041.188  39043.162
00:00:00.00 endit  2   2   2   563.    559.  38488.165  38490.200
00:00:00.00 endit  3   3   3   56.3    555.  33014.533  33211.856
00:00:00.00 endit  4   4   4   5.63    517. -14306.459  2738.0343
00:00:00.00 endit  5   5   5   4.04    148. -2692.1131  2.2150883
00:00:00.00 endit  6   6   6   4.01    1.29  1.7908952  2.0000581
00:00:00.00 endit  7   7   7   3.95  0.0213  1.9999387  2.0000000
00:00:00.00 _endit  8   8   8   3.95 2.94e-05  2.0000000  2.0000000

Column 1      2     3   4   5    6       7       8          9
</pre><ul>
<li>Column 1: computation time in hh:mm:ss.dd,</li>
<li>Column 2: "endit" is convenient for grep and stands for "end of iteration". Iterations with <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a67e4eaa9ce3bd66f52387ccaa59908de" title="Returns the termination code of the bundle algorithm for the latest descent step. ...">termination_code()</a>!=0 are marked with "_endit".</li>
<li>Column 3: number of descent steps</li>
<li>Column 4: number of descent and null steps. Up to initialization calls and reevaluations, this is the number of evaluation calls to the function oracles from within the bundle method. In the example all calls led to descent steps.</li>
<li>Column 5: number of innermost iterations. It differs from column 5 only in the case of variables with bounds in which case it gives the number of updates of the multipliers for the bounds (or primal slacks in Lagrangean relaxation). Exceedingly high numbers in this column indicate that some variables are constantly at their bounds and it might be possible to improve convergence by deleting them (i.e. set them as constants to this bound and remove the variable).</li>
<li>Column 6: the weight of the quadratic term in the augmented problem.</li>
<li>Column 7: the norm of the aggregate subgradient. If it is small, say below 0.1, then mostly this is good indication that the objective value is close to optimal.</li>
<li>Column 8: the value of the cutting model in the last candidate point. It is always a lower bound on the true function value in this point</li>
<li>Column 9: the objective value in the latest point that led to a descent step, i.e., the point returend by <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a40b4df10fa42d417881ec55fad3616cd" title="Returns the next center point that was produced by the latest call to solve (in some problem modifica...">get_center()</a>. Whenever <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a67e4eaa9ce3bd66f52387ccaa59908de" title="Returns the termination code of the bundle algorithm for the latest descent step. ...">termination_code()</a> returns 0 this is also the objective value of the latest evaluation call to the function oracles and the value in the center point of the next iteration. </li>
</ul>

<p>Reimplemented from <a class="el" href="classConicBundle_1_1CBout.html#aed9a878aa9f402077e1f6453c0606535">ConicBundle::CBout</a>.</p>

</div>
</div>
<a id="a1ca9ca6eb41bb842f12f693292913416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca9ca6eb41bb842f12f693292913416">&#9670;&nbsp;</a></span>set_prox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_prox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1BundleProxObject.html">BundleProxObject</a> *&#160;</td>
          <td class="paramname"><em>proxp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For variable metric install the <a class="el" href="classConicBundle_1_1BundleProxObject.html" title="abstract interface that allows to use different -norms  with a positive definite matrix  in the proxi...">BundleProxObject</a> pointed to; the object is passed to the solver who will delete it on termination or when replaced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">proxp</td><td>(BundleProxObject*) replace the current <a class="el" href="classConicBundle_1_1BundleProxObject.html" title="abstract interface that allows to use different -norms  with a positive definite matrix  in the proxi...">BundleProxObject</a> by this object on the heap; NULL is allowed and results in the default choice; the object pointed to will be deleted by the solver</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2774c490b9a290bacfdfa60c07c0809c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2774c490b9a290bacfdfa60c07c0809c">&#9670;&nbsp;</a></span>set_sumbundle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_sumbundle </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_sumbundle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_local_models</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1BundleParameters.html">BundleParameters</a> *&#160;</td>
          <td class="paramname"><em>bundle_parameters</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>strategy</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts/ends the use of a common <a class="el" href="classConicBundle_1_1SumBundle.html" title="class for use with SumBlockModel and BundlData for storing and managing a common bundle describing (p...">SumBundle</a> of the given bundle_size with a heuristic rule for selecting up to n_local_models in each bundle iteration. </p>
<p>If the function is the sum of many functions, having a local model for every one of them may result in a huge quadratic subproblem. It may then be better to form a common model of most of the functions, where a heuristic dynamically selects a few of the functions, for which a local model seems worth while. Whether such a common model should be used, how many subgradients it should contain, and how many local models are to be selected at most are the parameters set here.</p>
<p>Setting these parameters only has an effect if bundle models of functions are present. If further functions are added later, the call should be repeated.</p>
<p>This interface provides a simpler access to the <a class="el" href="classConicBundle_1_1SumBundle.html" title="class for use with SumBlockModel and BundlData for storing and managing a common bundle describing (p...">SumBundle</a> features by using some default parameter choices that could be set separately in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a84a880b17fbf8146a5347532f6491874" title="Sets the maximum bundlesize and the maximum number of new subgradients added in a bundle update of th...">set_bundle_parameters()</a> and <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a22f7db55ed7f890ea2bff768132aa98a" title="Specifies the behavior of the model (of the specified function) concerning requests to join or start ...">set_sumbundle_parameters()</a> in a refined way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">use_sumbundle</td><td>(bool) use value true to switch the sumbundle on, use value false to switch it off</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_local_models</td><td>(int) upper bound on the number of local models to be used on top of the sumbundle's model, negative values correspond to no upper bound and all functions may have local models</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bundle_parameters</td><td>(const BundleParameters*) the maximum number of subgradients to be used in forming the <a class="el" href="classConicBundle_1_1SumBundle.html" title="class for use with SumBlockModel and BundlData for storing and managing a common bundle describing (p...">SumBundle</a> model, values &lt;=1 are set to 2;</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strategy</td><td>(int) this is currently in experimental stage and allows to choose among some internal sumbundle strategies (currently 0,1,2,11 are available)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a22f7db55ed7f890ea2bff768132aa98a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f7db55ed7f890ea2bff768132aa98a">&#9670;&nbsp;</a></span>set_sumbundle_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_sumbundle_parameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1SumBundleParametersObject.html">SumBundleParametersObject</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> *&#160;</td>
          <td class="paramname"><em>function</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the behavior of the model (of the specified function) concerning requests to join or start a <a class="el" href="classConicBundle_1_1SumBundle.html" title="class for use with SumBlockModel and BundlData for storing and managing a common bundle describing (p...">SumBundle</a> that subsumes several models instead of providing a separate model for each funciton. </p>
<p>The abstract interface for these Parameters is specified in <a class="el" href="classConicBundle_1_1SumBundleParametersObject.html" title="abstract interface for SumBundleHandler for the model selection and variable metric seletcion routine...">SumBundleParametersObject</a>, a concrete implementation is <a class="el" href="classConicBundle_1_1SumBundleParameters.html" title="implements two versions of select_model() (update_rule in {0,1}) ">SumBundleParameters</a>. Besides the usual <a class="el" href="classConicBundle_1_1BundleParameters.html" title="Serves for specifying parameters regarding the construction of cutting models. ">BundleParameters</a> the new main parameter is specified in <a class="el" href="classConicBundle_1_1SumBundleParametersObject.html#a8e768aa790d290ff839c7fbc97b18cf2" title="specifies the sumbundle modes the model accepts ">SumBundleParametersObject::set_acceptable_mode()</a>, see there.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>(const <a class="el" href="classConicBundle_1_1BundleParameters.html" title="Serves for specifying parameters regarding the construction of cutting models. ">BundleParameters</a>&amp;) some update parameters for the cutting model, see e.g. <a class="el" href="classConicBundle_1_1BundleParameters.html" title="Serves for specifying parameters regarding the construction of cutting models. ">ConicBundle::BundleParameters</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>if the aggregate subgradient of a particular function is desired, provide the pointer here, otherwise this referrs to the root function (if there is only one function to be optimized over, this is this single function, otherwise it is the sum of functions)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="abede1e498b73162f2b7e74f958df5bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abede1e498b73162f2b7e74f958df5bc0">&#9670;&nbsp;</a></span>set_term_relprec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_term_relprec </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>term_relprec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the relative precision requirements for successful termination (default 1e-5). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">term_relprec</td><td>(double) The algorithm stops with termination code 1, if predicted progress for the next step is less than term_relprec times absolute function value plus one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8f72743121e2fbd6f21eceda5295e9cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f72743121e2fbd6f21eceda5295e9cf">&#9670;&nbsp;</a></span>set_time_limit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConicBundle::MatrixCBSolver::set_time_limit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a>&#160;</td>
          <td class="paramname"><em>time_limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an upper bound on the number of seconds (user time, use negative numbers for no limit) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time_limit</td><td>(Integer)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a10bd1df5d2d7114c96f7cae063385109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10bd1df5d2d7114c96f7cae063385109">&#9670;&nbsp;</a></span>set_upper_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_upper_bound </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets upper bound for variable i, use <a class="el" href="group__cxxinterface.html#ga15948e7611155f822fc0331bcbb4a111" title="serves as the value &quot;minus infinity&quot;, i.e., all bounds &lt;= this value are set to this value and are re...">ConicBundle::CB_plus_infinity</a> for unbounded from below. </p>
<p>The algorithm may have to adapt the center point aftwards. In this case the old function values will be marked as outdated and will be recomputed at the next call to e.g. <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a2dbe46bc6b34684ea4895f8527e3c493" title="solves or does a prescribed number of iterations ">solve()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a650641f5e6dbaa711f3ac3441aa121b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650641f5e6dbaa711f3ac3441aa121b4">&#9670;&nbsp;</a></span>set_variable_metric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_variable_metric </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>do_variable_metric</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use a variable metric heuristic or switch off general metrics alltogether. (variable metric resets the quadratic term e.g. to some diagonal matrix, switching it off resets the quadratic term to the identity times the weight) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">do_variable_metric</td><td>(int)<ul>
<li>0 switch off the scaling heuristic</li>
<li>1 use a diagonal scaling heuristic</li>
<li>2 use a diagonal scaling heuristic combined with one for the bounds</li>
<li>3 use a low rank scaling heuristic</li>
<li>4 use a low rank scaling heuristic combined with a diagonal term</li>
<li>5 use a dense scaling heuristic</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afbddabcaa82723cbde924707efef9b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbddabcaa82723cbde924707efef9b60">&#9670;&nbsp;</a></span>set_weight_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_weight_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1BundleWeight.html">BundleWeight</a> *&#160;</td>
          <td class="paramname"><em>bw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the internal update routine for choosing the weight used in the proximal term; input NULL reinstalls the default routine. </p>
<p>The <a class="el" href="classConicBundle_1_1BundleWeight.html" title="Abstract interface for BundleSolver providing routines that determine the weight of the quadratic ter...">BundleWeight</a> class instance pointed to will be deleted on construction, i.e., ownership is passe over to the solver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bw</td><td>replace internal update routine by bw, value 0 reinstalls the default routine</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2dbe46bc6b34684ea4895f8527e3c493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dbe46bc6b34684ea4895f8527e3c493">&#9670;&nbsp;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::solve </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxsteps</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stop_at_descent_steps</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>solves or does a prescribed number of iterations </p>
<p>Bundle methods solve a problem by a sequence of so called descent steps that actually bring progress by moving from the current "center point" to a new center with better objective. A descent step may consist of several function evaluations (null steps), that lead to no immediate progress but mainly improve a cutting model of the objective function close to the current center point. A minimizer to the model is accepted as descent step if the function value at this point satisfies a sufficient decrease criterion in comparison to the decrease predicted by the model. Having found a descent step, the next center is automatically shifted to this successful candidate. Termination criteria may stop the process of seeking for a descent step, in which case the current center is kept and the routine <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a67e4eaa9ce3bd66f52387ccaa59908de" title="Returns the termination code of the bundle algorithm for the latest descent step. ...">termination_code()</a> returns the termination code.</p>
<p>Restarting, after each descent step, the bundle method from scratch with the new center as starting point does not endanger convergence. Therefore, a descent step is the smallest unit, after which user interaction can take place safely. To allow this there is a flag stop_at_descent_steps that will cause the code to return after the next descent step.</p>
<p>If you know what your are doing, you may also use the input parameter maxsteps to force the algorithm to return after at most maxsteps null steps. Calling solve again without any intermediate problem configurations will then simply continue the process where it stopped and convergence is save. During null steps one may not decrease the weight or delete nonzero variables of the center or the current candidate!</p>
<p>In a Lagrangean relaxation cutting plane approach one may want to separate and enlarge the dimension after a certain number of null steps. In this case the code will try to preserve the model, given appropriate subgradient extension routines have been provided. If the model cannot be extended, it has to be discarded (if subgradient extension is not successful this is done automatically), and the algorithm will be restarted from the current center point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxsteps</td><td>(int) if maxsteps&gt;0 the code returns after at most so many null steps</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stop_at_descent_steps</td><td>(int) if true the code also returns whenever a descent step occured</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>!= 0 otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a67e4eaa9ce3bd66f52387ccaa59908de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e4eaa9ce3bd66f52387ccaa59908de">&#9670;&nbsp;</a></span>termination_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::termination_code </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the termination code of the bundle algorithm for the latest descent step. </p>
<p>For resetting all counters relevant for termination see <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a9eeac5ece21d05a387eea9f755b15bff" title="clears all fail counts on numerical function oder model failures, may be useful if this caused premat...">clear_fail_counts()</a> .</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 : Not terminated. (Continue with the next <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a2dbe46bc6b34684ea4895f8527e3c493" title="solves or does a prescribed number of iterations ">solve()</a>)</li>
<li>1 : Relative precision criterion satisfied. (See <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#abede1e498b73162f2b7e74f958df5bc0" title="Sets the relative precision requirements for successful termination (default 1e-5). ">set_term_relprec()</a>)</li>
<li>2 : Timelimit exceeded. (Currently the C interface does not offer a timelimit.)</li>
<li>4 : Maximum number of function reevaluations exceeded. (Indicates that there is a problem with one of the function oracles that seems to deliver no valid upper bounds on the true function value for descent steps)</li>
<li>8 : Maximum number of quadratic subproblem failures exceeded. (Indicates that the numerical limits of the inner quadratic programming solver are reached, no further progress expected)</li>
<li>16 : maximum number of model evaluation failures exceeded (Indicates that the numerical limits of the setup of the subproblem are reached, no further progress expected)</li>
<li>32 : maximum number of failures to increase the augmented model value exceeded (Indicates that the numerical limits of the interplay between subproblem and quadratic programming solver are reached, no further progress expected)<ul>
<li>64 : maximum number of oracle calls (function evaluations) exceeded, see <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a85a8da56a2730b8d08b48aaff486c6bb" title="Sets an upper bound on the number of calls to the oracle (use negative numbers for no limit)...">set_eval_limit()</a></li>
<li>128 : maximum number of oracle failures exceeded. This refers to function evaluations that terminate with insufficient precision but still provide a new approximate subgradient. A failure typically indicates numerical difficulties with the precision requirements. (Currently the interface does not allow to manipulate the limit, it is set to 10) </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="MatrixCBSolver_8hxx_source.html">MatrixCBSolver.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
