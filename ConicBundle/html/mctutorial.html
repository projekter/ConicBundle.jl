<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ConicBundle: Tutorial Implementation of the SDP Max-Cut Relaxation with Triangle Separation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ConicBundle
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">The ConicBundle Library for Convex Optimization</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial Implementation of the SDP Max-Cut Relaxation with Triangle Separation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This text explains the theory and implementation of the example file "mc_triangle.cxx" whose source code is appended at the end. The text is structured as follows. It first introduces the max-cut problem and its canonical semidefinite relaxation and explains how this basic relaxation is implemented in the "main()" routine. Then it describes the Goemans-Williamson rounding procedure with its implementation in the subroutine "GW_rounding()". Finally the triangle inequalities are introduced and it is explained how they are added dynamically in the routine "update_triangle_constraints()".</p>
<h1>Max-Cut and Semidefinite Relaxation </h1>
<p>Given a graph <img class="formulaInl" alt="$G=(N,E)$" src="form_7.png"/> on node set s <img class="formulaInl" alt="$N=\{1,\dots,n\}$" src="form_8.png"/> and edge set <img class="formulaInl" alt="$E\subseteq{N\choose 2}=\{\{i,j\}\colon i,j\in N\}$" src="form_9.png"/>, the (unweighted) max-cut problem asks for a subset <img class="formulaInl" alt="$S\subseteq N$" src="form_10.png"/> so that the cardinality <img class="formulaInl" alt="$|\{\{i,j\}\in E\colon i\in S,j\in N\setminus S\}|$" src="form_11.png"/> of the edges in the cut (running between <img class="formulaInl" alt="$S$" src="form_12.png"/> and <img class="formulaInl" alt="$N\setminus S$" src="form_13.png"/>) is maximized.</p>
<p>For introducing the semidefinite relaxation we first need an algebraic formulation. Let the partition of nodes into <img class="formulaInl" alt="$S$" src="form_12.png"/> and <img class="formulaInl" alt="$N\setminus S$" src="form_13.png"/> be represented by a vector <img class="formulaInl" alt="$x\in\{-1,1\}^n$" src="form_14.png"/> (it does not matter, whether 1 or -1 represents <img class="formulaInl" alt="$S$" src="form_12.png"/>). Then <img class="formulaInl" alt="$\frac{1-x_ix_j}2$" src="form_15.png"/> is 1 if <img class="formulaInl" alt="$i$" src="form_16.png"/> and <img class="formulaInl" alt="$j$" src="form_17.png"/> are on different sides and 0 otherwise. So, if <img class="formulaInl" alt="$A\in\{0,1\}^{n\times n}$" src="form_18.png"/> is the adjacency matrix with <img class="formulaInl" alt="$a_{ij}=1\Leftrightarrow \{i,j\}\in E$" src="form_19.png"/>, the an algebraic formulation of Max-Cut is</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{(MC)}\quad \max_{x\in\{-1,1\}^n} \sum_{i&lt;j}a_{ij}\frac{1-x_ix_j}2.\]" src="form_20.png"/>
</p>
<p>This can be expressed in concise form with the graph Laplacian <img class="formulaInl" alt="$ L=\mathrm{Diag}(A\mathbf{1})-A$" src="form_21.png"/> [it collects the sum of the edges (the degree) on the diagonal and is minus the adjacency matrix on the offdiagonal elements],</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{(MC)}\quad\Leftrightarrow\quad \max_{x\in\{-1,1\}^n} \frac14x^\top L x\]" src="form_22.png"/>
</p>
<p>The factor <img class="formulaInl" alt="$\frac14$" src="form_23.png"/> accounts for the <img class="formulaInl" alt="$\frac12$" src="form_24.png"/> of the indicator term and the summing over both <img class="formulaInl" alt="$i&lt;j$" src="form_25.png"/> and <img class="formulaInl" alt="$i&gt;j$" src="form_26.png"/>.</p>
<p>For the next step we need the inner product between matrices <img class="formulaInl" alt="$A,B\in\mathbf{R}^{m\times n}$" src="form_27.png"/> for arbitrary dimensions <img class="formulaInl" alt="$m,n$" src="form_28.png"/>. We use the trace- or Frobenius inner product <img class="formulaInl" alt="$\langle A,B\rangle:=\mathrm{trace}(B^\top A)=\sum_i[A^\top B]_{ii}=\sum_{i,j} A_{ij}B_{ij}$" src="form_29.png"/>, then</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x^\top Lx=\langle Lx,x\rangle =\langle L,xx^\top\rangle. \]" src="form_30.png"/>
</p>
<p>Observe that <img class="formulaInl" alt="$xx^\top$" src="form_31.png"/> is a positive semidefinite matrix of rank one with all diagonal entries equal to one (because <img class="formulaInl" alt="$x_i^2=(\pm1)^2=1$" src="form_32.png"/>). The canonical semidefinite relaxation of Poljak and Rendl is now obtained by relaxing <img class="formulaInl" alt="$xx^\top$" src="form_31.png"/> to a positive semidefinite matrix <img class="formulaInl" alt="$X\succeq 0$" src="form_33.png"/> with all diagonal entries equal to one, <img class="formulaInl" alt="$\mathrm{diag}(X)=\mathbf{1}$" src="form_34.png"/>, while dropping the nonconvex rank one constraint,</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{(SMC)} \quad \begin{array}{ll} \max &amp; \langle\frac14 L,X\rangle\\ \mbox{s.t.} &amp; \mathrm{diag}(X)=\mathbf{1} \\ &amp; X\succeq 0 \end{array} \]" src="form_35.png"/>
</p>
<p><a class="el" href="classConicBundle_1_1PSCAffineFunction.html" title="general purpose implementation of PSCOracle as explained in implemention of a PSCOracle (PSCAffineFun...">ConicBundle::PSCAffineFunction</a> offers the support function (i.e., the supremum of a linear function over some set) <img class="formulaInl" alt="$f_\gamma(F(y))=\max_{\{X\succeq 0\colon \langle I,X\rangle =\gamma\}}\langle F(y),X\rangle$" src="form_36.png"/>, where <img class="formulaInl" alt="$\gamma&gt;0$" src="form_37.png"/> and <img class="formulaInl" alt="$F\colon \mathbf{R}^m\to \mathbf{S}^n$" src="form_38.png"/> is an affine matrix function like <img class="formulaInl" alt="$F(y)=C+\sum_{i}y_iA_i$" src="form_39.png"/>. To get (SMC) into this form, we may exploit that any feasible <img class="formulaInl" alt="$X$" src="form_40.png"/> satisfies <img class="formulaInl" alt="$\langle I,X\rangle =n$" src="form_41.png"/>, but we need to introduce Lagrange multipliers to move the diagonal constraints into the cost function,</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{(SMC)}\quad\Leftrightarrow\quad \min_{y\in\mathbf{R}^n} \max_{\{X\succeq 0\colon \langle I,X\rangle =n\}}[\langle\frac14 L-\sum_{i=1}^n y_iE_{ii},X\rangle +\mathbf{1}^\top y],\]" src="form_42.png"/>
</p>
<p>where <img class="formulaInl" alt="$y_i$" src="form_43.png"/> is the multiplier for the i-th diagonal constraint <img class="formulaInl" alt="$\langle E_{ii},X\rangle=1$" src="form_44.png"/>. The matrix <img class="formulaInl" alt="$E_{ii}=e_ie_i^\top$" src="form_45.png"/> has a single one in diagonal entry <img class="formulaInl" alt="$i$" src="form_16.png"/> and is zero otherwise. As an aside, adding the trace constraint while keeping all diagonal constraints introduces redundancy and the dual solutions are not unique, but we do not worry about this here. The equivalence is otherwise guaranteed by standard semidefinite duality theory.</p>
<h1>Implementing the Semidefinite Relaxation </h1>
<p>With this we may now start to look at the routine "main()" in the source code of "mc_triangle.cxx" at the end of the text.</p>
<h2>Reading the Graph Input Format </h2>
<p>The first few lines read the graph description with nnodes and medges= <img class="formulaInl" alt="$|E|$" src="form_46.png"/> edges of the form <img class="formulaInl" alt="$ \{i_h,j_h\}$" src="form_47.png"/> with (ignored) weight <img class="formulaInl" alt="$w_h$" src="form_48.png"/> for <img class="formulaInl" alt="$h=1,\dots,|E|$" src="form_49.png"/> from standard input in the input format (as produced by the random graph generator rudy with indices starting at 1)</p>
<p>nnodes medges i_1 j_1 2_1 i_2 j_2 w_2 ... i_medges j_medges w_medges</p>
<p>For generating the sparse matrix representation of the Laplacian each of the index vectors to i (indi) and j (indj) is stored in a <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html" title="Matrix class for integral values of type Integer ">CH_Matrix_Classes::Indexmatrix</a>, but in <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> and in <a class="el" href="namespaceCH__Matrix__Classes.html" title="Matrix Classes and Linear Algebra. See Matrix Classes (namespace CH_Matrix_Classes) for a quick intro...">CH_Matrix_Classes</a> indexing starts with 0, so each index is reduced by one. The uniform edge weight one is stored in the vector val of the same length and of type <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">CH_Matrix_Classes::Matrix</a> (replace this if you want general weights).</p>
<h2>Generating <img class="formulaInl" alt="$\frac14 L(G)$" src="form_50.png"/> with averaged diagonal </h2>
<p>Next, in the code the <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html" title="Matrix class of symmetric matrices with real values of type Real ">CH_Matrix_Classes::Sparsesym</a> L will almost hold the matrix <img class="formulaInl" alt="$\frac14L$" src="form_51.png"/> from above with the difference, that the final diagonal elements will all have the identical value <img class="formulaInl" alt="$\mathbf{1}^\top A\mathbf{1}/(4n)$" src="form_52.png"/> which seems to be a slightly better starting point in general. For this, L is first initialized by (nnodes,medges,indi,indj,val), the potential diagonal elements are deleted [it would be more efficient to ignore them on reading the input but this would complicate explanations], the sign of the offdiagonals is flipped and the averaged degree is added on the diagonal. Finally the factor <img class="formulaInl" alt="$\frac14$" src="form_23.png"/> is applied. The solution vector bestcut (representing the best found <img class="formulaInl" alt="$x\in\{-1,1\}^n$" src="form_14.png"/>) is initialized to the empty cut and the corresponding value is stored in bestcut_val.</p>
<h2>Setting up the <a class="el" href="classConicBundle_1_1PSCAffineFunction.html" title="general purpose implementation of PSCOracle as explained in implemention of a PSCOracle (PSCAffineFun...">ConicBundle::PSCAffineFunction</a> </h2>
<p>In the next step the affine matrix function</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[F(y)=C+\sum_{i=1}^m y_iA_i\quad \to \quad mc(y)=\frac14 L-\sum_{i=1}^n y_iE_{ii}\]" src="form_53.png"/>
</p>
<p>is formed. In general a <a class="el" href="classConicBundle_1_1PSCAffineFunction.html" title="general purpose implementation of PSCOracle as explained in implemention of a PSCOracle (PSCAffineFun...">ConicBundle::PSCAffineFunction</a> may have diagonal blocks of different orders and these sizes are communicated by a <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html" title="Matrix class for integral values of type Integer ">CH_Matrix_Classes::Indexmatrix</a> Xdim (here there is only one block of order nnodes); the coefficients are specified by a <a class="el" href="classConicBundle_1_1SparseCoeffmatMatrix.html" title="stores/organizes the CoeffmatPointer pointers to Coeffmat matrices with the purpose of describing the...">ConicBundle::SparseCoeffmatMatrix</a> C having only one column of the block diagonal form Xdim and a <a class="el" href="classConicBundle_1_1SparseCoeffmatMatrix.html" title="stores/organizes the CoeffmatPointer pointers to Coeffmat matrices with the purpose of describing the...">ConicBundle::SparseCoeffmatMatrix</a> opAt with <img class="formulaInl" alt="$m$" src="form_54.png"/> (here initially nnodes many) columns of block diagonal form Xdim. In the code Xdim signals one block of order nnodes, C is initialized to block structure Xdim and one column, its element (0,0) is then set to hold a coefficient matrix of type <a class="el" href="classConicBundle_1_1CMsymsparse.html" title="implements a general sparse symmetric Coeffmat based on CH_Matrix_Classes::Sparsesym (for use with Ma...">ConicBundle::CMsymsparse</a> which is initialized to a copy of L. Likewise, opAt is initialized to diagonal block structure Xdim with nnodes columns, each element (0,i) is set to contain a coefficient matrix of type <a class="el" href="classConicBundle_1_1CMsingleton.html" title="implements a Coeffmat having just one nonzero element (or two by symmetry) for use with MatrixSDPfunc...">ConicBundle::CMsingleton</a> holding <img class="formulaInl" alt="$-E_{ii}$" src="form_55.png"/> for i=1,..,nnodes. Now the PSCAffineFunction mc is initialized with C and opAt and, as last and optional argument, it is passed a <a class="el" href="classConicBundle_1_1GramSparsePSCPrimal.html" title="represents an PSCPrimal as the sum  of a Gram matrix and a sparse symmetric matrix  ...">ConicBundle::GramSparsePSCPrimal</a> object initialized to contain the support of L. Passing this "Primal" instructs the code on what kind of primal information it should form / aggregate along with forming the aggregate subgradient. The internal solution of the semidefinite quadratic subproblem is of the form <img class="formulaInl" alt="$X=P\Lambda P^\top+\alpha\bar X$" src="form_56.png"/>, where <img class="formulaInl" alt="$ P^\top P=I_k$" src="form_57.png"/> describes a face of the semidefinite cone of order k, <img class="formulaInl" alt="$\Lambda$" src="form_58.png"/> is a diagonal matrix and <img class="formulaInl" alt="$\bar X\in\{X\succeq 0\colon \langle I,X\rangle\}$" src="form_59.png"/> is an aggregate matrix so that <img class="formulaInl" alt="$\alpha+\langle I,\Lambda\rangle=n$" src="form_60.png"/>. The aggregate <img class="formulaInl" alt="$\bar X$" src="form_61.png"/> is not stored in full (for large orders this would not be efficient), but only on the support specified by the Primal, so here on the support of L. By the default bundle update rule the main information is kept in <img class="formulaInl" alt="$P\Lambda P^\top$" src="form_62.png"/> and the <a class="el" href="classConicBundle_1_1GramSparsePSCPrimal.html" title="represents an PSCPrimal as the sum  of a Gram matrix and a sparse symmetric matrix  ...">ConicBundle::GramSparsePSCPrimal</a> instructs the code to return the matrix <img class="formulaInl" alt="$P\Lambda^{\frac12}$" src="form_63.png"/> as the Gram part of the primal. This will be important for the triangle separation part. The final line of this code part sets the output options of mc to report only warnings and errors.</p>
<h2>Initializing the Solver with Design Variables and Function </h2>
<p>The next block initializes the bundle solver cbsolver and adds the function mc that is to be optimized. In <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a5129b50d68be01aaa8cb6825058a8f13" title="Initializes the problem by setting up the design space (the dimension and possibly box constraints on...">ConicBundle::MatrixCBSolver::init_problem()</a> the dimension of the design variables (here the initial number of <img class="formulaInl" alt="$y$" src="form_64.png"/>-variables is nnodes) is set with the lower and upper bounds lb and ub on these variables, no starting values, but linear cost coefficients in rhs (here the rhs vector is the <img class="formulaInl" alt="$\mathbf{1}$" src="form_65.png"/> vector of the diagonal constraints) [instead of lb and ub one could just pass the NULL vector because they only give the default values]. Then the function mc is added with function factor <img class="formulaInl" alt="$\gamma=n=$" src="form_66.png"/>nnodes as an objective function, so that <img class="formulaInl" alt="$f_\gamma(mc(y))=\max_{\{X\succeq 0\colon \langle I,X\rangle=\gamma\}} \langle mc(y),X\rangle$" src="form_67.png"/> is the function optimized. Of the last two arguments in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a3c503663b689ede0f1d004690d622e2f" title="Adds a function, typically derived from ConicBundle::FunctionOracle. If the dimension does not match ...">ConicBundle::MatrixCBSolver::add_function()</a> the 0 informs the solver that there is no AffineFunctionTransformation, and the "true" tells the solver that the argument vector of the function will be adapted dynamically with any addition or deletion of design variables. This will again be important for the addition of triangle inequalities.</p>
<h2>The Main Loop for Solving the Relaxation with Intermediate Interaction </h2>
<p>If the optimization problem is not changed during runtime, a call to <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a2dbe46bc6b34684ea4895f8527e3c493" title="solves or does a prescribed number of iterations ">ConicBundle::MatrixCBSolver::solve()</a> without arguments would suffice for solving the problem. Here, however, the point is to add further inequalities to (SMC) on the fly. As we solve the Lagrangian dual, the Lagrange multipliers to new inequalities are added as new design variables to the problem. In linear programming this would be done via call back routines, but in <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> everything is designed to work with Lagrangian relaxation of inequalities that affect several otherwise unrelated convex functions a the same time. So typically call backs cannot be assigned to single functions but a global view of the problem is needed. Therefore <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> offers a reverse interface by allowing to interrupt the algorithm after every descent step (safest variant) or even after every so many null steps for applying problem modifications. The draw back is that the user has to make sure that the selected dynamic problem modifications do not endanger convergence to the solution of the intended problem.</p>
<p>Before the main loop is started, some preparations are made for adding triangle inequalities like initializing the set of added triangle inequalities, their maximum violation observed. The call to <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a5229f01c537d914a60b896bf01e550d5" title="If set to true (the default is false), variables may be fixed automatically to active bounds if these...">ConicBundle::MatrixCBSolver::set_active_bounds_fixing()</a> allows the solver to fix design variables at their bounds if they show no tendency to move away from the bounds. Here, for the nonnegative Lagrange multipliers of inequality constraints, this amounts to internally ignore inequalities whose multipliers stay at 0 in future QP subproblem as if they had not been added at all. This may speed up the subproblem solution considerably. A variable fixed at zero by this heuristic can be removed without problems afterwards.</p>
<p>The main loop itself starts with calling <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a2dbe46bc6b34684ea4895f8527e3c493" title="solves or does a prescribed number of iterations ">ConicBundle::MatrixCBSolver::solve()</a> with the options to stop after at most 10 null steps as well as after each descent step. <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#af4b7d14796c16870dca8b563846be351" title="returns the current approximate primal solution corresponding to the aggregate subgradient of the spe...">ConicBundle::MatrixCBSolver::get_approximate_primal()</a> then retrieves the current approximate primal solution primalX in the representation selected in setting up the affine matrix function mc(). This primalX is then used in the GW_rounding() routine to generate a hopefully good partition for the max-cut problem. The best partition maximizing <img class="formulaInl" alt="$ x^\top L x$" src="form_68.png"/> so far is returned in bestcut and its value is given in bestcut_val. Because all edge weights are set to one, optimality of bestcut_val is guaranteed if the gap between the bound returned by <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#abadd5d33331ac8f52bb435a11d04a802" title="Returns the objective value resulting from last descent step (initially undefined). If no problem modification routines were called since then, it is the objective value at the point returned by get_center(). ">ConicBundle::MatrixCBSolver::get_objval()</a> and bestcut_val is less than one, in which case the code exits the loop. Otherwise <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a8715eb8a6c956d314a108c8fd29636f7" title="Returns NULL or (iff active bound fixing is turned on in set_active_bounds_fixing()) the indicator ve...">ConicBundle::MatrixCBSolver::get_fixed_active_bounds()</a> retrieves the indices to Lagrange multipliers of inequalities that were fixed to zero by the internal heuristic and calls the routine update_triangle_constraints() for adding new violated triangle inequalities and deleting previously added inequalities that now seem irrelevant.</p>
<p>The main loop is terminated once no more sufficiently violated inequalities are found and no significant further progress is expected in the bound or if the last call to solve resulted in some error termination condition.</p>
<p>The "main()" routine ends with displaying the reason for termination.</p>
<p>This also ends the description of the "main()" routine, and the text next describes the rounding procedure "GW_rounding()" which will be followed by the description of the routine for dynamically adding and deleting triangle inequalities.</p>
<h1>Goemans Williamson Random Hyperplane Rounding </h1>
<p>The approximation algorithm of Goemans and Williamson for max-cut is based on random hyperplane rounding that can be applied to any feasible solution of (SMC). Let <img class="formulaInl" alt="$X\in\{X\succeq 0\colon \mathrm{diag}(X)=\mathbf{1}\}$" src="form_69.png"/> and factorize <img class="formulaInl" alt="$X$" src="form_40.png"/> into <img class="formulaInl" alt="$X=V^\top V$" src="form_70.png"/> with <img class="formulaInl" alt="$V=[v_1,\dots,v_n]$" src="form_71.png"/>. The <img class="formulaInl" alt="$\|v_i\|=1$" src="form_72.png"/> are unit vectors satisfying <img class="formulaInl" alt="$X_{ij}=\langle v_i,v_j\rangle=\cos \varphi_{ij}$" src="form_73.png"/> with <img class="formulaInl" alt="$\varphi_{ij}$" src="form_74.png"/> the angle between the two vectors. The larger the angle, the more likely i and j should end up in opposite partitions. A consistent way of doing so is achieved by picking a random hyperplane via choosing its normal vector <img class="formulaInl" alt="$h$" src="form_75.png"/> according to some spherically symmetric distribution, e.g. the multivariate standard normal distribution and setting</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_i=\left\{\begin{array}{rl} 1 &amp; \mbox{if }\langle h,v_i \rangle &gt; 0,\\ -1 &amp; \mbox{if }\langle h,v_i \rangle \le 0.\\ \end{array}\right. \]" src="form_76.png"/>
</p>
<p> For nonnegative edge weights the expected value of <img class="formulaInl" alt="$x^\top Lx$" src="form_77.png"/> is then at least <img class="formulaInl" alt="$ 0.878\cdot\langle L,X\rangle$" src="form_78.png"/>.</p>
<h2>Implementation in GW_rounding() </h2>
<p>In the routine GW_rounding() the input parameter primalX holds the available information on the current approximation to the primal matrix <img class="formulaInl" alt="$X$" src="form_40.png"/> in the form conceived in the spectral bundle method of Helmberg and Rendl. I.e., one may think of the primal approximate solution as given in the form <img class="formulaInl" alt="$X=P\Lambda P^\top+\alpha\bar X$" src="form_56.png"/> with <img class="formulaInl" alt="$P^\top P=I_k$" src="form_79.png"/>, <img class="formulaInl" alt="$\Lambda\succeq 0$" src="form_80.png"/> diagonal, <img class="formulaInl" alt="$\alpha\ge 0$" src="form_81.png"/> with <img class="formulaInl" alt="$\langle I,\Lambda\rangle +\alpha=n$" src="form_82.png"/> and an aggregate matrix <img class="formulaInl" alt="$\bar X\in\{X\succeq 0\colon\langle I,X\rangle=1\}$" src="form_83.png"/> that is not available explicitly unless aggregated along on some support. The internal update rule for the orthonormal column vectors in <img class="formulaInl" alt="$P$" src="form_84.png"/> try to ensure that these capture the most important eigenspace of <img class="formulaInl" alt="$X$" src="form_40.png"/> and <img class="formulaInl" alt="$\Lambda=\mathrm{Diag}(\lambda_1\ge \cdots \ge \lambda_k\ge 0)$" src="form_85.png"/> give the approximate sorted eigenvalues of <img class="formulaInl" alt="$X$" src="form_40.png"/>. The default update rule tries to ensure that <img class="formulaInl" alt="$\alpha$" src="form_86.png"/> is small enough so that <img class="formulaInl" alt="$\bar X$" src="form_61.png"/> is not of relevance here.</p>
<p>In the code the call to <a class="el" href="classConicBundle_1_1GramSparsePSCPrimal.html#a0df6a020d662733b2050aa1ff0928b03" title="returns the matrix  giving rise to the Gram matrix  ">ConicBundle::GramSparsePSCPrimal::get_grammatrix()</a> for primalX (which was obtained via <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#af4b7d14796c16870dca8b563846be351" title="returns the current approximate primal solution corresponding to the aggregate subgradient of the spe...">ConicBundle::MatrixCBSolver::get_approximate_primal()</a>) returns <img class="formulaInl" alt="$V^\top=P\Lambda^{\frac12}$" src="form_87.png"/> in the matrix Gram_mat, so the first column of Gram_mat actually holds the most important information about the current <img class="formulaInl" alt="$X$" src="form_40.png"/>.</p>
<p>The first code block uses the signs of the first column of Gram_mat to produce a partition vector cut <img class="formulaInl" alt="$\in\{-1,1\}^n$" src="form_88.png"/> and evaluates it for the cost matrix L. If the result is better then the best partition vector found so far, it is stored as the new best partition.</p>
<p>The second block actually uses Goemans Williamson random hyperplane rounding. It fixes a number of tries (the maximum of nnodes/10 and 10). The loop executes these tries by drawing a random direction (the normal vector <img class="formulaInl" alt="$h$" src="form_75.png"/> of above) according to the multivariate normal distribution into rand_dir. genmult computes Gram_mat*rand_dir into cut, so cut(i) holds the inner product of rand_dir with row i of Gram_mat, which corresponds to the value <img class="formulaInl" alt="$\langle h,v_i \rangle$" src="form_89.png"/> above. Then the signs of cut are used to generate the partition vector cut <img class="formulaInl" alt="$\in\{-1,1\}^n$" src="form_88.png"/>, which is again evaluated and compared.</p>
<p>The final line of the routine outputs the current best value known.</p>
<p>It should be noted that a practical implementation might well try to use some local improvement heuristics on the outcomes of the random rounding procedure but this seems inappropriate for this tutorial.</p>
<h1>Dynamic Addition and Deletion of Triangle Inequalities </h1>
<p>The elliptope, i.e., the primal feasible set <img class="formulaInl" alt="$\{X\succeq 0\colon \mathrm{Diag}(X)=\mathbf{1}\}$" src="form_90.png"/> of (SMC), is a convex relaxation (a blown up version) of the matric cut polytope <img class="formulaInl" alt="$\mathrm{conv}\{xx^\top\colon x\in\{-1,1\}^n\}$" src="form_91.png"/>, see the book by Deza and Laurent for a full account of polyhedral theory related to the cut polytope and its variants and for further references. The most basic facet defining inequalities of the matric cut polytope are the so called triangle inequalities</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{array}{cccccccl} &amp;X_{ij}&amp;+&amp; X_{ik}&amp;+&amp;X_{jk}&amp;\ge &amp; -1,\\ &amp;X_{ij}&amp;-&amp; X_{ik}&amp;-&amp;X_{jk}&amp;\ge &amp; -1,\\ - &amp;X_{ij}&amp;+&amp; X_{ik}&amp;-&amp;X_{jk}&amp;\ge &amp; -1,\\ - &amp;X_{ij}&amp;-&amp; X_{ik}&amp;+&amp;X_{jk}&amp;\ge &amp; -1. \end{array} \]" src="form_92.png"/>
</p>
<p>Combinatorially they reflect that in a triangle graph on nodes i,j,k at most two of the edges ij, ik, jk can be in any cut and if there is one edge in the cut then another one must be in the cut as well.</p>
<p>In fact, for any cycle of the graph a cut always intersects an even number of the cycle's edges. The corresponding cycle inequalities can be separated in polynomial time. In linear programming approaches, these cycle inequalities form the basis of most relaxations. The cycle inequalities provide a complete description of the cut polytope of planar graphs. If all triangle inequalities are satisfied, all cycle inequalities are satisfied as well. In linear programming relaxations adding triangle inequalities for edges that are not in the support of the cost matrix does not help. In the semidefinite relaxation, however, even triangle inequalities outside the support may improve the value of the relaxation, because the semidefiniteness condition leads to nonlinear crossconnections between all matrix elements. For large sparse graphs it may be computationally too expensive to work work with the full matrix <img class="formulaInl" alt="$X$" src="form_40.png"/> and separating the sparse cycle inequalities on a carefully selected support may improve running times considerably without a big loss in quality (see the work of Armbruster, Fuegenschuh, Helmberg and Martin). This, however, is clearly outside the scope of this tutorial implementation. So here, for the sake of simplicity, we will not worry about forming and using the dense <img class="formulaInl" alt="$X$" src="form_40.png"/> for full separation of the triangle inequalities by direct enumeration. Yet, forming the full matrix here is the sole reason why this example implementation is not a viable option for large scale sparse instances.</p>
<p>Suppose now that for some index set <img class="formulaInl" alt="$\mathcal{T}$" src="form_93.png"/> the triangle inequalities (multiplied by -1) <img class="formulaInl" alt="$\langle A_t,X\rangle\le 1$" src="form_94.png"/> are added to (SMC), then</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{(SMC)} \quad \begin{array}{ll} \max &amp; \langle\frac14 L,X\rangle\\ \mbox{s.t.} &amp; \mathrm{diag}(X)=\mathbf{1}, \\ &amp; \langle A_t,X\rangle \le 1, \quad t\in\mathcal{T},\\ &amp; X\succeq 0 \end{array} \quad\Leftrightarrow\quad \min_{y\in\mathbf{R}^{n+|\mathcal{T}|},y_{\mathcal{T}}\ge 0} \max_{\{X\succeq 0\colon \langle I,X\rangle =n\}}[\langle\frac14 L-\sum_{i=1}^n y_iE_{ii}-\sum_{t\in \mathcal{T}} y_tA_{t},X\rangle +\mathbf{1}^\top y] \]" src="form_95.png"/>
</p>
<p>Thus, adding these primal inequalities corresponds to appending variables <img class="formulaInl" alt="$y_t\ge 0$" src="form_96.png"/> for <img class="formulaInl" alt="$t\in\mathcal{T}$" src="form_97.png"/> and appending the coefficient matrices <img class="formulaInl" alt="$A_t$" src="form_98.png"/> to the affine matrix function.</p>
<p>A central difference of the Lagrangian relaxation approach to standard linear programming implementations is that an approximate primal solution <img class="formulaInl" alt="$X$" src="form_40.png"/> will only roughly satisfy newly added inequalities. Because Lagrange multipliers only penalize violations but do not prohibit violations, most added cutting planes will actually still be violated by the approximate primal solutions generated by the bundle method. So the same inequalities may be separated and added over and over again unless precautions are taken against that. It can be shown that it suffices to add the most violated cutting planes whenever they are not already present in the model in order to guarantee convergence. The implementation will therefore keep identifiers of the added triangle inequalities in a separate set, add violated inequalities only if their identifiers are not yet in the set, and delete inactive inequalities only after this test.</p>
<h2>Implementation in update_triangle_constraints() </h2>
<p>The routine consists of a small initial block for 0. forming the approximate primal X matrix and four successive blocks for 1. finding the most violated triangle inequalities, 2. building the coefficient matrices for those that are not yet included in the set of added triangle inequalities, 3. adding the new variables and coefficient matrices to the problem, and 4. deleting old inequalities whose multipliers have been fixed to zero in the heuristic for active bounds fixing.</p>
<p><b>0. Forming the Approximate Primal X Matrix</b></p>
<p>As described before, the input parameter primalX, retrieved by <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#af4b7d14796c16870dca8b563846be351" title="returns the current approximate primal solution corresponding to the aggregate subgradient of the spe...">ConicBundle::MatrixCBSolver::get_approximate_primal()</a> in the main loop, holds the available information on the current approximation to the primal matrix <img class="formulaInl" alt="$X$" src="form_40.png"/> in the form conceived in the spectral bundle method of Helmberg and Rendl. I.e., internally the primal approximate solution is given in the form <img class="formulaInl" alt="$X=P\Lambda P^\top+\alpha\bar X$" src="form_56.png"/> with <img class="formulaInl" alt="$P^\top P=I_k$" src="form_79.png"/>, <img class="formulaInl" alt="$\Lambda\succeq 0$" src="form_80.png"/> diagonal, <img class="formulaInl" alt="$\alpha\ge 0$" src="form_81.png"/> with <img class="formulaInl" alt="$\langle I,\Lambda\rangle +\alpha=n$" src="form_82.png"/> and an aggregate matrix <img class="formulaInl" alt="$\bar X\in\{X\succeq 0\colon\langle I,X\rangle=1\}$" src="form_83.png"/> that is not available explicitly unless aggregated along on some support. The internal update rule for the orthonormal column vectors in <img class="formulaInl" alt="$P$" src="form_84.png"/> try to ensure that these capture the most important eigenspace of <img class="formulaInl" alt="$X$" src="form_40.png"/> and <img class="formulaInl" alt="$\Lambda=\mathrm{Diag}(\lambda_1\ge \cdots \ge \lambda_k\ge 0)$" src="form_85.png"/> give the approximate sorted eigenvalues of <img class="formulaInl" alt="$X$" src="form_40.png"/>. Even though the default update rule tries to ensure that <img class="formulaInl" alt="$\alpha$" src="form_86.png"/> is small, it might be important for separation to have <img class="formulaInl" alt="$X$" src="form_40.png"/> available on the original support of <img class="formulaInl" alt="$L$" src="form_99.png"/> as precisely as possible. For this purpose the support of <img class="formulaInl" alt="$L$" src="form_99.png"/> was entered in setting up the generating primal information when initializing the affine matrix function mc() in the routine main(). Due to this, any aggregation leading to the conceptual <img class="formulaInl" alt="$\alpha\bar X$" src="form_100.png"/> is carried out explicitly on the support of <img class="formulaInl" alt="$L$" src="form_99.png"/> and available only on this support as CH_Matrix_Classes::Sparseym in the sparse symmetric matrix part of the class <a class="el" href="classConicBundle_1_1GramSparsePSCPrimal.html" title="represents an PSCPrimal as the sum  of a Gram matrix and a sparse symmetric matrix  ...">ConicBundle::GramSparsePSCPrimal</a>, while the Gram matrix part retrievable by the call to <a class="el" href="classConicBundle_1_1GramSparsePSCPrimal.html#a0df6a020d662733b2050aa1ff0928b03" title="returns the matrix  giving rise to the Gram matrix  ">ConicBundle::GramSparsePSCPrimal::get_grammatrix()</a> returns <img class="formulaInl" alt="$P\Lambda^{\frac12}$" src="form_63.png"/>. So if <img class="formulaInl" alt="$\mathcal{P}_L$" src="form_101.png"/> denotes the projection onto the support of <img class="formulaInl" alt="$L$" src="form_99.png"/>, primalX holds <img class="formulaInl" alt="$P\Lambda^{\frac12}(P\Lambda^{\frac12})^\top+\mathcal{P}_L(\alpha\bar X)$" src="form_102.png"/>.</p>
<p>With the initialization "Symmatrix X(*primalX);" the variable X is initialized as a dense symmetric matrix with sparse symmetric matrix part <img class="formulaInl" alt="$\mathcal{P}_L(\alpha\bar X)$" src="form_103.png"/> stored in primalX. The second line "rankadd(primalX-&gt;get_grammatrix(),X,1.,1.);" adds <img class="formulaInl" alt="$P\Lambda^{\frac12}(P\Lambda^{\frac12})^\top$" src="form_104.png"/> to X.</p>
<p><b>1. Finding the Most Violated Triangle Inequalities</b></p>
<p>For organizational purposes triangle inequalities are identified by the index triple <img class="formulaInl" alt="$t=(i,\pm j,\pm k)$" src="form_105.png"/> as implemented in the class Triangle which is equipped with a total order operator&lt; for comparisons in the standard template library implementation std::set&lt;Triangle&gt; underlying the type AddedTriangles. The input/output parameter added_triangles holds the set of triangle inequalities <img class="formulaInl" alt="$\mathcal{T}$" src="form_93.png"/> added to the problem. For identifying the most violated inequalities the class TriangleViolation stores a Triangle identifier together with the "violation value" <img class="formulaInl" alt="$-\langle A_t,X\rangle$" src="form_106.png"/> and offers a operator&lt; so that the least violated inequalities (largest value <img class="formulaInl" alt="$-\langle A_t,X\rangle$" src="form_106.png"/>) come first in the standard template library implementation std::priority_queue&lt;TriangleViolation&gt; most_violated.</p>
<p>The block starts with fixing an upper bound at_most_n_violated on the number of violated triangle inequalities to be added in this call and a threshold on the "violation value" <img class="formulaInl" alt="$-\langle A_t,X\rangle$" src="form_106.png"/> (everything below -1 is violated, so the value -1-1e-3 corresponds to an actual minimum violations of 1e-3).</p>
<p>The three loops enumerate all possible triangles. A inequality violated according to the threshold is added to the priority queue if there is still room or if it is more violated then the least violated one of the queue, which is then popped followed by insertion of the new inequality.</p>
<p><b>2. Building the Coefficient Matrices</b></p>
<p>For later initialization of the <a class="el" href="classConicBundle_1_1SparseCoeffmatMatrix.html" title="stores/organizes the CoeffmatPointer pointers to Coeffmat matrices with the purpose of describing the...">ConicBundle::SparseCoeffmatMatrix</a> that needs to be appended to mc(), it will be convenient to collect the coefficient matrices of new triangles inequalities in the <a class="el" href="group__implemented__psc__oracle.html#gaa065caa1c123a98624554ea3a2af65ef" title="convenient for initializing SparseCoeffmatMatrix via the sparse (block_i,column_i,Coeffmat_i), i=1,...,nz (nonzeros) format with Indexmatrix,Indexmatrix,CoeffmatVector ">ConicBundle::CoeffmatVector</a> tr_ineqs which is simply a std::vector of <a class="el" href="classConicBundle_1_1CoeffmatPointer.html" title="pointer class for Coeffmat for deleting objects on the heap if Coefmat::use_cnt is reduced to zero an...">ConicBundle::CoeffmatPointer</a> (pointers to coefficient matrices). For each triangle inequality the appropriate format of a coefficient matrix is a <a class="el" href="classConicBundle_1_1CMsymsparse.html" title="implements a general sparse symmetric Coeffmat based on CH_Matrix_Classes::Sparsesym (for use with Ma...">ConicBundle::CMsymsparse</a> which needs to be initialized via sparse symmetric matrix <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html" title="Matrix class of symmetric matrices with real values of type Real ">CH_Matrix_Classes::Sparsesym</a> A, which will have the three nonzero elements corresponding to the pairs ij, ik, jk. The corresponding vectors describing the indices and values of A are initialized to the appropriate sizes before entering the loop on the violated triangle inequalities.</p>
<p>The loop continues as long as the priority queue most_violated still holds entries. The top element is checked on containment in the set added_triangles and skipped if it is in there. Otherwise its tree violation is computed for displaying some statistical information, it is added into added_triangles, and a new coefficient matrix formed via the Sparsesym A is appended to tr_ineqs.</p>
<p>Note that it may happen that all separated inequalities are already in the set added_triangles because a few iterations of the bundle method may not suffice to reduce violation sufficiently for other inequalities to emerge. In this case the reported violation is 0 and may not reflect to correct state of things.</p>
<p><b>3. Adding the New Variables and Coefficient Matrices</b></p>
<p>When appending new variables via MatrixCBSolver::append_variables() it is also necessary to communicate to the function mc() how to modify itself via specifying in the function object modification map <a class="el" href="namespaceConicBundle.html#ad078c3e597a104edaccd983cddf6a134" title="In order to pass on problem modifications, FunObjModMap allows to specify a FunctionObjectModificatio...">ConicBundle::FunObjModMap</a> modmap a corresponding <a class="el" href="classConicBundle_1_1PSCAffineModification.html" title="class for collecting and organizing a sequence of changes to block diagonal symmetric affine matrix f...">ConicBundle::PSCAffineModification</a> object funmod for the function mc(). For performing consistency checks all modification objects have to be initialized with the current dimensions of the object to be modified; after that, modifications can be added consistently to the modification object which collects them for later collective application to the intended object. Here a <a class="el" href="classConicBundle_1_1SparseCoeffmatMatrix.html" title="stores/organizes the CoeffmatPointer pointers to Coeffmat matrices with the purpose of describing the...">ConicBundle::SparseCoeffmatMatrix</a> scm holding as columns the new coefficient matrices collected in tr_ineqs is appended to funmod in a call to its routine <a class="el" href="classConicBundle_1_1PSCAffineModification.html#aced75851a81f1850daf8915211be3d4a" title="append information on new variables at the respective ends ">ConicBundle::PSCAffineModification::add_append_vars()</a>. The reference to funmod is then entered into the modification map modmap for mc(). In the call to <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#ae94677e63dc7736099a77acaad553a3f" title="Append new variables (always in last postions in this order). ">ConicBundle::MatrixCBSolver::append_variables()</a> this modification map modmap is then passed along with the number of variables to be appended, their lower bounds (value 0 for nonnegative), upper bounds (Null pointer for not existing), two null pointers for constraint columns and starting values, and the cost vector of all ones.</p>
<p>Note that in adding new inequalities <img class="formulaInl" alt="$\langle A_t,\cdot\rangle\le 1$" src="form_107.png"/> whose support is outside <img class="formulaInl" alt="$L$" src="form_99.png"/> the corresponding subgradient entry <img class="formulaInl" alt="$t$" src="form_108.png"/> cannot be recovered for the aggregate <img class="formulaInl" alt="$\bar X$" src="form_61.png"/>, because the precise values of some entries of <img class="formulaInl" alt="$\bar X$" src="form_61.png"/> needed in the evaluation of <img class="formulaInl" alt="$\langle A_t,\bar X\rangle$" src="form_109.png"/> are not available. So whenever such inequalities are added, the aggregate will automatically be removed from the cutting model of the bundle method. This may lead to a noticeable loss in the quality of the cutting model whenever the corresponding coefficient <img class="formulaInl" alt="$\alpha$" src="form_86.png"/> is sizable. This is another reason in favor of bundle updating rules that keep <img class="formulaInl" alt="$\alpha$" src="form_86.png"/> small as well as in favor of separating inequalities on the updated support of <img class="formulaInl" alt="$\bar X$" src="form_61.png"/>.</p>
<p><b>4. Deleting old inequalities</b></p>
<p>In deleting inequalities and their associated Lagrange multipliers it is convenient if the current function evaluations and cutting models stay valid. The cutting model is generated by a subset of <img class="formulaInl" alt="$\{X\succeq 0\colon \langle I,X\rangle=n\}$" src="form_110.png"/> and the latter is not affected by deletions of coordinates in existing subgradients, so the cutting model is not affected in any way by deletions. For function evaluations the matter is more delicate. Here the objective is a support function evaluated for a cost vector affinely depending on the design variables y. For such functions any deletion of variables of value zero does not affect the outcome. Therefore deleting variables that are exactly zero in the current center and the current candidate (they coincide after descent steps) is safe. If, however, the deleted variable has a value ever so slightly deviating from zero, <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> will automatically reevaluate the function at the respective point. In order to be sure that problem modifications do not cause additional evaluations it is convenient to use the heuristic enabled by <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a5229f01c537d914a60b896bf01e550d5" title="If set to true (the default is false), variables may be fixed automatically to active bounds if these...">ConicBundle::MatrixCBSolver::set_active_bounds_fixing()</a> in main(). If the current center has a variable at its bounds and for a candidate the same bound is strongly active for the same variable, this variable is fixed to this bound for the next iterations until a descent step occurs. If, after the descent step, the variable is not deleted, it is set free again (and maybe fixed anew directly afterwards).</p>
<p>Here the only bounds are the lower bounds zero and any variable fixed to this bound by the heuristic will be exactly zero for the candidate as well. If the multiplier of a new inequality does not even start to get positive, its center coordinate still has value zero and so this quickly helps to get rid of less relevant inequalities. If multipliers got positive initially for some center point but then turned zero again, they may get fixed for this new center so that they are only deleted if their usefulness is in doubt repeatedly. The heuristic seems to work well but it is also not more than a rather simple heuristic.</p>
<p>The input variable fixed_indices provides a pointer to the indicator vector of fixed variable indices, if such a pointer was returned by the call to <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a8715eb8a6c956d314a108c8fd29636f7" title="Returns NULL or (iff active bound fixing is turned on in set_active_bounds_fixing()) the indicator ve...">ConicBundle::MatrixCBSolver::get_fixed_active_bounds()</a> in the main loop of main(). The variables to indices with nonzero entries in this vector are save to delete.</p>
<p>For didactic purposes rather than out of necessity each nonzero index is first tested for indeed having value zero in the center point centery retrieved by <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a40b4df10fa42d417881ec55fad3616cd" title="Returns the next center point that was produced by the latest call to solve (in some problem modifica...">ConicBundle::MatrixCBSolver::get_center()</a> before it is appended to the Indexmatrix delind. For each index in delind the corresponding coefficient matrix is extracted from mc() and cast into a pointer to <a class="el" href="classConicBundle_1_1CMsymsparse.html" title="implements a general sparse symmetric Coeffmat based on CH_Matrix_Classes::Sparsesym (for use with Ma...">ConicBundle::CMsymsparse</a>. The sparse representation indi,indj,val obtained by calling <a class="el" href="classConicBundle_1_1CMsymsparse.html#af09e1b09b679decfa193a6370511abcb" title="returns 0 if not sparse, otherwise 1 ">ConicBundle::CMsymsparse::sparse()</a> is then used to form the corresponding Triangle indicator t for finding and deleting t in the set added_triangles.</p>
<p>Finally the call to <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a6396522aada2447cf05b5e699adbd0f7" title="Deletes variables corresponding to the specified indices. ">ConicBundle::MatrixCBSolver::delete_variables()</a> with argument delind internally generates or updates the necessary modification objects that will be passed to the bundle method and the function mc() for actually deleting these indices and their associated bounds and coefficient matrices. The assignment of the new indices after deletion to the old indices before deletion is returned in map_to_old but this map is not needed here.</p>
<p>The deletion of variables is executed at the end of the function update_triangle_constraints() on purpose for two reasons. First, it seems pointless to add violated inequalities whose multipliers did not turn positive before even if the inequalities are still violated, so they should sill be present in added_triangles when testing for the addition of new inequalities. Second, when retrieving data after some variables have been deleted, the accumulated modifications on the problem description are executed first before returning the data. This may cause unnecessary additional work and even difficulties if some data like function values is invalidated by these modifications.</p>
<h1>The Source Code of mc_triangle.cxx </h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;set&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;queue&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="CMsingleton_8hxx.html">CMsingleton.hxx</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="CMsymsparse_8hxx.html">CMsymsparse.hxx</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="MatrixCBSolver_8hxx.html">MatrixCBSolver.hxx</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="PSCAffineFunction_8hxx.html">PSCAffineFunction.hxx</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceCH__Matrix__Classes.html">CH_Matrix_Classes</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceConicBundle.html">ConicBundle</a>;</div><div class="line"><span class="keyword">using namespace </span>std;</div><div class="line"></div><div class="line"><span class="comment">//*****************************************************************************</span></div><div class="line"><span class="comment">//                                Triangle</span></div><div class="line"><span class="comment">//*****************************************************************************</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>Triangle</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> i,j,k; </div><div class="line">  </div><div class="line"><span class="keyword">public</span>:</div><div class="line">  </div><div class="line">  Triangle(<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> ii,<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> jj,<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> kk,<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> signj,<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> signk):i(ii),j(jj*signj),k(kk*signk)</div><div class="line">  { assert((0&lt;=ii)&amp;&amp;(ii&lt;jj)&amp;&amp;(jj&lt;kk)&amp;&amp;(<a class="code" href="group__mymath.html#ga276d1229513a051379f74d47a3d23a78">std::abs</a>(signj)==1)&amp;&amp;(<a class="code" href="group__mymath.html#ga276d1229513a051379f74d47a3d23a78">std::abs</a>(signk)==1)); }</div><div class="line"></div><div class="line">  Triangle(<span class="keyword">const</span> Triangle&amp; tr)</div><div class="line">  { i=tr.i; j=tr.j; k=tr.k; }</div><div class="line"></div><div class="line">  ~Triangle(){}</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> <a class="code" href="group__Indexmatrix__friends.html#gaa432b2faadf4350010484d2aa01f136f">operator&lt;</a>(<span class="keyword">const</span> Triangle&amp; tr)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (i!=tr.i) <span class="keywordflow">return</span> (i&lt;tr.i);</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__mymath.html#ga276d1229513a051379f74d47a3d23a78">std::abs</a>(j)!=<a class="code" href="group__mymath.html#ga276d1229513a051379f74d47a3d23a78">std::abs</a>(tr.j)) <span class="keywordflow">return</span> (<a class="code" href="group__mymath.html#ga276d1229513a051379f74d47a3d23a78">std::abs</a>(j)&lt;<a class="code" href="group__mymath.html#ga276d1229513a051379f74d47a3d23a78">std::abs</a>(tr.j));</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__mymath.html#ga276d1229513a051379f74d47a3d23a78">std::abs</a>(k)!=<a class="code" href="group__mymath.html#ga276d1229513a051379f74d47a3d23a78">std::abs</a>(tr.k)) <span class="keywordflow">return</span> (<a class="code" href="group__mymath.html#ga276d1229513a051379f74d47a3d23a78">std::abs</a>(k)&lt;<a class="code" href="group__mymath.html#ga276d1229513a051379f74d47a3d23a78">std::abs</a>(tr.k));</div><div class="line">    <span class="keywordflow">if</span> (j!=tr.j) <span class="keywordflow">return</span> (j&lt;tr.j);</div><div class="line">    <span class="keywordflow">return</span> (k&lt;tr.k);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> get_ijk(<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>&amp; ii,<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>&amp; jj,<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>&amp; kk,<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>&amp; signj,<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>&amp; signk)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{ ii=i; jj=<a class="code" href="group__mymath.html#ga276d1229513a051379f74d47a3d23a78">std::abs</a>(j); kk=<a class="code" href="group__mymath.html#ga276d1229513a051379f74d47a3d23a78">std::abs</a>(k); signj=(j&lt;0?-1:1); signk=(k&lt;0?-1:1); }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">//*****************************************************************************</span></div><div class="line"><span class="comment">//                                TriangleViolation</span></div><div class="line"><span class="comment">//*****************************************************************************</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>TriangleViolation</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  Triangle triangle;</div><div class="line">  <a class="code" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> violation;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  TriangleViolation(<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> ii,<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> jj,<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> kk,<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> signj,<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> signk,<a class="code" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> viol):</div><div class="line">    triangle(ii,jj,kk,signj,signk),violation(viol)</div><div class="line">  {}</div><div class="line"></div><div class="line">  TriangleViolation(<span class="keyword">const</span> TriangleViolation&amp; Tr):</div><div class="line">    triangle(Tr.triangle),violation(Tr.violation)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> <a class="code" href="group__Indexmatrix__friends.html#gaa432b2faadf4350010484d2aa01f136f">operator&lt;</a>(<span class="keyword">const</span> TriangleViolation&amp; Tr)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> (violation&lt;Tr.violation);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> Triangle&amp; get_triangle()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{ <span class="keywordflow">return</span> triangle; }</div><div class="line"></div><div class="line">  <a class="code" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> get_violation()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{<span class="keywordflow">return</span> violation;}</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//*****************************************************************************</span></div><div class="line"><span class="comment">//                               added_triangles</span></div><div class="line"><span class="comment">//*****************************************************************************</span></div><div class="line"></div><div class="line"><span class="comment">//for storing information about the added triangle inequalities </span></div><div class="line"><span class="keyword">typedef</span> std::set&lt;Triangle&gt; AddedTriangles;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//*****************************************************************************</span></div><div class="line"><span class="comment">//                      update_triangle_constraints()</span></div><div class="line"><span class="comment">//*****************************************************************************</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> update_triangle_constraints(<a class="code" href="classConicBundle_1_1MatrixCBSolver.html">MatrixCBSolver</a>&amp; solver,<a class="code" href="classConicBundle_1_1PSCAffineFunction.html">PSCAffineFunction</a>&amp; mc,AddedTriangles&amp; added_triangles,<span class="keyword">const</span> <a class="code" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a>* fixed_indices,<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> nnodes,<span class="keyword">const</span> <a class="code" href="classConicBundle_1_1GramSparsePSCPrimal.html">GramSparsePSCPrimal</a>* primalX,<a class="code" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&amp; violation)</div><div class="line">{</div><div class="line">  <span class="comment">//-- get and form an approximation of the primal matrix X</span></div><div class="line">  <a class="code" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> X(*primalX);</div><div class="line">  <a class="code" href="namespaceCH__Matrix__Classes.html#addc379f9a6f5446df004d655c25671a2">rankadd</a>(primalX-&gt;<a class="code" href="classConicBundle_1_1GramSparsePSCPrimal.html#a0df6a020d662733b2050aa1ff0928b03">get_grammatrix</a>(),X,1.,1.);</div><div class="line"></div><div class="line">  <span class="comment">//-- find the n most violated triangle inequalities</span></div><div class="line">  std::size_t at_most_n_violated=std::size_t(<a class="code" href="group__mymath.html#gacc2ec082a83b13e107b4dba79386f1d5">max</a>(nnodes,10));</div><div class="line">  <a class="code" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> violation_threshold=-1-1e-3;</div><div class="line">  </div><div class="line">  std::priority_queue&lt;TriangleViolation&gt; most_violated;</div><div class="line">  <span class="keywordflow">for</span>(<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> i=0;i&lt;nnodes;i++){</div><div class="line">    <span class="keywordflow">for</span>(<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> j=i+1;j&lt;nnodes;j++){</div><div class="line">      <a class="code" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> xij=X(i,j);</div><div class="line">      <span class="keywordflow">for</span>(<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> k=j+1;k&lt;nnodes;k++){</div><div class="line">        <a class="code" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> xik=X(i,k);</div><div class="line">        <a class="code" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> xjk=X(j,k);</div><div class="line">        <span class="keywordtype">int</span> signj=1;</div><div class="line">        <span class="keywordtype">int</span> signk=1;</div><div class="line">        <a class="code" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> viol=xij+xik+xjk;</div><div class="line">        <a class="code" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> v=xij-xik-xjk;</div><div class="line">        <span class="keywordflow">if</span> (v&lt;viol){</div><div class="line">          viol=v;</div><div class="line">          signk=-1;</div><div class="line">        }</div><div class="line">        v=-xij+xik-xjk;</div><div class="line">        <span class="keywordflow">if</span> (v&lt;viol){</div><div class="line">          viol=v;</div><div class="line">          signj=-1;</div><div class="line">          signk=1;</div><div class="line">        }</div><div class="line">        v=-xij-xik+xjk;</div><div class="line">        <span class="keywordflow">if</span> (v&lt;viol){</div><div class="line">          viol=v;</div><div class="line">          signj=-1;</div><div class="line">          signk=-1;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (viol&lt;violation_threshold){</div><div class="line">          <span class="keywordflow">if</span> (most_violated.size()==at_most_n_violated){</div><div class="line">            most_violated.pop();</div><div class="line">          }</div><div class="line">          most_violated.push(TriangleViolation(i,j,k,signj,signk,viol));</div><div class="line">          <span class="keywordflow">if</span> (most_violated.size()==at_most_n_violated){</div><div class="line">            violation_threshold=most_violated.top().get_violation();</div><div class="line">          }</div><div class="line">        }</div><div class="line">      }  <span class="comment">// end k</span></div><div class="line">    } <span class="comment">// end j</span></div><div class="line">  } <span class="comment">// end i</span></div><div class="line"></div><div class="line">  <span class="comment">//-- build the coefficient matrices for those that are not yet included</span></div><div class="line">  <a class="code" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> indi(3,1,<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>(0));  <span class="comment">//row indices for sparse representation</span></div><div class="line">  <a class="code" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> indj(3,1,<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>(0));  <span class="comment">//col indices for sparse representation</span></div><div class="line">  <a class="code" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> val(3,1,1.);                <span class="comment">//values for sparse representation</span></div><div class="line">  <a class="code" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> A;                       <span class="comment">//sparse symmetric matrix representation</span></div><div class="line">  <a class="code" href="group__implemented__psc__oracle.html#gaa065caa1c123a98624554ea3a2af65ef">CoeffmatVector</a> tr_ineqs;           <span class="comment">//collects the ineqs coefficient matrices</span></div><div class="line">  tr_ineqs.reserve(most_violated.size());</div><div class="line">  <a class="code" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> sumviol=0.;     <span class="comment">//for computing the average violation of added ineqs</span></div><div class="line">  </div><div class="line">  <span class="keywordflow">while</span>(most_violated.size()&gt;0){</div><div class="line">    <span class="comment">//check whether the inequality is new</span></div><div class="line">    <span class="keywordflow">if</span> (added_triangles.find(most_violated.top().get_triangle())==added_triangles.end()){</div><div class="line">      <span class="comment">//it is new, form and append it multiplied by -1 for nonneg. multipiers</span></div><div class="line">      violation=-1.-most_violated.top().get_violation(); <span class="comment">//the last is the most violated one</span></div><div class="line">      sumviol+=violation;</div><div class="line">      added_triangles.insert(most_violated.top().get_triangle());</div><div class="line">      <a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> i,j,k,signj,signk;</div><div class="line">      most_violated.top().get_triangle().get_ijk(i,j,k,signj,signk);</div><div class="line">      indi(0)=i; indj(0)=j; val(0)=.5*signj;</div><div class="line">      indi(1)=i; indj(1)=k; val(1)=.5*signk;</div><div class="line">      indi(2)=j; indj(2)=k; val(2)=.5*signj*signk;</div><div class="line">      <a class="code" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> A(nnodes,3,indi,indj,val);</div><div class="line">      tr_ineqs.push_back(<span class="keyword">new</span> <a class="code" href="classConicBundle_1_1CMsymsparse.html">CMsymsparse</a>(A));</div><div class="line">    }</div><div class="line">    most_violated.pop();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">//-- add the coefficient matrices (the primal constraints) to the problem</span></div><div class="line">  <a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> ncols(<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>(tr_ineqs.size()));</div><div class="line">  <span class="keywordflow">if</span> (ncols&gt;0){</div><div class="line">    std::cout&lt;&lt;<span class="stringliteral">&quot; nnew=&quot;</span>&lt;&lt;ncols&lt;&lt;<span class="stringliteral">&quot; maxviol=&quot;</span>&lt;&lt;violation&lt;&lt;<span class="stringliteral">&quot; avgviol=&quot;</span>&lt;&lt;sumviol/ncols&lt;&lt;std::endl;</div><div class="line">    <span class="comment">//form the row of the coefficient matrix that has to be appended</span></div><div class="line">    indi.init(ncols,1,<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>(0));</div><div class="line">    indj.init(<a class="code" href="classCH__Matrix__Classes_1_1Range.html">Range</a>(0,ncols-1));</div><div class="line">    <a class="code" href="classConicBundle_1_1SparseCoeffmatMatrix.html">SparseCoeffmatMatrix</a> scm(mc.<a class="code" href="group__implemented__psc__oracle.html#ga9cc756f3c2cafe3d5be9f7abaaa39012">get_opAt</a>().<a class="code" href="classConicBundle_1_1SparseCoeffmatMatrix.html#a1f779177197adabe8345e79008d999f1">blockdim</a>(),ncols,&amp;indi,&amp;indj,&amp;tr_ineqs);</div><div class="line">    <span class="comment">//form the modification info for the PSCAffineFunction mc</span></div><div class="line">    <a class="code" href="classConicBundle_1_1PSCAffineModification.html">PSCAffineModification</a> funmod(solver.<a class="code" href="classConicBundle_1_1MatrixCBSolver.html#a9a7539b7da68fa4c0093005fe41ea73f">get_dim</a>(),mc.<a class="code" href="group__implemented__psc__oracle.html#ga9cc756f3c2cafe3d5be9f7abaaa39012">get_opAt</a>().<a class="code" href="classConicBundle_1_1SparseCoeffmatMatrix.html#a1f779177197adabe8345e79008d999f1">blockdim</a>(),&amp;solver); </div><div class="line">    funmod.<a class="code" href="classConicBundle_1_1PSCAffineModification.html#aced75851a81f1850daf8915211be3d4a">add_append_vars</a>(ncols,&amp;scm);</div><div class="line">    funmod.set_skip_extension(<span class="keyword">true</span>); <span class="comment">//constraints likely not in support of the Laplacian</span></div><div class="line">    <span class="comment">//set the function-object-modifcation-map</span></div><div class="line">    <a class="code" href="namespaceConicBundle.html#ad078c3e597a104edaccd983cddf6a134">FunObjModMap</a> modmap;</div><div class="line">    modmap[&amp;mc]=&amp;funmod;</div><div class="line">    <span class="comment">//append the new Lagrange mulitpliers for &lt;=1. constraints </span></div><div class="line">    <a class="code" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> lower_bounds(ncols,1,0.);</div><div class="line">    <a class="code" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> costs(ncols,1,1.);</div><div class="line">    <span class="keywordflow">if</span> (solver.<a class="code" href="classConicBundle_1_1MatrixCBSolver.html#ae94677e63dc7736099a77acaad553a3f">append_variables</a>(ncols,&amp;lower_bounds,0,0,0,&amp;costs,&amp;modmap)){</div><div class="line">      cout&lt;&lt;<span class="stringliteral">&quot;**** ERROR in solver.append_variables(...)&quot;</span>&lt;&lt;endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">//---- delete the triangle constraints whose multipliers are fixed to zero</span></div><div class="line">  <a class="code" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> centery;</div><div class="line">  <span class="keywordflow">if</span> (solver.<a class="code" href="classConicBundle_1_1MatrixCBSolver.html#a40b4df10fa42d417881ec55fad3616cd">get_center</a>(centery)){</div><div class="line">    cout&lt;&lt;<span class="stringliteral">&quot;**** ERROR in solver.get_candidate()&quot;</span>&lt;&lt;endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">if</span> (fixed_indices) {</div><div class="line">    <a class="code" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> delind(fixed_indices-&gt;<a class="code" href="classCH__Matrix__Classes_1_1Indexmatrix.html#ae14481555b24c34f9d37442d4e087935">rowdim</a>(),1);</div><div class="line">    delind.<a class="code" href="classCH__Matrix__Classes_1_1Indexmatrix.html#a8ef885d011c31c29df8f259e3d19ebfc">init</a>(0,1,<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>(0));</div><div class="line">    <span class="keywordflow">for</span>(<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> i=nnodes;i&lt;fixed_indices-&gt;<a class="code" href="classCH__Matrix__Classes_1_1Indexmatrix.html#ae14481555b24c34f9d37442d4e087935">rowdim</a>();i++){</div><div class="line">      <span class="keywordflow">if</span> ((*fixed_indices)(i)&amp;&amp;(centery(i)==0.)){</div><div class="line">        delind.<a class="code" href="classCH__Matrix__Classes_1_1Indexmatrix.html#a7e6bb9122767f53c31e81a81852c0fa3">concat_below</a>(i);</div><div class="line">      }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (delind.rowdim()&gt;0){</div><div class="line">      <span class="comment">//check which are triangle constraints for cleaning up AddedTriangles</span></div><div class="line">      <a class="code" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> indi,indj;</div><div class="line">      <a class="code" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> val;</div><div class="line">      <span class="keywordflow">for</span>(<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> i=0;i&lt;delind.rowdim();i++){</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classConicBundle_1_1CMsymsparse.html">CMsymsparse</a>* cm=<span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span><a class="code" href="classConicBundle_1_1CMsymsparse.html">CMsymsparse</a>*<span class="keyword">&gt;</span>(mc.<a class="code" href="group__implemented__psc__oracle.html#ga9cc756f3c2cafe3d5be9f7abaaa39012">get_opAt</a>()(0,delind(i)).ptr());</div><div class="line">        assert(cm);</div><div class="line">        cm-&gt;<a class="code" href="classConicBundle_1_1CMsymsparse.html#af09e1b09b679decfa193a6370511abcb">sparse</a>(indi,indj,val,2.);</div><div class="line">        assert(indi.<a class="code" href="classCH__Matrix__Classes_1_1Indexmatrix.html#ae14481555b24c34f9d37442d4e087935">rowdim</a>()==3);</div><div class="line">        <a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> ii=indi(0);</div><div class="line">        <a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> jj=indj(0);</div><div class="line">        <a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> kk=indj(1);</div><div class="line">        assert((indi(1)==ii)&amp;&amp;(indi(2)==jj)&amp;&amp;(indj(2)==kk)&amp;&amp;(ii&lt;jj)&amp;&amp;(jj&lt;kk));</div><div class="line">        <a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> signj=val(0)&gt;0?1:-1;</div><div class="line">        <a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> signk=val(1)&gt;0?1:-1;</div><div class="line">        assert(std::fabs(val(0)-signj)&lt;1e-6);</div><div class="line">        assert(std::fabs(val(1)-signk)&lt;1e-6);</div><div class="line">        assert(std::fabs(val(2)-signj*signk)&lt;1e-6);</div><div class="line">        AddedTriangles::iterator it=added_triangles.find(Triangle(ii,jj,kk,signj,signk));</div><div class="line">        assert(it!=added_triangles.end());</div><div class="line">        added_triangles.erase(it);</div><div class="line">      }</div><div class="line">      </div><div class="line">      <span class="comment">//delete the variable</span></div><div class="line">      <a class="code" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> map_to_old;</div><div class="line">      <span class="keywordflow">if</span>(solver.<a class="code" href="classConicBundle_1_1MatrixCBSolver.html#a6396522aada2447cf05b5e699adbd0f7">delete_variables</a>(delind,map_to_old)){</div><div class="line">        cout&lt;&lt;<span class="stringliteral">&quot;**** ERROR in solver.get_lbounds()&quot;</span>&lt;&lt;endl;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">      }</div><div class="line">      </div><div class="line">      cout&lt;&lt;<span class="stringliteral">&quot; deleted &quot;</span>&lt;&lt;delind.<a class="code" href="classCH__Matrix__Classes_1_1Indexmatrix.html#ae14481555b24c34f9d37442d4e087935">rowdim</a>();</div><div class="line">    }</div><div class="line">  }</div><div class="line">  cout&lt;&lt;<span class="stringliteral">&quot; next_dim=&quot;</span>&lt;&lt;solver.<a class="code" href="classConicBundle_1_1MatrixCBSolver.html#a9a7539b7da68fa4c0093005fe41ea73f">get_dim</a>()&lt;&lt;std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//*****************************************************************************</span></div><div class="line"><span class="comment">//                               GW_rounding()</span></div><div class="line"><span class="comment">//*****************************************************************************</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> GW_rounding(<span class="keyword">const</span> <a class="code" href="classConicBundle_1_1GramSparsePSCPrimal.html">GramSparsePSCPrimal</a>* primalX,<span class="keyword">const</span> <a class="code" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a>&amp; L,<a class="code" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&amp; bestcut,<a class="code" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&amp; bestcut_val)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&amp; Gram_mat=primalX-&gt;<a class="code" href="classConicBundle_1_1GramSparsePSCPrimal.html#a0df6a020d662733b2050aa1ff0928b03">get_grammatrix</a>();</div><div class="line">  <span class="comment">//--- try the signs of the most important column first</span></div><div class="line">  <a class="code" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> cut(Gram_mat.<a class="code" href="classCH__Matrix__Classes_1_1Matrix.html#aa0b971a8038cf3f399829404aff2a253">col</a>(0));</div><div class="line">  <span class="keywordflow">for</span>(<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> i=0;i&lt;cut.rowdim();i++)</div><div class="line">    cut(i)=cut(i)&gt;0.?1:-1;</div><div class="line">  <a class="code" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> cutval=<a class="code" href="namespaceCH__Matrix__Classes.html#af4fa805785a8e3572f072ef87046e3a4">ip</a>(cut,L*cut);</div><div class="line">  <span class="keywordflow">if</span> (cutval&gt;bestcut_val){</div><div class="line">    bestcut=cut;</div><div class="line">    bestcut_val=cutval;</div><div class="line">  }</div><div class="line">  <span class="comment">//--- try Goemans Williamson rounding</span></div><div class="line">  <a class="code" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> rand_dir;</div><div class="line">  <a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> n_tries=<a class="code" href="group__mymath.html#gacc2ec082a83b13e107b4dba79386f1d5">max</a>(L.<a class="code" href="classCH__Matrix__Classes_1_1Sparsesym.html#a4948e51843fc54506e1b8c72ef777db5">rowdim</a>()/10,10);</div><div class="line">  <span class="keywordflow">for</span> (<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> r=0;r&lt;n_tries;r++){</div><div class="line">    rand_dir.<a class="code" href="classCH__Matrix__Classes_1_1Matrix.html#a976bd8f8f2e92dad8d529cfdd85e3328">rand_normal</a>(Gram_mat.<a class="code" href="classCH__Matrix__Classes_1_1Matrix.html#aa4d7d4dd61273a6fd62a6b7357d845ad">coldim</a>(),1);</div><div class="line">    <a class="code" href="group__Indexmatrix__friends.html#ga1ca1762a0de9bf27d795eb5ea5db10db">genmult</a>(Gram_mat,rand_dir,cut);</div><div class="line">    <span class="keywordflow">for</span>(<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> i=0;i&lt;cut.rowdim();i++)</div><div class="line">      cut(i)=cut(i)&gt;0.?1:-1;</div><div class="line">    cutval=<a class="code" href="namespaceCH__Matrix__Classes.html#af4fa805785a8e3572f072ef87046e3a4">ip</a>(cut,L*cut);</div><div class="line">    <span class="keywordflow">if</span> (cutval&gt;bestcut_val){</div><div class="line">      bestcut=cut;</div><div class="line">      bestcut_val=cutval;</div><div class="line">    }</div><div class="line">  }</div><div class="line">  cout&lt;&lt;<span class="stringliteral">&quot; best_cut=&quot;</span>&lt;&lt;bestcut_val&lt;&lt;std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//*****************************************************************************</span></div><div class="line"><span class="comment">//                                 main()</span></div><div class="line"><span class="comment">//*****************************************************************************</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="comment">//---- read the graph into (indi,indj,val) triples (replace val by 1.)</span></div><div class="line">  <a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> nnodes,medges;</div><div class="line"></div><div class="line">  cin&gt;&gt;nnodes&gt;&gt;medges;</div><div class="line"></div><div class="line">  <a class="code" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> indi(medges,1,<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>(0));</div><div class="line">  <a class="code" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> indj(medges,1,<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>(0));</div><div class="line">  <a class="code" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> val(medges,1,1.);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt;medges; i++) {</div><div class="line">    <span class="keywordtype">int</span> head;</div><div class="line">    <span class="keywordtype">int</span> tail;</div><div class="line">    <span class="keywordtype">double</span> d;</div><div class="line">    cin&gt;&gt;tail&gt;&gt;head&gt;&gt;d;      </div><div class="line">    indi(i)=tail-1;</div><div class="line">    indj(i)=head-1;</div><div class="line">    <span class="comment">//val(i)=d;               //edge weight d could be plugged in here</span></div><div class="line">  }</div><div class="line">  </div><div class="line">  <span class="comment">//---- form Laplacian/4. as a Sparse Symmetric cost matrix</span></div><div class="line">  <a class="code" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> L(nnodes,medges,indi,indj,val);</div><div class="line">  <a class="code" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> Ldiag(<a class="code" href="group__Indexmatrix__friends.html#ga69ea0a39574b9819cc812c9954a276aa">diag</a>(L));</div><div class="line">  L-=<a class="code" href="namespaceCH__Matrix__Classes.html#a78bedebbd07509337535d711502f448e">sparseDiag</a>(Ldiag);</div><div class="line">  Ldiag.init(nnodes,1,<a class="code" href="group__Indexmatrix__friends.html#ga00ccad0d2dff09ef9a97e2525dab6972">sum</a>(L)/<a class="code" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>(nnodes));</div><div class="line">  L*=-1;</div><div class="line">  L+=<a class="code" href="namespaceCH__Matrix__Classes.html#a78bedebbd07509337535d711502f448e">sparseDiag</a>(Ldiag);</div><div class="line">  L/=4.;</div><div class="line">  <a class="code" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> bestcut(nnodes,1,1.);                <span class="comment">//initialize with empty cut</span></div><div class="line">  <a class="code" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> bestcut_val=<a class="code" href="namespaceCH__Matrix__Classes.html#af4fa805785a8e3572f072ef87046e3a4">ip</a>(bestcut,L*bestcut);</div><div class="line"></div><div class="line">  <span class="comment">//---- form the Affine Matrix Function Oracle</span></div><div class="line">  <a class="code" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> Xdim(1,1,nnodes);</div><div class="line">  <a class="code" href="classConicBundle_1_1SparseCoeffmatMatrix.html">SparseCoeffmatMatrix</a> C(Xdim,1);</div><div class="line">  C.set(0,0,<span class="keyword">new</span> <a class="code" href="classConicBundle_1_1CMsymsparse.html">CMsymsparse</a>(L));</div><div class="line"></div><div class="line">  <a class="code" href="classConicBundle_1_1SparseCoeffmatMatrix.html">SparseCoeffmatMatrix</a> opAt(Xdim,nnodes);</div><div class="line">  <span class="keywordflow">for</span> (<a class="code" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> i=0;i&lt;nnodes;i++)</div><div class="line">    opAt.set(0,i,<span class="keyword">new</span> <a class="code" href="classConicBundle_1_1CMsingleton.html">CMsingleton</a>(nnodes,i,i,-1.));</div><div class="line">  </div><div class="line">  <a class="code" href="classConicBundle_1_1PSCAffineFunction.html">PSCAffineFunction</a> mc(C,opAt,<span class="keyword">new</span> <a class="code" href="classConicBundle_1_1GramSparsePSCPrimal.html">GramSparsePSCPrimal</a>(L));</div><div class="line">  mc.<a class="code" href="group__implemented__psc__oracle.html#ga80f211db797c6a6ad04f5ac5f6d65a4f">set_out</a>(&amp;cout,0);</div><div class="line"></div><div class="line">  <span class="comment">//---- initialize the solver and the problem</span></div><div class="line">  <a class="code" href="classConicBundle_1_1MatrixCBSolver.html">MatrixCBSolver</a> cbsolver(&amp;cout,1);</div><div class="line">  <a class="code" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> lb(nnodes,1,<a class="code" href="group__cxxinterface.html#gae58492af3631a196b0edb8a8ebcda567">CB_minus_infinity</a>);</div><div class="line">  <a class="code" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> ub(nnodes,1,<a class="code" href="group__cxxinterface.html#ga15948e7611155f822fc0331bcbb4a111">CB_plus_infinity</a>);</div><div class="line">  <a class="code" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> rhs(nnodes,1,1.);</div><div class="line">  cbsolver.init_problem(nnodes,&amp;lb,&amp;ub,0,&amp;rhs);</div><div class="line">  cbsolver.add_function(mc,<a class="code" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>(nnodes),ObjectiveFunction,0,<span class="keyword">true</span>); </div><div class="line">   </div><div class="line">  <span class="comment">//---- call the solver</span></div><div class="line">  AddedTriangles added_triangles;  <span class="comment">//keeps track of added triangle inequalities</span></div><div class="line">  <a class="code" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> violation=0.;               <span class="comment">//latest maximum violation of a tr.-ineq.</span></div><div class="line">  <span class="comment">// if dual variables to tr.-ineqs. stay zero allow to fix them there </span></div><div class="line">  cbsolver.set_active_bounds_fixing(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">do</span> {</div><div class="line">    </div><div class="line">    <span class="comment">// solve with option to stop after 10 null steps or the next descent step</span></div><div class="line">    <span class="keywordtype">int</span> retval=cbsolver.solve(10,<span class="keyword">true</span>);</div><div class="line">    <span class="keywordflow">if</span> (retval) {</div><div class="line">      cout&lt;&lt;<span class="stringliteral">&quot;**** ERROR cbsolver.solve(..) returned &quot;</span>&lt;&lt;retval; </div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">//retrieve the current approximat primal semidefinite solution</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classConicBundle_1_1GramSparsePSCPrimal.html">GramSparsePSCPrimal</a>* primalX= <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span><a class="code" href="classConicBundle_1_1GramSparsePSCPrimal.html">GramSparsePSCPrimal</a>*<span class="keyword">&gt;</span>(cbsolver.get_approximate_primal(mc));</div><div class="line">    <span class="keywordflow">if</span> (primalX==0){</div><div class="line">      cout&lt;&lt;<span class="stringliteral">&quot;**** ERROR in cbsolver.get_approximate_primal()&quot;</span>&lt;&lt;endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">//try to improve the best found solution by Goemans-Williamson rounding</span></div><div class="line">    retval=GW_rounding(primalX,L,bestcut,bestcut_val);</div><div class="line">    <span class="keywordflow">if</span> (retval) {</div><div class="line">      cout&lt;&lt;<span class="stringliteral">&quot;**** GW_rounding(..) returned &quot;</span>&lt;&lt;retval; </div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (cbsolver.get_objval()-bestcut_val&lt;1.-1e-6){</div><div class="line">      cout&lt;&lt;<span class="stringliteral">&quot; gap between bound and feasible solution &lt;1.&quot;</span>&lt;&lt;std::endl;</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">//retrieve incidence vector of fixed variables</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a>* fixed_indices=cbsolver.get_fixed_active_bounds();</div><div class="line"></div><div class="line">    <span class="comment">// add new triangle inequalities and delete fixed ones</span></div><div class="line">    violation=0;</div><div class="line">    retval=update_triangle_constraints(cbsolver,mc,added_triangles,fixed_indices,nnodes,primalX,violation);</div><div class="line">    <span class="keywordflow">if</span> (retval) {</div><div class="line">      cout&lt;&lt;<span class="stringliteral">&quot;**** ERROR spearate(....) returned &quot;</span>&lt;&lt;retval; </div><div class="line">    }</div><div class="line">    </div><div class="line">  } <span class="keywordflow">while</span>((cbsolver.termination_code()==0)||</div><div class="line">          ((cbsolver.termination_code()&lt;2)&amp;&amp;(violation&gt;1e-2)));</div><div class="line"></div><div class="line">  <span class="comment">//---- print some information about the solution (process) and the problem</span></div><div class="line">  cbsolver.print_termination_code(cout);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
