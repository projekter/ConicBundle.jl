<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ConicBundle: CH_Matrix_Classes Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ConicBundle
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">CH_Matrix_Classes Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> Classes and Linear Algebra. See <a class="el" href="matrixclasses.html">Matrix Classes (namespace CH_Matrix_Classes)</a> for a quick introduction.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix class for integral values of type <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd" title="all integer numbers in calculations and indexing are of this type ">Integer</a>  <a href="classCH__Matrix__Classes_1_1Indexmatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1IterativeSolverObject.html">IterativeSolverObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface to iterative methods for solving Ax=b given by an <a class="el" href="classCH__Matrix__Classes_1_1IterativeSystemObject.html" title="Abstract base class for supplying the system for an iterative solver. ">IterativeSystemObject</a>.  <a href="classCH__Matrix__Classes_1_1IterativeSolverObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1IterativeSystemObject.html">IterativeSystemObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for supplying the system for an iterative solver.  <a href="classCH__Matrix__Classes_1_1IterativeSystemObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1LanczMaxEig.html">LanczMaxEig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classCH__Matrix__Classes_1_1Lanczos.html" title="Abstract interface to Lanzcos methods for computing a few extremal eigenvalues given via a Lanczosmat...">Lanczos</a> method allowing spectral transformation by Chebycheff polynomials and premature termination.  <a href="classCH__Matrix__Classes_1_1LanczMaxEig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Lanczos.html">Lanczos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface to Lanzcos methods for computing a few extremal eigenvalues given via a <a class="el" href="classCH__Matrix__Classes_1_1Lanczosmatrix.html" title="Abstract base class for supplying the input matrix for Lanzcosmethods. ">Lanczosmatrix</a>.  <a href="classCH__Matrix__Classes_1_1Lanczos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Lanczosmatrix.html">Lanczosmatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for supplying the input matrix for Lanzcosmethods.  <a href="classCH__Matrix__Classes_1_1Lanczosmatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Lanczpol.html">Lanczpol</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classCH__Matrix__Classes_1_1Lanczos.html" title="Abstract interface to Lanzcos methods for computing a few extremal eigenvalues given via a Lanczosmat...">Lanczos</a> method allowing spectral transformation by Chebycheff polynomials and premature termination.  <a href="classCH__Matrix__Classes_1_1Lanczpol.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCH__Matrix__Classes_1_1mat__greater__index.html">mat_greater_index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">"greater"-routine for sorting indices of value arrays by std::sort  <a href="structCH__Matrix__Classes_1_1mat__greater__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCH__Matrix__Classes_1_1mat__less__index.html">mat_less_index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">"less"-routine for sorting indices of value arrays by std::sort  <a href="structCH__Matrix__Classes_1_1mat__less__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix class for real values of type <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type ">Real</a>  <a href="classCH__Matrix__Classes_1_1Matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1MatrixError.html">MatrixError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Such an object is generated and passed to <a class="el" href="group__matop__matrixerror.html#ga6cb5e654c7a1ab7927cf4a6a5f8cf1ff" title="displays an error message and terminates via abort() or returns 1 in case of warnings. ">MEmessage()</a>, whenever an error occurs. It holds some output information on the error.  <a href="classCH__Matrix__Classes_1_1MatrixError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1MEdim.html">MEdim</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Such an object is generated and passed to <a class="el" href="group__matop__matrixerror.html#ga6cb5e654c7a1ab7927cf4a6a5f8cf1ff" title="displays an error message and terminates via abort() or returns 1 in case of warnings. ">MEmessage()</a> whenever matrix dimensions do not agree for a desired operation.  <a href="classCH__Matrix__Classes_1_1MEdim.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Memarray.html">Memarray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple memory manager for frequent allocation and deallocation of arrays of roughly the same size.  <a href="classCH__Matrix__Classes_1_1Memarray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Memarrayuser.html">Memarrayuser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">All derived classes share a common <a class="el" href="classCH__Matrix__Classes_1_1Memarray.html" title="A simple memory manager for frequent allocation and deallocation of arrays of roughly the same size...">Memarray</a> memory manager, which is generated with the first user and destructed when the last user is destructed.  <a href="classCH__Matrix__Classes_1_1Memarrayuser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1MEmem.html">MEmem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Such an object is generated and passed to <a class="el" href="group__matop__matrixerror.html#ga6cb5e654c7a1ab7927cf4a6a5f8cf1ff" title="displays an error message and terminates via abort() or returns 1 in case of warnings. ">MEmessage()</a> whenever a memory allocation fails.  <a href="classCH__Matrix__Classes_1_1MEmem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1MErange.html">MErange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Such an object is generated and passed to <a class="el" href="group__matop__matrixerror.html#ga6cb5e654c7a1ab7927cf4a6a5f8cf1ff" title="displays an error message and terminates via abort() or returns 1 in case of warnings. ">MEmessage()</a> whenever some index is out of range.  <a href="classCH__Matrix__Classes_1_1MErange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1MinRes.html">MinRes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCH__Matrix__Classes_1_1MinRes.html" title="MinRes method for solving Ax=b with symmetric (indefinite) matrix A and positive definite preconditio...">MinRes</a> method for solving Ax=b with symmetric (indefinite) matrix A and positive definite preconditioner M1 where the preconditioned system is A'x'=b' with A'=M1^{-.5}AM1^{-.5}, x'=M1^{.5}*x and b'=M1^{-.5}b. System matrix and preconditioner are provided by a <a class="el" href="classCH__Matrix__Classes_1_1IterativeSystemObject.html" title="Abstract base class for supplying the system for an iterative solver. ">CH_Matrix_Classes::IterativeSystemObject</a>.  <a href="classCH__Matrix__Classes_1_1MinRes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1PCG.html">PCG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preconditioned Conjugate Gradient method for solving Ax=b with (symmetric) positive definite matrix A and positive definite preconditioner M1 where the preconditioned system is A'x'=b' with A'=M1^{-.5}AM1^{-.5}, x'=M1^{.5}*x and b'=M1^{-.5}b. System matrix and preconditioner are provided by a <a class="el" href="classCH__Matrix__Classes_1_1IterativeSystemObject.html" title="Abstract base class for supplying the system for an iterative solver. ">CH_Matrix_Classes::IterativeSystemObject</a>.  <a href="classCH__Matrix__Classes_1_1PCG.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Psqmr.html">Psqmr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSQMR method for solving Ax=b with symmetric matrix A and symmetric preconditioner M=M1*M2 (M1 and M2 regular) where the preconditioned system is A'x'=b' with A'=M1^{-1}AM2^{-1}, x'=M2*x and b'=M1^{-1}b. System matrix and preconditioners are provided by a <a class="el" href="classCH__Matrix__Classes_1_1IterativeSystemObject.html" title="Abstract base class for supplying the system for an iterative solver. ">CH_Matrix_Classes::IterativeSystemObject</a>.  <a href="classCH__Matrix__Classes_1_1Psqmr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">allows to specify a range of integral values via (from, to, step) meaning {j=from+i*step:j in[from,to],i in {0,1,2,...}}  <a href="classCH__Matrix__Classes_1_1Range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Realrange.html">Realrange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">allows to specify a range of real values via (from, to, step,tol) meaning {x=from+i*step:x in(from-tol,to+tol),i in {0,1,2,...}}  <a href="classCH__Matrix__Classes_1_1Realrange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix class of sparse matrices with real values of type <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type ">Real</a>  <a href="classCH__Matrix__Classes_1_1Sparsemat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix class of symmetric matrices with real values of type <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type ">Real</a>  <a href="classCH__Matrix__Classes_1_1Sparsesym.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix class of symmetric matrices with real values of type <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type ">Real</a>  <a href="classCH__Matrix__Classes_1_1Symmatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga325dd69690071a98f09a8d74c50edccd"><td class="memItemLeft" align="right" valign="top">
typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a></td></tr>
<tr class="memdesc:ga325dd69690071a98f09a8d74c50edccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">all integer numbers in calculations and indexing are of this type <br /></td></tr>
<tr class="separator:ga325dd69690071a98f09a8d74c50edccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga531d7da3afa69ae831131bfe00f57f03"><td class="memItemLeft" align="right" valign="top">
typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a></td></tr>
<tr class="memdesc:ga531d7da3afa69ae831131bfe00f57f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">all real numbers in calculations are of this type <br /></td></tr>
<tr class="separator:ga531d7da3afa69ae831131bfe00f57f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga204f53041409b9f5efb2f8b41964b6b8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matop__matrixerror.html#ga204f53041409b9f5efb2f8b41964b6b8">Mtype</a> { <br />
&#160;&#160;<a class="el" href="group__matop__matrixerror.html#gga204f53041409b9f5efb2f8b41964b6b8acb13eb707ac23506847eaff9b5bf7907">MTglobalfun</a>, 
<a class="el" href="group__matop__matrixerror.html#gga204f53041409b9f5efb2f8b41964b6b8a98721b3185dbd848e0464401c2ac2991">MTindexmatrix</a>, 
<a class="el" href="group__matop__matrixerror.html#gga204f53041409b9f5efb2f8b41964b6b8a3e714e634e08a6d9345b82e9b616ccf3">MTmatrix</a>, 
<a class="el" href="group__matop__matrixerror.html#gga204f53041409b9f5efb2f8b41964b6b8ae886e71904483a6e647a9680cef1dbc5">MTsymmetric</a>, 
<br />
&#160;&#160;<a class="el" href="group__matop__matrixerror.html#gga204f53041409b9f5efb2f8b41964b6b8ace9d1b5ad9b28b4dfc2dbb8d757814d0">MTsparse</a>, 
<a class="el" href="group__matop__matrixerror.html#gga204f53041409b9f5efb2f8b41964b6b8aafb855e27185be8a7b33f210c1b6aa8b">MTsparsesym</a>
<br />
 }<tr class="memdesc:ga204f53041409b9f5efb2f8b41964b6b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">serves for specifying the source (matrix class or function) of the error  <a href="group__matop__matrixerror.html#ga204f53041409b9f5efb2f8b41964b6b8">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga204f53041409b9f5efb2f8b41964b6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36a66b038d3b495db56b668a56349fa8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matop__matrixerror.html#ga36a66b038d3b495db56b668a56349fa8">MEcode</a> { <br />
&#160;&#160;<a class="el" href="group__matop__matrixerror.html#gga36a66b038d3b495db56b668a56349fa8a466956aeace2007655ad3f4e248fe94e">ME_unspec</a>, 
<a class="el" href="group__matop__matrixerror.html#gga36a66b038d3b495db56b668a56349fa8a5a758328def3970ec3ab3067fbfe5523">ME_range</a>, 
<a class="el" href="group__matop__matrixerror.html#gga36a66b038d3b495db56b668a56349fa8af864c3c0f57d97225f8118b5d3d4b9d4">ME_mem</a>, 
<a class="el" href="group__matop__matrixerror.html#gga36a66b038d3b495db56b668a56349fa8a74e225bdc0facb7a96b9aad1fc45638e">ME_dim</a>, 
<br />
&#160;&#160;<a class="el" href="group__matop__matrixerror.html#gga36a66b038d3b495db56b668a56349fa8a0b32b89983321df50629cb7f9a0f7cf6">ME_num</a>, 
<a class="el" href="group__matop__matrixerror.html#gga36a66b038d3b495db56b668a56349fa8a6481caa6d5d43e93c57c77205c0623a0">ME_warning</a>
<br />
 }<tr class="memdesc:ga36a66b038d3b495db56b668a56349fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">serves for specifying the error type.  <a href="group__matop__matrixerror.html#ga36a66b038d3b495db56b668a56349fa8">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga36a66b038d3b495db56b668a56349fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad5a07879b3e760f4b4b0513cad303897"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:gad5a07879b3e760f4b4b0513cad303897"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#gad5a07879b3e760f4b4b0513cad303897">mat_xea</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const Val a)</td></tr>
<tr class="memdesc:gad5a07879b3e760f4b4b0513cad303897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]=a for len elements of the array x.  <a href="group__matop__templates.html#gad5a07879b3e760f4b4b0513cad303897">More...</a><br /></td></tr>
<tr class="separator:gad5a07879b3e760f4b4b0513cad303897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03fa5a0124c132922185d9fbb602e44b"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:ga03fa5a0124c132922185d9fbb602e44b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#ga03fa5a0124c132922185d9fbb602e44b">mat_xea</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incx, const Val a)</td></tr>
<tr class="memdesc:ga03fa5a0124c132922185d9fbb602e44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]=a for len elements of the array x incremented by incx.  <a href="group__matop__templates.html#ga03fa5a0124c132922185d9fbb602e44b">More...</a><br /></td></tr>
<tr class="separator:ga03fa5a0124c132922185d9fbb602e44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8aedc354b62b2c49683001dc14211ee"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:gae8aedc354b62b2c49683001dc14211ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#gae8aedc354b62b2c49683001dc14211ee">mat_xey</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const Val *y)</td></tr>
<tr class="memdesc:gae8aedc354b62b2c49683001dc14211ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an array of length len to destination x from source y.  <a href="group__matop__templates.html#gae8aedc354b62b2c49683001dc14211ee">More...</a><br /></td></tr>
<tr class="separator:gae8aedc354b62b2c49683001dc14211ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4358cbcd2a58a99af50fed38748661a"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:gad4358cbcd2a58a99af50fed38748661a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#gad4358cbcd2a58a99af50fed38748661a">mat_xey</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incx, const Val *y, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incy)</td></tr>
<tr class="memdesc:gad4358cbcd2a58a99af50fed38748661a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an array of length len to destination x (increment incx) from source y (increment incy).  <a href="group__matop__templates.html#gad4358cbcd2a58a99af50fed38748661a">More...</a><br /></td></tr>
<tr class="separator:gad4358cbcd2a58a99af50fed38748661a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9d0695fd0344c813eef63c75ef90d37"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:gad9d0695fd0344c813eef63c75ef90d37"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#gad9d0695fd0344c813eef63c75ef90d37">mat_xmey</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const Val *y)</td></tr>
<tr class="memdesc:gad9d0695fd0344c813eef63c75ef90d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]=-y[i] for len elements of the arrays x and y.  <a href="group__matop__templates.html#gad9d0695fd0344c813eef63c75ef90d37">More...</a><br /></td></tr>
<tr class="separator:gad9d0695fd0344c813eef63c75ef90d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf246a2653e6174ec52baf0dc6e1e4a14"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:gaf246a2653e6174ec52baf0dc6e1e4a14"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#gaf246a2653e6174ec52baf0dc6e1e4a14">mat_xmey</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incx, const Val *y, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incy)</td></tr>
<tr class="memdesc:gaf246a2653e6174ec52baf0dc6e1e4a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]=-y[i] for len elements of the arrays x and y incremented by incx and incy, respectively.  <a href="group__matop__templates.html#gaf246a2653e6174ec52baf0dc6e1e4a14">More...</a><br /></td></tr>
<tr class="separator:gaf246a2653e6174ec52baf0dc6e1e4a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6be673c0a0a4724dbead1cf7b0cad416"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:ga6be673c0a0a4724dbead1cf7b0cad416"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#ga6be673c0a0a4724dbead1cf7b0cad416">mat_xemx</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x)</td></tr>
<tr class="memdesc:ga6be673c0a0a4724dbead1cf7b0cad416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]=-x[i] for an array of length len.  <a href="group__matop__templates.html#ga6be673c0a0a4724dbead1cf7b0cad416">More...</a><br /></td></tr>
<tr class="separator:ga6be673c0a0a4724dbead1cf7b0cad416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadabc5ce6ad875746fac0e76e40b8a45b"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:gadabc5ce6ad875746fac0e76e40b8a45b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#gadabc5ce6ad875746fac0e76e40b8a45b">mat_xemx</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incx)</td></tr>
<tr class="memdesc:gadabc5ce6ad875746fac0e76e40b8a45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]=-x[i] for len elements of an array incremented by incx.  <a href="group__matop__templates.html#gadabc5ce6ad875746fac0e76e40b8a45b">More...</a><br /></td></tr>
<tr class="separator:gadabc5ce6ad875746fac0e76e40b8a45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89bb90c9989e7e51d948caf753cea0f9"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:ga89bb90c9989e7e51d948caf753cea0f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#ga89bb90c9989e7e51d948caf753cea0f9">mat_xemy</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const Val *y)</td></tr>
<tr class="memdesc:ga89bb90c9989e7e51d948caf753cea0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]=-y[i] for len elements of the arrays x and y.  <a href="group__matop__templates.html#ga89bb90c9989e7e51d948caf753cea0f9">More...</a><br /></td></tr>
<tr class="separator:ga89bb90c9989e7e51d948caf753cea0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74d0afdedb49d7f079e5d07af6ff3bb1"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:ga74d0afdedb49d7f079e5d07af6ff3bb1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#ga74d0afdedb49d7f079e5d07af6ff3bb1">mat_xemy</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incx, const Val *y, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incy)</td></tr>
<tr class="memdesc:ga74d0afdedb49d7f079e5d07af6ff3bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]=-y[i] for len elements of the arrays x and y incremented by incx and incy, respectively.  <a href="group__matop__templates.html#ga74d0afdedb49d7f079e5d07af6ff3bb1">More...</a><br /></td></tr>
<tr class="separator:ga74d0afdedb49d7f079e5d07af6ff3bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga046b4e8554ae684f1b787d6e7cd5e162"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:ga046b4e8554ae684f1b787d6e7cd5e162"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#ga046b4e8554ae684f1b787d6e7cd5e162">mat_xeya</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const Val *y, const Val a)</td></tr>
<tr class="memdesc:ga046b4e8554ae684f1b787d6e7cd5e162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]=a*y[i] for len elements of the arrays x and y.  <a href="group__matop__templates.html#ga046b4e8554ae684f1b787d6e7cd5e162">More...</a><br /></td></tr>
<tr class="separator:ga046b4e8554ae684f1b787d6e7cd5e162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf56f17c35f4534cd5622accd1917cb32"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:gaf56f17c35f4534cd5622accd1917cb32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#gaf56f17c35f4534cd5622accd1917cb32">mat_xeya</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incx, const Val *y, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incy, const Val a)</td></tr>
<tr class="memdesc:gaf56f17c35f4534cd5622accd1917cb32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]=a*y[i] for len elements of the arrays x and y incremented by incx and incy, respectively.  <a href="group__matop__templates.html#gaf56f17c35f4534cd5622accd1917cb32">More...</a><br /></td></tr>
<tr class="separator:gaf56f17c35f4534cd5622accd1917cb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga825c770ea8edcd35368b505992fe02eb"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:ga825c770ea8edcd35368b505992fe02eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#ga825c770ea8edcd35368b505992fe02eb">mat_xpey</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const Val *y)</td></tr>
<tr class="memdesc:ga825c770ea8edcd35368b505992fe02eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]+=y[i] for len elements of the arrays x and y.  <a href="group__matop__templates.html#ga825c770ea8edcd35368b505992fe02eb">More...</a><br /></td></tr>
<tr class="separator:ga825c770ea8edcd35368b505992fe02eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54c19a8982ce476bec7e0a74384bb850"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:ga54c19a8982ce476bec7e0a74384bb850"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#ga54c19a8982ce476bec7e0a74384bb850">mat_xpey</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incx, const Val *y, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incy)</td></tr>
<tr class="memdesc:ga54c19a8982ce476bec7e0a74384bb850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]+=y[i] for len elements of the arrays x and y incremented by incx and incy, respectively.  <a href="group__matop__templates.html#ga54c19a8982ce476bec7e0a74384bb850">More...</a><br /></td></tr>
<tr class="separator:ga54c19a8982ce476bec7e0a74384bb850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11f38a4959e52fb2d76b3bd84d39d458"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:ga11f38a4959e52fb2d76b3bd84d39d458"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#ga11f38a4959e52fb2d76b3bd84d39d458">mat_xhadey</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const Val *y)</td></tr>
<tr class="memdesc:ga11f38a4959e52fb2d76b3bd84d39d458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]*=y[i] for len elements of the arrays x and y.  <a href="group__matop__templates.html#ga11f38a4959e52fb2d76b3bd84d39d458">More...</a><br /></td></tr>
<tr class="separator:ga11f38a4959e52fb2d76b3bd84d39d458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ccb04c7f3c65e181105b730cb97e399"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:ga0ccb04c7f3c65e181105b730cb97e399"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#ga0ccb04c7f3c65e181105b730cb97e399">mat_xinvhadey</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const Val *y)</td></tr>
<tr class="memdesc:ga0ccb04c7f3c65e181105b730cb97e399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]/=y[i] for len elements of the arrays x and y, no zero checking!  <a href="group__matop__templates.html#ga0ccb04c7f3c65e181105b730cb97e399">More...</a><br /></td></tr>
<tr class="separator:ga0ccb04c7f3c65e181105b730cb97e399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd4663b2afda8808b5d142dd2611debf"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:gafd4663b2afda8808b5d142dd2611debf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#gafd4663b2afda8808b5d142dd2611debf">mat_xhadey</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incx, const Val *y, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incy)</td></tr>
<tr class="memdesc:gafd4663b2afda8808b5d142dd2611debf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]*=y[i] for len elements of the arrays x and y incremented by incx and incy, respectively.  <a href="group__matop__templates.html#gafd4663b2afda8808b5d142dd2611debf">More...</a><br /></td></tr>
<tr class="separator:gafd4663b2afda8808b5d142dd2611debf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacadbba4d121707db53182573cfff8a1a"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:gacadbba4d121707db53182573cfff8a1a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#gacadbba4d121707db53182573cfff8a1a">mat_xinvhadey</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incx, const Val *y, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incy)</td></tr>
<tr class="memdesc:gacadbba4d121707db53182573cfff8a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]/=y[i] for len elements of the arrays x and y incremented by incx and incy, respectively, no zero checking!  <a href="group__matop__templates.html#gacadbba4d121707db53182573cfff8a1a">More...</a><br /></td></tr>
<tr class="separator:gacadbba4d121707db53182573cfff8a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8885290881b77bb24fe9b3d2a05bc9c4"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:ga8885290881b77bb24fe9b3d2a05bc9c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#ga8885290881b77bb24fe9b3d2a05bc9c4">mat_xpeya</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const Val *y, const Val a)</td></tr>
<tr class="memdesc:ga8885290881b77bb24fe9b3d2a05bc9c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]+=a*y[i] for len elements of the arrays x and y.  <a href="group__matop__templates.html#ga8885290881b77bb24fe9b3d2a05bc9c4">More...</a><br /></td></tr>
<tr class="separator:ga8885290881b77bb24fe9b3d2a05bc9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab058211838e0d4aa33da7aa5a2d61eea"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:gab058211838e0d4aa33da7aa5a2d61eea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#gab058211838e0d4aa33da7aa5a2d61eea">mat_xpeya</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incx, const Val *y, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incy, const Val a)</td></tr>
<tr class="memdesc:gab058211838e0d4aa33da7aa5a2d61eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]+=a*y[i] for len elements of the arrays x and y incremented by incx and incy, respectively.  <a href="group__matop__templates.html#gab058211838e0d4aa33da7aa5a2d61eea">More...</a><br /></td></tr>
<tr class="separator:gab058211838e0d4aa33da7aa5a2d61eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07c914d1e0ec2b14f612f6cf5d80212a"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:ga07c914d1e0ec2b14f612f6cf5d80212a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#ga07c914d1e0ec2b14f612f6cf5d80212a">mat_xbpeya</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const Val *y, const Val a, const Val b)</td></tr>
<tr class="memdesc:ga07c914d1e0ec2b14f612f6cf5d80212a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]=a*y[i]+b*x[i] for len elements of the arrays x and y.  <a href="group__matop__templates.html#ga07c914d1e0ec2b14f612f6cf5d80212a">More...</a><br /></td></tr>
<tr class="separator:ga07c914d1e0ec2b14f612f6cf5d80212a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b1d17763c6b514a9f776fbd28db6f29"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:ga8b1d17763c6b514a9f776fbd28db6f29"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#ga8b1d17763c6b514a9f776fbd28db6f29">mat_xbpeya</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incx, const Val *y, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incy, const Val a, const Val b)</td></tr>
<tr class="memdesc:ga8b1d17763c6b514a9f776fbd28db6f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]=a*y[i]+b*x[i] for len elements of the arrays x and y incremented by incx and incy, respectively.  <a href="group__matop__templates.html#ga8b1d17763c6b514a9f776fbd28db6f29">More...</a><br /></td></tr>
<tr class="separator:ga8b1d17763c6b514a9f776fbd28db6f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e779f18ca402c7e1753ad447a836544"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:ga3e779f18ca402c7e1753ad447a836544"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#ga3e779f18ca402c7e1753ad447a836544">mat_xpea</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const Val a)</td></tr>
<tr class="memdesc:ga3e779f18ca402c7e1753ad447a836544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]+=a for len elements of the array x.  <a href="group__matop__templates.html#ga3e779f18ca402c7e1753ad447a836544">More...</a><br /></td></tr>
<tr class="separator:ga3e779f18ca402c7e1753ad447a836544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga086b53295119c794e6420520cb0218da"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:ga086b53295119c794e6420520cb0218da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#ga086b53295119c794e6420520cb0218da">mat_xpea</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incx, const Val a)</td></tr>
<tr class="memdesc:ga086b53295119c794e6420520cb0218da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]+=a for len elements of the array x incremented by incx.  <a href="group__matop__templates.html#ga086b53295119c794e6420520cb0218da">More...</a><br /></td></tr>
<tr class="separator:ga086b53295119c794e6420520cb0218da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga203fcff7c95a029a6c21e0fd1d571d73"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:ga203fcff7c95a029a6c21e0fd1d571d73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#ga203fcff7c95a029a6c21e0fd1d571d73">mat_xmultea</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const Val a)</td></tr>
<tr class="memdesc:ga203fcff7c95a029a6c21e0fd1d571d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]*=a for len elements of the array x.  <a href="group__matop__templates.html#ga203fcff7c95a029a6c21e0fd1d571d73">More...</a><br /></td></tr>
<tr class="separator:ga203fcff7c95a029a6c21e0fd1d571d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68e902e131dded22e774942c88c83adb"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:ga68e902e131dded22e774942c88c83adb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#ga68e902e131dded22e774942c88c83adb">mat_xmultea</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incx, const Val a)</td></tr>
<tr class="memdesc:ga68e902e131dded22e774942c88c83adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]*=a for len elements of the array x incremented by incx.  <a href="group__matop__templates.html#ga68e902e131dded22e774942c88c83adb">More...</a><br /></td></tr>
<tr class="separator:ga68e902e131dded22e774942c88c83adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26b60c8fa91346e8aca47884cfa932a7"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:ga26b60c8fa91346e8aca47884cfa932a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#ga26b60c8fa91346e8aca47884cfa932a7">mat_xdivea</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const Val a)</td></tr>
<tr class="memdesc:ga26b60c8fa91346e8aca47884cfa932a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]/=a for len elements of the array x.  <a href="group__matop__templates.html#ga26b60c8fa91346e8aca47884cfa932a7">More...</a><br /></td></tr>
<tr class="separator:ga26b60c8fa91346e8aca47884cfa932a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace6910641589be13adcfff7b581f18b6"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:gace6910641589be13adcfff7b581f18b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#gace6910641589be13adcfff7b581f18b6">mat_xdivea</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incx, const Val a)</td></tr>
<tr class="memdesc:gace6910641589be13adcfff7b581f18b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]/=a for len elements of the array x incremented by incx.  <a href="group__matop__templates.html#gace6910641589be13adcfff7b581f18b6">More...</a><br /></td></tr>
<tr class="separator:gace6910641589be13adcfff7b581f18b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae52f8ca3253bebc1e1b138d5c94c6808"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:gae52f8ca3253bebc1e1b138d5c94c6808"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#gae52f8ca3253bebc1e1b138d5c94c6808">mat_xmodea</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const Val a)</td></tr>
<tr class="memdesc:gae52f8ca3253bebc1e1b138d5c94c6808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]%=a for len elements of the array x.  <a href="group__matop__templates.html#gae52f8ca3253bebc1e1b138d5c94c6808">More...</a><br /></td></tr>
<tr class="separator:gae52f8ca3253bebc1e1b138d5c94c6808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d95b090a14419a8f9c95cc0ad14fb0a"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:ga3d95b090a14419a8f9c95cc0ad14fb0a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#ga3d95b090a14419a8f9c95cc0ad14fb0a">mat_xmodea</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incx, const Val a)</td></tr>
<tr class="memdesc:ga3d95b090a14419a8f9c95cc0ad14fb0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]%=a for len elements of the array x incremented by incx.  <a href="group__matop__templates.html#ga3d95b090a14419a8f9c95cc0ad14fb0a">More...</a><br /></td></tr>
<tr class="separator:ga3d95b090a14419a8f9c95cc0ad14fb0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc400d677478ff755da5a6ada1d0e5f8"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:gadc400d677478ff755da5a6ada1d0e5f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#gadc400d677478ff755da5a6ada1d0e5f8">mat_xeypz</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const Val *y, const Val *z)</td></tr>
<tr class="memdesc:gadc400d677478ff755da5a6ada1d0e5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]=y[i]+z[i] for len elements of the arrays x, y and z.  <a href="group__matop__templates.html#gadc400d677478ff755da5a6ada1d0e5f8">More...</a><br /></td></tr>
<tr class="separator:gadc400d677478ff755da5a6ada1d0e5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca50b5983d946901780f282497e2b9df"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:gaca50b5983d946901780f282497e2b9df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#gaca50b5983d946901780f282497e2b9df">mat_xeypz</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incx, const Val *y, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incy, const Val *z, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incz)</td></tr>
<tr class="memdesc:gaca50b5983d946901780f282497e2b9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]=y[i]+z[i] for len elements of the arrays x, y and z incremented by incx, incy, and incz, respectively.  <a href="group__matop__templates.html#gaca50b5983d946901780f282497e2b9df">More...</a><br /></td></tr>
<tr class="separator:gaca50b5983d946901780f282497e2b9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab15a236ad9594883c10c5683ecaab631"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:gab15a236ad9594883c10c5683ecaab631"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#gab15a236ad9594883c10c5683ecaab631">mat_xeymz</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const Val *y, const Val *z)</td></tr>
<tr class="memdesc:gab15a236ad9594883c10c5683ecaab631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]=y[i]-z[i] for len elements of the arrays x, y and z.  <a href="group__matop__templates.html#gab15a236ad9594883c10c5683ecaab631">More...</a><br /></td></tr>
<tr class="separator:gab15a236ad9594883c10c5683ecaab631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b9593dbc9d4705df7e13d2a517cfbfe"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:ga5b9593dbc9d4705df7e13d2a517cfbfe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#ga5b9593dbc9d4705df7e13d2a517cfbfe">mat_xeymz</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incx, const Val *y, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incy, const Val *z, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incz)</td></tr>
<tr class="memdesc:ga5b9593dbc9d4705df7e13d2a517cfbfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]=y[i]-z[i] for len elements of the arrays x, y and z incremented by incx, incy, and incz, respectively.  <a href="group__matop__templates.html#ga5b9593dbc9d4705df7e13d2a517cfbfe">More...</a><br /></td></tr>
<tr class="separator:ga5b9593dbc9d4705df7e13d2a517cfbfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga029a70e9fddbd7041ff910cc0de1fb49"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:ga029a70e9fddbd7041ff910cc0de1fb49"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#ga029a70e9fddbd7041ff910cc0de1fb49">mat_xeyapzb</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const Val *y, const Val *z, const Val a, const Val b)</td></tr>
<tr class="memdesc:ga029a70e9fddbd7041ff910cc0de1fb49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]=a*y[i]+b*z[i] for len elements of the arrays x, y and z.  <a href="group__matop__templates.html#ga029a70e9fddbd7041ff910cc0de1fb49">More...</a><br /></td></tr>
<tr class="separator:ga029a70e9fddbd7041ff910cc0de1fb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2b4a2b567b4f41eaf6af54e19e4a573"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:gaf2b4a2b567b4f41eaf6af54e19e4a573"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#gaf2b4a2b567b4f41eaf6af54e19e4a573">mat_xeyapzb</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incx, const Val *y, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incy, const Val *z, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incz, const Val a, const Val b)</td></tr>
<tr class="memdesc:gaf2b4a2b567b4f41eaf6af54e19e4a573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set x[i]=a*y[i]+b*z[i] for len elements of the arrays x, y and z incremented by incx, incy, and incz, respectively.  <a href="group__matop__templates.html#gaf2b4a2b567b4f41eaf6af54e19e4a573">More...</a><br /></td></tr>
<tr class="separator:gaf2b4a2b567b4f41eaf6af54e19e4a573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb4011ad6ce93b583e49ba9afe4f363e"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:gabb4011ad6ce93b583e49ba9afe4f363e"><td class="memTemplItemLeft" align="right" valign="top">Val&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#gabb4011ad6ce93b583e49ba9afe4f363e">mat_ip</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, const Val *x, const Val *y, const Val *d=0)</td></tr>
<tr class="memdesc:gabb4011ad6ce93b583e49ba9afe4f363e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return sum(x[i]*y[i]) summing over len elements of the arrays x and y.  <a href="group__matop__templates.html#gabb4011ad6ce93b583e49ba9afe4f363e">More...</a><br /></td></tr>
<tr class="separator:gabb4011ad6ce93b583e49ba9afe4f363e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac445fc9e7c5d34b1a0daae8f5a98f0f0"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:gac445fc9e7c5d34b1a0daae8f5a98f0f0"><td class="memTemplItemLeft" align="right" valign="top">Val&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#gac445fc9e7c5d34b1a0daae8f5a98f0f0">mat_ip</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, const Val *x, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incx, const Val *y, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incy, const Val *d=0, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incd=1)</td></tr>
<tr class="memdesc:gac445fc9e7c5d34b1a0daae8f5a98f0f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">return sum(x[i]*y[i]) summing over len elements of the arrays x and y incremented by incx and incy, respectively.  <a href="group__matop__templates.html#gac445fc9e7c5d34b1a0daae8f5a98f0f0">More...</a><br /></td></tr>
<tr class="separator:gac445fc9e7c5d34b1a0daae8f5a98f0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbfeedec1d1f7131134c9115ea91f1c4"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:gabbfeedec1d1f7131134c9115ea91f1c4"><td class="memTemplItemLeft" align="right" valign="top">Val&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#gabbfeedec1d1f7131134c9115ea91f1c4">mat_ip_dense_sparse</a> (const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> lenx, const Val *x, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> leny, const Val *yval, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> *yind, const Val *d=0)</td></tr>
<tr class="memdesc:gabbfeedec1d1f7131134c9115ea91f1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">return sum(x[yind[j]]*yval[j]) summing over elements of the dense array x and a sparse array representation of y.  <a href="group__matop__templates.html#gabbfeedec1d1f7131134c9115ea91f1c4">More...</a><br /></td></tr>
<tr class="separator:gabbfeedec1d1f7131134c9115ea91f1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d0476b21054629023bcf5453ea895c6"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:ga3d0476b21054629023bcf5453ea895c6"><td class="memTemplItemLeft" align="right" valign="top">Val&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#ga3d0476b21054629023bcf5453ea895c6">mat_ip_sparse_sparse</a> (const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> lenx, const Val *xval, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> *xind, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> leny, const Val *yval, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> *yind, const Val *d)</td></tr>
<tr class="memdesc:ga3d0476b21054629023bcf5453ea895c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">return sum(xval[i]*yval[j] for i,j with xind[i]==yind[j]) summing over elements of the sparse array representations of x and y.  <a href="group__matop__templates.html#ga3d0476b21054629023bcf5453ea895c6">More...</a><br /></td></tr>
<tr class="separator:ga3d0476b21054629023bcf5453ea895c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea70d0545e13e0397f6b3ca0233e04d0"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:gaea70d0545e13e0397f6b3ca0233e04d0"><td class="memTemplItemLeft" align="right" valign="top">Val&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#gaea70d0545e13e0397f6b3ca0233e04d0">mat_ip</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, const Val *x)</td></tr>
<tr class="memdesc:gaea70d0545e13e0397f6b3ca0233e04d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">return sum(x[i]*x[i]) summing over len elements of the array x.  <a href="group__matop__templates.html#gaea70d0545e13e0397f6b3ca0233e04d0">More...</a><br /></td></tr>
<tr class="separator:gaea70d0545e13e0397f6b3ca0233e04d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabb74ddd35abbf3717089bed965cdf6d"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:gaabb74ddd35abbf3717089bed965cdf6d"><td class="memTemplItemLeft" align="right" valign="top">Val&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#gaabb74ddd35abbf3717089bed965cdf6d">mat_ip</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, const Val *x, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incx)</td></tr>
<tr class="memdesc:gaabb74ddd35abbf3717089bed965cdf6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return sum(x[i]*x[i]) summing over len elements of the array x incremented by incx.  <a href="group__matop__templates.html#gaabb74ddd35abbf3717089bed965cdf6d">More...</a><br /></td></tr>
<tr class="separator:gaabb74ddd35abbf3717089bed965cdf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae86755a7490e4f24556f7aa419d82d58"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:gae86755a7490e4f24556f7aa419d82d58"><td class="memTemplItemLeft" align="right" valign="top">Val&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#gae86755a7490e4f24556f7aa419d82d58">mat_sum</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, const Val *x)</td></tr>
<tr class="memdesc:gae86755a7490e4f24556f7aa419d82d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns sum(x[i]) over len elements of the array x.  <a href="group__matop__templates.html#gae86755a7490e4f24556f7aa419d82d58">More...</a><br /></td></tr>
<tr class="separator:gae86755a7490e4f24556f7aa419d82d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga514f9864f059e2bc3b1ff99444eb8e21"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:ga514f9864f059e2bc3b1ff99444eb8e21"><td class="memTemplItemLeft" align="right" valign="top">Val&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#ga514f9864f059e2bc3b1ff99444eb8e21">mat_sum</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, const Val *x, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incx)</td></tr>
<tr class="memdesc:ga514f9864f059e2bc3b1ff99444eb8e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns sum(x[i]) over len elements of the array x incremented by incx.  <a href="group__matop__templates.html#ga514f9864f059e2bc3b1ff99444eb8e21">More...</a><br /></td></tr>
<tr class="separator:ga514f9864f059e2bc3b1ff99444eb8e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga876b419668d261a47e36047406e62ec7"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:ga876b419668d261a47e36047406e62ec7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#ga876b419668d261a47e36047406e62ec7">mat_equal</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, const Val *x, const Val *y)</td></tr>
<tr class="memdesc:ga876b419668d261a47e36047406e62ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the elements of the arrays x and y are exactly equal.  <a href="group__matop__templates.html#ga876b419668d261a47e36047406e62ec7">More...</a><br /></td></tr>
<tr class="separator:ga876b419668d261a47e36047406e62ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfdd25c763beb66d328817f73e36c86b"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:gacfdd25c763beb66d328817f73e36c86b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#gacfdd25c763beb66d328817f73e36c86b">mat_swap</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, Val *y)</td></tr>
<tr class="memdesc:gacfdd25c763beb66d328817f73e36c86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap values x[i] and y[i] for len elements of the arrays x and y.  <a href="group__matop__templates.html#gacfdd25c763beb66d328817f73e36c86b">More...</a><br /></td></tr>
<tr class="separator:gacfdd25c763beb66d328817f73e36c86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5aa3cb4a6f9103428412f9cae20a7a9"><td class="memTemplParams" colspan="2">template&lt;class Val &gt; </td></tr>
<tr class="memitem:gaf5aa3cb4a6f9103428412f9cae20a7a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__templates.html#gaf5aa3cb4a6f9103428412f9cae20a7a9">mat_swap</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> len, Val *x, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incx, Val *y, const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> incy)</td></tr>
<tr class="memdesc:gaf5aa3cb4a6f9103428412f9cae20a7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap values x[i] and y[i] for len elements of the arrays x and y incremented by incx and incy, respectively.  <a href="group__matop__templates.html#gaf5aa3cb4a6f9103428412f9cae20a7a9">More...</a><br /></td></tr>
<tr class="separator:gaf5aa3cb4a6f9103428412f9cae20a7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cb5e654c7a1ab7927cf4a6a5f8cf1ff"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matop__matrixerror.html#ga6cb5e654c7a1ab7927cf4a6a5f8cf1ff">MEmessage</a> (const <a class="el" href="classCH__Matrix__Classes_1_1MatrixError.html">MatrixError</a> &amp;)</td></tr>
<tr class="memdesc:ga6cb5e654c7a1ab7927cf4a6a5f8cf1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">displays an error message and terminates via abort() or returns 1 in case of warnings. <br /></td></tr>
<tr class="separator:ga6cb5e654c7a1ab7927cf4a6a5f8cf1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12afb877e290f87967a8e21803b09981"><td class="memTemplParams" colspan="2">
template&lt;class Mat1 , class Mat2 &gt; </td></tr>
<tr class="memitem:ga12afb877e290f87967a8e21803b09981"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matop__matrixerror.html#ga12afb877e290f87967a8e21803b09981">chk_mult</a> (const Mat1 &amp;, const Mat2 &amp;, int=0, int=0)</td></tr>
<tr class="memdesc:ga12afb877e290f87967a8e21803b09981"><td class="mdescLeft">&#160;</td><td class="mdescRight">CONICBUNDLE_DEBUG being undefined, the template function is removed. Otherwise it would check, whether matrices x and y can be multiplied. <br /></td></tr>
<tr class="separator:ga12afb877e290f87967a8e21803b09981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga346ef954b4e7706c8dc81f83759623e7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga346ef954b4e7706c8dc81f83759623e7"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memarraygroup.html#ga346ef954b4e7706c8dc81f83759623e7">mem_provide</a> (<a class="el" href="classCH__Matrix__Classes_1_1Memarray.html">Memarray</a> &amp;memarray, long provide, long in_use, long &amp;avail, T *&amp;store)</td></tr>
<tr class="memdesc:ga346ef954b4e7706c8dc81f83759623e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">provide sufficient memory for an existing array, reallocating and copying the old information upon need, returns 0 upon success, !=0 upon failure.  <a href="group__memarraygroup.html#ga346ef954b4e7706c8dc81f83759623e7">More...</a><br /></td></tr>
<tr class="separator:ga346ef954b4e7706c8dc81f83759623e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5139e47f21cac788131699f7213e964b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga5139e47f21cac788131699f7213e964b"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memarraygroup.html#ga5139e47f21cac788131699f7213e964b">mem_provide_init0</a> (<a class="el" href="classCH__Matrix__Classes_1_1Memarray.html">Memarray</a> &amp;memarray, long provide, long &amp;avail, T *&amp;store)</td></tr>
<tr class="memdesc:ga5139e47f21cac788131699f7213e964b"><td class="mdescLeft">&#160;</td><td class="mdescRight">provide sufficient memory for an existing array, reallocating and copying the old information and initializing the new entries to 0, returns 0 upon success, !=0 upon failure.  <a href="group__memarraygroup.html#ga5139e47f21cac788131699f7213e964b">More...</a><br /></td></tr>
<tr class="separator:ga5139e47f21cac788131699f7213e964b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga276d1229513a051379f74d47a3d23a78"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mymath.html#ga276d1229513a051379f74d47a3d23a78">abs</a> (double d)</td></tr>
<tr class="memdesc:ga276d1229513a051379f74d47a3d23a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">absolute value of a double <br /></td></tr>
<tr class="separator:ga276d1229513a051379f74d47a3d23a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac021fdd2b11ea66f35a90db5c2cd134e"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mymath.html#gac021fdd2b11ea66f35a90db5c2cd134e">abs</a> (int d)</td></tr>
<tr class="memdesc:gac021fdd2b11ea66f35a90db5c2cd134e"><td class="mdescLeft">&#160;</td><td class="mdescRight">absolute value of an int <br /></td></tr>
<tr class="separator:gac021fdd2b11ea66f35a90db5c2cd134e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed8f997ad1b99df6ad6169a13ab425b9"><td class="memItemLeft" align="right" valign="top">
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mymath.html#gaed8f997ad1b99df6ad6169a13ab425b9">abs</a> (long d)</td></tr>
<tr class="memdesc:gaed8f997ad1b99df6ad6169a13ab425b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">absolute value of a long <br /></td></tr>
<tr class="separator:gaed8f997ad1b99df6ad6169a13ab425b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc2ec082a83b13e107b4dba79386f1d5"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mymath.html#gacc2ec082a83b13e107b4dba79386f1d5">max</a> (double a, double b)</td></tr>
<tr class="memdesc:gacc2ec082a83b13e107b4dba79386f1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum value of two double variables <br /></td></tr>
<tr class="separator:gacc2ec082a83b13e107b4dba79386f1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2f99d7e71e92fcd1b0b27c20d6d30b1"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mymath.html#gab2f99d7e71e92fcd1b0b27c20d6d30b1">min</a> (double a, double b)</td></tr>
<tr class="memdesc:gab2f99d7e71e92fcd1b0b27c20d6d30b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">minimum value of two double variables <br /></td></tr>
<tr class="separator:gab2f99d7e71e92fcd1b0b27c20d6d30b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d9a5a9dbf17d634f528500a2909e98e"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mymath.html#ga9d9a5a9dbf17d634f528500a2909e98e">max</a> (int a, int b)</td></tr>
<tr class="memdesc:ga9d9a5a9dbf17d634f528500a2909e98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum value of two int variables <br /></td></tr>
<tr class="separator:ga9d9a5a9dbf17d634f528500a2909e98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3867cddbf919f74436ef27850753c33"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mymath.html#gac3867cddbf919f74436ef27850753c33">min</a> (int a, int b)</td></tr>
<tr class="memdesc:gac3867cddbf919f74436ef27850753c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">minimum value of two int variables <br /></td></tr>
<tr class="separator:gac3867cddbf919f74436ef27850753c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa162a61346499aafb262913cd75e2de5"><td class="memItemLeft" align="right" valign="top">
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mymath.html#gaa162a61346499aafb262913cd75e2de5">max</a> (long a, long b)</td></tr>
<tr class="memdesc:gaa162a61346499aafb262913cd75e2de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum value of two long vriables <br /></td></tr>
<tr class="separator:gaa162a61346499aafb262913cd75e2de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e416a19db05785975c3dcb4fd4fb17f"><td class="memItemLeft" align="right" valign="top">
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mymath.html#ga1e416a19db05785975c3dcb4fd4fb17f">min</a> (long a, long b)</td></tr>
<tr class="memdesc:ga1e416a19db05785975c3dcb4fd4fb17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">minimum value of two long variables <br /></td></tr>
<tr class="separator:ga1e416a19db05785975c3dcb4fd4fb17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga988c76a3ce5bb825c7a78795ec90d8d3"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mymath.html#ga988c76a3ce5bb825c7a78795ec90d8d3">swap</a> (double &amp;a, double &amp;b)</td></tr>
<tr class="memdesc:ga988c76a3ce5bb825c7a78795ec90d8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">swaps two double variables <br /></td></tr>
<tr class="separator:ga988c76a3ce5bb825c7a78795ec90d8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff8a21e82c196b44fc86e8f9ba6a09dd"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mymath.html#gaff8a21e82c196b44fc86e8f9ba6a09dd">swap</a> (long &amp;a, long &amp;b)</td></tr>
<tr class="memdesc:gaff8a21e82c196b44fc86e8f9ba6a09dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">swaps two long variables <br /></td></tr>
<tr class="separator:gaff8a21e82c196b44fc86e8f9ba6a09dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabffcd4b0b1cdedd56c4ce513d4e76cd"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mymath.html#gaabffcd4b0b1cdedd56c4ce513d4e76cd">swap</a> (int &amp;a, int &amp;b)</td></tr>
<tr class="memdesc:gaabffcd4b0b1cdedd56c4ce513d4e76cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">swpas two int variables <br /></td></tr>
<tr class="separator:gaabffcd4b0b1cdedd56c4ce513d4e76cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa622e70b090f7b75c25b882690f650bc"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mymath.html#gaa622e70b090f7b75c25b882690f650bc">swap</a> (bool &amp;a, bool &amp;b)</td></tr>
<tr class="memdesc:gaa622e70b090f7b75c25b882690f650bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">swpas two bool variables <br /></td></tr>
<tr class="separator:gaa622e70b090f7b75c25b882690f650bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ce57fae6c8fd57e25b92d378bf7db5d"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mymath.html#ga0ce57fae6c8fd57e25b92d378bf7db5d">sqr</a> (int a)</td></tr>
<tr class="memdesc:ga0ce57fae6c8fd57e25b92d378bf7db5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a*a for int a <br /></td></tr>
<tr class="separator:ga0ce57fae6c8fd57e25b92d378bf7db5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b43c5c24398a9c1520450d7fe6e8195"><td class="memItemLeft" align="right" valign="top">
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mymath.html#ga0b43c5c24398a9c1520450d7fe6e8195">sqr</a> (long a)</td></tr>
<tr class="memdesc:ga0b43c5c24398a9c1520450d7fe6e8195"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a*a for long a <br /></td></tr>
<tr class="separator:ga0b43c5c24398a9c1520450d7fe6e8195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga410a9795157cce348d46145a6daa5c3f"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mymath.html#ga410a9795157cce348d46145a6daa5c3f">sqr</a> (double a)</td></tr>
<tr class="memdesc:ga410a9795157cce348d46145a6daa5c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a*a for double a <br /></td></tr>
<tr class="separator:ga410a9795157cce348d46145a6daa5c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5fbcd816c7dc27979cca384c2efc3ce"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mymath.html#gae5fbcd816c7dc27979cca384c2efc3ce">sqrt</a> (int a)</td></tr>
<tr class="memdesc:gae5fbcd816c7dc27979cca384c2efc3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">return sqrt for int a <br /></td></tr>
<tr class="separator:gae5fbcd816c7dc27979cca384c2efc3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ffb897e0fc06a902595769b9fb59764"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mymath.html#ga8ffb897e0fc06a902595769b9fb59764">sqrt</a> (long a)</td></tr>
<tr class="memdesc:ga8ffb897e0fc06a902595769b9fb59764"><td class="mdescLeft">&#160;</td><td class="mdescRight">return sqrt for long a <br /></td></tr>
<tr class="separator:ga8ffb897e0fc06a902595769b9fb59764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14d33daa05e13067f1346d40f53c15f5"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mymath.html#ga14d33daa05e13067f1346d40f53c15f5">sign</a> (int a)</td></tr>
<tr class="memdesc:ga14d33daa05e13067f1346d40f53c15f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the signum of an int a (1 for a&gt;0,-1 for a&lt;0,0 for a==0) <br /></td></tr>
<tr class="separator:ga14d33daa05e13067f1346d40f53c15f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a1a5f38ac2573379755e9be5a1946d8"><td class="memItemLeft" align="right" valign="top">
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mymath.html#ga3a1a5f38ac2573379755e9be5a1946d8">sign</a> (long a)</td></tr>
<tr class="memdesc:ga3a1a5f38ac2573379755e9be5a1946d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the signum of a long a (1 for a&gt;0,-1 for a&lt;0,0 for a==0) <br /></td></tr>
<tr class="separator:ga3a1a5f38ac2573379755e9be5a1946d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa36bf0a019caf95696e9927088176dd6"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mymath.html#gaa36bf0a019caf95696e9927088176dd6">sign</a> (double a)</td></tr>
<tr class="memdesc:gaa36bf0a019caf95696e9927088176dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the signum of a double a (1. for a&gt;0.,-1. for a&lt;0.,0. for a==0.) <br /></td></tr>
<tr class="separator:gaa36bf0a019caf95696e9927088176dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga517be5dca03231ad5111eeaf7bdf5070"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mymath.html#ga517be5dca03231ad5111eeaf7bdf5070">sign</a> (double a, double tol)</td></tr>
<tr class="memdesc:ga517be5dca03231ad5111eeaf7bdf5070"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the signum of a double a with tolerance (1. for a&gt;tol,-1. for a&lt;-tol,0. otherwise) <br /></td></tr>
<tr class="separator:ga517be5dca03231ad5111eeaf7bdf5070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82a97346a943e23a1681192d561700b3"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mymath.html#ga82a97346a943e23a1681192d561700b3">d_sign</a> (double a, double b)</td></tr>
<tr class="memdesc:ga82a97346a943e23a1681192d561700b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a if a and b have the same sign, return -a otherwise <br /></td></tr>
<tr class="separator:ga82a97346a943e23a1681192d561700b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69ea0a39574b9819cc812c9954a276aa"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#ga69ea0a39574b9819cc812c9954a276aa">diag</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:ga69ea0a39574b9819cc812c9954a276aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector v consisting of the elements v(i)=A(i,i), 0&lt;=i&lt;min(row dimension,column dimension) <br /></td></tr>
<tr class="separator:ga69ea0a39574b9819cc812c9954a276aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67e758914db120354480f8e1af026fa0"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#ga67e758914db120354480f8e1af026fa0">swap</a> (<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A, <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:ga67e758914db120354480f8e1af026fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap the content of the two matrices A and B (involves no copying) <br /></td></tr>
<tr class="separator:ga67e758914db120354480f8e1af026fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8a5d77412da96a82add5f82e309feb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#gaa8a5d77412da96a82add5f82e309feb4">xbpeya</a> (<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;x, const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;y, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> alpha=1, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> beta=0, int ytrans=0)</td></tr>
<tr class="memdesc:gaa8a5d77412da96a82add5f82e309feb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns x= alpha*y+beta*x, where y may be transposed (ytrans=1); if beta==0. then x is initialized to the correct size  <a href="group__Indexmatrix__friends.html#gaa8a5d77412da96a82add5f82e309feb4">More...</a><br /></td></tr>
<tr class="separator:gaa8a5d77412da96a82add5f82e309feb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6905d9a5e1f79b5d1a3aead34ed8019"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#gaa6905d9a5e1f79b5d1a3aead34ed8019">xeyapzb</a> (<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;x, const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;y, const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;z, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> alpha=1, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> beta=1)</td></tr>
<tr class="memdesc:gaa6905d9a5e1f79b5d1a3aead34ed8019"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns x= alpha*y+beta*z; x is initialized to the correct size; alpha and beta have default value 1  <a href="group__Indexmatrix__friends.html#gaa6905d9a5e1f79b5d1a3aead34ed8019">More...</a><br /></td></tr>
<tr class="separator:gaa6905d9a5e1f79b5d1a3aead34ed8019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ca1762a0de9bf27d795eb5ea5db10db"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#ga1ca1762a0de9bf27d795eb5ea5db10db">genmult</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> alpha=1, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> beta=0, int atrans=0, int btrans=0)</td></tr>
<tr class="memdesc:ga1ca1762a0de9bf27d795eb5ea5db10db"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0 then C is initialized to the correct size <br /></td></tr>
<tr class="separator:ga1ca1762a0de9bf27d795eb5ea5db10db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe9e150f9dee325c76b3f1efbe291a20"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#gafe9e150f9dee325c76b3f1efbe291a20">transpose</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:gafe9e150f9dee325c76b3f1efbe291a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html" title="Matrix class for integral values of type Integer ">Indexmatrix</a> that is the transpose of A <br /></td></tr>
<tr class="separator:gafe9e150f9dee325c76b3f1efbe291a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e9fbd9a19709978dba22d7b76da70bc"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#ga4e9fbd9a19709978dba22d7b76da70bc">abs</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:ga4e9fbd9a19709978dba22d7b76da70bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html" title="Matrix class for integral values of type Integer ">Indexmatrix</a> B with entries B(i,j)=abs(A(i,j)) <br /></td></tr>
<tr class="separator:ga4e9fbd9a19709978dba22d7b76da70bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5b0f541c77cbcb3cc9b4e8d82cf8c8b"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#gac5b0f541c77cbcb3cc9b4e8d82cf8c8b">trace</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:gac5b0f541c77cbcb3cc9b4e8d82cf8c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the sum of the diagonal elements A(i,i) over all i <br /></td></tr>
<tr class="separator:gac5b0f541c77cbcb3cc9b4e8d82cf8c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02c4708617107fcd9015143f497f65ca"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#ga02c4708617107fcd9015143f497f65ca">sumrows</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:ga02c4708617107fcd9015143f497f65ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a row vector holding the sum over all rows, i.e., (1 1 ... 1)*A <br /></td></tr>
<tr class="separator:ga02c4708617107fcd9015143f497f65ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8ee8e65579d4529212184d1cd67b80a"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#gaa8ee8e65579d4529212184d1cd67b80a">sumcols</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:gaa8ee8e65579d4529212184d1cd67b80a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector holding the sum over all columns, i.e., A*(1 1 ... 1)^T <br /></td></tr>
<tr class="separator:gaa8ee8e65579d4529212184d1cd67b80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00ccad0d2dff09ef9a97e2525dab6972"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#ga00ccad0d2dff09ef9a97e2525dab6972">sum</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:ga00ccad0d2dff09ef9a97e2525dab6972"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the sum over all elements of A, i.e., (1 1 ... 1)*A*(1 1 ... 1)^T <br /></td></tr>
<tr class="separator:ga00ccad0d2dff09ef9a97e2525dab6972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa432b2faadf4350010484d2aa01f136f"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#gaa432b2faadf4350010484d2aa01f136f">operator&lt;</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:gaa432b2faadf4350010484d2aa01f136f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Integer(A(i,j)&lt;B(i,j)) for all i,j <br /></td></tr>
<tr class="separator:gaa432b2faadf4350010484d2aa01f136f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a1e41b37611ba35ff4af43279f7eb69"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#ga1a1e41b37611ba35ff4af43279f7eb69">operator&lt;=</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:ga1a1e41b37611ba35ff4af43279f7eb69"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Integer(A(i,j)&lt;=B(i,j)) for all i,j <br /></td></tr>
<tr class="separator:ga1a1e41b37611ba35ff4af43279f7eb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae357b8c5f611d91140e58218b2f95eae"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#gae357b8c5f611d91140e58218b2f95eae">operator==</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:gae357b8c5f611d91140e58218b2f95eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Integer(A(i,j)==B(i,j)) for all i,j <br /></td></tr>
<tr class="separator:gae357b8c5f611d91140e58218b2f95eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92de8a2bf82207939493612b3e7f2554"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#ga92de8a2bf82207939493612b3e7f2554">operator!=</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:ga92de8a2bf82207939493612b3e7f2554"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Integer(A(i,j)!=B(i,j)) for all i,j <br /></td></tr>
<tr class="separator:ga92de8a2bf82207939493612b3e7f2554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41e09f8d9ecdb7e7f1859f4ad6f89e4c"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#ga41e09f8d9ecdb7e7f1859f4ad6f89e4c">operator&lt;</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> d)</td></tr>
<tr class="memdesc:ga41e09f8d9ecdb7e7f1859f4ad6f89e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Integer(A(i,j)&lt;d) for all i,j <br /></td></tr>
<tr class="separator:ga41e09f8d9ecdb7e7f1859f4ad6f89e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31fe7bccdc575283cd72a4bb6f8538d1"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#ga31fe7bccdc575283cd72a4bb6f8538d1">operator&gt;</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> d)</td></tr>
<tr class="memdesc:ga31fe7bccdc575283cd72a4bb6f8538d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Integer(A(i,j)&gt;d) for all i,j <br /></td></tr>
<tr class="separator:ga31fe7bccdc575283cd72a4bb6f8538d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f86d8fa004bc0973267903b1a20be61"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#ga1f86d8fa004bc0973267903b1a20be61">operator&lt;=</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> d)</td></tr>
<tr class="memdesc:ga1f86d8fa004bc0973267903b1a20be61"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Integer(A(i,j)&lt;=d) for all i,j <br /></td></tr>
<tr class="separator:ga1f86d8fa004bc0973267903b1a20be61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e245c029df94ebd8f0361bb4b52a18c"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#ga1e245c029df94ebd8f0361bb4b52a18c">operator&gt;=</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> d)</td></tr>
<tr class="memdesc:ga1e245c029df94ebd8f0361bb4b52a18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Integer(A(i,j)&gt;=d) for all i,j <br /></td></tr>
<tr class="separator:ga1e245c029df94ebd8f0361bb4b52a18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61fee4cb48329880e9bb0127d3572d9b"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#ga61fee4cb48329880e9bb0127d3572d9b">operator==</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> d)</td></tr>
<tr class="memdesc:ga61fee4cb48329880e9bb0127d3572d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Integer(A(i,j)==d) for all i,j <br /></td></tr>
<tr class="separator:ga61fee4cb48329880e9bb0127d3572d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67d31574fb1b26f1612bb62a83375790"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#ga67d31574fb1b26f1612bb62a83375790">operator!=</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> d)</td></tr>
<tr class="memdesc:ga67d31574fb1b26f1612bb62a83375790"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Integer(A(i,j)!=d) for all i,j <br /></td></tr>
<tr class="separator:ga67d31574fb1b26f1612bb62a83375790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddb10292638f48c7df579c5657259fe4"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#gaddb10292638f48c7df579c5657259fe4">minrows</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:gaddb10292638f48c7df579c5657259fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a row vector holding in each column the minimum over all rows in this column <br /></td></tr>
<tr class="separator:gaddb10292638f48c7df579c5657259fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8085f6b7fbb94e9e48e2df7f12b8d130"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#ga8085f6b7fbb94e9e48e2df7f12b8d130">mincols</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:ga8085f6b7fbb94e9e48e2df7f12b8d130"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector holding in each row the minimum over all columns in this row <br /></td></tr>
<tr class="separator:ga8085f6b7fbb94e9e48e2df7f12b8d130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga950185d651b0eebdce621338c980b2bc"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#ga950185d651b0eebdce621338c980b2bc">min</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> *iindex=0, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> *jindex=0)</td></tr>
<tr class="memdesc:ga950185d651b0eebdce621338c980b2bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the minimum value over all elements of the matrix <br /></td></tr>
<tr class="separator:ga950185d651b0eebdce621338c980b2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafca441738dac01685fcdbbf1989e800d"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#gafca441738dac01685fcdbbf1989e800d">maxrows</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:gafca441738dac01685fcdbbf1989e800d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a row vector holding in each column the maximum over all rows in this column <br /></td></tr>
<tr class="separator:gafca441738dac01685fcdbbf1989e800d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac587ed8479b3ee7adcf821f56ba4631b"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#gac587ed8479b3ee7adcf821f56ba4631b">maxcols</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:gac587ed8479b3ee7adcf821f56ba4631b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector holding in each row the maximum over all columns in this row <br /></td></tr>
<tr class="separator:gac587ed8479b3ee7adcf821f56ba4631b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga963a8e6152b0800fedb746f22d8d2c20"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#ga963a8e6152b0800fedb746f22d8d2c20">max</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> *iindex=0, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> *jindex=0)</td></tr>
<tr class="memdesc:ga963a8e6152b0800fedb746f22d8d2c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the maximum value over all elements of the matrix <br /></td></tr>
<tr class="separator:ga963a8e6152b0800fedb746f22d8d2c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6c413e11586791aeb9fa0aae5153ea9"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#gac6c413e11586791aeb9fa0aae5153ea9">sortindex</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;vec, bool nondecreasing=true)</td></tr>
<tr class="memdesc:gac6c413e11586791aeb9fa0aae5153ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html" title="Matrix class for integral values of type Integer ">Indexmatrix</a> ind so that vec(ind(0))&lt;=vec(ind(1))&lt;=...&lt;=vec(ind(vec.dim()-1)) (vec may be rectangular, set nondecreasing=false for opposite order) <br /></td></tr>
<tr class="separator:gac6c413e11586791aeb9fa0aae5153ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d1057f1b2dc4b9b69c35be4dbe9b868"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#ga8d1057f1b2dc4b9b69c35be4dbe9b868">sortindex</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;vec, <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;ind, bool nondecreasing=true)</td></tr>
<tr class="memdesc:ga8d1057f1b2dc4b9b69c35be4dbe9b868"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets ind so that vec(ind(0))&lt;=vec(ind(1))&lt;=...&lt;=vec(ind(vec.dim()-1)) (vec may be rectangular, set nondecreasing=false for opposite order) <br /></td></tr>
<tr class="separator:ga8d1057f1b2dc4b9b69c35be4dbe9b868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7da62716ccd07a1147a5c445b9c2b9a7"><td class="memItemLeft" align="right" valign="top">
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#ga7da62716ccd07a1147a5c445b9c2b9a7">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:ga7da62716ccd07a1147a5c445b9c2b9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">output format (all <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd" title="all integer numbers in calculations and indexing are of this type ">Integer</a> values): nr nc \n A(1,1) A(1,2) ... A(1,nc) \n A(2,1) ... A(nr,nc) \n <br /></td></tr>
<tr class="separator:ga7da62716ccd07a1147a5c445b9c2b9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc6de4c88a125c752c059569f27d2dc1"><td class="memItemLeft" align="right" valign="top">
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Indexmatrix__friends.html#gabc6de4c88a125c752c059569f27d2dc1">operator&gt;&gt;</a> (std::istream &amp;i, <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:gabc6de4c88a125c752c059569f27d2dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">input format (all <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd" title="all integer numbers in calculations and indexing are of this type ">Integer</a> values): nr nc \n A(1,1) A(1,2) ... A(1,nc) \n A(2,1) ... A(nr,nc) \n <br /></td></tr>
<tr class="separator:gabc6de4c88a125c752c059569f27d2dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d9765b28c0376d11a5913aa75b1c55"><td class="memItemLeft" align="right" valign="top"><a id="af3d9765b28c0376d11a5913aa75b1c55"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#af3d9765b28c0376d11a5913aa75b1c55">diag</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:af3d9765b28c0376d11a5913aa75b1c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector v consisting of the elements v(i)=(*this)(i,i), 0&lt;=i&lt;min(row dimension,column dimension) <br /></td></tr>
<tr class="separator:af3d9765b28c0376d11a5913aa75b1c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0128b5a3bb05dde961b3eeac8f71e35"><td class="memItemLeft" align="right" valign="top"><a id="aa0128b5a3bb05dde961b3eeac8f71e35"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aa0128b5a3bb05dde961b3eeac8f71e35">xbpeya</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;x, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;y, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0., int ytrans=0)</td></tr>
<tr class="memdesc:aa0128b5a3bb05dde961b3eeac8f71e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns x= alpha*y+beta*x, where y may be transposed (ytrans=1); if beta==0. then x is initialized to the correct size <br /></td></tr>
<tr class="separator:aa0128b5a3bb05dde961b3eeac8f71e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade57ef6c7b70fe997727aa99a51999a5"><td class="memItemLeft" align="right" valign="top"><a id="ade57ef6c7b70fe997727aa99a51999a5"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ade57ef6c7b70fe997727aa99a51999a5">xeyapzb</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;x, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;y, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;z, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta=1.)</td></tr>
<tr class="memdesc:ade57ef6c7b70fe997727aa99a51999a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns x= alpha*y+beta*z; x is initialized to the correct size <br /></td></tr>
<tr class="separator:ade57ef6c7b70fe997727aa99a51999a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7320c2695bc4c821b844ef62d71ad5dd"><td class="memItemLeft" align="right" valign="top"><a id="a7320c2695bc4c821b844ef62d71ad5dd"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a7320c2695bc4c821b844ef62d71ad5dd">genmult</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0., int atrans=0, int btrans=0)</td></tr>
<tr class="memdesc:a7320c2695bc4c821b844ef62d71ad5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size <br /></td></tr>
<tr class="separator:a7320c2695bc4c821b844ef62d71ad5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9728f3ce40773225ffab67a2bcf0a5e"><td class="memItemLeft" align="right" valign="top"><a id="ad9728f3ce40773225ffab67a2bcf0a5e"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ad9728f3ce40773225ffab67a2bcf0a5e">transpose</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:ad9728f3ce40773225ffab67a2bcf0a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a transposed matrix of A <br /></td></tr>
<tr class="separator:ad9728f3ce40773225ffab67a2bcf0a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0933965fd86b7a6a5d0674be919485"><td class="memItemLeft" align="right" valign="top"><a id="a9a0933965fd86b7a6a5d0674be919485"></a>
std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a9a0933965fd86b7a6a5d0674be919485">assign</a> (std::vector&lt; double &gt; &amp;vec, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a9a0933965fd86b7a6a5d0674be919485"><td class="mdescLeft">&#160;</td><td class="mdescRight">interpret A as a vector and copy it to a std::vector&lt;double&gt; which is also returned <br /></td></tr>
<tr class="separator:a9a0933965fd86b7a6a5d0674be919485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ab94ea579cabe95893801fea392d0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a13ab94ea579cabe95893801fea392d0a">genmult</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta, int btrans)</td></tr>
<tr class="memdesc:a13ab94ea579cabe95893801fea392d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size  <a href="#a13ab94ea579cabe95893801fea392d0a">More...</a><br /></td></tr>
<tr class="separator:a13ab94ea579cabe95893801fea392d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6fda2aa4b4e5d7061129b05e5b3930"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a0a6fda2aa4b4e5d7061129b05e5b3930">genmult</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta, int atrans)</td></tr>
<tr class="memdesc:a0a6fda2aa4b4e5d7061129b05e5b3930"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size  <a href="#a0a6fda2aa4b4e5d7061129b05e5b3930">More...</a><br /></td></tr>
<tr class="separator:a0a6fda2aa4b4e5d7061129b05e5b3930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4407f0eefd61492afee5071dd36da2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a8d4407f0eefd61492afee5071dd36da2">genmult</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta, int btrans)</td></tr>
<tr class="memdesc:a8d4407f0eefd61492afee5071dd36da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size  <a href="#a8d4407f0eefd61492afee5071dd36da2">More...</a><br /></td></tr>
<tr class="separator:a8d4407f0eefd61492afee5071dd36da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8b19d132b924f83b0913ba420743f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a6c8b19d132b924f83b0913ba420743f9">genmult</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta, int atrans)</td></tr>
<tr class="memdesc:a6c8b19d132b924f83b0913ba420743f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size  <a href="#a6c8b19d132b924f83b0913ba420743f9">More...</a><br /></td></tr>
<tr class="separator:a6c8b19d132b924f83b0913ba420743f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429a75bdaccb90fe8ff90d83c928bcff"><td class="memItemLeft" align="right" valign="top"><a id="a429a75bdaccb90fe8ff90d83c928bcff"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a429a75bdaccb90fe8ff90d83c928bcff">genmult</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta, int atrans, int btrans)</td></tr>
<tr class="memdesc:a429a75bdaccb90fe8ff90d83c928bcff"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size <br /></td></tr>
<tr class="separator:a429a75bdaccb90fe8ff90d83c928bcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492d5b7d1338acb6d15d83d6aee208c2"><td class="memItemLeft" align="right" valign="top"><a id="a492d5b7d1338acb6d15d83d6aee208c2"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a492d5b7d1338acb6d15d83d6aee208c2">genmult</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta, int atrans, int btrans)</td></tr>
<tr class="memdesc:a492d5b7d1338acb6d15d83d6aee208c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size <br /></td></tr>
<tr class="separator:a492d5b7d1338acb6d15d83d6aee208c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2fe7f986bf81b0bb7b16ebde2e130c"><td class="memItemLeft" align="right" valign="top"><a id="aef2fe7f986bf81b0bb7b16ebde2e130c"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aef2fe7f986bf81b0bb7b16ebde2e130c">abs</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:aef2fe7f986bf81b0bb7b16ebde2e130c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix with elements (i,j)=abs((*this)(i,j)) for all i,j <br /></td></tr>
<tr class="separator:aef2fe7f986bf81b0bb7b16ebde2e130c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1263fd8238d4851a57e0a3b24f69507e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a1263fd8238d4851a57e0a3b24f69507e">trace</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a1263fd8238d4851a57e0a3b24f69507e"><td class="mdescLeft">&#160;</td><td class="mdescRight">=sum(diag(A))  <a href="#a1263fd8238d4851a57e0a3b24f69507e">More...</a><br /></td></tr>
<tr class="separator:a1263fd8238d4851a57e0a3b24f69507e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12c03eb581bf0337768dbfba77790d9"><td class="memItemLeft" align="right" valign="top"><a id="ab12c03eb581bf0337768dbfba77790d9"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ab12c03eb581bf0337768dbfba77790d9">normDsquared</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;d, int atrans=0, int dinv=0)</td></tr>
<tr class="memdesc:ab12c03eb581bf0337768dbfba77790d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns trace(A^TDA)=|A|^2_D with D=Diag(d). A may be transposed, D may be inverted but there is no check for division by zero <br /></td></tr>
<tr class="separator:ab12c03eb581bf0337768dbfba77790d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff4a63fee40253f0a39365b5841d035"><td class="memItemLeft" align="right" valign="top"><a id="a7ff4a63fee40253f0a39365b5841d035"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a7ff4a63fee40253f0a39365b5841d035">sumrows</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a7ff4a63fee40253f0a39365b5841d035"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a row vector holding the sum over all rows, i.e., (1 1 ... 1)*A <br /></td></tr>
<tr class="separator:a7ff4a63fee40253f0a39365b5841d035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39780a1c4e0fc5171214d1e03e83d7a"><td class="memItemLeft" align="right" valign="top"><a id="ad39780a1c4e0fc5171214d1e03e83d7a"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ad39780a1c4e0fc5171214d1e03e83d7a">sumcols</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:ad39780a1c4e0fc5171214d1e03e83d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector holding the sum over all columns, i.e., A*(1 1 ... 1)^T <br /></td></tr>
<tr class="separator:ad39780a1c4e0fc5171214d1e03e83d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98799872c9ecba180dfef64c9fed6c3d"><td class="memItemLeft" align="right" valign="top"><a id="a98799872c9ecba180dfef64c9fed6c3d"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a98799872c9ecba180dfef64c9fed6c3d">sum</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a98799872c9ecba180dfef64c9fed6c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the sum over all elements of A, i.e., (1 1 ... 1)*A*(1 1 ... 1)^T <br /></td></tr>
<tr class="separator:a98799872c9ecba180dfef64c9fed6c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff1249ede11a65b43dd0b2d218e4657"><td class="memItemLeft" align="right" valign="top"><a id="a4ff1249ede11a65b43dd0b2d218e4657"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a4ff1249ede11a65b43dd0b2d218e4657">house</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;x, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> i=0, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> j=0, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> tol=1e-10)</td></tr>
<tr class="memdesc:a4ff1249ede11a65b43dd0b2d218e4657"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the Householder vector of size A.rowdim() for the subcolumn A(i:A.rowdim(),j) <br /></td></tr>
<tr class="separator:a4ff1249ede11a65b43dd0b2d218e4657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e58e04b7b203630b9f0437cc1a7c02"><td class="memItemLeft" align="right" valign="top"><a id="a80e58e04b7b203630b9f0437cc1a7c02"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a80e58e04b7b203630b9f0437cc1a7c02">rowhouse</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;v, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> i=0, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> j=0)</td></tr>
<tr class="memdesc:a80e58e04b7b203630b9f0437cc1a7c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Housholder pre-multiplication of A with Householder vector v; the first nonzero of v is index i, the multplication is applied to all columns of A with index &gt;=j; always returns 0. <br /></td></tr>
<tr class="separator:a80e58e04b7b203630b9f0437cc1a7c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67360ae946daa9c7b5a7454667ebfc30"><td class="memItemLeft" align="right" valign="top"><a id="a67360ae946daa9c7b5a7454667ebfc30"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a67360ae946daa9c7b5a7454667ebfc30">colhouse</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;v, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> i=0, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> j=0)</td></tr>
<tr class="memdesc:a67360ae946daa9c7b5a7454667ebfc30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Housholder post-multiplication of A with Householder vector v; the first nonzero of v is index i, the multplication is applied to all rows of A with index &gt;=j; always returns 0. <br /></td></tr>
<tr class="separator:a67360ae946daa9c7b5a7454667ebfc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3c215b9186077749da97b4dce3594c"><td class="memItemLeft" align="right" valign="top"><a id="a4e3c215b9186077749da97b4dce3594c"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a4e3c215b9186077749da97b4dce3594c">operator&lt;</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:a4e3c215b9186077749da97b4dce3594c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(A(i,j)&lt;B(i,j)) for all i,j <br /></td></tr>
<tr class="separator:a4e3c215b9186077749da97b4dce3594c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254d2dc386c18c3c6b4e92722d8b836c"><td class="memItemLeft" align="right" valign="top"><a id="a254d2dc386c18c3c6b4e92722d8b836c"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a254d2dc386c18c3c6b4e92722d8b836c">operator&lt;=</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:a254d2dc386c18c3c6b4e92722d8b836c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(A(i,j)&lt;=B(i,j)) for all i,j <br /></td></tr>
<tr class="separator:a254d2dc386c18c3c6b4e92722d8b836c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3853ab964a6873bf4065507bc67b59d"><td class="memItemLeft" align="right" valign="top"><a id="ae3853ab964a6873bf4065507bc67b59d"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ae3853ab964a6873bf4065507bc67b59d">operator==</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:ae3853ab964a6873bf4065507bc67b59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(A(i,j)==B(i,j)) for all i,j <br /></td></tr>
<tr class="separator:ae3853ab964a6873bf4065507bc67b59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f13f424a27ad7ee64f567de4c109dde"><td class="memItemLeft" align="right" valign="top"><a id="a3f13f424a27ad7ee64f567de4c109dde"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a3f13f424a27ad7ee64f567de4c109dde">operator!=</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:a3f13f424a27ad7ee64f567de4c109dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(A(i,j)!=B(i,j)) for all i,j <br /></td></tr>
<tr class="separator:a3f13f424a27ad7ee64f567de4c109dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec43fb1b5fac750a79c43ff19afed350"><td class="memItemLeft" align="right" valign="top"><a id="aec43fb1b5fac750a79c43ff19afed350"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aec43fb1b5fac750a79c43ff19afed350">operator&lt;</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:aec43fb1b5fac750a79c43ff19afed350"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(A(i,j)&lt;d) for all i,j <br /></td></tr>
<tr class="separator:aec43fb1b5fac750a79c43ff19afed350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce6b57c4d432913746615237bd662a0"><td class="memItemLeft" align="right" valign="top"><a id="a4ce6b57c4d432913746615237bd662a0"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a4ce6b57c4d432913746615237bd662a0">operator&gt;</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:a4ce6b57c4d432913746615237bd662a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(A(i,j)&gt;d) for all i,j <br /></td></tr>
<tr class="separator:a4ce6b57c4d432913746615237bd662a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c6cd2648ba62fc747586fbff31dd3c"><td class="memItemLeft" align="right" valign="top"><a id="a40c6cd2648ba62fc747586fbff31dd3c"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a40c6cd2648ba62fc747586fbff31dd3c">operator&lt;=</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:a40c6cd2648ba62fc747586fbff31dd3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(A(i,j)&lt;=d) for all i,j <br /></td></tr>
<tr class="separator:a40c6cd2648ba62fc747586fbff31dd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae098c17b6d566cc9b1e050c073a848ea"><td class="memItemLeft" align="right" valign="top"><a id="ae098c17b6d566cc9b1e050c073a848ea"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ae098c17b6d566cc9b1e050c073a848ea">operator&gt;=</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:ae098c17b6d566cc9b1e050c073a848ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(A(i,j)&gt;=d) for all i,j <br /></td></tr>
<tr class="separator:ae098c17b6d566cc9b1e050c073a848ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78e1073170d1f5ff17d45c9574c8a5f"><td class="memItemLeft" align="right" valign="top"><a id="af78e1073170d1f5ff17d45c9574c8a5f"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#af78e1073170d1f5ff17d45c9574c8a5f">operator==</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:af78e1073170d1f5ff17d45c9574c8a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(A(i,j)==d) for all i,j <br /></td></tr>
<tr class="separator:af78e1073170d1f5ff17d45c9574c8a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf57a9b23afc6c622b036260e132876"><td class="memItemLeft" align="right" valign="top"><a id="a4bf57a9b23afc6c622b036260e132876"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a4bf57a9b23afc6c622b036260e132876">operator!=</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:a4bf57a9b23afc6c622b036260e132876"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(A(i,j)!=d) for all i,j <br /></td></tr>
<tr class="separator:a4bf57a9b23afc6c622b036260e132876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac404adc58d3fd51a429fd46db7b7a685"><td class="memItemLeft" align="right" valign="top"><a id="ac404adc58d3fd51a429fd46db7b7a685"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ac404adc58d3fd51a429fd46db7b7a685">minrows</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:ac404adc58d3fd51a429fd46db7b7a685"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a row vector holding in each column the minimum over all rows in this column <br /></td></tr>
<tr class="separator:ac404adc58d3fd51a429fd46db7b7a685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4818150a81b0cfd2841892e8563eada8"><td class="memItemLeft" align="right" valign="top"><a id="a4818150a81b0cfd2841892e8563eada8"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a4818150a81b0cfd2841892e8563eada8">mincols</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a4818150a81b0cfd2841892e8563eada8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector holding in each row the minimum over all columns in this row <br /></td></tr>
<tr class="separator:a4818150a81b0cfd2841892e8563eada8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8876ba181d8ab7f5c9f7eee1fb3ff05"><td class="memItemLeft" align="right" valign="top"><a id="ac8876ba181d8ab7f5c9f7eee1fb3ff05"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ac8876ba181d8ab7f5c9f7eee1fb3ff05">min</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> *iindex=0, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> *jindex=0)</td></tr>
<tr class="memdesc:ac8876ba181d8ab7f5c9f7eee1fb3ff05"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the minimum value over all elements of the matrix <br /></td></tr>
<tr class="separator:ac8876ba181d8ab7f5c9f7eee1fb3ff05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a8016c62f0caa1d695279d894057e9"><td class="memItemLeft" align="right" valign="top"><a id="a00a8016c62f0caa1d695279d894057e9"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a00a8016c62f0caa1d695279d894057e9">maxrows</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a00a8016c62f0caa1d695279d894057e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a row vector holding in each column the maximum over all rows in this column <br /></td></tr>
<tr class="separator:a00a8016c62f0caa1d695279d894057e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9aca7c21d76ebbe834e4559d68c6c0"><td class="memItemLeft" align="right" valign="top"><a id="a1f9aca7c21d76ebbe834e4559d68c6c0"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a1f9aca7c21d76ebbe834e4559d68c6c0">maxcols</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a1f9aca7c21d76ebbe834e4559d68c6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector holding in each row the maximum over all columns in this row <br /></td></tr>
<tr class="separator:a1f9aca7c21d76ebbe834e4559d68c6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68088532b5a594c459670de9cc6c7cd"><td class="memItemLeft" align="right" valign="top"><a id="ac68088532b5a594c459670de9cc6c7cd"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ac68088532b5a594c459670de9cc6c7cd">max</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> *iindex=0, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> *jindex=0)</td></tr>
<tr class="memdesc:ac68088532b5a594c459670de9cc6c7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the maximum value over all elements of the matrix <br /></td></tr>
<tr class="separator:ac68088532b5a594c459670de9cc6c7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761997c0961ea6d2873178c2ce6b5e9f"><td class="memItemLeft" align="right" valign="top"><a id="a761997c0961ea6d2873178c2ce6b5e9f"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a761997c0961ea6d2873178c2ce6b5e9f">sortindex</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;vec, bool nondecreasing=true)</td></tr>
<tr class="memdesc:a761997c0961ea6d2873178c2ce6b5e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html" title="Matrix class for integral values of type Integer ">Indexmatrix</a> ind so that vec(ind(0))&lt;=vec(ind(1))&lt;=...&lt;=vec(ind(vec.dim()-1)) (vec may be rectangular, set nondecreasing=false for opposite order) <br /></td></tr>
<tr class="separator:a761997c0961ea6d2873178c2ce6b5e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa3b439a59998cfb4c7256396a0f8e2"><td class="memItemLeft" align="right" valign="top"><a id="aeaa3b439a59998cfb4c7256396a0f8e2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aeaa3b439a59998cfb4c7256396a0f8e2">sortindex</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;vec, <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;ind, bool nondecreasing=true)</td></tr>
<tr class="memdesc:aeaa3b439a59998cfb4c7256396a0f8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets ind so that vec(ind(0))&lt;=vec(ind(1))&lt;=...&lt;=vec(ind(vec.dim()-1)) (vec may be rectangular, set nondecreasing=false for opposite order) <br /></td></tr>
<tr class="separator:aeaa3b439a59998cfb4c7256396a0f8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910719fc8a489e075552a563ef536d61"><td class="memItemLeft" align="right" valign="top"><a id="a910719fc8a489e075552a563ef536d61"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a910719fc8a489e075552a563ef536d61">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;v)</td></tr>
<tr class="memdesc:a910719fc8a489e075552a563ef536d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">output format (nr and nc are <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd" title="all integer numbers in calculations and indexing are of this type ">Integer</a> values, all others <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type ">Real</a> values): <br />
 nr nc \n A(1,1) A(1,2) ... A(1,nc) \n A(2,1) ... A(nr,nc) \n <br /></td></tr>
<tr class="separator:a910719fc8a489e075552a563ef536d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebf3c4731f299c57eb910f4d82a988b"><td class="memItemLeft" align="right" valign="top"><a id="a3ebf3c4731f299c57eb910f4d82a988b"></a>
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a3ebf3c4731f299c57eb910f4d82a988b">operator&gt;&gt;</a> (std::istream &amp;i, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;v)</td></tr>
<tr class="memdesc:a3ebf3c4731f299c57eb910f4d82a988b"><td class="mdescLeft">&#160;</td><td class="mdescRight">input format (nr and nc are <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd" title="all integer numbers in calculations and indexing are of this type ">Integer</a> values, all others <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type ">Real</a> values): <br />
 nr nc \n A(1,1) A(1,2) ... A(1,nc) \n A(2,1) ... A(nr,nc) \n <br /></td></tr>
<tr class="separator:a3ebf3c4731f299c57eb910f4d82a988b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fa805785a8e3572f072ef87046e3a4"><td class="memItemLeft" align="right" valign="top"><a id="af4fa805785a8e3572f072ef87046e3a4"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#af4fa805785a8e3572f072ef87046e3a4">ip</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:af4fa805785a8e3572f072ef87046e3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j <br /></td></tr>
<tr class="separator:af4fa805785a8e3572f072ef87046e3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d922d61a7c98f7325d4c9cc2edad85d"><td class="memItemLeft" align="right" valign="top"><a id="a2d922d61a7c98f7325d4c9cc2edad85d"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a2d922d61a7c98f7325d4c9cc2edad85d">colip</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> j, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> *scaling=0)</td></tr>
<tr class="memdesc:a2d922d61a7c98f7325d4c9cc2edad85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the squared Frobenius norm of column j of A, i.e., the sum of A(i,j)*A(i,j) over all i with possibly (if scaling!=0) each term i multiplied by (*scaling)(i) <br /></td></tr>
<tr class="separator:a2d922d61a7c98f7325d4c9cc2edad85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae914563dedfab8334960060d8279ee8e"><td class="memItemLeft" align="right" valign="top"><a id="ae914563dedfab8334960060d8279ee8e"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ae914563dedfab8334960060d8279ee8e">rowip</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> i, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> *scaling=0)</td></tr>
<tr class="memdesc:ae914563dedfab8334960060d8279ee8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the squared Frobenius norm of row i of A, i.e., the sum of A(i,j)*A(i,j) over all j with possibly (if scaling!=0) each term j multiplied by (*scaling)(j) <br /></td></tr>
<tr class="separator:ae914563dedfab8334960060d8279ee8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08089e8dd9b58c4c298ec9369ff0efd"><td class="memItemLeft" align="right" valign="top"><a id="ad08089e8dd9b58c4c298ec9369ff0efd"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ad08089e8dd9b58c4c298ec9369ff0efd">colsip</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:ad08089e8dd9b58c4c298ec9369ff0efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the column vector of the squared Frobenius norm of all columns j of A, i.e., the sum of A(i,j)*A(i,j) over all i for each j <br /></td></tr>
<tr class="separator:ad08089e8dd9b58c4c298ec9369ff0efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61fcebc3d037d7b65d34f5e42d3f358"><td class="memItemLeft" align="right" valign="top"><a id="af61fcebc3d037d7b65d34f5e42d3f358"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#af61fcebc3d037d7b65d34f5e42d3f358">rowsip</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:af61fcebc3d037d7b65d34f5e42d3f358"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the row vector of the squared Frobenius norm of all rowd i of A, i.e., the sum of A(i,j)*A(i,j) over all j for each i <br /></td></tr>
<tr class="separator:af61fcebc3d037d7b65d34f5e42d3f358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed7811322a356cde32a04ee672908a8"><td class="memItemLeft" align="right" valign="top"><a id="a3ed7811322a356cde32a04ee672908a8"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a3ed7811322a356cde32a04ee672908a8">norm2</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a3ed7811322a356cde32a04ee672908a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the Frobenius norm of A, i.e., the square root of the sum of A(i,j)*A(i,j) over all i,j <br /></td></tr>
<tr class="separator:a3ed7811322a356cde32a04ee672908a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab6c8636a39ffacb9a1f60b5e8a05e9"><td class="memItemLeft" align="right" valign="top"><a id="a0ab6c8636a39ffacb9a1f60b5e8a05e9"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a0ab6c8636a39ffacb9a1f60b5e8a05e9">operator*</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:a0ab6c8636a39ffacb9a1f60b5e8a05e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> equal to A*B <br /></td></tr>
<tr class="separator:a0ab6c8636a39ffacb9a1f60b5e8a05e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e2d5bb07635285685e5d675112ea07"><td class="memItemLeft" align="right" valign="top"><a id="a07e2d5bb07635285685e5d675112ea07"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a07e2d5bb07635285685e5d675112ea07">operator+</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:a07e2d5bb07635285685e5d675112ea07"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> equal to A+B <br /></td></tr>
<tr class="separator:a07e2d5bb07635285685e5d675112ea07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7f5c8470cfe3d3b3ddd1ca94de295e"><td class="memItemLeft" align="right" valign="top"><a id="a1f7f5c8470cfe3d3b3ddd1ca94de295e"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a1f7f5c8470cfe3d3b3ddd1ca94de295e">operator-</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:a1f7f5c8470cfe3d3b3ddd1ca94de295e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> equal to A-B <br /></td></tr>
<tr class="separator:a1f7f5c8470cfe3d3b3ddd1ca94de295e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e0a5c93e3b7a521f64a5829f88bd2e"><td class="memItemLeft" align="right" valign="top"><a id="aa7e0a5c93e3b7a521f64a5829f88bd2e"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aa7e0a5c93e3b7a521f64a5829f88bd2e">operator%</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:aa7e0a5c93e3b7a521f64a5829f88bd2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">ATTENTION: this is redefined as the Hadamard product, C(i,j)=A(i,j)*B(i,j) for all i,j. <br /></td></tr>
<tr class="separator:aa7e0a5c93e3b7a521f64a5829f88bd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a59b8daa2548614553c7dfdfd67dd64"><td class="memItemLeft" align="right" valign="top"><a id="a8a59b8daa2548614553c7dfdfd67dd64"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a8a59b8daa2548614553c7dfdfd67dd64">operator/</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:a8a59b8daa2548614553c7dfdfd67dd64"><td class="mdescLeft">&#160;</td><td class="mdescRight">ATTENTION: this is redefined to act componentwise without checking for zeros, C(i,j)=A(i,j)/B(i,j) for all i,j. <br /></td></tr>
<tr class="separator:a8a59b8daa2548614553c7dfdfd67dd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51cb732f9c2608c62bf77eee2f7ce8b3"><td class="memItemLeft" align="right" valign="top"><a id="a51cb732f9c2608c62bf77eee2f7ce8b3"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a51cb732f9c2608c62bf77eee2f7ce8b3">operator*</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:a51cb732f9c2608c62bf77eee2f7ce8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> equal to A*d <br /></td></tr>
<tr class="separator:a51cb732f9c2608c62bf77eee2f7ce8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde7b3071dc700f1c35fe9042b2d40a4"><td class="memItemLeft" align="right" valign="top"><a id="adde7b3071dc700f1c35fe9042b2d40a4"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#adde7b3071dc700f1c35fe9042b2d40a4">operator*</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:adde7b3071dc700f1c35fe9042b2d40a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> equal to d*A <br /></td></tr>
<tr class="separator:adde7b3071dc700f1c35fe9042b2d40a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b939cce2e7144bff22742fbcd96ab26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a1b939cce2e7144bff22742fbcd96ab26">operator/</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:a1b939cce2e7144bff22742fbcd96ab26"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> equal to A/d; ATTENTION: d is NOT checked for 0  <a href="#a1b939cce2e7144bff22742fbcd96ab26">More...</a><br /></td></tr>
<tr class="separator:a1b939cce2e7144bff22742fbcd96ab26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd5488d328f1dea59ca987206c5f747"><td class="memItemLeft" align="right" valign="top"><a id="accd5488d328f1dea59ca987206c5f747"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#accd5488d328f1dea59ca987206c5f747">operator+</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:accd5488d328f1dea59ca987206c5f747"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns (i,j)=A(i,j)+d for all i,j <br /></td></tr>
<tr class="separator:accd5488d328f1dea59ca987206c5f747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9361b0549535dd94e48d3b5352bbd4d9"><td class="memItemLeft" align="right" valign="top"><a id="a9361b0549535dd94e48d3b5352bbd4d9"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a9361b0549535dd94e48d3b5352bbd4d9">operator+</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a9361b0549535dd94e48d3b5352bbd4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns (i,j)=A(i,j)+d for all i,j <br /></td></tr>
<tr class="separator:a9361b0549535dd94e48d3b5352bbd4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb93fbfd511dfe7b0df58d8e2a8ec6db"><td class="memItemLeft" align="right" valign="top"><a id="aeb93fbfd511dfe7b0df58d8e2a8ec6db"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aeb93fbfd511dfe7b0df58d8e2a8ec6db">operator-</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:aeb93fbfd511dfe7b0df58d8e2a8ec6db"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns (i,j)=A(i,j)-d for all i,j <br /></td></tr>
<tr class="separator:aeb93fbfd511dfe7b0df58d8e2a8ec6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f76951c39da0dcba768a26301335f4c"><td class="memItemLeft" align="right" valign="top"><a id="a5f76951c39da0dcba768a26301335f4c"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a5f76951c39da0dcba768a26301335f4c">operator-</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a5f76951c39da0dcba768a26301335f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns (i,j)=d-A(i,j) for all i,j <br /></td></tr>
<tr class="separator:a5f76951c39da0dcba768a26301335f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef8e887706cb7e70ecbe578de73bd51"><td class="memItemLeft" align="right" valign="top"><a id="a0ef8e887706cb7e70ecbe578de73bd51"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a0ef8e887706cb7e70ecbe578de73bd51">QR_factor</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;Q, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;R, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> tol)</td></tr>
<tr class="memdesc:a0ef8e887706cb7e70ecbe578de73bd51"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes a Householder QR factorization of A and outputs Q and R leaving A unchanged; always returns 0 <br /></td></tr>
<tr class="separator:a0ef8e887706cb7e70ecbe578de73bd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a5ff081efc33bfd7cba0c766ecc58d"><td class="memItemLeft" align="right" valign="top"><a id="a01a5ff081efc33bfd7cba0c766ecc58d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a01a5ff081efc33bfd7cba0c766ecc58d">QR_factor</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;Q, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;R, <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;piv, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> tol)</td></tr>
<tr class="memdesc:a01a5ff081efc33bfd7cba0c766ecc58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes a Householder QR factorization of A with pivating. It outputs Q, R, and the pivoting permuation in piv; returns the rank of A <br /></td></tr>
<tr class="separator:a01a5ff081efc33bfd7cba0c766ecc58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653e878070b51404c087e6c8d5bb58e9"><td class="memItemLeft" align="right" valign="top"><a id="a653e878070b51404c087e6c8d5bb58e9"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a653e878070b51404c087e6c8d5bb58e9">triu</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> i=0)</td></tr>
<tr class="memdesc:a653e878070b51404c087e6c8d5bb58e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">retuns a matrix that keeps the upper triangle of A starting with diagonal d, i.e., (i,j)=A(i,j) for 0&lt;=i&lt;row dimension, max(0,i+d)&lt;=j&lt;column dimension, and sets (i,j)=0 otherwise <br /></td></tr>
<tr class="separator:a653e878070b51404c087e6c8d5bb58e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c1e9fe138fa0e122de1c84b158d108"><td class="memItemLeft" align="right" valign="top"><a id="a09c1e9fe138fa0e122de1c84b158d108"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a09c1e9fe138fa0e122de1c84b158d108">tril</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> i=0)</td></tr>
<tr class="memdesc:a09c1e9fe138fa0e122de1c84b158d108"><td class="mdescLeft">&#160;</td><td class="mdescRight">retuns a matrix that keeps the lower triangle of A starting with diagonal d, i.e., (i,j)=A(i,j) for 0&lt;=i&lt;row dimension, 0&lt;=j&lt;min(i+d+1,column dimension), and sets (i,j)=0 otherwise <br /></td></tr>
<tr class="separator:a09c1e9fe138fa0e122de1c84b158d108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d4d2e6159ae8d646142ed44829a52b"><td class="memItemLeft" align="right" valign="top"><a id="ab6d4d2e6159ae8d646142ed44829a52b"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ab6d4d2e6159ae8d646142ed44829a52b">concat_right</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:ab6d4d2e6159ae8d646142ed44829a52b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a new matrix [A, B], i.e., it concats matrices A and B rowwise; A or B may be a 0x0 matrix <br /></td></tr>
<tr class="separator:ab6d4d2e6159ae8d646142ed44829a52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77a7182d21dc8e34ae05bfdbe233048"><td class="memItemLeft" align="right" valign="top"><a id="aa77a7182d21dc8e34ae05bfdbe233048"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aa77a7182d21dc8e34ae05bfdbe233048">concat_below</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:aa77a7182d21dc8e34ae05bfdbe233048"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a bew matrix [A; B], i.e., it concats matrices A and B columnwise; A or B may be a 0x0 matrix <br /></td></tr>
<tr class="separator:aa77a7182d21dc8e34ae05bfdbe233048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c675590f1624b466c71e5f09a110193"><td class="memItemLeft" align="right" valign="top"><a id="a3c675590f1624b466c71e5f09a110193"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a3c675590f1624b466c71e5f09a110193">swap</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:a3c675590f1624b466c71e5f09a110193"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap the content of the two matrices A and B (involves no copying) <br /></td></tr>
<tr class="separator:a3c675590f1624b466c71e5f09a110193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd23fc827db091ea01b6b531b8b573b"><td class="memItemLeft" align="right" valign="top"><a id="adbd23fc827db091ea01b6b531b8b573b"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#adbd23fc827db091ea01b6b531b8b573b">rand</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> rows, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> cols, <a class="el" href="classCH__Tools_1_1GB__rand.html">CH_Tools::GB_rand</a> *random_generator=0)</td></tr>
<tr class="memdesc:adbd23fc827db091ea01b6b531b8b573b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a nr x nc matrix with (i,j) assigned a random number uniformly from [0,1] for all i,j <br /></td></tr>
<tr class="separator:adbd23fc827db091ea01b6b531b8b573b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683da07e407e22966282ad71a8f7795d"><td class="memItemLeft" align="right" valign="top"><a id="a683da07e407e22966282ad71a8f7795d"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a683da07e407e22966282ad71a8f7795d">inv</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a683da07e407e22966282ad71a8f7795d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix with elements (i,j)=1./((*this)(i,j)) for all i,j; ATTENTION: no check for division by zero <br /></td></tr>
<tr class="separator:a683da07e407e22966282ad71a8f7795d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2eaef698f0c1146c9bd3354fd247e9"><td class="memItemLeft" align="right" valign="top"><a id="a6b2eaef698f0c1146c9bd3354fd247e9"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a6b2eaef698f0c1146c9bd3354fd247e9">sqrt</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a6b2eaef698f0c1146c9bd3354fd247e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix with elements (i,j)=sqrt((*this)(i,j)) for all i,j <br /></td></tr>
<tr class="separator:a6b2eaef698f0c1146c9bd3354fd247e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e62842c5eb1808e7df7bb3b2100657"><td class="memItemLeft" align="right" valign="top"><a id="ac0e62842c5eb1808e7df7bb3b2100657"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ac0e62842c5eb1808e7df7bb3b2100657">sqr</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:ac0e62842c5eb1808e7df7bb3b2100657"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix with elements (i,j)=sqr((*this)(i,j)) for all i,j <br /></td></tr>
<tr class="separator:ac0e62842c5eb1808e7df7bb3b2100657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7180499e4c6aa221348e958835dae2b"><td class="memItemLeft" align="right" valign="top"><a id="ad7180499e4c6aa221348e958835dae2b"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ad7180499e4c6aa221348e958835dae2b">sign</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> tol=1e-12)</td></tr>
<tr class="memdesc:ad7180499e4c6aa221348e958835dae2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix with elements (i,j)=sign((*this)(i,j)) for all i,j using <a class="el" href="group__mymath.html#ga517be5dca03231ad5111eeaf7bdf5070" title="return the signum of a double a with tolerance (1. for a&gt;tol,-1. for a&lt;-tol,0. otherwise) ...">sign(double,double)</a> <br /></td></tr>
<tr class="separator:ad7180499e4c6aa221348e958835dae2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24dd53c8a2f3816b972f8abbdd32655c"><td class="memItemLeft" align="right" valign="top"><a id="a24dd53c8a2f3816b972f8abbdd32655c"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a24dd53c8a2f3816b972f8abbdd32655c">floor</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a24dd53c8a2f3816b972f8abbdd32655c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix with elements (i,j)=floor((*this)(i,j)) for all i,j <br /></td></tr>
<tr class="separator:a24dd53c8a2f3816b972f8abbdd32655c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f06d3ad675d578e9a929ff96a3d1a61"><td class="memItemLeft" align="right" valign="top"><a id="a3f06d3ad675d578e9a929ff96a3d1a61"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a3f06d3ad675d578e9a929ff96a3d1a61">ceil</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a3f06d3ad675d578e9a929ff96a3d1a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix with elements (i,j)=ceil((*this)(i,j)) for all i,j <br /></td></tr>
<tr class="separator:a3f06d3ad675d578e9a929ff96a3d1a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9963541cf8629f070f95549aefbb7aaf"><td class="memItemLeft" align="right" valign="top"><a id="a9963541cf8629f070f95549aefbb7aaf"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a9963541cf8629f070f95549aefbb7aaf">rint</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a9963541cf8629f070f95549aefbb7aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix with elements (i,j)=rint((*this)(i,j)) for all i,j <br /></td></tr>
<tr class="separator:a9963541cf8629f070f95549aefbb7aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab57f8e4e21114a3e07095873509f263"><td class="memItemLeft" align="right" valign="top"><a id="aab57f8e4e21114a3e07095873509f263"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aab57f8e4e21114a3e07095873509f263">round</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:aab57f8e4e21114a3e07095873509f263"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix with elements (i,j)=round((*this)(i,j)) for all i,j <br /></td></tr>
<tr class="separator:aab57f8e4e21114a3e07095873509f263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880e83eb4bcfb178499ab1dce5350b50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a880e83eb4bcfb178499ab1dce5350b50">operator&gt;</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:a880e83eb4bcfb178499ab1dce5350b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(A(i,j)&gt;d) for all i,j  <a href="#a880e83eb4bcfb178499ab1dce5350b50">More...</a><br /></td></tr>
<tr class="separator:a880e83eb4bcfb178499ab1dce5350b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab296276d96d420c797f8ad827f7c88ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ab296276d96d420c797f8ad827f7c88ba">operator&gt;=</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:ab296276d96d420c797f8ad827f7c88ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(A(i,j)&gt;=d) for all i,j  <a href="#ab296276d96d420c797f8ad827f7c88ba">More...</a><br /></td></tr>
<tr class="separator:ab296276d96d420c797f8ad827f7c88ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d10d965acc3350b325a2d102ee077a"><td class="memItemLeft" align="right" valign="top"><a id="aa8d10d965acc3350b325a2d102ee077a"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aa8d10d965acc3350b325a2d102ee077a">operator&lt;</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:aa8d10d965acc3350b325a2d102ee077a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(d&lt;A(i,j)) for all i,j <br /></td></tr>
<tr class="separator:aa8d10d965acc3350b325a2d102ee077a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90745439e8f1baead5681b1581d614b9"><td class="memItemLeft" align="right" valign="top"><a id="a90745439e8f1baead5681b1581d614b9"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a90745439e8f1baead5681b1581d614b9">operator&gt;</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a90745439e8f1baead5681b1581d614b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(d&gt;A(i,j)) for all i,j <br /></td></tr>
<tr class="separator:a90745439e8f1baead5681b1581d614b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80c9d78354b72afc9070ec516e56db3"><td class="memItemLeft" align="right" valign="top"><a id="ac80c9d78354b72afc9070ec516e56db3"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ac80c9d78354b72afc9070ec516e56db3">operator&lt;=</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:ac80c9d78354b72afc9070ec516e56db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(d&lt;=A(i,j)) for all i,j <br /></td></tr>
<tr class="separator:ac80c9d78354b72afc9070ec516e56db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02fce7916d444e6dd384f576fd86e64"><td class="memItemLeft" align="right" valign="top"><a id="ae02fce7916d444e6dd384f576fd86e64"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ae02fce7916d444e6dd384f576fd86e64">operator&gt;=</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:ae02fce7916d444e6dd384f576fd86e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(d&gt;=A(i,j)) for all i,j <br /></td></tr>
<tr class="separator:ae02fce7916d444e6dd384f576fd86e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699deeca0f401b8fa7c3019b7baf9033"><td class="memItemLeft" align="right" valign="top"><a id="a699deeca0f401b8fa7c3019b7baf9033"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a699deeca0f401b8fa7c3019b7baf9033">operator==</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a699deeca0f401b8fa7c3019b7baf9033"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(d==A(i,j)) for all i,j <br /></td></tr>
<tr class="separator:a699deeca0f401b8fa7c3019b7baf9033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c89f6f77515bcfaf7c33f8967c9c4c4"><td class="memItemLeft" align="right" valign="top"><a id="a1c89f6f77515bcfaf7c33f8967c9c4c4"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a1c89f6f77515bcfaf7c33f8967c9c4c4">operator!=</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a1c89f6f77515bcfaf7c33f8967c9c4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a matrix having elements (i,j)=Real(d!=A(i,j)) for all i,j <br /></td></tr>
<tr class="separator:a1c89f6f77515bcfaf7c33f8967c9c4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e663420a97baca6422221a23be9a2a"><td class="memItemLeft" align="right" valign="top"><a id="aa8e663420a97baca6422221a23be9a2a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aa8e663420a97baca6422221a23be9a2a">equal</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:aa8e663420a97baca6422221a23be9a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if both matrices have the same size and the same elements <br /></td></tr>
<tr class="separator:aa8e663420a97baca6422221a23be9a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18be44877952230406e1856624383256"><td class="memItemLeft" align="right" valign="top"><a id="a18be44877952230406e1856624383256"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a18be44877952230406e1856624383256">find</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> tol=1e-10)</td></tr>
<tr class="memdesc:a18be44877952230406e1856624383256"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html" title="Matrix class for integral values of type Integer ">Indexmatrix</a> ind so that A(ind(i)) 0&lt;=i&lt;ind.dim() runs through all nonzero elements with abs(A(j))&gt;tol <br /></td></tr>
<tr class="separator:a18be44877952230406e1856624383256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31efb2bffc8a51f197512ddca00e641d"><td class="memItemLeft" align="right" valign="top"><a id="a31efb2bffc8a51f197512ddca00e641d"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a31efb2bffc8a51f197512ddca00e641d">find_number</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> num=0., <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> tol=1e-10)</td></tr>
<tr class="memdesc:a31efb2bffc8a51f197512ddca00e641d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html" title="Matrix class for integral values of type Integer ">Indexmatrix</a> ind so that A(ind(i)) 0&lt;=i&lt;ind.dim() runs through all elements of A having value num, i.e., abs(A(j)-num)&lt;tol <br /></td></tr>
<tr class="separator:a31efb2bffc8a51f197512ddca00e641d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3b493fa4a3efe6ff814d5fec936080"><td class="memItemLeft" align="right" valign="top"><a id="aab3b493fa4a3efe6ff814d5fec936080"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aab3b493fa4a3efe6ff814d5fec936080">diag</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:aab3b493fa4a3efe6ff814d5fec936080"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector v consisting of the elements v(i)=(*this)(i,i), 0&lt;=i&lt;row dimension <br /></td></tr>
<tr class="separator:aab3b493fa4a3efe6ff814d5fec936080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66468aff7f5d83bf306396293b5a7ac0"><td class="memItemLeft" align="right" valign="top"><a id="a66468aff7f5d83bf306396293b5a7ac0"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a66468aff7f5d83bf306396293b5a7ac0">Diag</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a66468aff7f5d83bf306396293b5a7ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a symmetric diagonal matrix S of order A.dim() with vec(A) on the diagonal, i.e., S(i,i)=A(i) for all i and S(i,j)=0 for i!=j <br /></td></tr>
<tr class="separator:a66468aff7f5d83bf306396293b5a7ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc379f9a6f5446df004d655c25671a2"><td class="memItemLeft" align="right" valign="top"><a id="addc379f9a6f5446df004d655c25671a2"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#addc379f9a6f5446df004d655c25671a2">rankadd</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0., int trans=0)</td></tr>
<tr class="memdesc:addc379f9a6f5446df004d655c25671a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha* A*A^T, where A may be transposed. If beta==0. then C is initiliazed to the correct size. <br /></td></tr>
<tr class="separator:addc379f9a6f5446df004d655c25671a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a86adaed0bb3a0f00210ca14423888a"><td class="memItemLeft" align="right" valign="top"><a id="a7a86adaed0bb3a0f00210ca14423888a"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a7a86adaed0bb3a0f00210ca14423888a">scaledrankadd</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;D, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0., int trans=0)</td></tr>
<tr class="memdesc:a7a86adaed0bb3a0f00210ca14423888a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha* A*D*A^T, where D is a vector representing a diagonal matrix and A may be transposed; if beta==0. then C is initialized to the correct size <br /></td></tr>
<tr class="separator:a7a86adaed0bb3a0f00210ca14423888a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777a3bf467256cc36ecbe9e0c108326a"><td class="memItemLeft" align="right" valign="top"><a id="a777a3bf467256cc36ecbe9e0c108326a"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a777a3bf467256cc36ecbe9e0c108326a">rank2add</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0., int trans=0)</td></tr>
<tr class="memdesc:a777a3bf467256cc36ecbe9e0c108326a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*(A*B^T+B*A^T)/2 [or for transposed (A^T*B+B^T*A)/2]. If beta==0. then C is initiliazed to the correct size. <br /></td></tr>
<tr class="separator:a777a3bf467256cc36ecbe9e0c108326a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb874bcdf2644fff97ca3bf35d234361"><td class="memItemLeft" align="right" valign="top"><a id="afb874bcdf2644fff97ca3bf35d234361"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#afb874bcdf2644fff97ca3bf35d234361">genmult</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0., int btrans=0)</td></tr>
<tr class="memdesc:afb874bcdf2644fff97ca3bf35d234361"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where B may be transposed; if beta==0. then C is initialized to the correct size <br /></td></tr>
<tr class="separator:afb874bcdf2644fff97ca3bf35d234361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3030c38169abace48e33c6b687bc883"><td class="memItemLeft" align="right" valign="top"><a id="af3030c38169abace48e33c6b687bc883"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#af3030c38169abace48e33c6b687bc883">genmult</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0., int atrans=0)</td></tr>
<tr class="memdesc:af3030c38169abace48e33c6b687bc883"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A may be transposed; if beta==0. then C is initialized to the correct size <br /></td></tr>
<tr class="separator:af3030c38169abace48e33c6b687bc883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836246d700cb0e6eed72e68a860cd124"><td class="memItemLeft" align="right" valign="top"><a id="a836246d700cb0e6eed72e68a860cd124"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a836246d700cb0e6eed72e68a860cd124">rankadd</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0., int trans=0)</td></tr>
<tr class="memdesc:a836246d700cb0e6eed72e68a860cd124"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha* A*A^T, where A may be transposed; if beta==0. then C is initialized to the correct size <br /></td></tr>
<tr class="separator:a836246d700cb0e6eed72e68a860cd124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3c8aca933463eb973f279ee1667d9f"><td class="memItemLeft" align="right" valign="top"><a id="a8f3c8aca933463eb973f279ee1667d9f"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a8f3c8aca933463eb973f279ee1667d9f">scaledrankadd</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;D, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0., int trans=0)</td></tr>
<tr class="memdesc:a8f3c8aca933463eb973f279ee1667d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha* A*D*A^T, where D is a vector representing a diagonal matrix and A may be transposed; if beta==0. then C is initialized to the correct size <br /></td></tr>
<tr class="separator:a8f3c8aca933463eb973f279ee1667d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d41b3c1f3043c6a6a689d2cb38d031"><td class="memItemLeft" align="right" valign="top"><a id="a25d41b3c1f3043c6a6a689d2cb38d031"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a25d41b3c1f3043c6a6a689d2cb38d031">rank2add</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0., int trans=0)</td></tr>
<tr class="memdesc:a25d41b3c1f3043c6a6a689d2cb38d031"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*(A*B^T+B*A^T)/2 [or for transposed (A^T*B+B^T*A)/2]. If beta==0. then C is initiliazed to the correct size. <br /></td></tr>
<tr class="separator:a25d41b3c1f3043c6a6a689d2cb38d031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80d416505e193feebeee2985e98a25f"><td class="memItemLeft" align="right" valign="top"><a id="ac80d416505e193feebeee2985e98a25f"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ac80d416505e193feebeee2985e98a25f">abs</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:ac80d416505e193feebeee2985e98a25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> with elements abs(A(i,j)) <br /></td></tr>
<tr class="separator:ac80d416505e193feebeee2985e98a25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdfbed23574a9387c3d5cd44cdbb59e"><td class="memItemLeft" align="right" valign="top"><a id="a0cdfbed23574a9387c3d5cd44cdbb59e"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a0cdfbed23574a9387c3d5cd44cdbb59e">trace</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:a0cdfbed23574a9387c3d5cd44cdbb59e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the sum of the diagonal elements A(i,i) over all i <br /></td></tr>
<tr class="separator:a0cdfbed23574a9387c3d5cd44cdbb59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab858b0e9900bfb4c573c9d02ea124ffa"><td class="memItemLeft" align="right" valign="top"><a id="ab858b0e9900bfb4c573c9d02ea124ffa"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ab858b0e9900bfb4c573c9d02ea124ffa">ip</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:ab858b0e9900bfb4c573c9d02ea124ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j <br /></td></tr>
<tr class="separator:ab858b0e9900bfb4c573c9d02ea124ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9f9292af33925304a31812316c62c4"><td class="memItemLeft" align="right" valign="top"><a id="a0a9f9292af33925304a31812316c62c4"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a0a9f9292af33925304a31812316c62c4">ip</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:a0a9f9292af33925304a31812316c62c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j <br /></td></tr>
<tr class="separator:a0a9f9292af33925304a31812316c62c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b63bf8bd489e649b1c0916ede3a5424"><td class="memItemLeft" align="right" valign="top"><a id="a9b63bf8bd489e649b1c0916ede3a5424"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a9b63bf8bd489e649b1c0916ede3a5424">ip</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:a9b63bf8bd489e649b1c0916ede3a5424"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j <br /></td></tr>
<tr class="separator:a9b63bf8bd489e649b1c0916ede3a5424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a480e2ba3a7d7a3c20a936e6ad9e25"><td class="memItemLeft" align="right" valign="top"><a id="a96a480e2ba3a7d7a3c20a936e6ad9e25"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a96a480e2ba3a7d7a3c20a936e6ad9e25">sumrows</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:a96a480e2ba3a7d7a3c20a936e6ad9e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a row vector holding the sum over all rows, i.e., (1 1 ... 1)*A <br /></td></tr>
<tr class="separator:a96a480e2ba3a7d7a3c20a936e6ad9e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1c1584a5182ec612462c847d596ee3"><td class="memItemLeft" align="right" valign="top"><a id="abe1c1584a5182ec612462c847d596ee3"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#abe1c1584a5182ec612462c847d596ee3">sumcols</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:abe1c1584a5182ec612462c847d596ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector holding the sum over all columns, i.e., A*(1 1 ... 1)^T <br /></td></tr>
<tr class="separator:abe1c1584a5182ec612462c847d596ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f1a51705d03e09b50921abf1c62194"><td class="memItemLeft" align="right" valign="top"><a id="a26f1a51705d03e09b50921abf1c62194"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a26f1a51705d03e09b50921abf1c62194">sum</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:a26f1a51705d03e09b50921abf1c62194"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the sum over all elements of A, i.e., (1 1 ... 1)*A*(1 1 ... 1)^T <br /></td></tr>
<tr class="separator:a26f1a51705d03e09b50921abf1c62194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b18f8ae12e90afe1f4229a66ee205b"><td class="memItemLeft" align="right" valign="top"><a id="ab4b18f8ae12e90afe1f4229a66ee205b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ab4b18f8ae12e90afe1f4229a66ee205b">svec</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;sv, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> a=1., bool add=false, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> startindex_vec=-1, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> startindex_A=0, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> blockdim=-1)</td></tr>
<tr class="memdesc:ab4b18f8ae12e90afe1f4229a66ee205b"><td class="mdescLeft">&#160;</td><td class="mdescRight">the symmetric vec operator stacks the lower triangle of A to a n*(n+1)/2 vector with the same norm2 as A; here it sets svec(A)=[a11,sqrt(2)a12,...,sqrt(2)a1n,a22,...,sqrt(2)a(n-1,n),ann]', multiplies it by a and sets or adds (if add==true) it to v starting from startindex_vec possibly restricted to the subblock of order blockdim (whenever &gt;=0, else blockdim is set to A.rowdim()-startindex_A) starting from startindex_A (must be &gt;=0); if add==false and startindex_vec&lt;0 then vec is also reinitialzed to the appropriate size <br /></td></tr>
<tr class="separator:ab4b18f8ae12e90afe1f4229a66ee205b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2fcd40e920d4010e116c573c57be9e"><td class="memItemLeft" align="right" valign="top"><a id="a1b2fcd40e920d4010e116c573c57be9e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a1b2fcd40e920d4010e116c573c57be9e">sveci</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;sv, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> a=1., bool add=false, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> startindex_vec=0, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> startindex_A=-1, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> blockdim=-1)</td></tr>
<tr class="memdesc:a1b2fcd40e920d4010e116c573c57be9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">the inverse operator to svec, extracts from v at startindex_vec (&gt;=0) the symmetric matrix of blockdim adding its mutliple by a into A starting at startindex_A; if add==false and startindex_A&lt;0 A is initialized to the size of blockdim; if the latter is also negative then v.dim()-startindex_vec must match an exact order and matrix A is initialized to this size. In all other cases the size of the symmetric matrix determines the missing parameters and vec.dim-startindex_vec <br /></td></tr>
<tr class="separator:a1b2fcd40e920d4010e116c573c57be9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22fa549265303d13eea7f009acb26c8"><td class="memItemLeft" align="right" valign="top"><a id="ae22fa549265303d13eea7f009acb26c8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ae22fa549265303d13eea7f009acb26c8">skron</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;S, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., bool add=false, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> startindex_S=-1)</td></tr>
<tr class="memdesc:ae22fa549265303d13eea7f009acb26c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">def symmetric Kronecker product (A skron B)svec(C)=(BCA'+ACB')/2; sets S=alpha*(A skron B) or S*=... (if add==true) possibly shifted to the block starting at startindex_S; if add==false and startindex_S&lt;0, S is initialzed to the correct size <br /></td></tr>
<tr class="separator:ae22fa549265303d13eea7f009acb26c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b1f60db853604089780f641d79fb92"><td class="memItemLeft" align="right" valign="top"><a id="a22b1f60db853604089780f641d79fb92"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a22b1f60db853604089780f641d79fb92">symscale</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;S, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0., int btrans=0)</td></tr>
<tr class="memdesc:a22b1f60db853604089780f641d79fb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets S=beta*S+alpha*B'*A*B for symmatrix A and matrix B <br /></td></tr>
<tr class="separator:a22b1f60db853604089780f641d79fb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e86f97935882ce2c85c8bea07db03b"><td class="memItemLeft" align="right" valign="top"><a id="ac2e86f97935882ce2c85c8bea07db03b"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ac2e86f97935882ce2c85c8bea07db03b">minrows</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:ac2e86f97935882ce2c85c8bea07db03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a row vector holding in each column the minimum over all rows in this column <br /></td></tr>
<tr class="separator:ac2e86f97935882ce2c85c8bea07db03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d6936691bbcefc84e305c0d2506fae"><td class="memItemLeft" align="right" valign="top"><a id="ae8d6936691bbcefc84e305c0d2506fae"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ae8d6936691bbcefc84e305c0d2506fae">mincols</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:ae8d6936691bbcefc84e305c0d2506fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector holding in each row the minimum over all columns in this row <br /></td></tr>
<tr class="separator:ae8d6936691bbcefc84e305c0d2506fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbed2690b967b1710ef1810c0391aee"><td class="memItemLeft" align="right" valign="top"><a id="a2bbed2690b967b1710ef1810c0391aee"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a2bbed2690b967b1710ef1810c0391aee">min</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:a2bbed2690b967b1710ef1810c0391aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the minimum value over all elements of the matrix <br /></td></tr>
<tr class="separator:a2bbed2690b967b1710ef1810c0391aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3614266b0adfaed5e4ef25ab9251de3a"><td class="memItemLeft" align="right" valign="top"><a id="a3614266b0adfaed5e4ef25ab9251de3a"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a3614266b0adfaed5e4ef25ab9251de3a">maxrows</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:a3614266b0adfaed5e4ef25ab9251de3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a row vector holding in each column the maximum over all rows in this column <br /></td></tr>
<tr class="separator:a3614266b0adfaed5e4ef25ab9251de3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc737dab700eef83f9d7d15f48b63ed"><td class="memItemLeft" align="right" valign="top"><a id="a6dc737dab700eef83f9d7d15f48b63ed"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a6dc737dab700eef83f9d7d15f48b63ed">maxcols</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:a6dc737dab700eef83f9d7d15f48b63ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector holding in each row the maximum over all columns in this row <br /></td></tr>
<tr class="separator:a6dc737dab700eef83f9d7d15f48b63ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d3f543a9a8f98c53d473652e32d7a8"><td class="memItemLeft" align="right" valign="top"><a id="ab2d3f543a9a8f98c53d473652e32d7a8"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ab2d3f543a9a8f98c53d473652e32d7a8">max</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:ab2d3f543a9a8f98c53d473652e32d7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the maximum value over all elements of the matrix <br /></td></tr>
<tr class="separator:ab2d3f543a9a8f98c53d473652e32d7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aed6b21f73325b4315ec15035b89676"><td class="memItemLeft" align="right" valign="top"><a id="a8aed6b21f73325b4315ec15035b89676"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a8aed6b21f73325b4315ec15035b89676">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:a8aed6b21f73325b4315ec15035b89676"><td class="mdescLeft">&#160;</td><td class="mdescRight">output format (nr and nc are <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd" title="all integer numbers in calculations and indexing are of this type ">Integer</a> values, all others <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type ">Real</a> values): <br />
 nr nc \n A(1,1) A(1,2) ... A(1,nc) \n A(2,1) ... A(nr,nc) \n <br /></td></tr>
<tr class="separator:a8aed6b21f73325b4315ec15035b89676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fad02e37ef26186b11caf416b9a5fe"><td class="memItemLeft" align="right" valign="top"><a id="a61fad02e37ef26186b11caf416b9a5fe"></a>
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a61fad02e37ef26186b11caf416b9a5fe">operator&gt;&gt;</a> (std::istream &amp;i, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:a61fad02e37ef26186b11caf416b9a5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">input format (nr and nc are <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd" title="all integer numbers in calculations and indexing are of this type ">Integer</a> values, all others <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type ">Real</a> values): <br />
 nr nc \n A(1,1) A(1,2) ... A(1,nc) \n A(2,1) ... A(nr,nc) \n <br /></td></tr>
<tr class="separator:a61fad02e37ef26186b11caf416b9a5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f496066644b9e2916bd0aa30b18b9ed"><td class="memItemLeft" align="right" valign="top"><a id="a7f496066644b9e2916bd0aa30b18b9ed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a7f496066644b9e2916bd0aa30b18b9ed">swap</a> (<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:a7f496066644b9e2916bd0aa30b18b9ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap the content of the two matrices A and B (involves no copying) <br /></td></tr>
<tr class="separator:a7f496066644b9e2916bd0aa30b18b9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5bd36e93862df08d94e617b3da117f"><td class="memItemLeft" align="right" valign="top"><a id="a5a5bd36e93862df08d94e617b3da117f"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a5a5bd36e93862df08d94e617b3da117f">xbpeya</a> (<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;x, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;y, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0.)</td></tr>
<tr class="memdesc:a5a5bd36e93862df08d94e617b3da117f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns x= alpha*y+beta*x; if beta==0. then x is initialized to the correct size <br /></td></tr>
<tr class="separator:a5a5bd36e93862df08d94e617b3da117f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b9987ec91dc9c6cbc16bb3f27fda34"><td class="memItemLeft" align="right" valign="top"><a id="af7b9987ec91dc9c6cbc16bb3f27fda34"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#af7b9987ec91dc9c6cbc16bb3f27fda34">xeyapzb</a> (<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;x, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;y, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;z, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta=1.)</td></tr>
<tr class="memdesc:af7b9987ec91dc9c6cbc16bb3f27fda34"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns x= alpha*y+beta*z; x is initialized to the correct size <br /></td></tr>
<tr class="separator:af7b9987ec91dc9c6cbc16bb3f27fda34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecdc3e003bf111b5516a1488a41e7c2"><td class="memItemLeft" align="right" valign="top"><a id="a0ecdc3e003bf111b5516a1488a41e7c2"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a0ecdc3e003bf111b5516a1488a41e7c2">operator*</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:a0ecdc3e003bf111b5516a1488a41e7c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A*B <br /></td></tr>
<tr class="separator:a0ecdc3e003bf111b5516a1488a41e7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75384021f7932a11f3807669ed80f561"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a75384021f7932a11f3807669ed80f561">operator%</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:a75384021f7932a11f3807669ed80f561"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals AB (where % is overloaded as elementwise multiplication)  <a href="#a75384021f7932a11f3807669ed80f561">More...</a><br /></td></tr>
<tr class="separator:a75384021f7932a11f3807669ed80f561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1474ccc2daa5b055adea4a771f80fb99"><td class="memItemLeft" align="right" valign="top"><a id="a1474ccc2daa5b055adea4a771f80fb99"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a1474ccc2daa5b055adea4a771f80fb99">operator+</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:a1474ccc2daa5b055adea4a771f80fb99"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A+B <br /></td></tr>
<tr class="separator:a1474ccc2daa5b055adea4a771f80fb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ecae51a5135a8ad6811f5b83c3100d"><td class="memItemLeft" align="right" valign="top"><a id="a04ecae51a5135a8ad6811f5b83c3100d"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a04ecae51a5135a8ad6811f5b83c3100d">operator-</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:a04ecae51a5135a8ad6811f5b83c3100d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A-B <br /></td></tr>
<tr class="separator:a04ecae51a5135a8ad6811f5b83c3100d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f562909af8af7270e3a9f71fcee608e"><td class="memItemLeft" align="right" valign="top"><a id="a7f562909af8af7270e3a9f71fcee608e"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a7f562909af8af7270e3a9f71fcee608e">operator*</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:a7f562909af8af7270e3a9f71fcee608e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A*B <br /></td></tr>
<tr class="separator:a7f562909af8af7270e3a9f71fcee608e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa618c4840a835b48c7b6567b8b8b0443"><td class="memItemLeft" align="right" valign="top"><a id="aa618c4840a835b48c7b6567b8b8b0443"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aa618c4840a835b48c7b6567b8b8b0443">operator*</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:aa618c4840a835b48c7b6567b8b8b0443"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A*B <br /></td></tr>
<tr class="separator:aa618c4840a835b48c7b6567b8b8b0443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8105819501583f5e0f73715a7c8519"><td class="memItemLeft" align="right" valign="top"><a id="a2a8105819501583f5e0f73715a7c8519"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a2a8105819501583f5e0f73715a7c8519">operator+</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:a2a8105819501583f5e0f73715a7c8519"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A+B <br /></td></tr>
<tr class="separator:a2a8105819501583f5e0f73715a7c8519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e8774a7dfde5295e813efe2f5a09af"><td class="memItemLeft" align="right" valign="top"><a id="ac2e8774a7dfde5295e813efe2f5a09af"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ac2e8774a7dfde5295e813efe2f5a09af">operator+</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:ac2e8774a7dfde5295e813efe2f5a09af"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A+B <br /></td></tr>
<tr class="separator:ac2e8774a7dfde5295e813efe2f5a09af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1488d490f99806467fdba6df61128497"><td class="memItemLeft" align="right" valign="top"><a id="a1488d490f99806467fdba6df61128497"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a1488d490f99806467fdba6df61128497">operator-</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:a1488d490f99806467fdba6df61128497"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A-B <br /></td></tr>
<tr class="separator:a1488d490f99806467fdba6df61128497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34a2c2962fa829f2a5e8ecf8ab61daa"><td class="memItemLeft" align="right" valign="top"><a id="aa34a2c2962fa829f2a5e8ecf8ab61daa"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aa34a2c2962fa829f2a5e8ecf8ab61daa">operator-</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:aa34a2c2962fa829f2a5e8ecf8ab61daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A-B <br /></td></tr>
<tr class="separator:aa34a2c2962fa829f2a5e8ecf8ab61daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d632b48a0449de2968d74bea886bb5e"><td class="memItemLeft" align="right" valign="top"><a id="a5d632b48a0449de2968d74bea886bb5e"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a5d632b48a0449de2968d74bea886bb5e">operator*</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:a5d632b48a0449de2968d74bea886bb5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> that equals A*d <br /></td></tr>
<tr class="separator:a5d632b48a0449de2968d74bea886bb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae275f5de7ad15d5d6507064ea4979f9a"><td class="memItemLeft" align="right" valign="top"><a id="ae275f5de7ad15d5d6507064ea4979f9a"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ae275f5de7ad15d5d6507064ea4979f9a">operator*</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:ae275f5de7ad15d5d6507064ea4979f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> that equals A*d <br /></td></tr>
<tr class="separator:ae275f5de7ad15d5d6507064ea4979f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8dc947c5b20130d3c1815c18b9a17b"><td class="memItemLeft" align="right" valign="top"><a id="a4b8dc947c5b20130d3c1815c18b9a17b"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a4b8dc947c5b20130d3c1815c18b9a17b">operator/</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:a4b8dc947c5b20130d3c1815c18b9a17b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> that equals A/d; ATTENTION: no check against division by zero <br /></td></tr>
<tr class="separator:a4b8dc947c5b20130d3c1815c18b9a17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d5af24a0341639f0e326951f50707e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#af6d5af24a0341639f0e326951f50707e">operator+</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:af6d5af24a0341639f0e326951f50707e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> that equals A+d (d is added to each element)  <a href="#af6d5af24a0341639f0e326951f50707e">More...</a><br /></td></tr>
<tr class="separator:af6d5af24a0341639f0e326951f50707e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71861033ab9ab93a83fded17ae0ea669"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a71861033ab9ab93a83fded17ae0ea669">operator+</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:a71861033ab9ab93a83fded17ae0ea669"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> that equals A+d (d is added to each element)  <a href="#a71861033ab9ab93a83fded17ae0ea669">More...</a><br /></td></tr>
<tr class="separator:a71861033ab9ab93a83fded17ae0ea669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad23869576e96b9fad346cf2cc1b2c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a9ad23869576e96b9fad346cf2cc1b2c2">operator-</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:a9ad23869576e96b9fad346cf2cc1b2c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> that equals A-d (d is subtracted from each element)  <a href="#a9ad23869576e96b9fad346cf2cc1b2c2">More...</a><br /></td></tr>
<tr class="separator:a9ad23869576e96b9fad346cf2cc1b2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d2b3ac69a6abc0973b77b486d55572"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ab2d2b3ac69a6abc0973b77b486d55572">operator-</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:ab2d2b3ac69a6abc0973b77b486d55572"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> that equals d-A (each element subtracted from d)  <a href="#ab2d2b3ac69a6abc0973b77b486d55572">More...</a><br /></td></tr>
<tr class="separator:ab2d2b3ac69a6abc0973b77b486d55572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f4e35f5d1dffdc6b0c7a3272581e4a"><td class="memItemLeft" align="right" valign="top"><a id="ad8f4e35f5d1dffdc6b0c7a3272581e4a"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ad8f4e35f5d1dffdc6b0c7a3272581e4a">svec</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:ad8f4e35f5d1dffdc6b0c7a3272581e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">the symmetric vec operator, stacks the lower triangle of A to a n*(n+1)/2 vector with the same norm2 as A; i.e., it returns svec(A)=[a11,sqrt(2)a12,...,sqrt(2)a1n,a22,...,sqrt(2)a(n-1,n),ann]' <br /></td></tr>
<tr class="separator:ad8f4e35f5d1dffdc6b0c7a3272581e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76617a0fc2dcbda0853de1bdab5eb441"><td class="memItemLeft" align="right" valign="top"><a id="a76617a0fc2dcbda0853de1bdab5eb441"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a76617a0fc2dcbda0853de1bdab5eb441">skron</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., bool add=false, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> startindex_S=-1)</td></tr>
<tr class="memdesc:a76617a0fc2dcbda0853de1bdab5eb441"><td class="mdescLeft">&#160;</td><td class="mdescRight">the symmetric Kronecker product, defined via (A skron B)svec(C)=(BCA'+ACB')/2; sets or adds (if add==true) the symmetric matrix a*(A skron B) into S starting at startindex_S; if add==false and startindex_S&lt;0, S is initialzed to the correct size <br /></td></tr>
<tr class="separator:a76617a0fc2dcbda0853de1bdab5eb441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0350e6d0ab16eae95e4a3c91194ec48a"><td class="memItemLeft" align="right" valign="top"><a id="a0350e6d0ab16eae95e4a3c91194ec48a"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a0350e6d0ab16eae95e4a3c91194ec48a">norm2</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:a0350e6d0ab16eae95e4a3c91194ec48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the Frobenius norm of A, i.e., the square root of the sum of A(i,j)*A(i,j) over all i,j <br /></td></tr>
<tr class="separator:a0350e6d0ab16eae95e4a3c91194ec48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e2eba5715c21f2b26dd72ea87aceea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ab7e2eba5715c21f2b26dd72ea87aceea">transpose</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>
<tr class="memdesc:ab7e2eba5715c21f2b26dd72ea87aceea"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a copy of A (drop it or use a constructor instead)  <a href="#ab7e2eba5715c21f2b26dd72ea87aceea">More...</a><br /></td></tr>
<tr class="separator:ab7e2eba5715c21f2b26dd72ea87aceea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ab056d6e3ad5dcb43e712d32510f41"><td class="memItemLeft" align="right" valign="top"><a id="a05ab056d6e3ad5dcb43e712d32510f41"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a05ab056d6e3ad5dcb43e712d32510f41">swap</a> (<a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;B)</td></tr>
<tr class="memdesc:a05ab056d6e3ad5dcb43e712d32510f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap the content of the two sparse matrices A and B (involves no copying) <br /></td></tr>
<tr class="separator:a05ab056d6e3ad5dcb43e712d32510f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952d1255f4d432bc8642b7534d22428e"><td class="memItemLeft" align="right" valign="top"><a id="a952d1255f4d432bc8642b7534d22428e"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a952d1255f4d432bc8642b7534d22428e">xbpeya</a> (<a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;x, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;y, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0., int ytrans=0)</td></tr>
<tr class="memdesc:a952d1255f4d432bc8642b7534d22428e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns x= alpha*y+beta*x, where y may be transposed (ytrans=1); if beta==0. then x is initialized to the correct size <br /></td></tr>
<tr class="separator:a952d1255f4d432bc8642b7534d22428e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ee78eada36c980a83f62790188196e"><td class="memItemLeft" align="right" valign="top"><a id="a12ee78eada36c980a83f62790188196e"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a12ee78eada36c980a83f62790188196e">genmult</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0., int atrans=0, int btrans=0)</td></tr>
<tr class="memdesc:a12ee78eada36c980a83f62790188196e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size <br /></td></tr>
<tr class="separator:a12ee78eada36c980a83f62790188196e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6873f512d9ed382b5ea3200d9e80cb42"><td class="memItemLeft" align="right" valign="top"><a id="a6873f512d9ed382b5ea3200d9e80cb42"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a6873f512d9ed382b5ea3200d9e80cb42">operator*</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;B)</td></tr>
<tr class="memdesc:a6873f512d9ed382b5ea3200d9e80cb42"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html" title="Matrix class of sparse matrices with real values of type Real ">Sparsemat</a> equal to A*B <br /></td></tr>
<tr class="separator:a6873f512d9ed382b5ea3200d9e80cb42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851f7baaf0ec9b1e25d22e37b77e62a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a851f7baaf0ec9b1e25d22e37b77e62a8">genmult</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0., int btrans=0)</td></tr>
<tr class="memdesc:a851f7baaf0ec9b1e25d22e37b77e62a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size  <a href="#a851f7baaf0ec9b1e25d22e37b77e62a8">More...</a><br /></td></tr>
<tr class="separator:a851f7baaf0ec9b1e25d22e37b77e62a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec989e433eb1503875968be18f9ee82e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aec989e433eb1503875968be18f9ee82e">genmult</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0., int atrans=0)</td></tr>
<tr class="memdesc:aec989e433eb1503875968be18f9ee82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size  <a href="#aec989e433eb1503875968be18f9ee82e">More...</a><br /></td></tr>
<tr class="separator:aec989e433eb1503875968be18f9ee82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3ea68298ec395b9e9f9676ae3659fb"><td class="memItemLeft" align="right" valign="top"><a id="aec3ea68298ec395b9e9f9676ae3659fb"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aec3ea68298ec395b9e9f9676ae3659fb">abs</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A)</td></tr>
<tr class="memdesc:aec3ea68298ec395b9e9f9676ae3659fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a Sparsmat with elements abs((*this)(i,j)) for all i,j <br /></td></tr>
<tr class="separator:aec3ea68298ec395b9e9f9676ae3659fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b160a0356146bd7acc7e44d8e85be4"><td class="memItemLeft" align="right" valign="top"><a id="aa6b160a0356146bd7acc7e44d8e85be4"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aa6b160a0356146bd7acc7e44d8e85be4">trace</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A)</td></tr>
<tr class="memdesc:aa6b160a0356146bd7acc7e44d8e85be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the sum of the diagonal elements A(i,i) over all i <br /></td></tr>
<tr class="separator:aa6b160a0356146bd7acc7e44d8e85be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34477757aa3170d7e6c9a458f016cf08"><td class="memItemLeft" align="right" valign="top"><a id="a34477757aa3170d7e6c9a458f016cf08"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a34477757aa3170d7e6c9a458f016cf08">ip</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;B)</td></tr>
<tr class="memdesc:a34477757aa3170d7e6c9a458f016cf08"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j <br /></td></tr>
<tr class="separator:a34477757aa3170d7e6c9a458f016cf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b6a5b5ea79d8b46247f2f552693231"><td class="memItemLeft" align="right" valign="top"><a id="a83b6a5b5ea79d8b46247f2f552693231"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a83b6a5b5ea79d8b46247f2f552693231">ip</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:a83b6a5b5ea79d8b46247f2f552693231"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j <br /></td></tr>
<tr class="separator:a83b6a5b5ea79d8b46247f2f552693231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c12fe257ee35c57a18018ea1c6090ba"><td class="memItemLeft" align="right" valign="top"><a id="a5c12fe257ee35c57a18018ea1c6090ba"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a5c12fe257ee35c57a18018ea1c6090ba">colip</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> j, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> *scaling=0)</td></tr>
<tr class="memdesc:a5c12fe257ee35c57a18018ea1c6090ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the squared Frobenius norm of col i of A, i.e., the sum of A(i,j)*A(i,j) over all i with possibly (if scaling!=0) each term i multiplied by (*scaling)(i) <br /></td></tr>
<tr class="separator:a5c12fe257ee35c57a18018ea1c6090ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13db2f114f46cbf0eeab45523cdb517"><td class="memItemLeft" align="right" valign="top"><a id="ac13db2f114f46cbf0eeab45523cdb517"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ac13db2f114f46cbf0eeab45523cdb517">rowip</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a> i, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> *scaling=0)</td></tr>
<tr class="memdesc:ac13db2f114f46cbf0eeab45523cdb517"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the squared Frobenius norm of row i of A, i.e., the sum of A(i,j)*A(i,j) over all j with possibly (if scaling!=0) each term j multiplied by (*scaling)(j) <br /></td></tr>
<tr class="separator:ac13db2f114f46cbf0eeab45523cdb517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514702944dfbc90ee1e8961cb6f8e710"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a514702944dfbc90ee1e8961cb6f8e710">colsip</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> *colscaling=0)</td></tr>
<tr class="memdesc:a514702944dfbc90ee1e8961cb6f8e710"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the row vector of the squared Frobenius norm of all columns j of A, i.e., the sum of A(i,j)*A(i,j) over all i for each j with possibly (if scaling!=0) each term i multiplied by (*scaling)(i)  <a href="#a514702944dfbc90ee1e8961cb6f8e710">More...</a><br /></td></tr>
<tr class="separator:a514702944dfbc90ee1e8961cb6f8e710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ff32d040c0182bf14c99f82c704b5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ac0ff32d040c0182bf14c99f82c704b5c">rowsip</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> *rowscaling=0)</td></tr>
<tr class="memdesc:ac0ff32d040c0182bf14c99f82c704b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the column vector of the squared Frobenius norm of all rows i of A, i.e., the sum of A(i,j)*A(i,j) over all j for each i with possibly (if scaling!=0) each term j multiplied by (*scaling)(j)  <a href="#ac0ff32d040c0182bf14c99f82c704b5c">More...</a><br /></td></tr>
<tr class="separator:ac0ff32d040c0182bf14c99f82c704b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b49e506f059ccc0b06a1beaa6bb572a"><td class="memItemLeft" align="right" valign="top"><a id="a1b49e506f059ccc0b06a1beaa6bb572a"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a1b49e506f059ccc0b06a1beaa6bb572a">sumrows</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A)</td></tr>
<tr class="memdesc:a1b49e506f059ccc0b06a1beaa6bb572a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a row vector holding the sum over all rows, i.e., (1 1 ... 1)*A <br /></td></tr>
<tr class="separator:a1b49e506f059ccc0b06a1beaa6bb572a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac159c59c53595dc0ec735ee12391a8ff"><td class="memItemLeft" align="right" valign="top"><a id="ac159c59c53595dc0ec735ee12391a8ff"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ac159c59c53595dc0ec735ee12391a8ff">sumcols</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A)</td></tr>
<tr class="memdesc:ac159c59c53595dc0ec735ee12391a8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector holding the sum over all columns, i.e., A*(1 1 ... 1)^T <br /></td></tr>
<tr class="separator:ac159c59c53595dc0ec735ee12391a8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c55552830a20cf37d16ac7d7bda41b5"><td class="memItemLeft" align="right" valign="top"><a id="a5c55552830a20cf37d16ac7d7bda41b5"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a5c55552830a20cf37d16ac7d7bda41b5">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;v)</td></tr>
<tr class="memdesc:a5c55552830a20cf37d16ac7d7bda41b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">output format: nr nc nz \n i1 j1 val1\n i2 j2 val2\n ... inz jnz valnz\n <br /></td></tr>
<tr class="separator:a5c55552830a20cf37d16ac7d7bda41b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1226c1e62e24a60e51961b1da49fbeb6"><td class="memItemLeft" align="right" valign="top"><a id="a1226c1e62e24a60e51961b1da49fbeb6"></a>
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a1226c1e62e24a60e51961b1da49fbeb6">operator&gt;&gt;</a> (std::istream &amp;i, <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;v)</td></tr>
<tr class="memdesc:a1226c1e62e24a60e51961b1da49fbeb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">input format: nr nc nz \n i1 j1 val1\n i2 j2 val2\n ... inz jnz valnz\n <br /></td></tr>
<tr class="separator:a1226c1e62e24a60e51961b1da49fbeb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbdfcec82b472c6feefe196dd957cd9"><td class="memItemLeft" align="right" valign="top"><a id="aadbdfcec82b472c6feefe196dd957cd9"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aadbdfcec82b472c6feefe196dd957cd9">concat_right</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;B)</td></tr>
<tr class="memdesc:aadbdfcec82b472c6feefe196dd957cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a new sparse matrix [A, B], i.e., it concats matrices A and B rowwise; A or B may be a 0x0 matrix <br /></td></tr>
<tr class="separator:aadbdfcec82b472c6feefe196dd957cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452ddb563735c7943d609b7777a6af89"><td class="memItemLeft" align="right" valign="top"><a id="a452ddb563735c7943d609b7777a6af89"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a452ddb563735c7943d609b7777a6af89">concat_below</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;B)</td></tr>
<tr class="memdesc:a452ddb563735c7943d609b7777a6af89"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a new sparse matrix [A; B], i.e., it concats matrices A and B columnwise; A or B may be a 0x0 matrix <br /></td></tr>
<tr class="separator:a452ddb563735c7943d609b7777a6af89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c0ce7025e3152ccf6b231a828f8a52"><td class="memItemLeft" align="right" valign="top"><a id="ab6c0ce7025e3152ccf6b231a828f8a52"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ab6c0ce7025e3152ccf6b231a828f8a52">norm2</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A)</td></tr>
<tr class="memdesc:ab6c0ce7025e3152ccf6b231a828f8a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the Frobenius norm of A, i.e., the square root of the sum of A(i,j)*A(i,j) over all i,j <br /></td></tr>
<tr class="separator:ab6c0ce7025e3152ccf6b231a828f8a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ff17ab35195f0f26a34fb2eaf8676f"><td class="memItemLeft" align="right" valign="top"><a id="a57ff17ab35195f0f26a34fb2eaf8676f"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a57ff17ab35195f0f26a34fb2eaf8676f">operator+</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;B)</td></tr>
<tr class="memdesc:a57ff17ab35195f0f26a34fb2eaf8676f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html" title="Matrix class of sparse matrices with real values of type Real ">Sparsemat</a> equal to A+B <br /></td></tr>
<tr class="separator:a57ff17ab35195f0f26a34fb2eaf8676f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee13dc9570897e001e99e9672a04d4d5"><td class="memItemLeft" align="right" valign="top"><a id="aee13dc9570897e001e99e9672a04d4d5"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aee13dc9570897e001e99e9672a04d4d5">operator-</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;B)</td></tr>
<tr class="memdesc:aee13dc9570897e001e99e9672a04d4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html" title="Matrix class of sparse matrices with real values of type Real ">Sparsemat</a> equal to A-B <br /></td></tr>
<tr class="separator:aee13dc9570897e001e99e9672a04d4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fa193eafc522a72838fa7e96f08959"><td class="memItemLeft" align="right" valign="top"><a id="af3fa193eafc522a72838fa7e96f08959"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#af3fa193eafc522a72838fa7e96f08959">operator*</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:af3fa193eafc522a72838fa7e96f08959"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html" title="Matrix class of sparse matrices with real values of type Real ">Sparsemat</a> equal to A*d <br /></td></tr>
<tr class="separator:af3fa193eafc522a72838fa7e96f08959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee1fc6a76f8750755768704d01d94d3"><td class="memItemLeft" align="right" valign="top"><a id="a5ee1fc6a76f8750755768704d01d94d3"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a5ee1fc6a76f8750755768704d01d94d3">operator*</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A)</td></tr>
<tr class="memdesc:a5ee1fc6a76f8750755768704d01d94d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html" title="Matrix class of sparse matrices with real values of type Real ">Sparsemat</a> equal to d*A <br /></td></tr>
<tr class="separator:a5ee1fc6a76f8750755768704d01d94d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523237073ec0df15acffa341da973571"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a523237073ec0df15acffa341da973571">operator/</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:a523237073ec0df15acffa341da973571"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html" title="Matrix class of sparse matrices with real values of type Real ">Sparsemat</a> equal to A/d; ATTENTION: no check against division by zero  <a href="#a523237073ec0df15acffa341da973571">More...</a><br /></td></tr>
<tr class="separator:a523237073ec0df15acffa341da973571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c16b11d7d9a886a4b51cf00117acc1"><td class="memItemLeft" align="right" valign="top"><a id="a14c16b11d7d9a886a4b51cf00117acc1"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a14c16b11d7d9a886a4b51cf00117acc1">operator*</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:a14c16b11d7d9a886a4b51cf00117acc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> equal to A*B <br /></td></tr>
<tr class="separator:a14c16b11d7d9a886a4b51cf00117acc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ddeb4e458c792ff60baf4736e1bc38"><td class="memItemLeft" align="right" valign="top"><a id="a59ddeb4e458c792ff60baf4736e1bc38"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a59ddeb4e458c792ff60baf4736e1bc38">operator*</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;B)</td></tr>
<tr class="memdesc:a59ddeb4e458c792ff60baf4736e1bc38"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> equal to A*B <br /></td></tr>
<tr class="separator:a59ddeb4e458c792ff60baf4736e1bc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3755f56f173cb046ca8860fa4a88418"><td class="memItemLeft" align="right" valign="top"><a id="ab3755f56f173cb046ca8860fa4a88418"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ab3755f56f173cb046ca8860fa4a88418">operator+</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:ab3755f56f173cb046ca8860fa4a88418"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> equal to A+B <br /></td></tr>
<tr class="separator:ab3755f56f173cb046ca8860fa4a88418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f1da2658e7d47eab81311a6aae589b"><td class="memItemLeft" align="right" valign="top"><a id="ad2f1da2658e7d47eab81311a6aae589b"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ad2f1da2658e7d47eab81311a6aae589b">operator+</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;B)</td></tr>
<tr class="memdesc:ad2f1da2658e7d47eab81311a6aae589b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> equal to A+B <br /></td></tr>
<tr class="separator:ad2f1da2658e7d47eab81311a6aae589b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d8bc7bb2b44acaafcee1cd12e543c6"><td class="memItemLeft" align="right" valign="top"><a id="a90d8bc7bb2b44acaafcee1cd12e543c6"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a90d8bc7bb2b44acaafcee1cd12e543c6">operator-</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:a90d8bc7bb2b44acaafcee1cd12e543c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> equal to A-B <br /></td></tr>
<tr class="separator:a90d8bc7bb2b44acaafcee1cd12e543c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a0acdc0a416fba1cc1ade37f4f4f3c"><td class="memItemLeft" align="right" valign="top"><a id="a91a0acdc0a416fba1cc1ade37f4f4f3c"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a91a0acdc0a416fba1cc1ade37f4f4f3c">operator-</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;B)</td></tr>
<tr class="memdesc:a91a0acdc0a416fba1cc1ade37f4f4f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> equal to A-B <br /></td></tr>
<tr class="separator:a91a0acdc0a416fba1cc1ade37f4f4f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad948e642219a3c867ab1ab6a41a3943c"><td class="memItemLeft" align="right" valign="top"><a id="ad948e642219a3c867ab1ab6a41a3943c"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ad948e642219a3c867ab1ab6a41a3943c">ip</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;B)</td></tr>
<tr class="memdesc:ad948e642219a3c867ab1ab6a41a3943c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j <br /></td></tr>
<tr class="separator:ad948e642219a3c867ab1ab6a41a3943c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5e5fdb0b5d32049c17f9c8cba34667"><td class="memItemLeft" align="right" valign="top"><a id="a1c5e5fdb0b5d32049c17f9c8cba34667"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a1c5e5fdb0b5d32049c17f9c8cba34667">sum</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A)</td></tr>
<tr class="memdesc:a1c5e5fdb0b5d32049c17f9c8cba34667"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the sum over all elements of A, i.e., (1 1 ... 1)*A*(1 1 ... 1)^T <br /></td></tr>
<tr class="separator:a1c5e5fdb0b5d32049c17f9c8cba34667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf177f3bfa24cb94f5fc7d8e27f2892f"><td class="memItemLeft" align="right" valign="top"><a id="aaf177f3bfa24cb94f5fc7d8e27f2892f"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aaf177f3bfa24cb94f5fc7d8e27f2892f">transpose</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A)</td></tr>
<tr class="memdesc:aaf177f3bfa24cb94f5fc7d8e27f2892f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html" title="Matrix class of sparse matrices with real values of type Real ">Sparsemat</a> that is the transpose of A <br /></td></tr>
<tr class="separator:aaf177f3bfa24cb94f5fc7d8e27f2892f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e0657ad380733175acfcfefacb037f"><td class="memItemLeft" align="right" valign="top"><a id="a66e0657ad380733175acfcfefacb037f"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a66e0657ad380733175acfcfefacb037f">diag</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A)</td></tr>
<tr class="memdesc:a66e0657ad380733175acfcfefacb037f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the diagonal of A as a dense <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> vector <br /></td></tr>
<tr class="separator:a66e0657ad380733175acfcfefacb037f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bedebbd07509337535d711502f448e"><td class="memItemLeft" align="right" valign="top"><a id="a78bedebbd07509337535d711502f448e"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a78bedebbd07509337535d711502f448e">sparseDiag</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> tol=<a class="el" href="sparsmat_8hxx.html#aedc1602a5c77a496b2125f204a45f9d5">SPARSE_ZERO_TOL</a>)</td></tr>
<tr class="memdesc:a78bedebbd07509337535d711502f448e"><td class="mdescLeft">&#160;</td><td class="mdescRight">forms a sparse symmetrix matrix having vector A on its diagonal <br /></td></tr>
<tr class="separator:a78bedebbd07509337535d711502f448e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade259b2a429745d1c61121fb61d96cb2"><td class="memItemLeft" align="right" valign="top"><a id="ade259b2a429745d1c61121fb61d96cb2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ade259b2a429745d1c61121fb61d96cb2">swap</a> (<a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A, <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;B)</td></tr>
<tr class="memdesc:ade259b2a429745d1c61121fb61d96cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap the content of the two sparse matrices A and B (involves no copying) <br /></td></tr>
<tr class="separator:ade259b2a429745d1c61121fb61d96cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4cce680e26c7615805bf5f9165d17c"><td class="memItemLeft" align="right" valign="top"><a id="ace4cce680e26c7615805bf5f9165d17c"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ace4cce680e26c7615805bf5f9165d17c">xeyapzb</a> (<a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;x, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;y, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;z, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta=1.)</td></tr>
<tr class="memdesc:ace4cce680e26c7615805bf5f9165d17c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns x= alpha*y+beta*z; x is initialized to the correct size <br /></td></tr>
<tr class="separator:ace4cce680e26c7615805bf5f9165d17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe58ffd8f189a061962d63f0763e7a2"><td class="memItemLeft" align="right" valign="top"><a id="aabe58ffd8f189a061962d63f0763e7a2"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aabe58ffd8f189a061962d63f0763e7a2">support_rankadd</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;C, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0., int trans=0)</td></tr>
<tr class="memdesc:aabe58ffd8f189a061962d63f0763e7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*AA^T (or A^TA), but only on the current support of C <br /></td></tr>
<tr class="separator:aabe58ffd8f189a061962d63f0763e7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac8dcbd20ce95b336cf4a54132a2b5e"><td class="memItemLeft" align="right" valign="top"><a id="a9ac8dcbd20ce95b336cf4a54132a2b5e"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a9ac8dcbd20ce95b336cf4a54132a2b5e">ip</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;B)</td></tr>
<tr class="memdesc:a9ac8dcbd20ce95b336cf4a54132a2b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j <br /></td></tr>
<tr class="separator:a9ac8dcbd20ce95b336cf4a54132a2b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702c77f671a29c507bbcd6534f2e5903"><td class="memItemLeft" align="right" valign="top"><a id="a702c77f671a29c507bbcd6534f2e5903"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a702c77f671a29c507bbcd6534f2e5903">abs</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A)</td></tr>
<tr class="memdesc:a702c77f671a29c507bbcd6534f2e5903"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html" title="Matrix class of symmetric matrices with real values of type Real ">Sparsesym</a> with elements abs((*this)(i,j)) for all i,j <br /></td></tr>
<tr class="separator:a702c77f671a29c507bbcd6534f2e5903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1537bb1ac96b2b1fc17fef5f9c167d97"><td class="memItemLeft" align="right" valign="top"><a id="a1537bb1ac96b2b1fc17fef5f9c167d97"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a1537bb1ac96b2b1fc17fef5f9c167d97">trace</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A)</td></tr>
<tr class="memdesc:a1537bb1ac96b2b1fc17fef5f9c167d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the sum of the diagonal elements A(i,i) over all i <br /></td></tr>
<tr class="separator:a1537bb1ac96b2b1fc17fef5f9c167d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044b1db4efbacd6660c5598984d0be87"><td class="memItemLeft" align="right" valign="top"><a id="a044b1db4efbacd6660c5598984d0be87"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a044b1db4efbacd6660c5598984d0be87">ip</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;B)</td></tr>
<tr class="memdesc:a044b1db4efbacd6660c5598984d0be87"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j <br /></td></tr>
<tr class="separator:a044b1db4efbacd6660c5598984d0be87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc81d01c54763f8f26d68d83c44da9f"><td class="memItemLeft" align="right" valign="top"><a id="affc81d01c54763f8f26d68d83c44da9f"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#affc81d01c54763f8f26d68d83c44da9f">ip</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;B)</td></tr>
<tr class="memdesc:affc81d01c54763f8f26d68d83c44da9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j <br /></td></tr>
<tr class="separator:affc81d01c54763f8f26d68d83c44da9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7084a04bd6416f70ac1280ad51532629"><td class="memItemLeft" align="right" valign="top"><a id="a7084a04bd6416f70ac1280ad51532629"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a7084a04bd6416f70ac1280ad51532629">norm2</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A)</td></tr>
<tr class="memdesc:a7084a04bd6416f70ac1280ad51532629"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the Frobenius norm of A, i.e., the square root of the sum of A(i,j)*A(i,j) over all i,j <br /></td></tr>
<tr class="separator:a7084a04bd6416f70ac1280ad51532629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37f00224f234504e40032520b1a8d71"><td class="memItemLeft" align="right" valign="top"><a id="af37f00224f234504e40032520b1a8d71"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#af37f00224f234504e40032520b1a8d71">sumrows</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A)</td></tr>
<tr class="memdesc:af37f00224f234504e40032520b1a8d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a row vector holding the sum over all rows, i.e., (1 1 ... 1)*A <br /></td></tr>
<tr class="separator:af37f00224f234504e40032520b1a8d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2d9bf5ea611a8d46997d5e4049475c"><td class="memItemLeft" align="right" valign="top"><a id="a8b2d9bf5ea611a8d46997d5e4049475c"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a8b2d9bf5ea611a8d46997d5e4049475c">sum</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A)</td></tr>
<tr class="memdesc:a8b2d9bf5ea611a8d46997d5e4049475c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the sum over all elements of A, i.e., (1 1 ... 1)*A*(1 1 ... 1)^T <br /></td></tr>
<tr class="separator:a8b2d9bf5ea611a8d46997d5e4049475c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9828f088b0142cdff4bdac2f59ffa431"><td class="memItemLeft" align="right" valign="top"><a id="a9828f088b0142cdff4bdac2f59ffa431"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a9828f088b0142cdff4bdac2f59ffa431">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;v)</td></tr>
<tr class="memdesc:a9828f088b0142cdff4bdac2f59ffa431"><td class="mdescLeft">&#160;</td><td class="mdescRight">output format (lower triangle): nr nz \n i1 j1 val1\n i2 j2 val2\n ... inz jnz valnz\n <br /></td></tr>
<tr class="separator:a9828f088b0142cdff4bdac2f59ffa431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae46beb2b2cf55112378ad93e9ab5431"><td class="memItemLeft" align="right" valign="top"><a id="aae46beb2b2cf55112378ad93e9ab5431"></a>
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aae46beb2b2cf55112378ad93e9ab5431">operator&gt;&gt;</a> (std::istream &amp;i, <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;v)</td></tr>
<tr class="memdesc:aae46beb2b2cf55112378ad93e9ab5431"><td class="mdescLeft">&#160;</td><td class="mdescRight">input format (lower triangle): nr nz \n i1 j1 val1\n i2 j2 val2\n ... inz jnz valnz\n <br /></td></tr>
<tr class="separator:aae46beb2b2cf55112378ad93e9ab5431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab195dc4debfd397f6aa466a95c92cc05"><td class="memItemLeft" align="right" valign="top"><a id="ab195dc4debfd397f6aa466a95c92cc05"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ab195dc4debfd397f6aa466a95c92cc05">xbpeya</a> (<a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;x, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;y, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0.)</td></tr>
<tr class="memdesc:ab195dc4debfd397f6aa466a95c92cc05"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns x= alpha*y+beta*x; if beta==0. then x is initialized to the correct size <br /></td></tr>
<tr class="separator:ab195dc4debfd397f6aa466a95c92cc05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce2c625a9a8aa257f111b06a029f3c6"><td class="memItemLeft" align="right" valign="top"><a id="a2ce2c625a9a8aa257f111b06a029f3c6"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a2ce2c625a9a8aa257f111b06a029f3c6">operator+</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;B)</td></tr>
<tr class="memdesc:a2ce2c625a9a8aa257f111b06a029f3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html" title="Matrix class of symmetric matrices with real values of type Real ">Sparsesym</a> that equals A+B <br /></td></tr>
<tr class="separator:a2ce2c625a9a8aa257f111b06a029f3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63602394415b5258cf04493c690522bc"><td class="memItemLeft" align="right" valign="top"><a id="a63602394415b5258cf04493c690522bc"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a63602394415b5258cf04493c690522bc">operator-</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;B)</td></tr>
<tr class="memdesc:a63602394415b5258cf04493c690522bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html" title="Matrix class of symmetric matrices with real values of type Real ">Sparsesym</a> that equals A-B <br /></td></tr>
<tr class="separator:a63602394415b5258cf04493c690522bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f8f15c7c67212bc3d15d7b4a304946"><td class="memItemLeft" align="right" valign="top"><a id="a94f8f15c7c67212bc3d15d7b4a304946"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a94f8f15c7c67212bc3d15d7b4a304946">operator*</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:a94f8f15c7c67212bc3d15d7b4a304946"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html" title="Matrix class of symmetric matrices with real values of type Real ">Sparsesym</a> that equals A*d <br /></td></tr>
<tr class="separator:a94f8f15c7c67212bc3d15d7b4a304946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ccfc2087cec30d8fc79e52728a1c72a"><td class="memItemLeft" align="right" valign="top"><a id="a1ccfc2087cec30d8fc79e52728a1c72a"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a1ccfc2087cec30d8fc79e52728a1c72a">operator*</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A)</td></tr>
<tr class="memdesc:a1ccfc2087cec30d8fc79e52728a1c72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html" title="Matrix class of symmetric matrices with real values of type Real ">Sparsesym</a> that equals A*d <br /></td></tr>
<tr class="separator:a1ccfc2087cec30d8fc79e52728a1c72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af182eb9635fca9906958ca097fbb4963"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#af182eb9635fca9906958ca097fbb4963">operator/</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>
<tr class="memdesc:af182eb9635fca9906958ca097fbb4963"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html" title="Matrix class of symmetric matrices with real values of type Real ">Sparsesym</a> that equals A/d; ATTENTION: no check for devision by zero  <a href="#af182eb9635fca9906958ca097fbb4963">More...</a><br /></td></tr>
<tr class="separator:af182eb9635fca9906958ca097fbb4963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a880aafcb2135a6ad608e18209b61e1"><td class="memItemLeft" align="right" valign="top"><a id="a0a880aafcb2135a6ad608e18209b61e1"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a0a880aafcb2135a6ad608e18209b61e1">operator*</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:a0a880aafcb2135a6ad608e18209b61e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A*B <br /></td></tr>
<tr class="separator:a0a880aafcb2135a6ad608e18209b61e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899afcfade000fe377ba6fc9192462ff"><td class="memItemLeft" align="right" valign="top"><a id="a899afcfade000fe377ba6fc9192462ff"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a899afcfade000fe377ba6fc9192462ff">operator*</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;B)</td></tr>
<tr class="memdesc:a899afcfade000fe377ba6fc9192462ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A*B <br /></td></tr>
<tr class="separator:a899afcfade000fe377ba6fc9192462ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a8caf154ed0263717f3063b475ba94"><td class="memItemLeft" align="right" valign="top"><a id="ae5a8caf154ed0263717f3063b475ba94"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ae5a8caf154ed0263717f3063b475ba94">operator+</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;B)</td></tr>
<tr class="memdesc:ae5a8caf154ed0263717f3063b475ba94"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A+B <br /></td></tr>
<tr class="separator:ae5a8caf154ed0263717f3063b475ba94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c15316aa9ab0f95916623905b1cd0f"><td class="memItemLeft" align="right" valign="top"><a id="ab3c15316aa9ab0f95916623905b1cd0f"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ab3c15316aa9ab0f95916623905b1cd0f">operator+</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:ab3c15316aa9ab0f95916623905b1cd0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A+B <br /></td></tr>
<tr class="separator:ab3c15316aa9ab0f95916623905b1cd0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4e691ecdb7c7e08b03be5a1bd8f8bb"><td class="memItemLeft" align="right" valign="top"><a id="a9d4e691ecdb7c7e08b03be5a1bd8f8bb"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a9d4e691ecdb7c7e08b03be5a1bd8f8bb">operator-</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;B)</td></tr>
<tr class="memdesc:a9d4e691ecdb7c7e08b03be5a1bd8f8bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A-B <br /></td></tr>
<tr class="separator:a9d4e691ecdb7c7e08b03be5a1bd8f8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea47bd74002310e60e8819ea070c8fcc"><td class="memItemLeft" align="right" valign="top"><a id="aea47bd74002310e60e8819ea070c8fcc"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aea47bd74002310e60e8819ea070c8fcc">operator-</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:aea47bd74002310e60e8819ea070c8fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A-B <br /></td></tr>
<tr class="separator:aea47bd74002310e60e8819ea070c8fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8c4bf3fda44d91bca9d6c3e956674d"><td class="memItemLeft" align="right" valign="top"><a id="aae8c4bf3fda44d91bca9d6c3e956674d"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aae8c4bf3fda44d91bca9d6c3e956674d">ip</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:aae8c4bf3fda44d91bca9d6c3e956674d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j <br /></td></tr>
<tr class="separator:aae8c4bf3fda44d91bca9d6c3e956674d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c54db87e1362db51c184f6f2186822"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a48c54db87e1362db51c184f6f2186822">transpose</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A)</td></tr>
<tr class="memdesc:a48c54db87e1362db51c184f6f2186822"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a copy of A (drop it or use a constructor instead)  <a href="#a48c54db87e1362db51c184f6f2186822">More...</a><br /></td></tr>
<tr class="separator:a48c54db87e1362db51c184f6f2186822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251a0d1056cde3d50cc6584ad7f361a4"><td class="memItemLeft" align="right" valign="top"><a id="a251a0d1056cde3d50cc6584ad7f361a4"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a251a0d1056cde3d50cc6584ad7f361a4">sumcols</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A)</td></tr>
<tr class="memdesc:a251a0d1056cde3d50cc6584ad7f361a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector holding the sum over all columns, i.e., A*(1 1 ... 1)^T <br /></td></tr>
<tr class="separator:a251a0d1056cde3d50cc6584ad7f361a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc80564503aa34760945eccc774f2a2"><td class="memItemLeft" align="right" valign="top"><a id="a2dc80564503aa34760945eccc774f2a2"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a2dc80564503aa34760945eccc774f2a2">operator+</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:a2dc80564503aa34760945eccc774f2a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> that equals A+B <br /></td></tr>
<tr class="separator:a2dc80564503aa34760945eccc774f2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcaf349919c89efcd308beebc25f9cd6"><td class="memItemLeft" align="right" valign="top"><a id="abcaf349919c89efcd308beebc25f9cd6"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#abcaf349919c89efcd308beebc25f9cd6">operator+</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;B)</td></tr>
<tr class="memdesc:abcaf349919c89efcd308beebc25f9cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> that equals A+B <br /></td></tr>
<tr class="separator:abcaf349919c89efcd308beebc25f9cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b31cac45a3de1839c87a98a63297cf4"><td class="memItemLeft" align="right" valign="top"><a id="a0b31cac45a3de1839c87a98a63297cf4"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a0b31cac45a3de1839c87a98a63297cf4">operator-</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:a0b31cac45a3de1839c87a98a63297cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> that equals A-B <br /></td></tr>
<tr class="separator:a0b31cac45a3de1839c87a98a63297cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1962037e70927a690c9cd855acda0ee8"><td class="memItemLeft" align="right" valign="top"><a id="a1962037e70927a690c9cd855acda0ee8"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a1962037e70927a690c9cd855acda0ee8">operator-</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;B)</td></tr>
<tr class="memdesc:a1962037e70927a690c9cd855acda0ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> that equals A-B <br /></td></tr>
<tr class="separator:a1962037e70927a690c9cd855acda0ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4e3643583c40ffdded99ab393dcbb9"><td class="memItemLeft" align="right" valign="top"><a id="a5b4e3643583c40ffdded99ab393dcbb9"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a5b4e3643583c40ffdded99ab393dcbb9">ip</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:a5b4e3643583c40ffdded99ab393dcbb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j <br /></td></tr>
<tr class="separator:a5b4e3643583c40ffdded99ab393dcbb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6149f342427960553a7db50422d0fdf3"><td class="memItemLeft" align="right" valign="top"><a id="a6149f342427960553a7db50422d0fdf3"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a6149f342427960553a7db50422d0fdf3">operator*</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;B)</td></tr>
<tr class="memdesc:a6149f342427960553a7db50422d0fdf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A*B <br /></td></tr>
<tr class="separator:a6149f342427960553a7db50422d0fdf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a347e1f5f725a23b31c8fc353d1fb9"><td class="memItemLeft" align="right" valign="top"><a id="a75a347e1f5f725a23b31c8fc353d1fb9"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a75a347e1f5f725a23b31c8fc353d1fb9">operator*</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;B)</td></tr>
<tr class="memdesc:a75a347e1f5f725a23b31c8fc353d1fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A*B <br /></td></tr>
<tr class="separator:a75a347e1f5f725a23b31c8fc353d1fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940777e56b71bf3cc9f19d3ba6df8157"><td class="memItemLeft" align="right" valign="top"><a id="a940777e56b71bf3cc9f19d3ba6df8157"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a940777e56b71bf3cc9f19d3ba6df8157">operator*</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;B)</td></tr>
<tr class="memdesc:a940777e56b71bf3cc9f19d3ba6df8157"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A*B <br /></td></tr>
<tr class="separator:a940777e56b71bf3cc9f19d3ba6df8157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedde6bbd7b9ca8188c86a10a4c274a5"><td class="memItemLeft" align="right" valign="top"><a id="afedde6bbd7b9ca8188c86a10a4c274a5"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#afedde6bbd7b9ca8188c86a10a4c274a5">operator*</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>
<tr class="memdesc:afedde6bbd7b9ca8188c86a10a4c274a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals A*B <br /></td></tr>
<tr class="separator:afedde6bbd7b9ca8188c86a10a4c274a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Equal (Members)</div></td></tr>
<tr class="memitem:a16387c5fc145abd989eeb0553c34255a"><td class="memItemLeft" align="right" valign="top"><a id="a16387c5fc145abd989eeb0553c34255a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a16387c5fc145abd989eeb0553c34255a">equal</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;B, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> eqtol=1e-10)</td></tr>
<tr class="memdesc:a16387c5fc145abd989eeb0553c34255a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns 1 if both matrices are identical, 0 otherwise <br /></td></tr>
<tr class="separator:a16387c5fc145abd989eeb0553c34255a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3cb6e8174aec4fd9b9655114af75c8"><td class="memItemLeft" align="right" valign="top"><a id="abe3cb6e8174aec4fd9b9655114af75c8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#abe3cb6e8174aec4fd9b9655114af75c8">equal</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;B, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> eqtol=1e-10)</td></tr>
<tr class="memdesc:abe3cb6e8174aec4fd9b9655114af75c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns 1 if both matrices are identical, 0 otherwise <br /></td></tr>
<tr class="separator:abe3cb6e8174aec4fd9b9655114af75c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gad9894a125f09b6480726ff044e52d5e5"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matop__types.html#gad9894a125f09b6480726ff044e52d5e5">max_Integer</a> = INT_MAX</td></tr>
<tr class="memdesc:gad9894a125f09b6480726ff044e52d5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximal attainable value by an <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd" title="all integer numbers in calculations and indexing are of this type ">Integer</a> <br /></td></tr>
<tr class="separator:gad9894a125f09b6480726ff044e52d5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa21ed3ae5fe140c9eb48c795def72e6b"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matop__types.html#gaa21ed3ae5fe140c9eb48c795def72e6b">min_Integer</a> = INT_MIN</td></tr>
<tr class="memdesc:gaa21ed3ae5fe140c9eb48c795def72e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">minimal attainable value by an <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd" title="all integer numbers in calculations and indexing are of this type ">Integer</a> <br /></td></tr>
<tr class="separator:gaa21ed3ae5fe140c9eb48c795def72e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc0777e17e0f4a89dc7550c346a40ba2"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matop__types.html#gadc0777e17e0f4a89dc7550c346a40ba2">max_Real</a> = DBL_MAX</td></tr>
<tr class="memdesc:gadc0777e17e0f4a89dc7550c346a40ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximal attainable value by a <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type ">Real</a> <br /></td></tr>
<tr class="separator:gadc0777e17e0f4a89dc7550c346a40ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae028c06dbd10356165a7250e96b47323"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matop__types.html#gae028c06dbd10356165a7250e96b47323">min_Real</a> = -DBL_MAX</td></tr>
<tr class="memdesc:gae028c06dbd10356165a7250e96b47323"><td class="mdescLeft">&#160;</td><td class="mdescRight">minimal attainable value by a <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type ">Real</a> <br /></td></tr>
<tr class="separator:gae028c06dbd10356165a7250e96b47323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaa1fdcdf799fecb69ad711a81dc23b5"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matop__types.html#gadaa1fdcdf799fecb69ad711a81dc23b5">eps_Real</a> = DBL_EPSILON</td></tr>
<tr class="memdesc:gadaa1fdcdf799fecb69ad711a81dc23b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">machine epsilon for type <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type ">Real</a> <br /></td></tr>
<tr class="separator:gadaa1fdcdf799fecb69ad711a81dc23b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga232db86121d190593a401956dde04c00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCH__Tools_1_1GB__rand.html">CH_Tools::GB_rand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matop__globals.html#ga232db86121d190593a401956dde04c00">mat_randgen</a></td></tr>
<tr class="memdesc:ga232db86121d190593a401956dde04c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">common random number generator for use when a random matrix is generated.  <a href="group__matop__globals.html#ga232db86121d190593a401956dde04c00">More...</a><br /></td></tr>
<tr class="separator:ga232db86121d190593a401956dde04c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d5b683433019820632bcfb983cd2ece"><td class="memItemLeft" align="right" valign="top">
std::default_random_engine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matop__globals.html#ga0d5b683433019820632bcfb983cd2ece">mat_std_randgen</a></td></tr>
<tr class="memdesc:ga0d5b683433019820632bcfb983cd2ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">optional fast alternative random number generator from std <br /></td></tr>
<tr class="separator:ga0d5b683433019820632bcfb983cd2ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad404e57aca35cb59534b4054dafd8b84"><td class="memItemLeft" align="right" valign="top">
std::mt19937&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matop__globals.html#gad404e57aca35cb59534b4054dafd8b84">mat_mt_randgen</a></td></tr>
<tr class="memdesc:gad404e57aca35cb59534b4054dafd8b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">optional high quality alternative random number generator from std <br /></td></tr>
<tr class="separator:gad404e57aca35cb59534b4054dafd8b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3955ba951c272cf552302b98024aa34"><td class="memItemLeft" align="right" valign="top">
std::mt19937_64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matop__globals.html#gab3955ba951c272cf552302b98024aa34">mat_mt64_randgen</a></td></tr>
<tr class="memdesc:gab3955ba951c272cf552302b98024aa34"><td class="mdescLeft">&#160;</td><td class="mdescRight">optional high quality alternative random number generator from std <br /></td></tr>
<tr class="separator:gab3955ba951c272cf552302b98024aa34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5579af973b2773401952ea9012c89e7"><td class="memItemLeft" align="right" valign="top">
std::ostream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matop__globals.html#gac5579af973b2773401952ea9012c89e7">materrout</a></td></tr>
<tr class="memdesc:gac5579af973b2773401952ea9012c89e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">if not zero, this is the output stream for runtime error messages, by default it is set to &amp;std::cout <br /></td></tr>
<tr class="separator:gac5579af973b2773401952ea9012c89e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> Classes and Linear Algebra. See <a class="el" href="matrixclasses.html">Matrix Classes (namespace CH_Matrix_Classes)</a> for a quick introduction. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a514702944dfbc90ee1e8961cb6f8e710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a514702944dfbc90ee1e8961cb6f8e710">&#9670;&nbsp;</a></span>colsip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> CH_Matrix_Classes::colsip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> *&#160;</td>
          <td class="paramname"><em>colscaling</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the row vector of the squared Frobenius norm of all columns j of A, i.e., the sum of A(i,j)*A(i,j) over all i for each j with possibly (if scaling!=0) each term i multiplied by (*scaling)(i) </p>
<p>returns the column vector of the squared Frobenius norm of all columns j of A, i.e., the sum of A(i,j)*A(i,j) over all i for each j with possibly (if scaling~=0) each term i multiplied by (*scaling)(i) </p>

</div>
</div>
<a id="a851f7baaf0ec9b1e25d22e37b77e62a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851f7baaf0ec9b1e25d22e37b77e62a8">&#9670;&nbsp;</a></span>genmult() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&amp; CH_Matrix_Classes::genmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td>
          <td class="paramname"><em>beta</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>btrans</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size </p>
<p>returns C=beta*C+alpha*A*B, where B may be transposed; if beta==0. then C is initialized to the correct size </p>

</div>
</div>
<a id="aec989e433eb1503875968be18f9ee82e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec989e433eb1503875968be18f9ee82e">&#9670;&nbsp;</a></span>genmult() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&amp; CH_Matrix_Classes::genmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td>
          <td class="paramname"><em>beta</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>atrans</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size </p>
<p>returns C=beta*C+alpha*A*B, where A may be transposed; if beta==0. then C is initialized to the correct size </p>

</div>
</div>
<a id="a13ab94ea579cabe95893801fea392d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ab94ea579cabe95893801fea392d0a">&#9670;&nbsp;</a></span>genmult() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp; CH_Matrix_Classes::genmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>btrans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size </p>
<p>returns C=beta*C+alpha*A*B, where B may be transposed; C must not be equal to B; if beta==0. then C is initialized to the correct size </p>

</div>
</div>
<a id="a0a6fda2aa4b4e5d7061129b05e5b3930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a6fda2aa4b4e5d7061129b05e5b3930">&#9670;&nbsp;</a></span>genmult() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp; CH_Matrix_Classes::genmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>atrans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size </p>
<p>returns C=beta*C+alpha*A*B, where A may be transposed; C must not be equal to A; if beta==0. then C is initialized to the correct size </p>

</div>
</div>
<a id="a8d4407f0eefd61492afee5071dd36da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4407f0eefd61492afee5071dd36da2">&#9670;&nbsp;</a></span>genmult() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&amp; CH_Matrix_Classes::genmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>btrans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size </p>
<p>returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to B; if beta==0. then C is initialized to the correct size </p>

</div>
</div>
<a id="a6c8b19d132b924f83b0913ba420743f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8b19d132b924f83b0913ba420743f9">&#9670;&nbsp;</a></span>genmult() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&amp; CH_Matrix_Classes::genmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>atrans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size </p>
<p>returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to B; if beta==0. then C is initialized to the correct size </p>

</div>
</div>
<a id="a75384021f7932a11f3807669ed80f561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75384021f7932a11f3807669ed80f561">&#9670;&nbsp;</a></span>operator%()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> CH_Matrix_Classes::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> that equals AB (where % is overloaded as elementwise multiplication) </p>
<p>ATTENTION: this is redefined as the Hadamard product and sets (i,j)=A(i,j)*B(i,j) for all i&lt;=j. </p>

</div>
</div>
<a id="af6d5af24a0341639f0e326951f50707e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d5af24a0341639f0e326951f50707e">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> CH_Matrix_Classes::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> that equals A+d (d is added to each element) </p>
<p>returns (i,j)=A(i,j)+d for all i&lt;=j </p>

</div>
</div>
<a id="a71861033ab9ab93a83fded17ae0ea669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71861033ab9ab93a83fded17ae0ea669">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> CH_Matrix_Classes::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> that equals A+d (d is added to each element) </p>
<p>returns (i,j)=A(i,j)+d for all i&lt;=j </p>

</div>
</div>
<a id="a9ad23869576e96b9fad346cf2cc1b2c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad23869576e96b9fad346cf2cc1b2c2">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> CH_Matrix_Classes::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> that equals A-d (d is subtracted from each element) </p>
<p>returns (i,j)=A(i,j)-d for all i&lt;=j </p>

</div>
</div>
<a id="ab2d2b3ac69a6abc0973b77b486d55572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d2b3ac69a6abc0973b77b486d55572">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> CH_Matrix_Classes::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html" title="Matrix class of symmetric matrices with real values of type Real ">Symmatrix</a> that equals d-A (each element subtracted from d) </p>
<p>returns (i,j)=d-A(i,j) for all i&lt;=j </p>

<p class="reference">Referenced by <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a1c2fb45683aaa043d2ff8d3a10f100c2">CH_Matrix_Classes::Symmatrix::get_store()</a>, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#aa5a0a0248a4bb0eda3a0b004c28527a4">CH_Matrix_Classes::Symmatrix::operator%=()</a>, and <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ab4c30091f07177dd6d52986e46759d2e">CH_Matrix_Classes::Symmatrix::transpose()</a>.</p>

</div>
</div>
<a id="af182eb9635fca9906958ca097fbb4963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af182eb9635fca9906958ca097fbb4963">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> CH_Matrix_Classes::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html" title="Matrix class of symmetric matrices with real values of type Real ">Sparsesym</a> that equals A/d; ATTENTION: no check for devision by zero </p>
<p>ATTENTION: d is NOT checked for 0. </p>

<p class="reference">References <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html#a08d95130d5c16daaf38246e0986e1107">CH_Matrix_Classes::Sparsesym::Sparsesym()</a>.</p>

</div>
</div>
<a id="a523237073ec0df15acffa341da973571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a523237073ec0df15acffa341da973571">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> CH_Matrix_Classes::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html" title="Matrix class of sparse matrices with real values of type Real ">Sparsemat</a> equal to A/d; ATTENTION: no check against division by zero </p>
<p>ATTENTION: d is NOT checked for 0. </p>

<p class="reference">References <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html#a024b41c0f00339ec7da16a9a11c69bec">CH_Matrix_Classes::Sparsemat::Sparsemat()</a>.</p>

</div>
</div>
<a id="a1b939cce2e7144bff22742fbcd96ab26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b939cce2e7144bff22742fbcd96ab26">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> CH_Matrix_Classes::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a>&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> equal to A/d; ATTENTION: d is NOT checked for 0 </p>
<p>ATTENTION: d is NOT checked for 0. </p>

<p class="reference">References <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html#a68649603858ee102447d2d29f73259b0">CH_Matrix_Classes::Matrix::Matrix()</a>.</p>

</div>
</div>
<a id="a880e83eb4bcfb178499ab1dce5350b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880e83eb4bcfb178499ab1dce5350b50">&#9670;&nbsp;</a></span>operator>()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> CH_Matrix_Classes::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a matrix having elements (i,j)=Real(A(i,j)&gt;d) for all i,j </p>
<p>returns a matrix having elements (i,j)=Real(A(i,j)&gt;B(i,j)) for all i,j </p>

</div>
</div>
<a id="ab296276d96d420c797f8ad827f7c88ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab296276d96d420c797f8ad827f7c88ba">&#9670;&nbsp;</a></span>operator>=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> CH_Matrix_Classes::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a matrix having elements (i,j)=Real(A(i,j)&gt;=d) for all i,j </p>
<p>returns a matrix having elements (i,j)=Real(A(i,j)&gt;=B(i,j)) for all i,j </p>

</div>
</div>
<a id="ac0ff32d040c0182bf14c99f82c704b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ff32d040c0182bf14c99f82c704b5c">&#9670;&nbsp;</a></span>rowsip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> CH_Matrix_Classes::rowsip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> *&#160;</td>
          <td class="paramname"><em>rowscaling</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the column vector of the squared Frobenius norm of all rows i of A, i.e., the sum of A(i,j)*A(i,j) over all j for each i with possibly (if scaling!=0) each term j multiplied by (*scaling)(j) </p>
<p>returns the row vector of the squared Frobenius norm of all rows i of A, i.e., the sum of A(i,j)*A(i,j) over all j for each i with possibly (if scaling~=0) each term j multiplied by (*scaling)(j) </p>

</div>
</div>
<a id="a1263fd8238d4851a57e0a3b24f69507e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1263fd8238d4851a57e0a3b24f69507e">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">Real</a> CH_Matrix_Classes::trace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>=sum(diag(A)) </p>
<p>returns the sum of the diagonal elements A(i,i) over all i </p>

</div>
</div>
<a id="a48c54db87e1362db51c184f6f2186822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c54db87e1362db51c184f6f2186822">&#9670;&nbsp;</a></span>transpose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> CH_Matrix_Classes::transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a copy of A (drop it or use a constructor instead) </p>
<p>(drop it or use a constructor instead) </p>

<p class="reference">References <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html#a08d95130d5c16daaf38246e0986e1107">CH_Matrix_Classes::Sparsesym::Sparsesym()</a>.</p>

</div>
</div>
<a id="ab7e2eba5715c21f2b26dd72ea87aceea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e2eba5715c21f2b26dd72ea87aceea">&#9670;&nbsp;</a></span>transpose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> CH_Matrix_Classes::transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a copy of A (drop it or use a constructor instead) </p>
<p>(drop it or use a constructor instead) </p>

<p class="reference">References <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a77b76cc41cb98ad78dc90cfdd17e6f1c">CH_Matrix_Classes::Symmatrix::Symmatrix()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
