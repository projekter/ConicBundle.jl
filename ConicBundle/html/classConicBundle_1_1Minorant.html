<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ConicBundle: ConicBundle::Minorant Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ConicBundle
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceConicBundle.html">ConicBundle</a></li><li class="navelem"><a class="el" href="classConicBundle_1_1Minorant.html">Minorant</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classConicBundle_1_1Minorant-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ConicBundle::Minorant Class Reference<div class="ingroups"><a class="el" href="group__cxxinterface.html">Interface to ConicBundle for the Language C++</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>this is used to describe affine minorants of convex functions that will be used for generating cutting models of these functions.  
 <a href="classConicBundle_1_1Minorant.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CBSolver_8hxx_source.html">CBSolver.hxx</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ConicBundle::Minorant:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classConicBundle_1_1Minorant.png" usemap="#ConicBundle::Minorant_map" alt=""/>
  <map id="ConicBundle::Minorant_map" name="ConicBundle::Minorant_map">
<area href="classConicBundle_1_1MatrixMinorant.html" title="Minorant interface supporting Matrix classes; simple constructros for subgradients given by column ve..." alt="ConicBundle::MatrixMinorant" shape="rect" coords="0,56,175,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a74d73027782201199643caf0b89f4948"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#a74d73027782201199643caf0b89f4948">Minorant</a> (double <a class="el" href="classConicBundle_1_1Minorant.html#adf70a53630641ad54bfc7b6c808dbdaa">offset</a>, const <a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">DVector</a> &amp;subg, <a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> *primal=0, bool offset_at_origin=false)</td></tr>
<tr class="memdesc:a74d73027782201199643caf0b89f4948"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classConicBundle_1_1Minorant.html" title="this is used to describe affine minorants of convex functions that will be used for generating cuttin...">Minorant</a> constructor for a dense subgradient specified via a DVector.  <a href="#a74d73027782201199643caf0b89f4948">More...</a><br /></td></tr>
<tr class="separator:a74d73027782201199643caf0b89f4948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674535f43a2539aca6916f1814f25b98"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#a674535f43a2539aca6916f1814f25b98">Minorant</a> (double <a class="el" href="classConicBundle_1_1Minorant.html#adf70a53630641ad54bfc7b6c808dbdaa">offset</a>, const <a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">DVector</a> &amp;subg_val, const <a class="el" href="group__cxxinterface.html#ga2ba782d3f05e6d9a1964638a6b97a390">IVector</a> &amp;subg_ind, <a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> *primal=0, bool offset_at_origin=false)</td></tr>
<tr class="memdesc:a674535f43a2539aca6916f1814f25b98"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classConicBundle_1_1Minorant.html" title="this is used to describe affine minorants of convex functions that will be used for generating cuttin...">Minorant</a> constructor for a sparse subgradient where the nonzero values are specified by DVector and the corresponding indices by an IVector.  <a href="#a674535f43a2539aca6916f1814f25b98">More...</a><br /></td></tr>
<tr class="separator:a674535f43a2539aca6916f1814f25b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2513608e34e5c30bdafd54215a70b3a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#a2513608e34e5c30bdafd54215a70b3a6">Minorant</a> (bool offset_at_origin=true, double <a class="el" href="classConicBundle_1_1Minorant.html#adf70a53630641ad54bfc7b6c808dbdaa">offset</a>=0., int n_elementes=0, const double *coeffs=0, const int *indices=0, double scale_val=1., <a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> *primal=0)</td></tr>
<tr class="memdesc:a2513608e34e5c30bdafd54215a70b3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">default initializes a zero minorant, see full explanation otherwise; NOTE: if the offset supplied by the minorant refers to the evaluation point (i.e., if it is the function value at the point of evaluation), set <em>offset_at_origin</em> = false !  <a href="#a2513608e34e5c30bdafd54215a70b3a6">More...</a><br /></td></tr>
<tr class="separator:a2513608e34e5c30bdafd54215a70b3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40af1d2406a4c796dae103d9a2d54526"><td class="memItemLeft" align="right" valign="top"><a id="a40af1d2406a4c796dae103d9a2d54526"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#a40af1d2406a4c796dae103d9a2d54526">Minorant</a> (const <a class="el" href="classConicBundle_1_1Minorant.html">Minorant</a> *mnrt, double factor=1., bool with_primal=false)</td></tr>
<tr class="memdesc:a40af1d2406a4c796dae103d9a2d54526"><td class="mdescLeft">&#160;</td><td class="mdescRight">they main purpose of this constructor is to allow easy cloning for derived classes <br /></td></tr>
<tr class="separator:a40af1d2406a4c796dae103d9a2d54526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf70a53630641ad54bfc7b6c808dbdaa"><td class="memItemLeft" align="right" valign="top"><a id="adf70a53630641ad54bfc7b6c808dbdaa"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#adf70a53630641ad54bfc7b6c808dbdaa">offset</a> () const</td></tr>
<tr class="memdesc:adf70a53630641ad54bfc7b6c808dbdaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the current offset value <br /></td></tr>
<tr class="separator:adf70a53630641ad54bfc7b6c808dbdaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20154062a8cc7821ffd58c6f8b000864"><td class="memItemLeft" align="right" valign="top"><a id="a20154062a8cc7821ffd58c6f8b000864"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#a20154062a8cc7821ffd58c6f8b000864">add_offset</a> (double value)</td></tr>
<tr class="memdesc:a20154062a8cc7821ffd58c6f8b000864"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds this value to the current offset value <br /></td></tr>
<tr class="separator:a20154062a8cc7821ffd58c6f8b000864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d4bffb350df7053b119a42bdc30185"><td class="memItemLeft" align="right" valign="top"><a id="aa2d4bffb350df7053b119a42bdc30185"></a>
virtual bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#aa2d4bffb350df7053b119a42bdc30185">offset_gives_value_at_origin</a> ()</td></tr>
<tr class="memdesc:aa2d4bffb350df7053b119a42bdc30185"><td class="mdescLeft">&#160;</td><td class="mdescRight">allows to specify/modify whether the offset refers to origin or to the point of evaluation at which this minorant was supplied <br /></td></tr>
<tr class="separator:aa2d4bffb350df7053b119a42bdc30185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62fda45193c2f6ae86ab499bae9d1eb0"><td class="memItemLeft" align="right" valign="top"><a id="a62fda45193c2f6ae86ab499bae9d1eb0"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#a62fda45193c2f6ae86ab499bae9d1eb0">offset_gives_value_at_origin</a> () const</td></tr>
<tr class="memdesc:a62fda45193c2f6ae86ab499bae9d1eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if the offset refers to origin and false, if the offset refers to the value of the minorant in the point of the oracle evaluation at which this minorant was supplied <br /></td></tr>
<tr class="separator:a62fda45193c2f6ae86ab499bae9d1eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cebe40957a0764bdfbcb170b87d9cb"><td class="memItemLeft" align="right" valign="top"><a id="a22cebe40957a0764bdfbcb170b87d9cb"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#a22cebe40957a0764bdfbcb170b87d9cb">coeff</a> (int i)</td></tr>
<tr class="memdesc:a22cebe40957a0764bdfbcb170b87d9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the value of the coefficient in coordinate i <br /></td></tr>
<tr class="separator:a22cebe40957a0764bdfbcb170b87d9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c7c5372777d7b9f56d0f2eac68659d"><td class="memItemLeft" align="right" valign="top"><a id="a21c7c5372777d7b9f56d0f2eac68659d"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#a21c7c5372777d7b9f56d0f2eac68659d">add_coeff</a> (int i, double value)</td></tr>
<tr class="memdesc:a21c7c5372777d7b9f56d0f2eac68659d"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds the value to the coefficient in coordinate i <br /></td></tr>
<tr class="separator:a21c7c5372777d7b9f56d0f2eac68659d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acceb09c03b908a255d0e136eaa589576"><td class="memItemLeft" align="right" valign="top"><a id="acceb09c03b908a255d0e136eaa589576"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#acceb09c03b908a255d0e136eaa589576">add_coeffs</a> (int n_elements, const double *values, double factor=1., int start_pos=0)</td></tr>
<tr class="memdesc:acceb09c03b908a255d0e136eaa589576"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds the n values (possibly multiplied by factor) to consecutive coefficients starting at start_pos (by default 0); this always converts the minroant into a dense vector first and adds then <br /></td></tr>
<tr class="separator:acceb09c03b908a255d0e136eaa589576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45cfab34f6b4f9cacb1735b1303021d4"><td class="memItemLeft" align="right" valign="top"><a id="a45cfab34f6b4f9cacb1735b1303021d4"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#a45cfab34f6b4f9cacb1735b1303021d4">add_coeffs</a> (int n_elements, const double *values, const int *indices, double factor=1.)</td></tr>
<tr class="memdesc:a45cfab34f6b4f9cacb1735b1303021d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds the n values (possibly multiplied by factor) to the coefficients indicated by indices (if zero, this calls the other add_coeffs for the consecutive version) <br /></td></tr>
<tr class="separator:a45cfab34f6b4f9cacb1735b1303021d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e0aa303ea6c6f45754219f77653418"><td class="memItemLeft" align="right" valign="top"><a id="a97e0aa303ea6c6f45754219f77653418"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#a97e0aa303ea6c6f45754219f77653418">sparsify</a> (double tol=<a class="el" href="group__cxxinterface.html#ga0183b4724a5783c099911a5950c1401f">CB_minorant_zero_tolerance</a>, double sparsity_ratio=<a class="el" href="group__cxxinterface.html#ga68d9c24386fc088ee22451d08dd2ea4a">CB_minorant_sparsity_ratio</a>)</td></tr>
<tr class="memdesc:a97e0aa303ea6c6f45754219f77653418"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts to sparse format with zeros of absolut value at most tol*(fabs(offset)+1) if the given ratio of elements is zero in relation to the maximum nonzero index <br /></td></tr>
<tr class="separator:a97e0aa303ea6c6f45754219f77653418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b751dd7209ea744a7b55910fefb249"><td class="memItemLeft" align="right" valign="top"><a id="a14b751dd7209ea744a7b55910fefb249"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#a14b751dd7209ea744a7b55910fefb249">nonzeros</a> ()</td></tr>
<tr class="memdesc:a14b751dd7209ea744a7b55910fefb249"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of nonzero coefficients <br /></td></tr>
<tr class="separator:a14b751dd7209ea744a7b55910fefb249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2d0b2f8b72e9d0e50408f754a966bb"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#acb2d0b2f8b72e9d0e50408f754a966bb">get_coeffs</a> (int &amp;n_elements, const double *&amp;coeffs, const int *&amp;indices) const</td></tr>
<tr class="memdesc:acb2d0b2f8b72e9d0e50408f754a966bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the list of all nonzero coefficients by returning pointers to the arrays and their common length n_elements  <a href="#acb2d0b2f8b72e9d0e50408f754a966bb">More...</a><br /></td></tr>
<tr class="separator:acb2d0b2f8b72e9d0e50408f754a966bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2c306857b3ed1eddc1a1a8102a7528"><td class="memItemLeft" align="right" valign="top">virtual double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#aaf2c306857b3ed1eddc1a1a8102a7528">get_dense_coeff_store</a> (int n_elements)</td></tr>
<tr class="memdesc:aaf2c306857b3ed1eddc1a1a8102a7528"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the returned pointer is not NULL it gives direct access to the array of current coefficient values with indices 0 up to n_elements-1;.  <a href="#aaf2c306857b3ed1eddc1a1a8102a7528">More...</a><br /></td></tr>
<tr class="separator:aaf2c306857b3ed1eddc1a1a8102a7528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988c5f1581cdb147fc953c0653807003"><td class="memItemLeft" align="right" valign="top"><a id="a988c5f1581cdb147fc953c0653807003"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#a988c5f1581cdb147fc953c0653807003">reassign_coeffs</a> (int n_elements, const int *map_to_old_coeffs)</td></tr>
<tr class="memdesc:a988c5f1581cdb147fc953c0653807003"><td class="mdescLeft">&#160;</td><td class="mdescRight">resorts (and deletes) coefficients so that afterwards it has n_elements and the new coeff(i) has the previous value of coeff(map_to_old_coeff(i)) <br /></td></tr>
<tr class="separator:a988c5f1581cdb147fc953c0653807003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f816b1e8a90dea020658c7aa613db6a"><td class="memItemLeft" align="right" valign="top"><a id="a8f816b1e8a90dea020658c7aa613db6a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#a8f816b1e8a90dea020658c7aa613db6a">set_primal</a> (<a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> *)</td></tr>
<tr class="memdesc:a8f816b1e8a90dea020658c7aa613db6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">if the minorant is generated by <a class="el" href="classConicBundle_1_1PrimalData.html" title="In Lagrangean relaxation an approximate primal solution can be generated by supplying primal informat...">PrimalData</a> and this should be aggregated along, insert a heap object of it here (see <a class="el" href="classConicBundle_1_1PrimalData.html" title="In Lagrangean relaxation an approximate primal solution can be generated by supplying primal informat...">PrimalData</a>) <br /></td></tr>
<tr class="separator:a8f816b1e8a90dea020658c7aa613db6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf1ff174a8c2faba5af73948361e1b6"><td class="memItemLeft" align="right" valign="top"><a id="abbf1ff174a8c2faba5af73948361e1b6"></a>
virtual <a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#abbf1ff174a8c2faba5af73948361e1b6">get_primal</a> ()</td></tr>
<tr class="memdesc:abbf1ff174a8c2faba5af73948361e1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns NULL if there is no primal data and otherwise a pointer to it <br /></td></tr>
<tr class="separator:abbf1ff174a8c2faba5af73948361e1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5259d2adf54aed832ba4137e93969545"><td class="memItemLeft" align="right" valign="top"><a id="a5259d2adf54aed832ba4137e93969545"></a>
virtual const <a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#a5259d2adf54aed832ba4137e93969545">get_primal</a> () const</td></tr>
<tr class="memdesc:a5259d2adf54aed832ba4137e93969545"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns NULL if there is no primal data and otherwise a pointer to it (const version) <br /></td></tr>
<tr class="separator:a5259d2adf54aed832ba4137e93969545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd947aba12b6739feaec5f06d759980"><td class="memItemLeft" align="right" valign="top"><a id="a1bd947aba12b6739feaec5f06d759980"></a>
virtual <a class="el" href="classConicBundle_1_1Minorant.html">Minorant</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#a1bd947aba12b6739feaec5f06d759980">clone_minorant</a> (double factor=1., bool with_primal=true) const</td></tr>
<tr class="memdesc:a1bd947aba12b6739feaec5f06d759980"><td class="mdescLeft">&#160;</td><td class="mdescRight">generates a full copy (multiplied by factor) on the heap and returns a pointer to it (it also includes a clone of the primal data if with_primal==true, otherwise the copy will have no primal data) <br /></td></tr>
<tr class="separator:a1bd947aba12b6739feaec5f06d759980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12965fd98f9629517ec8d330f1302b45"><td class="memItemLeft" align="right" valign="top"><a id="a12965fd98f9629517ec8d330f1302b45"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#a12965fd98f9629517ec8d330f1302b45">aggregate</a> (const <a class="el" href="classConicBundle_1_1Minorant.html">Minorant</a> &amp;minorant, double factor=1.)</td></tr>
<tr class="memdesc:a12965fd98f9629517ec8d330f1302b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds factor*minorant to this and does this also for the primal if it is availabe <br /></td></tr>
<tr class="separator:a12965fd98f9629517ec8d330f1302b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362ed4357ea83a21479289dcf78ce676"><td class="memItemLeft" align="right" valign="top"><a id="a362ed4357ea83a21479289dcf78ce676"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#a362ed4357ea83a21479289dcf78ce676">number_aggregated</a> () const</td></tr>
<tr class="memdesc:a362ed4357ea83a21479289dcf78ce676"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of minorants aggregated in this one, value 1 thus means not aggregated <br /></td></tr>
<tr class="separator:a362ed4357ea83a21479289dcf78ce676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bff88dbe36f21f12d9db1eaf16853ca"><td class="memItemLeft" align="right" valign="top"><a id="a5bff88dbe36f21f12d9db1eaf16853ca"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#a5bff88dbe36f21f12d9db1eaf16853ca">scale_minorant</a> (double scale_val)</td></tr>
<tr class="memdesc:a5bff88dbe36f21f12d9db1eaf16853ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">mutliply offset and coefficients (and <a class="el" href="classConicBundle_1_1PrimalData.html" title="In Lagrangean relaxation an approximate primal solution can be generated by supplying primal informat...">PrimalData</a>, if given) by scale_val <br /></td></tr>
<tr class="separator:a5bff88dbe36f21f12d9db1eaf16853ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30d8a25458d54a841bd586e86301251"><td class="memItemLeft" align="right" valign="top"><a id="aa30d8a25458d54a841bd586e86301251"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#aa30d8a25458d54a841bd586e86301251">norm_squared</a> () const</td></tr>
<tr class="memdesc:aa30d8a25458d54a841bd586e86301251"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the squared Euclidean norm <br /></td></tr>
<tr class="separator:aa30d8a25458d54a841bd586e86301251"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a05d3ecce176095ae7a0c8b48e841ac65"><td class="memItemLeft" align="right" valign="top"><a id="a05d3ecce176095ae7a0c8b48e841ac65"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#a05d3ecce176095ae7a0c8b48e841ac65">Minorant</a> (const <a class="el" href="classConicBundle_1_1Minorant.html">Minorant</a> &amp;)</td></tr>
<tr class="memdesc:a05d3ecce176095ae7a0c8b48e841ac65"><td class="mdescLeft">&#160;</td><td class="mdescRight">forbidden, blocked deliberately <br /></td></tr>
<tr class="separator:a05d3ecce176095ae7a0c8b48e841ac65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4ac90661402b3bb20281691e8648ba"><td class="memItemLeft" align="right" valign="top"><a id="a4c4ac90661402b3bb20281691e8648ba"></a>
<a class="el" href="classConicBundle_1_1Minorant.html">Minorant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#a4c4ac90661402b3bb20281691e8648ba">operator=</a> (const <a class="el" href="classConicBundle_1_1Minorant.html">Minorant</a> &amp;)</td></tr>
<tr class="memdesc:a4c4ac90661402b3bb20281691e8648ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">forbidden, blocked deliberately <br /></td></tr>
<tr class="separator:a4c4ac90661402b3bb20281691e8648ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a78af5296c164178c69c3973c014612fa"><td class="memItemLeft" align="right" valign="top"><a id="a78af5296c164178c69c3973c014612fa"></a>
MinorantData *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1Minorant.html#a78af5296c164178c69c3973c014612fa">data</a></td></tr>
<tr class="memdesc:a78af5296c164178c69c3973c014612fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation details are hidden on purpose <br /></td></tr>
<tr class="separator:a78af5296c164178c69c3973c014612fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>this is used to describe affine minorants of convex functions that will be used for generating cutting models of these functions. </p>
<p>They have to be returned in calls to evaluation oracles like in <a class="el" href="classConicBundle_1_1FunctionOracle.html#a10d135676ae61d26bb068fadef2526d3" title="Called by the solver. Has to Return function value and at least one (epsilon) subgradient and...">FunctionOracle::evaluate()</a> or <a class="el" href="classConicBundle_1_1MatrixFunctionOracle.html#a5bf180324668e4baaa431edb5ba56993" title="Called by the solver. Has to Return function value and at least one (epsilon) subgradient and...">MatrixFunctionOracle::evaluate()</a>.</p>
<p>The <a class="el" href="classConicBundle_1_1Minorant.html" title="this is used to describe affine minorants of convex functions that will be used for generating cuttin...">Minorant</a> is of the form f(point)=offset+ inner_product(coeff,point), offset and coeff must be specified by the user by using the constructors or <a class="el" href="classConicBundle_1_1Minorant.html#a20154062a8cc7821ffd58c6f8b000864" title="adds this value to the current offset value ">add_offset()</a> and <a class="el" href="classConicBundle_1_1Minorant.html#acceb09c03b908a255d0e136eaa589576" title="adds the n values (possibly multiplied by factor) to consecutive coefficients starting at start_pos (...">add_coeffs()</a>. The dimension need not be specified (it is clear from point) and it is always assumed without actual checking that all nonzero coefficients are restricted to the dimension.</p>
<p>Sometimes it is more natural for the user to specify the offset at the point where the evaluation took place, in this case the minorant would have the form f(point)=offset+ inner_prodcut(coeff,point-evalpoint). If the user wants to avoid computing the offset with respect to the origin, it suffices to set offset_at_origin=false at initialization berfore returning the minorant.</p>
<p>Once a minorant is returned in an oracle evaluation, control over this object is handed over to <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a>. <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> may want to and is allowed to clone or modify the minorants and will eventually delete this object. Thus a minorant (and all its associated date) must be an object on the heap.</p>
<p>The implementation of this class is given in Minorant.cxx </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a74d73027782201199643caf0b89f4948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d73027782201199643caf0b89f4948">&#9670;&nbsp;</a></span>Minorant() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConicBundle::Minorant::Minorant </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">DVector</a> &amp;&#160;</td>
          <td class="paramname"><em>subg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> *&#160;</td>
          <td class="paramname"><em>primal</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>offset_at_origin</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classConicBundle_1_1Minorant.html" title="this is used to describe affine minorants of convex functions that will be used for generating cuttin...">Minorant</a> constructor for a dense subgradient specified via a DVector. </p>
<p>Suppose in the evaluation of your oracle at the current point <img class="formulaInl" alt="$y$" src="form_64.png"/> you determine a subgradient <img class="formulaInl" alt="$s$" src="form_116.png"/> for the subgradient inequality</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(z)\ge f(y)+\langle s,z-y\rangle\quad\forall z\in\mathbf{R}^m, \]" src="form_117.png"/>
</p>
<p>then use <img class="formulaInl" alt="$f(y)$" src="form_118.png"/> for <em>offset</em> and <img class="formulaInl" alt="$s$" src="form_116.png"/> in the form of a DVector in <em>subg</em> and keep the default value <em>offset_at_origin</em> == false.</p>
<p>If, on the other hand, your oracle implements a support function for some compact set <img class="formulaInl" alt="$\mathcal{X}\subset\mathbf{R}^m$" src="form_119.png"/> like</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(y) = \max_{x\in\mathcal{X}} x^\top y\]" src="form_120.png"/>
</p>
<p>then it is actually more efficient to return 0 for <em>offset</em>, a maximizing <img class="formulaInl" alt="$x$" src="form_121.png"/> in @ subg and to put <em>offset_at_origin</em> = true.</p>
<p>You may also pass over a <a class="el" href="classConicBundle_1_1PrimalData.html" title="In Lagrangean relaxation an approximate primal solution can be generated by supplying primal informat...">PrimalData</a> object in primal that will be then be owned and later deleted by the minorant and aggregated along with the minornat </p>

</div>
</div>
<a id="a674535f43a2539aca6916f1814f25b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674535f43a2539aca6916f1814f25b98">&#9670;&nbsp;</a></span>Minorant() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConicBundle::Minorant::Minorant </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__cxxinterface.html#gada58ad89c25718a894f1399f7c061f0b">DVector</a> &amp;&#160;</td>
          <td class="paramname"><em>subg_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__cxxinterface.html#ga2ba782d3f05e6d9a1964638a6b97a390">IVector</a> &amp;&#160;</td>
          <td class="paramname"><em>subg_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> *&#160;</td>
          <td class="paramname"><em>primal</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>offset_at_origin</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classConicBundle_1_1Minorant.html" title="this is used to describe affine minorants of convex functions that will be used for generating cuttin...">Minorant</a> constructor for a sparse subgradient where the nonzero values are specified by DVector and the corresponding indices by an IVector. </p>
<p>Suppose in the evaluation of your oracle at the current point <img class="formulaInl" alt="$y$" src="form_64.png"/> you determine a subgradient <img class="formulaInl" alt="$s$" src="form_116.png"/> with few nonzeros for the subgradient inequality</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(z)\ge f(y)+\langle s,z-y\rangle\quad\forall z\in\mathbf{R}^m, \]" src="form_117.png"/>
</p>
<p>then use <img class="formulaInl" alt="$f(y)$" src="form_118.png"/> for <em>offset</em> and pass <img class="formulaInl" alt="$s$" src="form_116.png"/> by giving the nonzeros in the DVector <em>subg_val</em>, the corresponding indices in a IVector of the same length in <em>subg_ind</em> and keep the default value <em>offset_at_origin</em> == false.</p>
<p>If, on the other hand, your oracle implements a support function for some compact set <img class="formulaInl" alt="$\mathcal{X}\subset\mathbf{R}^m$" src="form_119.png"/> like</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(y) = \max_{x\in\mathcal{X}} x^\top y\]" src="form_120.png"/>
</p>
<p>then it is actually more efficient to return 0 for <em>offset</em>, a sparse maximizing <img class="formulaInl" alt="$x$" src="form_121.png"/> in <em>subg_val</em> and <em>subg_ind</em> and to put <em>offset_at_origin</em> = true.</p>
<p>You may also pass over a <a class="el" href="classConicBundle_1_1PrimalData.html" title="In Lagrangean relaxation an approximate primal solution can be generated by supplying primal informat...">PrimalData</a> object in primal that will be then be owned and later deleted by the minorant and aggregated along with the minornat </p>

</div>
</div>
<a id="a2513608e34e5c30bdafd54215a70b3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2513608e34e5c30bdafd54215a70b3a6">&#9670;&nbsp;</a></span>Minorant() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConicBundle::Minorant::Minorant </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>offset_at_origin</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_elementes</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>coeffs</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indices</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale_val</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> *&#160;</td>
          <td class="paramname"><em>primal</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>default initializes a zero minorant, see full explanation otherwise; NOTE: if the offset supplied by the minorant refers to the evaluation point (i.e., if it is the function value at the point of evaluation), set <em>offset_at_origin</em> = false ! </p>
<p>In many applications, in particular for Lagrangian relaxation, the offset is more naturally given for the origin, and giving it this way also reduces computational cost a bit, so <em>offset_at_origin</em> = true is the suggested default. If, however, the minorant arises from a subgradient inequality by evaluation in the current point, you may as well give the function value as offset directly and set <em>offset_at_origin=false</em>;</p>
<p>The data specifying the minorant may be set here or (part of) it may be entered/added later. The meaning of the other parameters is as follows.</p>
<p><em>offset</em> gives the constant value (if offset_at_origin = false then relative to the evaluation point)</p>
<p><em>n_elements</em> gives the number of elements specified by <em>coeffs</em> (and possibly indices), but if <em>coeffs</em> == NULL it just asks to reserve space for that many coefficients</p>
<p>If <em>coeffs</em> is not NULL, it points to an array of doubles of size at least <em>n_elements</em>. If <em>indices</em> == NULL then coeff[i] belongs to position i for i=0 to n_elements-1, otherwise coeff[i] belongs to position indices[i]. All data is copied, the arrays are not modified, not used later and not deleted here.</p>
<p>The entire input data (offset and coefficients) is multplied by <em>scale_val</em> to give the final minorant (scale_val is not memorized internally but executed immediately).</p>
<p>If the minorant arises from <em><a class="el" href="classConicBundle_1_1PrimalData.html" title="In Lagrangean relaxation an approximate primal solution can be generated by supplying primal informat...">PrimalData</a></em> and the primal data should be aggregated along, it may be entered here or in the routine <a class="el" href="classConicBundle_1_1Minorant.html#a8f816b1e8a90dea020658c7aa613db6a" title="if the minorant is generated by PrimalData and this should be aggregated along, insert a heap object ...">Minorant::set_primal()</a>. The object pointed to is then owned by <a class="el" href="classConicBundle_1_1Minorant.html" title="this is used to describe affine minorants of convex functions that will be used for generating cuttin...">Minorant</a> and will be deleted by <a class="el" href="classConicBundle_1_1Minorant.html" title="this is used to describe affine minorants of convex functions that will be used for generating cuttin...">Minorant</a> on its destruction. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acb2d0b2f8b72e9d0e50408f754a966bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2d0b2f8b72e9d0e50408f754a966bb">&#9670;&nbsp;</a></span>get_coeffs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ConicBundle::Minorant::get_coeffs </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>n_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the list of all nonzero coefficients by returning pointers to the arrays and their common length n_elements </p>
<p>If on return coeffs==NULL this is interpreted as the zero vector. If on return indices==NULL, the indices are 0 to n_elements-1. If on return indices!=NULL, the entries of this array will be sorted in strictly increasing order </p>

</div>
</div>
<a id="aaf2c306857b3ed1eddc1a1a8102a7528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2c306857b3ed1eddc1a1a8102a7528">&#9670;&nbsp;</a></span>get_dense_coeff_store()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double* ConicBundle::Minorant::get_dense_coeff_store </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_elements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the returned pointer is not NULL it gives direct access to the array of current coefficient values with indices 0 up to n_elements-1;. </p>
<p>If the return value is NULL, the representation may not be available or access to the store may not be granted; in this case other routines like get_coeffs and add_coeffs have to be used.</p>
<p>This routine is mainly intended for increasing efficiency in some internal computations; the validity of the pointer returned may get lost with any call to any other routine of this <a class="el" href="classConicBundle_1_1Minorant.html" title="this is used to describe affine minorants of convex functions that will be used for generating cuttin...">Minorant</a>, so during manipulations of the stored values no other routines should be called. Needless to say, this routine should only be used by experts. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="CBSolver_8hxx_source.html">CBSolver.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
