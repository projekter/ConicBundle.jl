<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ConicBundle: sparsmat.hxx File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ConicBundle
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d60f6684020cb105011de41729268593.html">Matrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sparsmat.hxx File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header declaring the class <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html" title="Matrix class of sparse matrices with real values of type Real ">CH_Matrix_Classes::Sparsemat</a> for sparse matrices with Real elements.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="symmat_8hxx_source.html">symmat.hxx</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sparssym_8hxx_source.html">sparssym.hxx</a>&quot;</code><br />
</div>
<p><a href="sparsmat_8hxx_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">CH_Matrix_Classes::Sparsemat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix class of sparse matrices with real values of type <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type ">Real</a>  <a href="classCH__Matrix__Classes_1_1Sparsemat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceCH__Matrix__Classes"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html">CH_Matrix_Classes</a></td></tr>
<tr class="memdesc:namespaceCH__Matrix__Classes"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> Classes and Linear Algebra. See <a class="el" href="matrixclasses.html">Matrix Classes (namespace CH_Matrix_Classes)</a> for a quick introduction. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aedc1602a5c77a496b2125f204a45f9d5"><td class="memItemLeft" align="right" valign="top"><a id="aedc1602a5c77a496b2125f204a45f9d5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparsmat_8hxx.html#aedc1602a5c77a496b2125f204a45f9d5">SPARSE_ZERO_TOL</a>&#160;&#160;&#160;1e-60</td></tr>
<tr class="memdesc:aedc1602a5c77a496b2125f204a45f9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">if the absolute value of an element is below this value, it is considered zero <br /></td></tr>
<tr class="separator:aedc1602a5c77a496b2125f204a45f9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a05ab056d6e3ad5dcb43e712d32510f41"><td class="memItemLeft" align="right" valign="top"><a id="a05ab056d6e3ad5dcb43e712d32510f41"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a05ab056d6e3ad5dcb43e712d32510f41">CH_Matrix_Classes::swap</a> (Sparsemat &amp;A, Sparsemat &amp;B)</td></tr>
<tr class="memdesc:a05ab056d6e3ad5dcb43e712d32510f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap the content of the two sparse matrices A and B (involves no copying) <br /></td></tr>
<tr class="separator:a05ab056d6e3ad5dcb43e712d32510f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952d1255f4d432bc8642b7534d22428e"><td class="memItemLeft" align="right" valign="top"><a id="a952d1255f4d432bc8642b7534d22428e"></a>
Sparsemat &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a952d1255f4d432bc8642b7534d22428e">CH_Matrix_Classes::xbpeya</a> (Sparsemat &amp;x, const Sparsemat &amp;y, Real alpha=1., Real beta=0., int ytrans=0)</td></tr>
<tr class="memdesc:a952d1255f4d432bc8642b7534d22428e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns x= alpha*y+beta*x, where y may be transposed (ytrans=1); if beta==0. then x is initialized to the correct size <br /></td></tr>
<tr class="separator:a952d1255f4d432bc8642b7534d22428e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429a75bdaccb90fe8ff90d83c928bcff"><td class="memItemLeft" align="right" valign="top"><a id="a429a75bdaccb90fe8ff90d83c928bcff"></a>
Matrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a429a75bdaccb90fe8ff90d83c928bcff">CH_Matrix_Classes::genmult</a> (const Sparsemat &amp;A, const Matrix &amp;B, Matrix &amp;C, Real alpha, Real beta, int atrans, int btrans)</td></tr>
<tr class="memdesc:a429a75bdaccb90fe8ff90d83c928bcff"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size <br /></td></tr>
<tr class="separator:a429a75bdaccb90fe8ff90d83c928bcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492d5b7d1338acb6d15d83d6aee208c2"><td class="memItemLeft" align="right" valign="top"><a id="a492d5b7d1338acb6d15d83d6aee208c2"></a>
Matrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a492d5b7d1338acb6d15d83d6aee208c2">CH_Matrix_Classes::genmult</a> (const Matrix &amp;A, const Sparsemat &amp;B, Matrix &amp;C, Real alpha, Real beta, int atrans, int btrans)</td></tr>
<tr class="memdesc:a492d5b7d1338acb6d15d83d6aee208c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size <br /></td></tr>
<tr class="separator:a492d5b7d1338acb6d15d83d6aee208c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ee78eada36c980a83f62790188196e"><td class="memItemLeft" align="right" valign="top"><a id="a12ee78eada36c980a83f62790188196e"></a>
Matrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a12ee78eada36c980a83f62790188196e">CH_Matrix_Classes::genmult</a> (const Sparsemat &amp;A, const Sparsemat &amp;B, Matrix &amp;C, Real alpha=1., Real beta=0., int atrans=0, int btrans=0)</td></tr>
<tr class="memdesc:a12ee78eada36c980a83f62790188196e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size <br /></td></tr>
<tr class="separator:a12ee78eada36c980a83f62790188196e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6873f512d9ed382b5ea3200d9e80cb42"><td class="memItemLeft" align="right" valign="top"><a id="a6873f512d9ed382b5ea3200d9e80cb42"></a>
Sparsemat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a6873f512d9ed382b5ea3200d9e80cb42">CH_Matrix_Classes::operator*</a> (const Sparsemat &amp;A, const Sparsemat &amp;B)</td></tr>
<tr class="memdesc:a6873f512d9ed382b5ea3200d9e80cb42"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html" title="Matrix class of sparse matrices with real values of type Real ">Sparsemat</a> equal to A*B <br /></td></tr>
<tr class="separator:a6873f512d9ed382b5ea3200d9e80cb42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851f7baaf0ec9b1e25d22e37b77e62a8"><td class="memItemLeft" align="right" valign="top">Matrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a851f7baaf0ec9b1e25d22e37b77e62a8">CH_Matrix_Classes::genmult</a> (const Sparsesym &amp;A, const Sparsemat &amp;B, Matrix &amp;C, Real alpha=1., Real beta=0., int btrans=0)</td></tr>
<tr class="memdesc:a851f7baaf0ec9b1e25d22e37b77e62a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size  <a href="namespaceCH__Matrix__Classes.html#a851f7baaf0ec9b1e25d22e37b77e62a8">More...</a><br /></td></tr>
<tr class="separator:a851f7baaf0ec9b1e25d22e37b77e62a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec989e433eb1503875968be18f9ee82e"><td class="memItemLeft" align="right" valign="top">Matrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aec989e433eb1503875968be18f9ee82e">CH_Matrix_Classes::genmult</a> (const Sparsemat &amp;A, const Sparsesym &amp;B, Matrix &amp;C, Real alpha=1., Real beta=0., int atrans=0)</td></tr>
<tr class="memdesc:aec989e433eb1503875968be18f9ee82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size  <a href="namespaceCH__Matrix__Classes.html#aec989e433eb1503875968be18f9ee82e">More...</a><br /></td></tr>
<tr class="separator:aec989e433eb1503875968be18f9ee82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3ea68298ec395b9e9f9676ae3659fb"><td class="memItemLeft" align="right" valign="top"><a id="aec3ea68298ec395b9e9f9676ae3659fb"></a>
Sparsemat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aec3ea68298ec395b9e9f9676ae3659fb">CH_Matrix_Classes::abs</a> (const Sparsemat &amp;A)</td></tr>
<tr class="memdesc:aec3ea68298ec395b9e9f9676ae3659fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a Sparsmat with elements abs((*this)(i,j)) for all i,j <br /></td></tr>
<tr class="separator:aec3ea68298ec395b9e9f9676ae3659fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b160a0356146bd7acc7e44d8e85be4"><td class="memItemLeft" align="right" valign="top"><a id="aa6b160a0356146bd7acc7e44d8e85be4"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aa6b160a0356146bd7acc7e44d8e85be4">CH_Matrix_Classes::trace</a> (const Sparsemat &amp;A)</td></tr>
<tr class="memdesc:aa6b160a0356146bd7acc7e44d8e85be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the sum of the diagonal elements A(i,i) over all i <br /></td></tr>
<tr class="separator:aa6b160a0356146bd7acc7e44d8e85be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34477757aa3170d7e6c9a458f016cf08"><td class="memItemLeft" align="right" valign="top"><a id="a34477757aa3170d7e6c9a458f016cf08"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a34477757aa3170d7e6c9a458f016cf08">CH_Matrix_Classes::ip</a> (const Sparsemat &amp;A, const Sparsemat &amp;B)</td></tr>
<tr class="memdesc:a34477757aa3170d7e6c9a458f016cf08"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j <br /></td></tr>
<tr class="separator:a34477757aa3170d7e6c9a458f016cf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b6a5b5ea79d8b46247f2f552693231"><td class="memItemLeft" align="right" valign="top"><a id="a83b6a5b5ea79d8b46247f2f552693231"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a83b6a5b5ea79d8b46247f2f552693231">CH_Matrix_Classes::ip</a> (const Sparsemat &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:a83b6a5b5ea79d8b46247f2f552693231"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j <br /></td></tr>
<tr class="separator:a83b6a5b5ea79d8b46247f2f552693231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c12fe257ee35c57a18018ea1c6090ba"><td class="memItemLeft" align="right" valign="top"><a id="a5c12fe257ee35c57a18018ea1c6090ba"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a5c12fe257ee35c57a18018ea1c6090ba">CH_Matrix_Classes::colip</a> (const Sparsemat &amp;A, Integer j, const Matrix *scaling=0)</td></tr>
<tr class="memdesc:a5c12fe257ee35c57a18018ea1c6090ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the squared Frobenius norm of col i of A, i.e., the sum of A(i,j)*A(i,j) over all i with possibly (if scaling!=0) each term i multiplied by (*scaling)(i) <br /></td></tr>
<tr class="separator:a5c12fe257ee35c57a18018ea1c6090ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13db2f114f46cbf0eeab45523cdb517"><td class="memItemLeft" align="right" valign="top"><a id="ac13db2f114f46cbf0eeab45523cdb517"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ac13db2f114f46cbf0eeab45523cdb517">CH_Matrix_Classes::rowip</a> (const Sparsemat &amp;A, Integer i, const Matrix *scaling=0)</td></tr>
<tr class="memdesc:ac13db2f114f46cbf0eeab45523cdb517"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the squared Frobenius norm of row i of A, i.e., the sum of A(i,j)*A(i,j) over all j with possibly (if scaling!=0) each term j multiplied by (*scaling)(j) <br /></td></tr>
<tr class="separator:ac13db2f114f46cbf0eeab45523cdb517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514702944dfbc90ee1e8961cb6f8e710"><td class="memItemLeft" align="right" valign="top">Sparsemat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a514702944dfbc90ee1e8961cb6f8e710">CH_Matrix_Classes::colsip</a> (const Sparsemat &amp;A, const Matrix *colscaling=0)</td></tr>
<tr class="memdesc:a514702944dfbc90ee1e8961cb6f8e710"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the row vector of the squared Frobenius norm of all columns j of A, i.e., the sum of A(i,j)*A(i,j) over all i for each j with possibly (if scaling!=0) each term i multiplied by (*scaling)(i)  <a href="namespaceCH__Matrix__Classes.html#a514702944dfbc90ee1e8961cb6f8e710">More...</a><br /></td></tr>
<tr class="separator:a514702944dfbc90ee1e8961cb6f8e710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ff32d040c0182bf14c99f82c704b5c"><td class="memItemLeft" align="right" valign="top">Sparsemat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ac0ff32d040c0182bf14c99f82c704b5c">CH_Matrix_Classes::rowsip</a> (const Sparsemat &amp;A, const Matrix *rowscaling=0)</td></tr>
<tr class="memdesc:ac0ff32d040c0182bf14c99f82c704b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the column vector of the squared Frobenius norm of all rows i of A, i.e., the sum of A(i,j)*A(i,j) over all j for each i with possibly (if scaling!=0) each term j multiplied by (*scaling)(j)  <a href="namespaceCH__Matrix__Classes.html#ac0ff32d040c0182bf14c99f82c704b5c">More...</a><br /></td></tr>
<tr class="separator:ac0ff32d040c0182bf14c99f82c704b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b49e506f059ccc0b06a1beaa6bb572a"><td class="memItemLeft" align="right" valign="top"><a id="a1b49e506f059ccc0b06a1beaa6bb572a"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a1b49e506f059ccc0b06a1beaa6bb572a">CH_Matrix_Classes::sumrows</a> (const Sparsemat &amp;A)</td></tr>
<tr class="memdesc:a1b49e506f059ccc0b06a1beaa6bb572a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a row vector holding the sum over all rows, i.e., (1 1 ... 1)*A <br /></td></tr>
<tr class="separator:a1b49e506f059ccc0b06a1beaa6bb572a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac159c59c53595dc0ec735ee12391a8ff"><td class="memItemLeft" align="right" valign="top"><a id="ac159c59c53595dc0ec735ee12391a8ff"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ac159c59c53595dc0ec735ee12391a8ff">CH_Matrix_Classes::sumcols</a> (const Sparsemat &amp;A)</td></tr>
<tr class="memdesc:ac159c59c53595dc0ec735ee12391a8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a column vector holding the sum over all columns, i.e., A*(1 1 ... 1)^T <br /></td></tr>
<tr class="separator:ac159c59c53595dc0ec735ee12391a8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c55552830a20cf37d16ac7d7bda41b5"><td class="memItemLeft" align="right" valign="top"><a id="a5c55552830a20cf37d16ac7d7bda41b5"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a5c55552830a20cf37d16ac7d7bda41b5">CH_Matrix_Classes::operator&lt;&lt;</a> (std::ostream &amp;o, const Sparsemat &amp;v)</td></tr>
<tr class="memdesc:a5c55552830a20cf37d16ac7d7bda41b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">output format: nr nc nz \n i1 j1 val1\n i2 j2 val2\n ... inz jnz valnz\n <br /></td></tr>
<tr class="separator:a5c55552830a20cf37d16ac7d7bda41b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1226c1e62e24a60e51961b1da49fbeb6"><td class="memItemLeft" align="right" valign="top"><a id="a1226c1e62e24a60e51961b1da49fbeb6"></a>
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a1226c1e62e24a60e51961b1da49fbeb6">CH_Matrix_Classes::operator&gt;&gt;</a> (std::istream &amp;i, Sparsemat &amp;v)</td></tr>
<tr class="memdesc:a1226c1e62e24a60e51961b1da49fbeb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">input format: nr nc nz \n i1 j1 val1\n i2 j2 val2\n ... inz jnz valnz\n <br /></td></tr>
<tr class="separator:a1226c1e62e24a60e51961b1da49fbeb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbdfcec82b472c6feefe196dd957cd9"><td class="memItemLeft" align="right" valign="top"><a id="aadbdfcec82b472c6feefe196dd957cd9"></a>
Sparsemat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aadbdfcec82b472c6feefe196dd957cd9">CH_Matrix_Classes::concat_right</a> (const Sparsemat &amp;A, const Sparsemat &amp;B)</td></tr>
<tr class="memdesc:aadbdfcec82b472c6feefe196dd957cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a new sparse matrix [A, B], i.e., it concats matrices A and B rowwise; A or B may be a 0x0 matrix <br /></td></tr>
<tr class="separator:aadbdfcec82b472c6feefe196dd957cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452ddb563735c7943d609b7777a6af89"><td class="memItemLeft" align="right" valign="top"><a id="a452ddb563735c7943d609b7777a6af89"></a>
Sparsemat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a452ddb563735c7943d609b7777a6af89">CH_Matrix_Classes::concat_below</a> (const Sparsemat &amp;A, const Sparsemat &amp;B)</td></tr>
<tr class="memdesc:a452ddb563735c7943d609b7777a6af89"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a new sparse matrix [A; B], i.e., it concats matrices A and B columnwise; A or B may be a 0x0 matrix <br /></td></tr>
<tr class="separator:a452ddb563735c7943d609b7777a6af89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c0ce7025e3152ccf6b231a828f8a52"><td class="memItemLeft" align="right" valign="top"><a id="ab6c0ce7025e3152ccf6b231a828f8a52"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ab6c0ce7025e3152ccf6b231a828f8a52">CH_Matrix_Classes::norm2</a> (const Sparsemat &amp;A)</td></tr>
<tr class="memdesc:ab6c0ce7025e3152ccf6b231a828f8a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the Frobenius norm of A, i.e., the square root of the sum of A(i,j)*A(i,j) over all i,j <br /></td></tr>
<tr class="separator:ab6c0ce7025e3152ccf6b231a828f8a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ff17ab35195f0f26a34fb2eaf8676f"><td class="memItemLeft" align="right" valign="top"><a id="a57ff17ab35195f0f26a34fb2eaf8676f"></a>
Sparsemat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a57ff17ab35195f0f26a34fb2eaf8676f">CH_Matrix_Classes::operator+</a> (const Sparsemat &amp;A, const Sparsemat &amp;B)</td></tr>
<tr class="memdesc:a57ff17ab35195f0f26a34fb2eaf8676f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html" title="Matrix class of sparse matrices with real values of type Real ">Sparsemat</a> equal to A+B <br /></td></tr>
<tr class="separator:a57ff17ab35195f0f26a34fb2eaf8676f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee13dc9570897e001e99e9672a04d4d5"><td class="memItemLeft" align="right" valign="top"><a id="aee13dc9570897e001e99e9672a04d4d5"></a>
Sparsemat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aee13dc9570897e001e99e9672a04d4d5">CH_Matrix_Classes::operator-</a> (const Sparsemat &amp;A, const Sparsemat &amp;B)</td></tr>
<tr class="memdesc:aee13dc9570897e001e99e9672a04d4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html" title="Matrix class of sparse matrices with real values of type Real ">Sparsemat</a> equal to A-B <br /></td></tr>
<tr class="separator:aee13dc9570897e001e99e9672a04d4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fa193eafc522a72838fa7e96f08959"><td class="memItemLeft" align="right" valign="top"><a id="af3fa193eafc522a72838fa7e96f08959"></a>
Sparsemat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#af3fa193eafc522a72838fa7e96f08959">CH_Matrix_Classes::operator*</a> (const Sparsemat &amp;A, Real d)</td></tr>
<tr class="memdesc:af3fa193eafc522a72838fa7e96f08959"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html" title="Matrix class of sparse matrices with real values of type Real ">Sparsemat</a> equal to A*d <br /></td></tr>
<tr class="separator:af3fa193eafc522a72838fa7e96f08959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee1fc6a76f8750755768704d01d94d3"><td class="memItemLeft" align="right" valign="top"><a id="a5ee1fc6a76f8750755768704d01d94d3"></a>
Sparsemat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a5ee1fc6a76f8750755768704d01d94d3">CH_Matrix_Classes::operator*</a> (Real d, const Sparsemat &amp;A)</td></tr>
<tr class="memdesc:a5ee1fc6a76f8750755768704d01d94d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html" title="Matrix class of sparse matrices with real values of type Real ">Sparsemat</a> equal to d*A <br /></td></tr>
<tr class="separator:a5ee1fc6a76f8750755768704d01d94d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523237073ec0df15acffa341da973571"><td class="memItemLeft" align="right" valign="top">Sparsemat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a523237073ec0df15acffa341da973571">CH_Matrix_Classes::operator/</a> (const Sparsemat &amp;A, Real d)</td></tr>
<tr class="memdesc:a523237073ec0df15acffa341da973571"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html" title="Matrix class of sparse matrices with real values of type Real ">Sparsemat</a> equal to A/d; ATTENTION: no check against division by zero  <a href="namespaceCH__Matrix__Classes.html#a523237073ec0df15acffa341da973571">More...</a><br /></td></tr>
<tr class="separator:a523237073ec0df15acffa341da973571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c16b11d7d9a886a4b51cf00117acc1"><td class="memItemLeft" align="right" valign="top"><a id="a14c16b11d7d9a886a4b51cf00117acc1"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a14c16b11d7d9a886a4b51cf00117acc1">CH_Matrix_Classes::operator*</a> (const Sparsemat &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:a14c16b11d7d9a886a4b51cf00117acc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> equal to A*B <br /></td></tr>
<tr class="separator:a14c16b11d7d9a886a4b51cf00117acc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ddeb4e458c792ff60baf4736e1bc38"><td class="memItemLeft" align="right" valign="top"><a id="a59ddeb4e458c792ff60baf4736e1bc38"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a59ddeb4e458c792ff60baf4736e1bc38">CH_Matrix_Classes::operator*</a> (const Matrix &amp;A, const Sparsemat &amp;B)</td></tr>
<tr class="memdesc:a59ddeb4e458c792ff60baf4736e1bc38"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> equal to A*B <br /></td></tr>
<tr class="separator:a59ddeb4e458c792ff60baf4736e1bc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3755f56f173cb046ca8860fa4a88418"><td class="memItemLeft" align="right" valign="top"><a id="ab3755f56f173cb046ca8860fa4a88418"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ab3755f56f173cb046ca8860fa4a88418">CH_Matrix_Classes::operator+</a> (const Sparsemat &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:ab3755f56f173cb046ca8860fa4a88418"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> equal to A+B <br /></td></tr>
<tr class="separator:ab3755f56f173cb046ca8860fa4a88418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f1da2658e7d47eab81311a6aae589b"><td class="memItemLeft" align="right" valign="top"><a id="ad2f1da2658e7d47eab81311a6aae589b"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ad2f1da2658e7d47eab81311a6aae589b">CH_Matrix_Classes::operator+</a> (const Matrix &amp;A, const Sparsemat &amp;B)</td></tr>
<tr class="memdesc:ad2f1da2658e7d47eab81311a6aae589b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> equal to A+B <br /></td></tr>
<tr class="separator:ad2f1da2658e7d47eab81311a6aae589b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d8bc7bb2b44acaafcee1cd12e543c6"><td class="memItemLeft" align="right" valign="top"><a id="a90d8bc7bb2b44acaafcee1cd12e543c6"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a90d8bc7bb2b44acaafcee1cd12e543c6">CH_Matrix_Classes::operator-</a> (const Sparsemat &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:a90d8bc7bb2b44acaafcee1cd12e543c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> equal to A-B <br /></td></tr>
<tr class="separator:a90d8bc7bb2b44acaafcee1cd12e543c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a0acdc0a416fba1cc1ade37f4f4f3c"><td class="memItemLeft" align="right" valign="top"><a id="a91a0acdc0a416fba1cc1ade37f4f4f3c"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a91a0acdc0a416fba1cc1ade37f4f4f3c">CH_Matrix_Classes::operator-</a> (const Matrix &amp;A, const Sparsemat &amp;B)</td></tr>
<tr class="memdesc:a91a0acdc0a416fba1cc1ade37f4f4f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real ">Matrix</a> equal to A-B <br /></td></tr>
<tr class="separator:a91a0acdc0a416fba1cc1ade37f4f4f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad948e642219a3c867ab1ab6a41a3943c"><td class="memItemLeft" align="right" valign="top"><a id="ad948e642219a3c867ab1ab6a41a3943c"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#ad948e642219a3c867ab1ab6a41a3943c">CH_Matrix_Classes::ip</a> (const Matrix &amp;A, const Sparsemat &amp;B)</td></tr>
<tr class="memdesc:ad948e642219a3c867ab1ab6a41a3943c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j <br /></td></tr>
<tr class="separator:ad948e642219a3c867ab1ab6a41a3943c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5e5fdb0b5d32049c17f9c8cba34667"><td class="memItemLeft" align="right" valign="top"><a id="a1c5e5fdb0b5d32049c17f9c8cba34667"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a1c5e5fdb0b5d32049c17f9c8cba34667">CH_Matrix_Classes::sum</a> (const Sparsemat &amp;A)</td></tr>
<tr class="memdesc:a1c5e5fdb0b5d32049c17f9c8cba34667"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the sum over all elements of A, i.e., (1 1 ... 1)*A*(1 1 ... 1)^T <br /></td></tr>
<tr class="separator:a1c5e5fdb0b5d32049c17f9c8cba34667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf177f3bfa24cb94f5fc7d8e27f2892f"><td class="memItemLeft" align="right" valign="top"><a id="aaf177f3bfa24cb94f5fc7d8e27f2892f"></a>
Sparsemat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#aaf177f3bfa24cb94f5fc7d8e27f2892f">CH_Matrix_Classes::transpose</a> (const Sparsemat &amp;A)</td></tr>
<tr class="memdesc:aaf177f3bfa24cb94f5fc7d8e27f2892f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html" title="Matrix class of sparse matrices with real values of type Real ">Sparsemat</a> that is the transpose of A <br /></td></tr>
<tr class="separator:aaf177f3bfa24cb94f5fc7d8e27f2892f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Equal (Members)</div></td></tr>
<tr class="memitem:a16387c5fc145abd989eeb0553c34255a"><td class="memItemLeft" align="right" valign="top"><a id="a16387c5fc145abd989eeb0553c34255a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCH__Matrix__Classes.html#a16387c5fc145abd989eeb0553c34255a">CH_Matrix_Classes::equal</a> (const Sparsemat &amp;A, const Sparsemat &amp;B, Real eqtol=1e-10)</td></tr>
<tr class="memdesc:a16387c5fc145abd989eeb0553c34255a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns 1 if both matrices are identical, 0 otherwise <br /></td></tr>
<tr class="separator:a16387c5fc145abd989eeb0553c34255a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header declaring the class <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html" title="Matrix class of sparse matrices with real values of type Real ">CH_Matrix_Classes::Sparsemat</a> for sparse matrices with Real elements. </p>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2005-03-01 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Christoph Helmberg </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
