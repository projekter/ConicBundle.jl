<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ConicBundle: ConicBundle::SOCOracle Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ConicBundle
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceConicBundle.html">ConicBundle</a></li><li class="navelem"><a class="el" href="classConicBundle_1_1SOCOracle.html">SOCOracle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classConicBundle_1_1SOCOracle-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ConicBundle::SOCOracle Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__abstract__soc__oracle.html">abstract second order cone oracle</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Oracle interface for minimization of the support function over the seoncd order cone with <img class="formulaInl" alt="$x_0=1$" src="form_269.png"/> for an affine cost function or, equivalently, Lagrangian relaxation of second order cone programs.  
 <a href="classConicBundle_1_1SOCOracle.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SOCOracle_8hxx_source.html">SOCOracle.hxx</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ConicBundle::SOCOracle:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classConicBundle_1_1SOCOracle.png" usemap="#ConicBundle::SOCOracle_map" alt=""/>
  <map id="ConicBundle::SOCOracle_map" name="ConicBundle::SOCOracle_map">
<area href="classConicBundle_1_1ModifiableOracleObject.html" title="ModifiableOracle provides all oracles with a uniform interface for a modification routine and an on/o..." alt="ConicBundle::ModifiableOracleObject" shape="rect" coords="0,56,225,80"/>
<area href="classConicBundle_1_1FunctionObject.html" title="basic function object (abstract class). It serves for using the same interface on distinct oracle typ..." alt="ConicBundle::FunctionObject" shape="rect" coords="0,0,225,24"/>
<area href="classConicBundle_1_1SOCSupportFunction.html" title="general purpose implementation of SOCOracle as explained in implemention of a SOCOracle (SOCSupportFu..." alt="ConicBundle::SOCSupportFunction" shape="rect" coords="0,168,225,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8eb7aa14d29a61f9f92598d499eec417"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classConicBundle_1_1Minorant.html">Minorant</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1SOCOracle.html#a8eb7aa14d29a61f9f92598d499eec417">generate_minorant</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;SOCvec)=0</td></tr>
<tr class="memdesc:a8eb7aa14d29a61f9f92598d499eec417"><td class="mdescLeft">&#160;</td><td class="mdescRight">generates the minorant that arises from the given second order cone vector. The minorant must allow some primal aggregation.  <a href="#a8eb7aa14d29a61f9f92598d499eec417">More...</a><br /></td></tr>
<tr class="separator:a8eb7aa14d29a61f9f92598d499eec417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8f2a736c84369b6c2b8bd92411aae5"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1SOCOracle.html#a4a8f2a736c84369b6c2b8bd92411aae5">extract_SOCvector</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;SOCvec, const <a class="el" href="classConicBundle_1_1Minorant.html">Minorant</a> *SOCminorant)=0</td></tr>
<tr class="memdesc:a4a8f2a736c84369b6c2b8bd92411aae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">given a minorant arising from convex combinations of minorants produced by <a class="el" href="classConicBundle_1_1SOCOracle.html#a8eb7aa14d29a61f9f92598d499eec417" title="generates the minorant that arises from the given second order cone vector. The minorant must allow s...">generate_minorant()</a> it determines a <img class="formulaInl" alt="$(x_0,\bar x)$" src="form_290.png"/> generating it and returns SOCvec <img class="formulaInl" alt="$=\bar x/\|\bar x\|$" src="form_291.png"/> or some unit vector if <img class="formulaInl" alt="$\bar x=0$" src="form_289.png"/>.  <a href="#a4a8f2a736c84369b6c2b8bd92411aae5">More...</a><br /></td></tr>
<tr class="separator:a4a8f2a736c84369b6c2b8bd92411aae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3bd114b0df4b15fb6c7859fa27b530"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1SOCOracle.html#aca3bd114b0df4b15fb6c7859fa27b530">projection</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;offset, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;coeffs, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;bar_P, const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> *index_subset=0)=0</td></tr>
<tr class="memdesc:aca3bd114b0df4b15fb6c7859fa27b530"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute projected coefficient matrices  <a href="#aca3bd114b0df4b15fb6c7859fa27b530">More...</a><br /></td></tr>
<tr class="separator:aca3bd114b0df4b15fb6c7859fa27b530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae345cfad842849d5a526fa9c808b34cb"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1SOCOracle.html#ae345cfad842849d5a526fa9c808b34cb">evaluate</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;current_point, const <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> relprec, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> &amp;SOC_value, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;SOC_vector, <a class="el" href="classConicBundle_1_1SOCPrimalExtender.html">SOCPrimalExtender</a> *&amp;primal_extender)=0</td></tr>
<tr class="separator:ae345cfad842849d5a526fa9c808b34cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad478de92645bf6d1d6eef4378879412b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1SOCOracle.html#ad478de92645bf6d1d6eef4378879412b">evaluate_projection</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;current_point, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;P, const <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> relprec, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> &amp;projected_SOC_value)=0</td></tr>
<tr class="separator:ad478de92645bf6d1d6eef4378879412b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec31d03edd6a507703ba27c2203b1fa"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1SOCOracle.html#adec31d03edd6a507703ba27c2203b1fa">apply_modification</a> (const <a class="el" href="classConicBundle_1_1OracleModification.html">OracleModification</a> &amp;, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *, bool &amp;, bool &amp;, bool &amp;, <a class="el" href="classConicBundle_1_1MinorantExtender.html">MinorantExtender</a> *&amp;)</td></tr>
<tr class="memdesc:adec31d03edd6a507703ba27c2203b1fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine need not be implemented unless variables (constraints in Lagrangean relaxation) are added or deleted on the fly.  <a href="#adec31d03edd6a507703ba27c2203b1fa">More...</a><br /></td></tr>
<tr class="separator:adec31d03edd6a507703ba27c2203b1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5193bf92040d22454ed69c9145913f75"><td class="memItemLeft" align="right" valign="top"><a id="a5193bf92040d22454ed69c9145913f75"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1SOCOracle.html#a5193bf92040d22454ed69c9145913f75">check_correctness</a> () const</td></tr>
<tr class="memdesc:a5193bf92040d22454ed69c9145913f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">switch on/off some correctnes checks on the oracle <br /></td></tr>
<tr class="separator:a5193bf92040d22454ed69c9145913f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classConicBundle_1_1ModifiableOracleObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classConicBundle_1_1ModifiableOracleObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classConicBundle_1_1ModifiableOracleObject.html">ConicBundle::ModifiableOracleObject</a></td></tr>
<tr class="memitem:aabf6cf7095bdac38ab14308b6c199761 inherit pub_methods_classConicBundle_1_1ModifiableOracleObject"><td class="memItemLeft" align="right" valign="top"><a id="aabf6cf7095bdac38ab14308b6c199761"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1ModifiableOracleObject.html#aabf6cf7095bdac38ab14308b6c199761">~ModifiableOracleObject</a> ()</td></tr>
<tr class="memdesc:aabf6cf7095bdac38ab14308b6c199761 inherit pub_methods_classConicBundle_1_1ModifiableOracleObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual destructor <br /></td></tr>
<tr class="separator:aabf6cf7095bdac38ab14308b6c199761 inherit pub_methods_classConicBundle_1_1ModifiableOracleObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Oracle interface for minimization of the support function over the seoncd order cone with <img class="formulaInl" alt="$x_0=1$" src="form_269.png"/> for an affine cost function or, equivalently, Lagrangian relaxation of second order cone programs. </p>
<p>Within the setting explained in <a class="el" href="group__abstract__soc__oracle.html">abstract second order cone oracle</a> the abstract class <a class="el" href="classConicBundle_1_1SOCOracle.html" title="Oracle interface for minimization of the support function over the seoncd order cone with  for an aff...">SOCOracle</a> defines a matrix free interface to the support function and the action of the affine cost function <img class="formulaInl" alt="$c+Ay$" src="form_248.png"/> for the second order bundle cutting model implemented in <a class="el" href="classConicBundle_1_1SOCModel.html" title="implements (as a derived class of ConeModel) a cutting model for a SOCOracle ">SOCModel</a>. In particular, it provides in</p>
<ul>
<li><a class="el" href="classConicBundle_1_1SOCOracle.html#a8eb7aa14d29a61f9f92598d499eec417" title="generates the minorant that arises from the given second order cone vector. The minorant must allow s...">generate_minorant()</a> the minorant corresponding to a SOC element (with primal data for primal aggregation)</li>
<li><a class="el" href="classConicBundle_1_1SOCOracle.html#a4a8f2a736c84369b6c2b8bd92411aae5" title="given a minorant arising from convex combinations of minorants produced by generate_minorant() it det...">extract_SOCvector()</a> returns for a minorant the SOC vector that gives rise to this minorant (for this all minorants must include this primal data)</li>
<li><a class="el" href="classConicBundle_1_1SOCOracle.html#aca3bd114b0df4b15fb6c7859fa27b530" title="compute projected coefficient matrices ">projection()</a> the projection of the affine cost function data onto a subspace of <img class="formulaInl" alt="$\bar x$" src="form_131.png"/> spanned by <img class="formulaInl" alt="$P$" src="form_84.png"/></li>
<li><a class="el" href="classConicBundle_1_1SOCOracle.html#ae345cfad842849d5a526fa9c808b34cb">evaluate()</a> for given <img class="formulaInl" alt="$y$" src="form_64.png"/> the function value for the affine cost vector or a SOC vector with sufficiently high SOC_value to exceed the threshold for null steps in the bundle method</li>
<li><a class="el" href="classConicBundle_1_1SOCOracle.html#ad478de92645bf6d1d6eef4378879412b">evaluate_projection()</a> for given <img class="formulaInl" alt="$y$" src="form_64.png"/> the same as in evaluate but now for the projected affine matrix function where <img class="formulaInl" alt="$\bar x$" src="form_131.png"/> is restricted to the span of <img class="formulaInl" alt="$P$" src="form_84.png"/>.</li>
<li>and the function <a class="el" href="classConicBundle_1_1SOCOracle.html#a5193bf92040d22454ed69c9145913f75" title="switch on/off some correctnes checks on the oracle ">check_correctness()</a> with the same meaning as in <a class="el" href="classConicBundle_1_1FunctionOracle.html" title="oracle interface (abstract class). For each of your functions, provide a derived class. ">ConicBundle::FunctionOracle</a></li>
</ul>
<p>For a concrete implementation of <a class="el" href="classConicBundle_1_1SOCOracle.html" title="Oracle interface for minimization of the support function over the seoncd order cone with  for an aff...">SOCOracle</a> see ConicBundle::AffineMatrixFunction . </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="adec31d03edd6a507703ba27c2203b1fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec31d03edd6a507703ba27c2203b1fa">&#9670;&nbsp;</a></span>apply_modification()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ConicBundle::SOCOracle::apply_modification </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1OracleModification.html">OracleModification</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1MinorantExtender.html">MinorantExtender</a> *&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This routine need not be implemented unless variables (constraints in Lagrangean relaxation) are added or deleted on the fly. </p>
<p>The routine is only called by the solver if the variables indeed get modified by the solver or a modification is passed on by the user via the solver interface. <em>oracle_modification</em> is then used to either transfer user supplied instructions to the oracle on how to modify itself or to inform the oracle about changes the solver was asked to perform on the variables. If available, the solver will also show the effect of these changes on the center point in <em>new_center</em> and <em>old_center</em>; if these are not available then they hold NULL. A user supplied <em>oracle_modification</em> will be checked for consistency with the actual changes in the variables and mismatches will cause failures.</p>
<p>The remaining variables are output variables by which the oracle tells the solver which information has a chance to be preserved in view of these changes. If e.g. the deletion of some nonzero variables invalidates the function value in the new center, the oracle has to set discard_objective_in_center=true. If the entire model cannot be preserved (this includes the aggregates and the function values), the oracle needs to set discard_model=true; If only aggregate minorants cannot be preserved, the oracle needs to set discard_aggregates=true; in the current implementation of <a class="el" href="classConicBundle_1_1SOCModel.html" title="implements (as a derived class of ConeModel) a cutting model for a SOCOracle ">SOCModel</a> this removes all minorants generated by <a class="el" href="classConicBundle_1_1SOCOracle.html#a8eb7aa14d29a61f9f92598d499eec417" title="generates the minorant that arises from the given second order cone vector. The minorant must allow s...">generate_minorant()</a> because each of them is typically generated by more than one Ritz vector. Whenever new variables were added, the model can only be preserved if the remaining minorants (maybe without aggregates) can be extended for these new variables. In this case the oracle has to supply the appropriate <a class="el" href="classConicBundle_1_1MinorantExtender.html" title="Interface for extending a Minorant, e.g., in Lagrangian Relaxation of cutting plane approaches...">MinorantExtender</a> via <em>minorant_extender</em> and only those minorants will be kept for which this operation succeeds.</p>
<p>Return value 0 indicates that these actions allow to continue without errors, other return values result in an overall error on these changes. </p>

<p>Reimplemented from <a class="el" href="classConicBundle_1_1ModifiableOracleObject.html#ab4f16d78fec3a02cc064003c2b02ddce">ConicBundle::ModifiableOracleObject</a>.</p>

<p>Reimplemented in <a class="el" href="classConicBundle_1_1SOCSupportFunction.html#a53c91285ccb5dd2dfd3038ec92ef9c94">ConicBundle::SOCSupportFunction</a>.</p>

</div>
</div>
<a id="ae345cfad842849d5a526fa9c808b34cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae345cfad842849d5a526fa9c808b34cb">&#9670;&nbsp;</a></span>evaluate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ConicBundle::SOCOracle::evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>current_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a>&#160;</td>
          <td class="paramname"><em>relprec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> &amp;&#160;</td>
          <td class="paramname"><em>SOC_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>SOC_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1SOCPrimalExtender.html">SOCPrimalExtender</a> *&amp;&#160;</td>
          <td class="paramname"><em>primal_extender</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>computes <img class="formulaInl" alt="$\max\{{1 \choose \bar x}^\top(c+Ay)\colon 1\ge\|\bar x\|\}$" src="form_295.png"/> and returns the value and a maximizing vector <img class="formulaInl" alt="${1 \choose \bar x}$" src="form_296.png"/>. </p><dl class="section return"><dt>Returns</dt><dd>0 on success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_point</td><td>argument = current variables = position where to evaluate the function </td></tr>
    <tr><td class="paramname">relprec</td><td>The columns of the matrix are orthonormal bundle vectors and may help to construct good startig vectors for the eigenvalue computation by iterative methods but have no other use. bundlevecs may have dimension 0. </td></tr>
    <tr><td class="paramname">SOC_value</td><td>on input: gives the threshold for a null step; a vector is good enough to yield sufficient improvement if its value exceeds this SOC_value.</td></tr>
  </table>
  </dd>
</dl>
<p>on output: the value obtained for the returned SOC_vector; if it is smaller than the input SOC_value, then ist must be guaranteed to lie within relprec*(max(abs(SOC_value),1.)) of the true optimum </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">SOC_vector</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SOC_vector</td><td>return a maximizing vector <img class="formulaInl" alt="${1\choose \bar x}$" src="form_297.png"/> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">primal_extender</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">primal_extender</td><td>(PrimalExtender*&amp;) if primal_data or vectors provided in (minonrants of) previous calls now have to be updated due to changes in the primal problem &ndash; e.g., this may happen in column generation &ndash; one may return a pointer to a <a class="el" href="classConicBundle_1_1SOCPrimalExtender.html" title="Interface for extending PrimalData, e.g., in Lagrangian relaxation of column generation approaches...">SOCPrimalExtender</a> object on the heap. This object will be used by <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> to update all its internally stored vectors and primal_data objects in its minorants by calling <a class="el" href="classConicBundle_1_1PrimalExtender.html#a13fc586276e23d575b935dbfe12495c0" title="called by ConicBundle to update internal PrimalData objects, has to return 0 on success ...">PrimalExtender::extend</a> on each of these. Afterwards <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> deletes primal_extender. If this is not needed, set the variable to NULL. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classConicBundle_1_1SOCSupportFunction.html#ac790296e862bfae5cdcce0d33859782f">ConicBundle::SOCSupportFunction</a>.</p>

</div>
</div>
<a id="ad478de92645bf6d1d6eef4378879412b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad478de92645bf6d1d6eef4378879412b">&#9670;&nbsp;</a></span>evaluate_projection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ConicBundle::SOCOracle::evaluate_projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>current_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a>&#160;</td>
          <td class="paramname"><em>relprec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> &amp;&#160;</td>
          <td class="paramname"><em>projected_SOC_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>compute SOC maximum for the restricted <img class="formulaInl" alt="$\bar x$" src="form_131.png"/> subspace spanned by P </p><dl class="section return"><dt>Returns</dt><dd>0 on success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_point</td><td>argument = current variable values = position where to evaluate the function </td></tr>
    <tr><td class="paramname">P</td><td>orthogonal matrix defining the projection; </td></tr>
    <tr><td class="paramname">relprec</td><td>relative precision requirement </td></tr>
    <tr><td class="paramname">projected_SOC_value</td><td>output: ortho </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classConicBundle_1_1SOCSupportFunction.html#ada34b797da6f5e328322cf9c0ffd9029">ConicBundle::SOCSupportFunction</a>.</p>

</div>
</div>
<a id="a4a8f2a736c84369b6c2b8bd92411aae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8f2a736c84369b6c2b8bd92411aae5">&#9670;&nbsp;</a></span>extract_SOCvector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ConicBundle::SOCOracle::extract_SOCvector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>SOCvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1Minorant.html">Minorant</a> *&#160;</td>
          <td class="paramname"><em>SOCminorant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>given a minorant arising from convex combinations of minorants produced by <a class="el" href="classConicBundle_1_1SOCOracle.html#a8eb7aa14d29a61f9f92598d499eec417" title="generates the minorant that arises from the given second order cone vector. The minorant must allow s...">generate_minorant()</a> it determines a <img class="formulaInl" alt="$(x_0,\bar x)$" src="form_290.png"/> generating it and returns SOCvec <img class="formulaInl" alt="$=\bar x/\|\bar x\|$" src="form_291.png"/> or some unit vector if <img class="formulaInl" alt="$\bar x=0$" src="form_289.png"/>. </p>
<p>This routine is needed when returning from a polyhedral model used by a <a class="el" href="classConicBundle_1_1SumBundleHandler.html" title="routines for updating and handling SumBundle components, possibly by cooperating over several recursi...">SumBundleHandler</a> in order to reconstruct an aggregate direction for the conic model. Note that generate_minorant has to provide suitable primal information for this, so that the convex combinations of the minorants allow this reconstruction. </p>

<p>Implemented in <a class="el" href="classConicBundle_1_1SOCSupportFunction.html#a40b2fbd46ba43d6acdf23fd01bd25980">ConicBundle::SOCSupportFunction</a>.</p>

</div>
</div>
<a id="a8eb7aa14d29a61f9f92598d499eec417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb7aa14d29a61f9f92598d499eec417">&#9670;&nbsp;</a></span>generate_minorant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classConicBundle_1_1Minorant.html">Minorant</a>* ConicBundle::SOCOracle::generate_minorant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>SOCvec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>generates the minorant that arises from the given second order cone vector. The minorant must allow some primal aggregation. </p>
<p>The returned minorant must satisfy offset_gives_value_at_origin()==true. The minorant is passed over to the caller and will be deleted there. From a convex combination of such minorants the routine extract_SOCvec() must be able to reproduce a suitable SOCvec, see there. </p>

<p>Implemented in <a class="el" href="classConicBundle_1_1SOCSupportFunction.html#ada68a42f3f5880c96c5da1f15d322a9c">ConicBundle::SOCSupportFunction</a>.</p>

</div>
</div>
<a id="aca3bd114b0df4b15fb6c7859fa27b530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3bd114b0df4b15fb6c7859fa27b530">&#9670;&nbsp;</a></span>projection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ConicBundle::SOCOracle::projection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>bar_P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> *&#160;</td>
          <td class="paramname"><em>index_subset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute projected coefficient matrices </p>
<p>The projection matrix is <img class="formulaInl" alt="$P=\left[\begin{array}{cc}1 &amp; 0 \\ 0 &amp; \bar P \end{array}\right]$" src="form_292.png"/>. offset <img class="formulaInl" alt="$=c^\top P$" src="form_293.png"/> always has to be computed. If index_subset==0, row i of coeffs is filled with row i of <img class="formulaInl" alt="$A^\top P$" src="form_294.png"/> for i=1,dots,m If index_subset!=0, row i of coeffs holds the row (*index_subset)(i) </p>

<p>Implemented in <a class="el" href="classConicBundle_1_1SOCSupportFunction.html#a6b90bd0170ff0f49c1b3f67e80041fa1">ConicBundle::SOCSupportFunction</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="SOCOracle_8hxx_source.html">SOCOracle.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
