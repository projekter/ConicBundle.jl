<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ConicBundle: Internal QP Solver for linearly constrained groundsets</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ConicBundle
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Internal QP Solver for linearly constrained groundsets</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1QPSolver.html">ConicBundle::QPSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classConicBundle_1_1QPSolver.html" title="QPSolver is the access point for ConicBundle to the internal constrained QP Solver, see Internal QP Solver for linearly constrained groundsets. ">QPSolver</a> is the access point for <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> to the internal constrained QP Solver, see <a class="el" href="group__ConstrainedQPSolver.html">Internal QP Solver for linearly constrained groundsets</a>.  <a href="classConicBundle_1_1QPSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1QPSolverBasicInterface.html">ConicBundle::QPSolverBasicInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the abstract interface for <a class="el" href="classConicBundle_1_1QPSolverBasicStructures.html" title="provides the basic variables and implements basic routines for the primal dual interior point solver ...">QPSolverBasicStructures</a> that the basic routines there need to access the cost and constraint data; it also defines the interface to <a class="el" href="classConicBundle_1_1QPSolverBasicStructures.html" title="provides the basic variables and implements basic routines for the primal dual interior point solver ...">QPSolverBasicStructures</a>, how to call those routines and how to retrieve the results.  <a href="classConicBundle_1_1QPSolverBasicInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1QPSolverParameters.html">ConicBundle::QPSolverParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">parameters for steering the termination criteria and solution method of the solver  <a href="classConicBundle_1_1QPSolverParameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1QPKKTSolverObject.html">ConicBundle::QPKKTSolverObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract class for setting up and solving the primal dual KKT System within <a class="el" href="classConicBundle_1_1QPSolverBasicStructures.html" title="provides the basic variables and implements basic routines for the primal dual interior point solver ...">QPSolverBasicStructures</a>  <a href="classConicBundle_1_1QPKKTSolverObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1QPDirectKKTSolver.html">ConicBundle::QPDirectKKTSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implements a direct KKT Solver variant of <a class="el" href="classConicBundle_1_1QPKKTSolverObject.html" title="abstract class for setting up and solving the primal dual KKT System within QPSolverBasicStructures ...">QPKKTSolverObject</a>  <a href="classConicBundle_1_1QPDirectKKTSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1QPKKT__SolverStats.html">ConicBundle::QPKKT_SolverStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for collecting statics in <a class="el" href="classConicBundle_1_1QPKKTSolverComparison.html" title="This is a pseudosolver designed for producing comparative statistics on the performance of mainly ite...">QPKKTSolverComparison</a>: For each bundle subproblem there is a block <a class="el" href="classConicBundle_1_1QPKKT__ProbStats.html" title="Used for collecting statics in QPKKTSolverComparison: For each bundle subproblem there is a block QPK...">QPKKT_ProbStats</a>, which holds for each KKT system a block of <a class="el" href="classConicBundle_1_1QPKKT__KKTStats.html" title="Used for collecting statics in QPKKTSolverComparison: For each bundle subproblem there is a block QPK...">QPKKT_KKTStats</a>, which holds for each solver a block <a class="el" href="classConicBundle_1_1QPKKT__SolverStats.html" title="Used for collecting statics in QPKKTSolverComparison: For each bundle subproblem there is a block QPK...">QPKKT_SolverStats</a> (this).  <a href="classConicBundle_1_1QPKKT__SolverStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1QPKKT__KKTStats.html">ConicBundle::QPKKT_KKTStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for collecting statics in <a class="el" href="classConicBundle_1_1QPKKTSolverComparison.html" title="This is a pseudosolver designed for producing comparative statistics on the performance of mainly ite...">QPKKTSolverComparison</a>: For each bundle subproblem there is a block <a class="el" href="classConicBundle_1_1QPKKT__ProbStats.html" title="Used for collecting statics in QPKKTSolverComparison: For each bundle subproblem there is a block QPK...">QPKKT_ProbStats</a>, which holds for each KKT system a block of <a class="el" href="classConicBundle_1_1QPKKT__KKTStats.html" title="Used for collecting statics in QPKKTSolverComparison: For each bundle subproblem there is a block QPK...">QPKKT_KKTStats</a> (this), which holds for each solver a block <a class="el" href="classConicBundle_1_1QPKKT__SolverStats.html" title="Used for collecting statics in QPKKTSolverComparison: For each bundle subproblem there is a block QPK...">QPKKT_SolverStats</a>.  <a href="classConicBundle_1_1QPKKT__KKTStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1QPKKT__ProbStats.html">ConicBundle::QPKKT_ProbStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for collecting statics in <a class="el" href="classConicBundle_1_1QPKKTSolverComparison.html" title="This is a pseudosolver designed for producing comparative statistics on the performance of mainly ite...">QPKKTSolverComparison</a>: For each bundle subproblem there is a block <a class="el" href="classConicBundle_1_1QPKKT__ProbStats.html" title="Used for collecting statics in QPKKTSolverComparison: For each bundle subproblem there is a block QPK...">QPKKT_ProbStats</a> (this), which holds for each KKT system a block of <a class="el" href="classConicBundle_1_1QPKKT__KKTStats.html" title="Used for collecting statics in QPKKTSolverComparison: For each bundle subproblem there is a block QPK...">QPKKT_KKTStats</a>, which holds for each solver a block <a class="el" href="classConicBundle_1_1QPKKT__SolverStats.html" title="Used for collecting statics in QPKKTSolverComparison: For each bundle subproblem there is a block QPK...">QPKKT_SolverStats</a>.  <a href="classConicBundle_1_1QPKKT__ProbStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1QPKKTSolverComparison.html">ConicBundle::QPKKTSolverComparison</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a pseudosolver designed for producing comparative statistics on the performance of mainly iterative solvers for the interior point KKT systems of <a class="el" href="classConicBundle_1_1QPSolver.html" title="QPSolver is the access point for ConicBundle to the internal constrained QP Solver, see Internal QP Solver for linearly constrained groundsets. ">QPSolver</a>.  <a href="classConicBundle_1_1QPKKTSolverComparison.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1QPIterativeKKTSolver.html">ConicBundle::QPIterativeKKTSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterative solver for the full symmetric, in general indefinite primal dual KKT System within <a class="el" href="classConicBundle_1_1QPSolverBasicStructures.html" title="provides the basic variables and implements basic routines for the primal dual interior point solver ...">QPSolverBasicStructures</a>.  <a href="classConicBundle_1_1QPIterativeKKTSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1QPIterativeKKTHASolver.html">ConicBundle::QPIterativeKKTHASolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterative solver for the reduced symmetric, in general indefinite primal dual KKT System within <a class="el" href="classConicBundle_1_1QPSolverBasicStructures.html" title="provides the basic variables and implements basic routines for the primal dual interior point solver ...">QPSolverBasicStructures</a>, where only H and A blocks remain, B and C are removed by Schur complements. If there is no A, PCG may used.  <a href="classConicBundle_1_1QPIterativeKKTHASolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1QPIterativeKKTHAeqSolver.html">ConicBundle::QPIterativeKKTHAeqSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterative solver for the reduced symmetric, in general indefinite primal dual KKT System within <a class="el" href="classConicBundle_1_1QPSolverBasicStructures.html" title="provides the basic variables and implements basic routines for the primal dual interior point solver ...">QPSolverBasicStructures</a>, where only the block H and the equality rows of A remain, the inequalities of A as well as B and C are removed by Schur complements. If there are no equalities in A, PCG may used, but MinRes seems to be more stable.  <a href="classConicBundle_1_1QPIterativeKKTHAeqSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1QPKKTPrecondObject.html">ConicBundle::QPKKTPrecondObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract Interface for preconditioners to be used with a <a class="el" href="classConicBundle_1_1QPIterativeKKTSolver.html" title="Iterative solver for the full symmetric, in general indefinite primal dual KKT System within QPSolver...">QPIterativeKKTSolver</a> and a <a class="el" href="classCH__Matrix__Classes_1_1IterativeSolverObject.html" title="Abstract interface to iterative methods for solving Ax=b given by an IterativeSystemObject. ">CH_Matrix_Classes::IterativeSolverObject</a>, see <a class="el" href="group__IterativeSolverInterfaces.html">Interfaces and Classes for Iterative Solvers like PCG, MINRES and PSQMR</a>. It will depend on the system setup and the solver method which preconditioning routines are called and what requirements the preconditioners have to fulfill. Feasible combinations lie in the responsibility of the caller and are not checked for correctness.  <a href="classConicBundle_1_1QPKKTPrecondObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1QPKKTSubspaceHPrecond.html">ConicBundle::QPKKTSubspaceHPrecond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subspace projection preconditioner for the H-block of the KKT-System assuming that B and C have been Schur complemented into the H-block. For the A-Block, if it is there, the identity is used. If there is no A-block, PCG may be used.  <a href="classConicBundle_1_1QPKKTSubspaceHPrecond.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1QPModelBlockObject.html">ConicBundle::QPModelBlockObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract interface for model blocks in the constrained <a class="el" href="classConicBundle_1_1QPSolver.html" title="QPSolver is the access point for ConicBundle to the internal constrained QP Solver, see Internal QP Solver for linearly constrained groundsets. ">QPSolver</a>  <a href="classConicBundle_1_1QPModelBlockObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1QPModelBlock.html">ConicBundle::QPModelBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">combines and provides basic functionalities of <a class="el" href="classConicBundle_1_1QPModelDataObject.html" title="abstract interface declaring the uniform outer appearance of general cutting models produced by the v...">QPModelDataObject</a> and <a class="el" href="classConicBundle_1_1QPModelBlockObject.html" title="abstract interface for model blocks in the constrained QPSolver ">QPModelBlockObject</a>, but is still abstract  <a href="classConicBundle_1_1QPModelBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1QPSumModelBlock.html">ConicBundle::QPSumModelBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implements a (virtual) cutting model being built of a (possibly recursive) sum of <a class="el" href="classConicBundle_1_1QPModelBlock.html" title="combines and provides basic functionalities of QPModelDataObject and QPModelBlockObject, but is still abstract ">QPModelBlock</a> cutting model instances for <a class="el" href="classConicBundle_1_1QPSolver.html" title="QPSolver is the access point for ConicBundle to the internal constrained QP Solver, see Internal QP Solver for linearly constrained groundsets. ">QPSolver</a>  <a href="classConicBundle_1_1QPSumModelBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1QPConeModelBlock.html">ConicBundle::QPConeModelBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implements a <a class="el" href="classConicBundle_1_1QPModelBlock.html" title="combines and provides basic functionalities of QPModelDataObject and QPModelBlockObject, but is still abstract ">QPModelBlock</a> for conic cutting models in <a class="el" href="classConicBundle_1_1QPSolver.html" title="QPSolver is the access point for ConicBundle to the internal constrained QP Solver, see Internal QP Solver for linearly constrained groundsets. ">QPSolver</a>  <a href="classConicBundle_1_1QPConeModelBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1InteriorPointBlock.html">ConicBundle::InteriorPointBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract interface for interior point vector/matrix variables and routines specific to primal dual complementarity conditions of symmetric cones  <a href="classConicBundle_1_1InteriorPointBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1NNCIPBlock.html">ConicBundle::NNCIPBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface for the interior point variable vector and routines specific to the primal dual complementarity conditions of the nonnegative cone  <a href="classConicBundle_1_1NNCIPBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1SOCIPBlock.html">ConicBundle::SOCIPBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface for interior point variable and routines specific to primal dual complementarity conditions of a second order cone  <a href="classConicBundle_1_1SOCIPBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1InteriorPointBundleBlock.html">ConicBundle::InteriorPointBundleBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract interface for interior point routines specific to primal dual complementarity conditions of a symmetric cone with special routines for handling the bundle and the trace constraint  <a href="classConicBundle_1_1InteriorPointBundleBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1NNCIPBundleBlock.html">ConicBundle::NNCIPBundleBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interior point variables and routines specific to primal dual complementarity conditions of a nonnegative cone with special routines for handling the bundle and the trace constraint  <a href="classConicBundle_1_1NNCIPBundleBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1SOCIPBundleBlock.html">ConicBundle::SOCIPBundleBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interior point variables and routines specific to primal dual complementarity conditions of a second order cone with special routines for handling the bundle and the trace constraint  <a href="classConicBundle_1_1SOCIPBundleBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1QPPSCOracleDataObject.html">ConicBundle::QPPSCOracleDataObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines an interface for passing on oracle information to <a class="el" href="classConicBundle_1_1PSCIPBundleBlock.html" title="interior point variables and routines specific to the primal dual complementarity conditions of a pos...">PSCIPBundleBlock</a>  <a href="classConicBundle_1_1QPPSCOracleDataObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>If the groundset (see e.g. <a class="el" href="classConicBundle_1_1LPGroundset.html" title="represents a polyhedral feasible ground set by affine constraints as in Linear Programming with speci...">LPGroundset</a>) of the convex optimization problem involves box constraints with a general quadratic proximal term (i.e. not just a diagonal) or general linear constraints even with diagonal proximal term, a constrained QP solver is required to determine the next candidate as the solution of the bundle subproblem. Because <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> is designed to handle also nonpolyhedral cutting models arising from support functions over the second order cone and positive semidefinite cone the general solver is an intererior point method. More precisely, it implements a primal dual predictor corrector method.</p>
<p>The main visible object is <a class="el" href="classConicBundle_1_1QPSolver.html" title="QPSolver is the access point for ConicBundle to the internal constrained QP Solver, see Internal QP Solver for linearly constrained groundsets. ">QPSolver</a>. This mainly serves as an interface for <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> as it implements a <a class="el" href="classConicBundle_1_1QPSolverObject.html" title="abstract interface for a QPSolver ">QPSolverObject</a> (for finding the next candidate via solving the quadratic bundle subproblem) and a QPDataPointer (for collection the cutting model information). The internal solver routines are mostly defined in <a class="el" href="classConicBundle_1_1QPSolverBasicStructures.html" title="provides the basic variables and implements basic routines for the primal dual interior point solver ...">QPSolverBasicStructures</a>. The basic structures serve to describe all parts in connection with the linearly constraint groundset and the general iterative procedure of when to collect which data, when to solver the primal dual KKT-system and when to perform line searches. The central part of setting up and solving the primal dual KKT-system is supplied externally via the <a class="el" href="classConicBundle_1_1QPSolverParameters.html" title="parameters for steering the termination criteria and solution method of the solver ...">QPSolverParameters</a>, which must specify a <a class="el" href="classConicBundle_1_1QPKKTSolverObject.html" title="abstract class for setting up and solving the primal dual KKT System within QPSolverBasicStructures ...">QPKKTSolverObject</a>. Currently the following options exist for such an <a class="el" href="classConicBundle_1_1QPKKTSolverObject.html" title="abstract class for setting up and solving the primal dual KKT System within QPSolverBasicStructures ...">QPKKTSolverObject</a>:</p>
<ul>
<li><a class="el" href="classConicBundle_1_1QPDirectKKTSolver.html" title="implements a direct KKT Solver variant of QPKKTSolverObject ">QPDirectKKTSolver</a> : by a Schur complement the quadratic term is computed into the lines of the linear constraints and the constraints describing the models. This system is then solved either with an aditional Schur complement by Cholesky or directly in indefinite form by Aasen's method.</li>
<li><a class="el" href="classConicBundle_1_1QPIterativeKKTSolver.html" title="Iterative solver for the full symmetric, in general indefinite primal dual KKT System within QPSolver...">QPIterativeKKTSolver</a> : It mainly offers a general interface for iterative methods, but also provides the matrix times vector multiplication for the entire KKT-System. This iterative solver class always just provides the matrix vector product for a special variant of the KKT-System in the style of a <a class="el" href="classCH__Matrix__Classes_1_1IterativeSystemObject.html" title="Abstract base class for supplying the system for an iterative solver. ">CH_Matrix_Classes::IterativeSystemObject</a>, the actual iterative solver with a suitable preconditioner must always be specified during construction by passing a <a class="el" href="classCH__Matrix__Classes_1_1IterativeSolverObject.html" title="Abstract interface to iterative methods for solving Ax=b given by an IterativeSystemObject. ">CH_Matrix_Classes::IterativeSolverObject</a> and possibly a <a class="el" href="classConicBundle_1_1QPKKTPrecondObject.html" title="Abstract Interface for preconditioners to be used with a QPIterativeKKTSolver and a CH_Matrix_Classes...">QPKKTPrecondObject</a> that fits the iterative solver and the system variant. So far no specific preconditioner is implemented for this system configuration, but <a class="el" href="classCH__Matrix__Classes_1_1Psqmr.html" title="PSQMR method for solving Ax=b with symmetric matrix A and symmetric preconditioner M=M1*M2 (M1 and M2...">CH_Matrix_Classes::Psqmr</a> and <a class="el" href="classCH__Matrix__Classes_1_1MinRes.html" title="MinRes method for solving Ax=b with symmetric (indefinite) matrix A and positive definite preconditio...">CH_Matrix_Classes::MinRes</a> are possible iterative solver options.</li>
<li><a class="el" href="classConicBundle_1_1QPIterativeKKTHASolver.html" title="Iterative solver for the reduced symmetric, in general indefinite primal dual KKT System within QPSol...">QPIterativeKKTHASolver</a> : is dervied from <a class="el" href="classConicBundle_1_1QPIterativeKKTSolver.html" title="Iterative solver for the full symmetric, in general indefinite primal dual KKT System within QPSolver...">QPIterativeKKTSolver</a> and differs in that in the KKT-system the model block is Schur complemented into the lines of the prox-termin (the H block), but the linear constraints of the ground set (the A block) is left untouched. So the KKT-System is reduced to the H and A blocks and the class implements the matrix vector product for this system variant. A preconditioning class for this setting is provided in <a class="el" href="classConicBundle_1_1QPKKTSubspaceHPrecond.html" title="Subspace projection preconditioner for the H-block of the KKT-System assuming that B and C have been ...">QPKKTSubspaceHPrecond</a>, which provides various options for obtaining a preconditioner for the H-block (and so far only for the H-block) via subspace projection and low rank inversion. If the linear constraint block A is friendly, this works fine with the iterative solvers <a class="el" href="classCH__Matrix__Classes_1_1MinRes.html" title="MinRes method for solving Ax=b with symmetric (indefinite) matrix A and positive definite preconditio...">CH_Matrix_Classes::MinRes</a> <a class="el" href="classCH__Matrix__Classes_1_1Psqmr.html" title="PSQMR method for solving Ax=b with symmetric matrix A and symmetric preconditioner M=M1*M2 (M1 and M2...">CH_Matrix_Classes::Psqmr</a>. If there is no A at all (but maybe box constraints), the best method is likely <a class="el" href="classCH__Matrix__Classes_1_1PCG.html" title="Preconditioned Conjugate Gradient method for solving Ax=b with (symmetric) positive definite matrix A...">CH_Matrix_Classes::PCG</a>.</li>
<li><a class="el" href="classConicBundle_1_1QPIterativeKKTHAeqSolver.html" title="Iterative solver for the reduced symmetric, in general indefinite primal dual KKT System within QPSol...">QPIterativeKKTHAeqSolver</a> : is dervied from <a class="el" href="classConicBundle_1_1QPIterativeKKTSolver.html" title="Iterative solver for the full symmetric, in general indefinite primal dual KKT System within QPSolver...">QPIterativeKKTSolver</a> and differs to <a class="el" href="classConicBundle_1_1QPIterativeKKTHASolver.html" title="Iterative solver for the reduced symmetric, in general indefinite primal dual KKT System within QPSol...">QPIterativeKKTHASolver</a> in that in the KKT-system also the inequality constraints of the A block are Schur complemented into the H block. Thus, in the presence of equality constraints the iterative solvers <a class="el" href="classCH__Matrix__Classes_1_1MinRes.html" title="MinRes method for solving Ax=b with symmetric (indefinite) matrix A and positive definite preconditio...">CH_Matrix_Classes::MinRes</a> is needed, if there are inequality constraints in A only then <a class="el" href="classCH__Matrix__Classes_1_1PCG.html" title="Preconditioned Conjugate Gradient method for solving Ax=b with (symmetric) positive definite matrix A...">CH_Matrix_Classes::PCG</a> can also be used. The combination with MinRes seems to be a bit more stable and together with preconditioner 31 of <a class="el" href="classConicBundle_1_1QPKKTSubspaceHPrecond.html" title="Subspace projection preconditioner for the H-block of the KKT-System assuming that B and C have been ...">QPKKTSubspaceHPrecond</a> this is currently the recommended combination for the iterative case.</li>
</ul>
<p>The cutting models are realized by two implemtented classes derived from <a class="el" href="classConicBundle_1_1QPModelBlock.html" title="combines and provides basic functionalities of QPModelDataObject and QPModelBlockObject, but is still abstract ">QPModelBlock</a> which brings together the abstract classes <a class="el" href="classConicBundle_1_1QPModelDataObject.html" title="abstract interface declaring the uniform outer appearance of general cutting models produced by the v...">QPModelDataObject</a> (interface for the cutting modles of <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a>) and <a class="el" href="classConicBundle_1_1QPModelBlockObject.html" title="abstract interface for model blocks in the constrained QPSolver ">QPModelBlockObject</a> (interface for <a class="el" href="classConicBundle_1_1QPSolverBasicInterface.html" title="defines the abstract interface for QPSolverBasicStructures that the basic routines there need to acce...">QPSolverBasicInterface</a> and the <a class="el" href="classConicBundle_1_1QPKKTSolverObject.html" title="abstract class for setting up and solving the primal dual KKT System within QPSolverBasicStructures ...">QPKKTSolverObject</a>)</p>
<ul>
<li><a class="el" href="classConicBundle_1_1QPConeModelBlock.html" title="implements a QPModelBlock for conic cutting models in QPSolver ">QPConeModelBlock</a> : it allows to describe any of the cutting models employed by the classes <a class="el" href="classConicBundle_1_1NNCModel.html" title="implements (as a derived class of SumBlockModel) a standard cutting plane model for a MatrixFunctionO...">NNCModel</a>, <a class="el" href="classConicBundle_1_1SOCModel.html" title="implements (as a derived class of ConeModel) a cutting model for a SOCOracle ">SOCModel</a>, <a class="el" href="classConicBundle_1_1PSCModel.html" title="implements (as a derived class of ConeModel) a cutting model for a PSCOracle ">PSCModel</a>, <a class="el" href="classConicBundle_1_1BoxModel.html" title="implements (as a derived class of ConeModel) a standard cutting plane model for a MatrixBoxOracle ...">BoxModel</a> by tying together the following implementations of the abstract class <a class="el" href="classConicBundle_1_1InteriorPointBundleBlock.html" title="abstract interface for interior point routines specific to primal dual complementarity conditions of ...">InteriorPointBundleBlock</a> <a class="el" href="classConicBundle_1_1NNCIPBundleBlock.html" title="interior point variables and routines specific to primal dual complementarity conditions of a nonnega...">NNCIPBundleBlock</a> (building on <a class="el" href="classConicBundle_1_1NNCIPBlock.html" title="interface for the interior point variable vector and routines specific to the primal dual complementa...">NNCIPBlock</a> for a nonnegative cone) <a class="el" href="classConicBundle_1_1SOCIPBundleBlock.html" title="interior point variables and routines specific to primal dual complementarity conditions of a second ...">SOCIPBundleBlock</a> (building on <a class="el" href="classConicBundle_1_1SOCIPBlock.html" title="interface for interior point variable and routines specific to primal dual complementarity conditions...">SOCIPBlock</a> for a second order cone) <a class="el" href="classConicBundle_1_1PSCIPBundleBlock.html" title="interior point variables and routines specific to the primal dual complementarity conditions of a pos...">PSCIPBundleBlock</a> (building on <a class="el" href="classConicBundle_1_1PSCIPBlock.html" title="interface for interior point variable and routines specific to primal dual complementarity conditions...">PSCIPBlock</a> for a positive semidefnite cone) <a class="el" href="classConicBundle_1_1BoxIPBundleBlock.html" title="QPBundleBlock interface for the interior point routines specific to the primal dual complementarity c...">BoxIPBundleBlock</a> (building also on <a class="el" href="classConicBundle_1_1NNCIPBlock.html" title="interface for the interior point variable vector and routines specific to the primal dual complementa...">NNCIPBlock</a> for the bounds)</li>
<li><a class="el" href="classConicBundle_1_1QPSumModelBlock.html" title="implements a (virtual) cutting model being built of a (possibly recursive) sum of QPModelBlock cuttin...">QPSumModelBlock</a> : it forms the sum of several <a class="el" href="classConicBundle_1_1QPModelBlock.html" title="combines and provides basic functionalities of QPModelDataObject and QPModelBlockObject, but is still abstract ">QPModelBlock</a> instances as required in <a class="el" href="classConicBundle_1_1SumModel.html" title="gives a SumBlockModel interface to a sum of (possibly AffineFunctionTransformation transformed) SumBl...">SumModel</a> </li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
