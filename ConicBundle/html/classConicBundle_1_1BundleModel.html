<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ConicBundle: ConicBundle::BundleModel Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ConicBundle
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceConicBundle.html">ConicBundle</a></li><li class="navelem"><a class="el" href="classConicBundle_1_1BundleModel.html">BundleModel</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classConicBundle_1_1BundleModel-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ConicBundle::BundleModel Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__InternalBundleModel.html">Classes for General and Specialized Cutting Models for Various Objective Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>abstract interface for <a class="el" href="classConicBundle_1_1BundleSolver.html" title="This is the internal bundle solver managing descent/null steps with inner updates for approximating t...">BundleSolver</a> giving access to all objective function specific bundle routines and model descriptions. In particular it hides the cutting model and the oracle.  
 <a href="classConicBundle_1_1BundleModel.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BundleModel_8hxx_source.html">BundleModel.hxx</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ConicBundle::BundleModel:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classConicBundle_1_1BundleModel.png" usemap="#ConicBundle::BundleModel_map" alt=""/>
  <map id="ConicBundle::BundleModel_map" name="ConicBundle::BundleModel_map">
<area href="classConicBundle_1_1VariableMetricModel.html" title="declares the interface that a BundelModel needs to provide for contributing to VariableMetric informa..." alt="ConicBundle::VariableMetricModel" shape="rect" coords="328,56,537,80"/>
<area href="classConicBundle_1_1CBout.html" title="base class for uniform use of WARNINGS and ERRORS (at some point in time) " alt="ConicBundle::CBout" shape="rect" coords="328,0,537,24"/>
<area href="classConicBundle_1_1SumBlockModel.html" title="abstract interface extending BundleModel so that any such model can be used alone or within SumModel ..." alt="ConicBundle::SumBlockModel" shape="rect" coords="328,168,537,192"/>
<area href="classConicBundle_1_1AFTModel.html" title="mimicks the model of a function with an AffineFunctionTransformation (AFT) applied to it..." alt="ConicBundle::AFTModel" shape="rect" coords="0,224,209,248"/>
<area href="classConicBundle_1_1ConeModel.html" title="provides a general abstract base class for conic cutting models with SumBundle capabilities (as a der..." alt="ConicBundle::ConeModel" shape="rect" coords="328,224,537,248"/>
<area href="classConicBundle_1_1SumModel.html" title="gives a SumBlockModel interface to a sum of (possibly AffineFunctionTransformation transformed) SumBl..." alt="ConicBundle::SumModel" shape="rect" coords="547,224,756,248"/>
<area href="classConicBundle_1_1BoxModel.html" title="implements (as a derived class of ConeModel) a standard cutting plane model for a MatrixBoxOracle ..." alt="ConicBundle::BoxModel" shape="rect" coords="0,280,209,304"/>
<area href="classConicBundle_1_1NNCModel.html" title="implements (as a derived class of SumBlockModel) a standard cutting plane model for a MatrixFunctionO..." alt="ConicBundle::NNCModel" shape="rect" coords="219,280,428,304"/>
<area href="classConicBundle_1_1PSCModel.html" title="implements (as a derived class of ConeModel) a cutting model for a PSCOracle " alt="ConicBundle::PSCModel" shape="rect" coords="438,280,647,304"/>
<area href="classConicBundle_1_1SOCModel.html" title="implements (as a derived class of ConeModel) a cutting model for a SOCOracle " alt="ConicBundle::SOCModel" shape="rect" coords="657,280,866,304"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a98559877353ac9b777b536a2e7ef4146"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1BundleModel.html#a98559877353ac9b777b536a2e7ef4146">ModelUpdate</a> { <a class="el" href="classConicBundle_1_1BundleModel.html#a98559877353ac9b777b536a2e7ef4146a35b1e4a3701e97a071ad7479114a28d4">new_subgradient</a>, 
<a class="el" href="classConicBundle_1_1BundleModel.html#a98559877353ac9b777b536a2e7ef4146a0c87f0b9bc86673635f6f491e2413df8">descent_step</a>, 
<a class="el" href="classConicBundle_1_1BundleModel.html#a98559877353ac9b777b536a2e7ef4146aa9feada80d27c677ad3b9734eafa36be">null_step</a>
 }<tr class="memdesc:a98559877353ac9b777b536a2e7ef4146"><td class="mdescLeft">&#160;</td><td class="mdescRight">for informing <a class="el" href="classConicBundle_1_1BundleModel.html#a95125c655bbbe00c590618d739d5e59a" title="generate the next cutting model and store the center information in the case of a descent step ...">update_model()</a> at what stage it is called to update the bundle so that the amount of information available is clear  <a href="classConicBundle_1_1BundleModel.html#a98559877353ac9b777b536a2e7ef4146">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a98559877353ac9b777b536a2e7ef4146"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abe029a9087f4912e9d35a9eff7448b58"><td class="memItemLeft" align="right" valign="top"><a id="abe029a9087f4912e9d35a9eff7448b58"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1BundleModel.html#abe029a9087f4912e9d35a9eff7448b58">BundleModel</a> (<a class="el" href="classConicBundle_1_1CBout.html">CBout</a> *cb=0, int cbinc=-1)</td></tr>
<tr class="memdesc:abe029a9087f4912e9d35a9eff7448b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor (cb allows to set output options) <br /></td></tr>
<tr class="separator:abe029a9087f4912e9d35a9eff7448b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a2297ebf702697217065a5a28d7fb3"><td class="memItemLeft" align="right" valign="top"><a id="af9a2297ebf702697217065a5a28d7fb3"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1BundleModel.html#af9a2297ebf702697217065a5a28d7fb3">~BundleModel</a> ()</td></tr>
<tr class="memdesc:af9a2297ebf702697217065a5a28d7fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual destructor <br /></td></tr>
<tr class="separator:af9a2297ebf702697217065a5a28d7fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b51cd1178e391e38b8eebc091c4e11a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1BundleModel.html#a2b51cd1178e391e38b8eebc091c4e11a">eval_function</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> &amp;ub_fid, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> &amp;ub, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> y_id, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;y, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> nullstep_bound, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> relprec)=0</td></tr>
<tr class="memdesc:a2b51cd1178e391e38b8eebc091c4e11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluates the objective function in <em>y</em> and returns an upper bound in <em>ub</em> within relative precision <em>relprec</em>.  <a href="#a2b51cd1178e391e38b8eebc091c4e11a">More...</a><br /></td></tr>
<tr class="separator:a2b51cd1178e391e38b8eebc091c4e11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86d333067a02494d0ecabd977c3f711"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1BundleModel.html#ac86d333067a02494d0ecabd977c3f711">eval_model</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> &amp;lb, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> y_id, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;y, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> relprec)=0</td></tr>
<tr class="memdesc:ac86d333067a02494d0ecabd977c3f711"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate the current cutting model in the given point  <a href="#ac86d333067a02494d0ecabd977c3f711">More...</a><br /></td></tr>
<tr class="separator:ac86d333067a02494d0ecabd977c3f711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6778687ff849b5822af0089d303692c3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1BundleModel.html#a6778687ff849b5822af0089d303692c3">start_augmodel</a> (<a class="el" href="classConicBundle_1_1QPModelDataPointer.html">QPModelDataPointer</a> &amp;blockp, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> cand_id, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;cand_y, const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> *indices=0)=0</td></tr>
<tr class="memdesc:a6778687ff849b5822af0089d303692c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">the returned <em>blockp</em> points to a description of the variables and constraints generating the cutting model as required by the current QP Sollver that provides<em>bolckp</em>, see <a class="el" href="classConicBundle_1_1QPModelDataObject.html" title="abstract interface declaring the uniform outer appearance of general cutting models produced by the v...">QPModelDataObject</a> (the object stays property of this), the constant_minorant and the bundle hold the corresponding model data  <a href="#a6778687ff849b5822af0089d303692c3">More...</a><br /></td></tr>
<tr class="separator:a6778687ff849b5822af0089d303692c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b3628c5b5519bdc183c1aaaef1f3b6"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1BundleModel.html#ac5b3628c5b5519bdc183c1aaaef1f3b6">make_model_aggregate</a> (bool &amp;penalty_parameter_increased, bool keep_penalty_fixed)=0</td></tr>
<tr class="memdesc:ac5b3628c5b5519bdc183c1aaaef1f3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">after the common QP is solved, this call asks to form the new aggregate from the solution. If keep_penalty_fixed==false the model may decide to increase some internal penalty parameter, has then to report this in penalty_parameter_increased but need not form the aggregate.  <a href="#ac5b3628c5b5519bdc183c1aaaef1f3b6">More...</a><br /></td></tr>
<tr class="separator:ac5b3628c5b5519bdc183c1aaaef1f3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97b3866698bc294b063f8d953026e1d"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1BundleModel.html#ac97b3866698bc294b063f8d953026e1d">get_model_aggregate</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> &amp;model_aggregate_id, <a class="el" href="classConicBundle_1_1MinorantPointer.html">MinorantPointer</a> &amp;model_aggregate)=0</td></tr>
<tr class="memdesc:ac97b3866698bc294b063f8d953026e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the model aggregate if available.  <a href="#ac97b3866698bc294b063f8d953026e1d">More...</a><br /></td></tr>
<tr class="separator:ac97b3866698bc294b063f8d953026e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95125c655bbbe00c590618d739d5e59a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1BundleModel.html#a95125c655bbbe00c590618d739d5e59a">update_model</a> (<a class="el" href="classConicBundle_1_1BundleModel.html#a98559877353ac9b777b536a2e7ef4146">ModelUpdate</a> model_update, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> center_id, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;center_y, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> cand_id, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;cand_y, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> model_maxviol, <a class="el" href="classConicBundle_1_1BundleProxObject.html">BundleProxObject</a> &amp;H)=0</td></tr>
<tr class="memdesc:a95125c655bbbe00c590618d739d5e59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate the next cutting model and store the center information in the case of a descent step  <a href="#a95125c655bbbe00c590618d739d5e59a">More...</a><br /></td></tr>
<tr class="separator:a95125c655bbbe00c590618d739d5e59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbaed7bd7e47811698ee12166beefd63"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1BundleModel.html#acbaed7bd7e47811698ee12166beefd63">synchronize_ids</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> &amp;new_center_ub_fid, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> new_center_id, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> old_center_id, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> &amp;new_cand_ub_fid, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> new_cand_id, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> old_cand_id, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> &amp;new_aggregate_id)=0</td></tr>
<tr class="memdesc:acbaed7bd7e47811698ee12166beefd63"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset all id counters and references to zero and center_id and cand_id to the given values if consistent data is available  <a href="#acbaed7bd7e47811698ee12166beefd63">More...</a><br /></td></tr>
<tr class="separator:acbaed7bd7e47811698ee12166beefd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9a0bd08d0373c1676895204bb090cf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1BundleModel.html#a1e9a0bd08d0373c1676895204bb090cf">center_modified</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> &amp;function_modification_id, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> center_id)=0</td></tr>
<tr class="memdesc:a1e9a0bd08d0373c1676895204bb090cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the evaluation data for the known <em>function_modification_id</em> and for the identifier <em>center_id</em> for the center point is no longer valid or available at the model.  <a href="#a1e9a0bd08d0373c1676895204bb090cf">More...</a><br /></td></tr>
<tr class="separator:a1e9a0bd08d0373c1676895204bb090cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394097e9bd63a36046154bbce94604cf"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1BundleModel.html#a394097e9bd63a36046154bbce94604cf">recompute_center</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> &amp;new_center_ub_fid, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> &amp;new_center_ub, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> center_id, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;center_y, bool accept_only_higher_values=false, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> relprec=-1.)=0</td></tr>
<tr class="memdesc:a394097e9bd63a36046154bbce94604cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">after modifications of the problem the center information may have to be recomputed partially or completely  <a href="#a394097e9bd63a36046154bbce94604cf">More...</a><br /></td></tr>
<tr class="separator:a394097e9bd63a36046154bbce94604cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9eb6606477b40be0cfe11fa5b27bd4"><td class="memItemLeft" align="right" valign="top"><a id="a5c9eb6606477b40be0cfe11fa5b27bd4"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1BundleModel.html#a5c9eb6606477b40be0cfe11fa5b27bd4">model_aggregate_modified</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> old_model_aggregate_id)=0</td></tr>
<tr class="memdesc:a5c9eb6606477b40be0cfe11fa5b27bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the data about the aggregate minorant has changed w.r.t. old_model_aggregate_id. In this case call provide_model_aggregate and then add_model_aggregate to update the model_aggregate <br /></td></tr>
<tr class="separator:a5c9eb6606477b40be0cfe11fa5b27bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb0c746bfacb7e989b29d7f816df893"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1BundleModel.html#acfb0c746bfacb7e989b29d7f816df893">provide_model_aggregate</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> y_id, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;y)=0</td></tr>
<tr class="memdesc:acfb0c746bfacb7e989b29d7f816df893"><td class="mdescLeft">&#160;</td><td class="mdescRight">makes sure that the model_aggregate returned by add_model_aggregate is actually a minorant contained in the next cutting model.  <a href="#acfb0c746bfacb7e989b29d7f816df893">More...</a><br /></td></tr>
<tr class="separator:acfb0c746bfacb7e989b29d7f816df893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0424d87ac5402a662365c9b19d7a3f42"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1BundleModel.html#a0424d87ac5402a662365c9b19d7a3f42">apply_modification</a> (bool &amp;no_changes, const <a class="el" href="classConicBundle_1_1GroundsetModification.html">GroundsetModification</a> &amp;gsmdf, const <a class="el" href="namespaceConicBundle.html#ad078c3e597a104edaccd983cddf6a134">FunObjModMap</a> &amp;funmdfmap, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> new_center_id, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;new_center, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> old_center_id, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;old_center)=0</td></tr>
<tr class="memdesc:a0424d87ac5402a662365c9b19d7a3f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">passes on modification information about function and ground set changes  <a href="#a0424d87ac5402a662365c9b19d7a3f42">More...</a><br /></td></tr>
<tr class="separator:a0424d87ac5402a662365c9b19d7a3f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b5b09607e0c1f5ccd2107b9b1176f7"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1BundleModel.html#ae5b5b09607e0c1f5ccd2107b9b1176f7">check_center_validity_by_candidate</a> (bool &amp;cand_minorant_is_below, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> center_id, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;center_y)=0</td></tr>
<tr class="memdesc:ae5b5b09607e0c1f5ccd2107b9b1176f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">consistency check for oracle computations: test if the subgradient inequality arising out of the last eval_function holds for <em>center_y</em>.  <a href="#ae5b5b09607e0c1f5ccd2107b9b1176f7">More...</a><br /></td></tr>
<tr class="separator:ae5b5b09607e0c1f5ccd2107b9b1176f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced6edcf6cf22e7eb081a84e0e3ca6d9"><td class="memItemLeft" align="right" valign="top"><a id="aced6edcf6cf22e7eb081a84e0e3ca6d9"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1BundleModel.html#aced6edcf6cf22e7eb081a84e0e3ca6d9">get_function_minorant</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> &amp;function_modification_id, <a class="el" href="classConicBundle_1_1MinorantPointer.html">MinorantPointer</a> &amp;minorant)=0</td></tr>
<tr class="memdesc:aced6edcf6cf22e7eb081a84e0e3ca6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the minorant corresponding to the subgradient inequality returned by the last function evaluation. If the minorant is not empty on input, the local minorant is added to it. If no subgradient is available or modifications invalidated it, the minorant will be set to empty. <br /></td></tr>
<tr class="separator:aced6edcf6cf22e7eb081a84e0e3ca6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe027a93c73eddaf08d8e78a75db0505"><td class="memItemLeft" align="right" valign="top"><a id="afe027a93c73eddaf08d8e78a75db0505"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1BundleModel.html#afe027a93c73eddaf08d8e78a75db0505">get_center_minorant</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> &amp;function_modification_id, <a class="el" href="classConicBundle_1_1MinorantPointer.html">MinorantPointer</a> &amp;minorant)=0</td></tr>
<tr class="memdesc:afe027a93c73eddaf08d8e78a75db0505"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the minorant corresponding to the subgradient inequality returned by the function evaluation for the current center. If the minorant is not empty on input, the local minorant is added to it. If no subgradient is available or modifications invalidated it, the minorant will be set to empty. <br /></td></tr>
<tr class="separator:afe027a93c73eddaf08d8e78a75db0505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19bc8c76d59607ca388a3f15cbaf0d5b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classConicBundle_1_1BundleModel.html">BundleModel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1BundleModel.html#a19bc8c76d59607ca388a3f15cbaf0d5b">transform</a> ()</td></tr>
<tr class="memdesc:a19bc8c76d59607ca388a3f15cbaf0d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload this in order apply transformations in between.  <a href="#a19bc8c76d59607ca388a3f15cbaf0d5b">More...</a><br /></td></tr>
<tr class="separator:a19bc8c76d59607ca388a3f15cbaf0d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfbd8c4accfe838d9e0ff7d81b6559f"><td class="memItemLeft" align="right" valign="top"><a id="acbfbd8c4accfe838d9e0ff7d81b6559f"></a>
<a class="el" href="classConicBundle_1_1VariableMetricModel.html">VariableMetricModel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1BundleModel.html#acbfbd8c4accfe838d9e0ff7d81b6559f">variable_metric_transform</a> ()</td></tr>
<tr class="memdesc:acbfbd8c4accfe838d9e0ff7d81b6559f"><td class="mdescLeft">&#160;</td><td class="mdescRight">replaces variable_metric_transform by transform <br /></td></tr>
<tr class="separator:acbfbd8c4accfe838d9e0ff7d81b6559f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classConicBundle_1_1VariableMetricModel"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classConicBundle_1_1VariableMetricModel')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classConicBundle_1_1VariableMetricModel.html">ConicBundle::VariableMetricModel</a></td></tr>
<tr class="memitem:a2c5dfc51c66edd27fb7102b1894d5efd inherit pub_methods_classConicBundle_1_1VariableMetricModel"><td class="memItemLeft" align="right" valign="top"><a id="a2c5dfc51c66edd27fb7102b1894d5efd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1VariableMetricModel.html#a2c5dfc51c66edd27fb7102b1894d5efd">VariableMetricModel</a> (<a class="el" href="classConicBundle_1_1CBout.html">CBout</a> *cb=0, int cbincr=-1)</td></tr>
<tr class="memdesc:a2c5dfc51c66edd27fb7102b1894d5efd inherit pub_methods_classConicBundle_1_1VariableMetricModel"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for passing on ouptut information <br /></td></tr>
<tr class="separator:a2c5dfc51c66edd27fb7102b1894d5efd inherit pub_methods_classConicBundle_1_1VariableMetricModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8777b8b64a274eaee436c2b7da4faa2a inherit pub_methods_classConicBundle_1_1VariableMetricModel"><td class="memItemLeft" align="right" valign="top"><a id="a8777b8b64a274eaee436c2b7da4faa2a"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1VariableMetricModel.html#a8777b8b64a274eaee436c2b7da4faa2a">~VariableMetricModel</a> ()</td></tr>
<tr class="memdesc:a8777b8b64a274eaee436c2b7da4faa2a inherit pub_methods_classConicBundle_1_1VariableMetricModel"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual destructor <br /></td></tr>
<tr class="separator:a8777b8b64a274eaee436c2b7da4faa2a inherit pub_methods_classConicBundle_1_1VariableMetricModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ada8d8381611cf24552e4f019f4dcce inherit pub_methods_classConicBundle_1_1VariableMetricModel"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1VariableMetricModel.html#a7ada8d8381611cf24552e4f019f4dcce">add_variable_metric</a> (<a class="el" href="classConicBundle_1_1VariableMetric.html">VariableMetric</a> &amp;H, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> y_id, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;y, bool descent_step, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> weightu, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> model_maxviol, const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> *indices=0)</td></tr>
<tr class="memdesc:a7ada8d8381611cf24552e4f019f4dcce inherit pub_methods_classConicBundle_1_1VariableMetricModel"><td class="mdescLeft">&#160;</td><td class="mdescRight">add to the variable metric information H some model dependent "second order" information of the function modelled  <a href="classConicBundle_1_1VariableMetricModel.html#a7ada8d8381611cf24552e4f019f4dcce">More...</a><br /></td></tr>
<tr class="separator:a7ada8d8381611cf24552e4f019f4dcce inherit pub_methods_classConicBundle_1_1VariableMetricModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classConicBundle_1_1CBout"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classConicBundle_1_1CBout')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classConicBundle_1_1CBout.html">ConicBundle::CBout</a></td></tr>
<tr class="memitem:aed9a878aa9f402077e1f6453c0606535 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#aed9a878aa9f402077e1f6453c0606535">set_out</a> (std::ostream *<a class="el" href="classConicBundle_1_1CBout.html#a1125693307dcbd83770e4569bf99ba19">out</a>=0, int <a class="el" href="classConicBundle_1_1CBout.html#a5ce873e4d4d6b00096d822fa65fd4d7a">print_level</a>=1)</td></tr>
<tr class="memdesc:aed9a878aa9f402077e1f6453c0606535 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the output level (out==NULL: no output at all, out!=NULL and level=0: errors and warnings, level&gt;0 increasingly detailed information)  <a href="classConicBundle_1_1CBout.html#aed9a878aa9f402077e1f6453c0606535">More...</a><br /></td></tr>
<tr class="separator:aed9a878aa9f402077e1f6453c0606535 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac4530f6a6e43d48833a16aa26358e2 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#adac4530f6a6e43d48833a16aa26358e2">set_cbout</a> (const <a class="el" href="classConicBundle_1_1CBout.html">CBout</a> *cb, int incr=-1)</td></tr>
<tr class="memdesc:adac4530f6a6e43d48833a16aa26358e2 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the output level relative to the given <a class="el" href="classConicBundle_1_1CBout.html" title="base class for uniform use of WARNINGS and ERRORS (at some point in time) ">CBout</a> class.  <a href="classConicBundle_1_1CBout.html#adac4530f6a6e43d48833a16aa26358e2">More...</a><br /></td></tr>
<tr class="separator:adac4530f6a6e43d48833a16aa26358e2 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07122b66dbab4e1e411c807079fda6b0 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="a07122b66dbab4e1e411c807079fda6b0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#a07122b66dbab4e1e411c807079fda6b0">clear_cbout</a> ()</td></tr>
<tr class="memdesc:a07122b66dbab4e1e411c807079fda6b0 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset to default settings (out=0,print_level=1) <br /></td></tr>
<tr class="separator:a07122b66dbab4e1e411c807079fda6b0 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e96394f860c57d18c7c1d096c21cf9 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="aa9e96394f860c57d18c7c1d096c21cf9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#aa9e96394f860c57d18c7c1d096c21cf9">CBout</a> (const <a class="el" href="classConicBundle_1_1CBout.html">CBout</a> *cb=0, int incr=-1)</td></tr>
<tr class="memdesc:aa9e96394f860c57d18c7c1d096c21cf9 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">calls set_cbout <br /></td></tr>
<tr class="separator:aa9e96394f860c57d18c7c1d096c21cf9 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24445af38af55dfbd25bfe3055a53d17 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="a24445af38af55dfbd25bfe3055a53d17"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#a24445af38af55dfbd25bfe3055a53d17">CBout</a> (std::ostream *outp, int pl=1)</td></tr>
<tr class="memdesc:a24445af38af55dfbd25bfe3055a53d17 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize correspondingly <br /></td></tr>
<tr class="separator:a24445af38af55dfbd25bfe3055a53d17 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4defbb041e13bf58221e54bba4554335 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="a4defbb041e13bf58221e54bba4554335"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#a4defbb041e13bf58221e54bba4554335">CBout</a> (const <a class="el" href="classConicBundle_1_1CBout.html">CBout</a> &amp;cb, int incr=0)</td></tr>
<tr class="memdesc:a4defbb041e13bf58221e54bba4554335 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor <br /></td></tr>
<tr class="separator:a4defbb041e13bf58221e54bba4554335 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04ddacb98b92a196319a2483774d4f4 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="ab04ddacb98b92a196319a2483774d4f4"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#ab04ddacb98b92a196319a2483774d4f4">cb_out</a> (int pl=-1) const</td></tr>
<tr class="memdesc:ab04ddacb98b92a196319a2483774d4f4 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if out!=0 and (pl&lt;print_level), pl&lt;0 should be used for WARNINGS and ERRORS only, pl==0 for usual output. <br /></td></tr>
<tr class="separator:ab04ddacb98b92a196319a2483774d4f4 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55dcbb4c6fff8dc3485f9dd3cb309af8 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="a55dcbb4c6fff8dc3485f9dd3cb309af8"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#a55dcbb4c6fff8dc3485f9dd3cb309af8">get_out</a> () const</td></tr>
<tr class="memdesc:a55dcbb4c6fff8dc3485f9dd3cb309af8 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="classConicBundle_1_1CBout.html#ab04ddacb98b92a196319a2483774d4f4" title="Returns true if out!=0 and (pl&lt;print_level), pl&lt;0 should be used for WARNINGS and ERRORS only...">cb_out()</a> returned true, this returns the output stream, but it will abort if called with out==0. <br /></td></tr>
<tr class="separator:a55dcbb4c6fff8dc3485f9dd3cb309af8 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b55664bdf89963b87c94e7fa69b8fd1 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="a6b55664bdf89963b87c94e7fa69b8fd1"></a>
std::ostream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#a6b55664bdf89963b87c94e7fa69b8fd1">get_out_ptr</a> () const</td></tr>
<tr class="memdesc:a6b55664bdf89963b87c94e7fa69b8fd1 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the pointer to the output stream <br /></td></tr>
<tr class="separator:a6b55664bdf89963b87c94e7fa69b8fd1 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88e5f8f443a40c6cb506e2c808525a3 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="ad88e5f8f443a40c6cb506e2c808525a3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#ad88e5f8f443a40c6cb506e2c808525a3">get_print_level</a> () const</td></tr>
<tr class="memdesc:ad88e5f8f443a40c6cb506e2c808525a3 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the print_level <br /></td></tr>
<tr class="separator:ad88e5f8f443a40c6cb506e2c808525a3 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dda97ab7acdfab7e95b89a25cc9541c inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="a5dda97ab7acdfab7e95b89a25cc9541c"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#a5dda97ab7acdfab7e95b89a25cc9541c">mfile_data</a> (std::ostream &amp;<a class="el" href="classConicBundle_1_1CBout.html#a1125693307dcbd83770e4569bf99ba19">out</a>) const</td></tr>
<tr class="memdesc:a5dda97ab7acdfab7e95b89a25cc9541c inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">writes problem data to the given outstream <br /></td></tr>
<tr class="separator:a5dda97ab7acdfab7e95b89a25cc9541c inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>abstract interface for <a class="el" href="classConicBundle_1_1BundleSolver.html" title="This is the internal bundle solver managing descent/null steps with inner updates for approximating t...">BundleSolver</a> giving access to all objective function specific bundle routines and model descriptions. In particular it hides the cutting model and the oracle. </p>
<p>Viewed from the <a class="el" href="classConicBundle_1_1BundleSolver.html" title="This is the internal bundle solver managing descent/null steps with inner updates for approximating t...">BundleSolver</a>, the basic data maintained by the <a class="el" href="classConicBundle_1_1BundleModel.html" title="abstract interface for BundleSolver giving access to all objective function specific bundle routines ...">BundleModel</a> are (see also <a class="el" href="classConicBundle_1_1BundleData.html" title="base class for use with SumBlockModel for storing and managing essential data of evaluations and the ...">ConicBundle::BundleData</a>)</p><ul>
<li>the function value in the center with the relative precision required at its computation (but it need NOT store the center or its subgradient)</li>
<li>the function value in the last candidate together with its subgradient and the required relative precision</li>
<li>the linear aggregate minorant to the function as collected over time.</li>
<li>a nonnegative counter modification_id that is increased by the model whenever changes in the function might invalidate the computed function value in the center</li>
<li>a nonnegative counter aggregate_id that is increased by the model whenever changes in the function or model might invalidate the aggregate minorant</li>
</ul>
<p>Note, it is not assumed that the model keeps track of the current center point, candidate point or the ground set; if such data is relevant, it is given by arguments.</p>
<p>The most important functionality required is</p><ul>
<li>to evaluate the function at a given point returning an upper bound on it in required precision (<a class="el" href="classConicBundle_1_1BundleModel.html#a2b51cd1178e391e38b8eebc091c4e11a" title="evaluates the objective function in y and returns an upper bound in ub within relative precision relp...">eval_function()</a>)</li>
<li>to evaluate the model in a given point (<a class="el" href="classConicBundle_1_1BundleModel.html#ac86d333067a02494d0ecabd977c3f711" title="evaluate the current cutting model in the given point ">eval_model()</a>)</li>
<li>to pass the model description for the bundle subproblem as a <a class="el" href="classConicBundle_1_1QPModelDataObject.html" title="abstract interface declaring the uniform outer appearance of general cutting models produced by the v...">QPModelDataObject</a> via <a class="el" href="classConicBundle_1_1QPModelDataPointer.html" title="abstract interface for automatically generating and retrieving the qp blocks with the model data that...">QPModelDataPointer</a> (<a class="el" href="classConicBundle_1_1BundleModel.html#a6778687ff849b5822af0089d303692c3" title="the returned blockp points to a description of the variables and constraints generating the cutting m...">start_augmodel()</a>)</li>
<li>to construct the next modelaggregate from the solution information in the <a class="el" href="classConicBundle_1_1QPModelDataObject.html" title="abstract interface declaring the uniform outer appearance of general cutting models produced by the v...">QPModelDataObject</a> after the bundle subproblem was solved (<a class="el" href="classConicBundle_1_1BundleModel.html#ac5b3628c5b5519bdc183c1aaaef1f3b6" title="after the common QP is solved, this call asks to form the new aggregate from the solution. If keep_penalty_fixed==false the model may decide to increase some internal penalty parameter, has then to report this in penalty_parameter_increased but need not form the aggregate. ">make_model_aggregate()</a>)</li>
<li>to return the most recent model aggregate (<a class="el" href="classConicBundle_1_1BundleModel.html#ac97b3866698bc294b063f8d953026e1d" title="returns the model aggregate if available. ">get_model_aggregate()</a>)</li>
<li>to update the model and center data according to the last candidate computations and the null/descent step decision (<a class="el" href="classConicBundle_1_1BundleModel.html#a95125c655bbbe00c590618d739d5e59a" title="generate the next cutting model and store the center information in the case of a descent step ...">update_model()</a>)</li>
</ul>
<p>Some convex functions offer the possibility of providing reasonable variable metric information for the proximal term. Limited support for adapting the proximal term by a variable metric heuristic is provided by the routine <a class="el" href="classConicBundle_1_1VariableMetricModel.html#a7ada8d8381611cf24552e4f019f4dcce" title="add to the variable metric information H some model dependent &quot;second order&quot; information of the funct...">add_variable_metric()</a>.</p>
<p><a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> is designed to handle problem changes on the fly, so a number of routines are devoted to recognizing and synchronizing external changes in the groundset data, the model or the function itself. In particular the bundle solver keeps track of the counter value of <em>center_id</em> that it receives along with data associated with the center and of the counter value of <em>aggregate_id</em> that it receives along with data associated with the model aggregate. When these values turn out to be smaller than the ones stored in the model, then the data needs to be synchronized before going on. The following routines serve this purpose: </p><pre class="fragment">- center_modified() checks whether center_id was increased
- recompute_center() reevaluates function in the center if this needed
- model_aggregate_modified() checks wether aggregate_id was increased
- provide_model_aggregate() provides a valid model aggregate, if the 
  current one is no longer valid
- apply_modification() passes on information on problem changes to the model
- synchronize_ids() allows to reset all ids to a common value from 
  outside (might be needed for branch and bound at some point in time)
</pre><p>The most typical implementation mistake when using <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual for a quick introd...">ConicBundle</a> is that the user returns incorrect function values and subgradients. In order to support recognizing this at least a little bit, it is possible to turn on a sanity check based on testing for consistency namely whether the new subgradient inequality computed in the candidate holds for the upper bound computed in the current center. This is done in the routine <a class="el" href="classConicBundle_1_1BundleModel.html#ae5b5b09607e0c1f5ccd2107b9b1176f7" title="consistency check for oracle computations: test if the subgradient inequality arising out of the last...">check_center_validity_by_candidate()</a>. If this fails, the center value might be small or the new subgradient might be wrong. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a98559877353ac9b777b536a2e7ef4146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98559877353ac9b777b536a2e7ef4146">&#9670;&nbsp;</a></span>ModelUpdate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classConicBundle_1_1BundleModel.html#a98559877353ac9b777b536a2e7ef4146">ConicBundle::BundleModel::ModelUpdate</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>for informing <a class="el" href="classConicBundle_1_1BundleModel.html#a95125c655bbbe00c590618d739d5e59a" title="generate the next cutting model and store the center information in the case of a descent step ...">update_model()</a> at what stage it is called to update the bundle so that the amount of information available is clear </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a98559877353ac9b777b536a2e7ef4146a35b1e4a3701e97a071ad7479114a28d4"></a>new_subgradient&#160;</td><td class="fielddoc"><p>the latest function evaluation and its subgradient arise from an extra evaluation of the function </p>
</td></tr>
<tr><td class="fieldname"><a id="a98559877353ac9b777b536a2e7ef4146a0c87f0b9bc86673635f6f491e2413df8"></a>descent_step&#160;</td><td class="fielddoc"><p>the latest function evaluation and its subgradient give rise to a descent step, preserving the aggregate is not that important </p>
</td></tr>
<tr><td class="fieldname"><a id="a98559877353ac9b777b536a2e7ef4146aa9feada80d27c677ad3b9734eafa36be"></a>null_step&#160;</td><td class="fielddoc"><p>the latest function evaluation and its subgradient resulted in a null step, preserve the aggregate! </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0424d87ac5402a662365c9b19d7a3f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0424d87ac5402a662365c9b19d7a3f42">&#9670;&nbsp;</a></span>apply_modification()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ConicBundle::BundleModel::apply_modification </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>no_changes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1GroundsetModification.html">GroundsetModification</a> &amp;&#160;</td>
          <td class="paramname"><em>gsmdf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceConicBundle.html#ad078c3e597a104edaccd983cddf6a134">FunObjModMap</a> &amp;&#160;</td>
          <td class="paramname"><em>funmdfmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a>&#160;</td>
          <td class="paramname"><em>new_center_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>new_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a>&#160;</td>
          <td class="paramname"><em>old_center_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>old_center</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>passes on modification information about function and ground set changes </p>
<p>If there is no center information or the current groundset modifications modify the center too much so that there is only hope to preserve some model information (the aggregate is of particular importance) but there is no hope to keep other previous evaluation information, then the routine is called with new_center_id=old_center_id=-1 and empty matrices in new_center and old_center will do.</p>
<p>If the current groundset modifications modify the center just a little or in a very canocial way so that there is a chance to preserve previous modle information and function evaluation results, then provide the old <em>old_center_id</em>, the <em>old_center</em> coordinates, and the current (new) <em>center_id</em> and <em>center_y</em> coordinates as they arise from the <a class="el" href="classConicBundle_1_1GroundsetModification.html" title="Collects modifications for the unconstrained Groundset for appending, deleting or reassigning variabl...">ConicBundle::GroundsetModification</a> <em>gsmdf</em> (if the ids match, they must be identical). For this class the information how to modify itself is given by the <a class="el" href="classConicBundle_1_1FunctionObjectModification.html" title="abstract interface for informing the bundle model routines about changes in the oracle function and...">ConicBundle::FunctionObjectModification</a> <em>fundmdfmap</em>[<em>oracle</em>], where <em>oracle</em> is the pointer to the function object (function oracle) that gives rise to this model. If no such <a class="el" href="classConicBundle_1_1Modification.html" title="base class for collecting and organizing a sequence of changes to linear data so that it can be carri...">Modification</a> is contained in the map, then there is no need to adapt to anything but the groundset changes. The class has to decide by itself which model components and function evaluation results can be preserved under these modificiations.</p>
<p>Depending on the modification, all function evaluation results may well be deleted or marked as outdated. The routine will try to preserve the model but in general this will not be possible. The output variable no_change is set to true if the modifications had no effect on the validitiy of any data returned so far; if no_change==false, the old data is no longer valid and needs recomputation. </p>

<p>Implemented in <a class="el" href="classConicBundle_1_1SumModel.html#ad30ab71dd5d3cf255c8c68abcb4fad66">ConicBundle::SumModel</a>, <a class="el" href="classConicBundle_1_1SumBlockModel.html#a3d9b6808371fbf8fec0ea79355b81230">ConicBundle::SumBlockModel</a>, and <a class="el" href="classConicBundle_1_1AFTModel.html#a1a2a82cd0898ad4d86cc08b198d0d987">ConicBundle::AFTModel</a>.</p>

</div>
</div>
<a id="a1e9a0bd08d0373c1676895204bb090cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9a0bd08d0373c1676895204bb090cf">&#9670;&nbsp;</a></span>center_modified()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ConicBundle::BundleModel::center_modified </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>function_modification_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a>&#160;</td>
          <td class="paramname"><em>center_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns true if the evaluation data for the known <em>function_modification_id</em> and for the identifier <em>center_id</em> for the center point is no longer valid or available at the model. </p>
<p>This usually means that some function or model modifications made it impossible to maintain or ensure the validity of the previously computed data (the subgradient in the center has no relevance here but would then also need to be removed).</p>
<p>If the model contains further models and relies on their evaluations, this call has to be propagated recursively to these and all intermediate results that rely on wrong computations have to be marked as no longer valid.</p>
<p>If there were changes but the model implementation is aware that these changes do not invalidate the center data, then it may also return a new <em>function_modification_id</em> and still return false.</p>
<p>If it returned true, call recompute_center to update the center data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">function_modification_id</td><td><ul>
<li>on input: the function id that was returned by routine computing the value in the current center (may be -1 if not initialized)</li>
<li>on output: the current function id (always &gt;=0)</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">center_id</td><td>the point id of the center point (always &gt;=0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>true if the center value should be recomputed (maybe due to recent changes in the function)</li>
<li>false if the old evaluation is still valid </li>
</ul>
</dd></dl>

<p>Implemented in <a class="el" href="classConicBundle_1_1SumModel.html#a6943da4e77c677ae10e70a4c5b131409">ConicBundle::SumModel</a>, <a class="el" href="classConicBundle_1_1SumBlockModel.html#a8be03bbdf3797539aecb70807f890b89">ConicBundle::SumBlockModel</a>, and <a class="el" href="classConicBundle_1_1AFTModel.html#a499922fe2c6795db20fa4a59dfcb13a1">ConicBundle::AFTModel</a>.</p>

</div>
</div>
<a id="ae5b5b09607e0c1f5ccd2107b9b1176f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b5b09607e0c1f5ccd2107b9b1176f7">&#9670;&nbsp;</a></span>check_center_validity_by_candidate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ConicBundle::BundleModel::check_center_validity_by_candidate </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>cand_minorant_is_below</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a>&#160;</td>
          <td class="paramname"><em>center_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>center_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>consistency check for oracle computations: test if the subgradient inequality arising out of the last eval_function holds for <em>center_y</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">cand_minorant_is_below</td><td>is set to true if subgradient inequality holds, otherwise false.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">center_id</td><td>point id of the center, it should match the one stored here</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">center_y</td><td>the coordinates of the current center (need not be available inside this class)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if all required data is available, !=0 if something failed </dd></dl>

<p>Implemented in <a class="el" href="classConicBundle_1_1SumModel.html#a57c7678b5c4e524216da9f1935656892">ConicBundle::SumModel</a>, <a class="el" href="classConicBundle_1_1AFTModel.html#a534fbc69c8480a071280d53a478bf977">ConicBundle::AFTModel</a>, and <a class="el" href="classConicBundle_1_1ConeModel.html#a195b1c70b077025c350079d95f70c61e">ConicBundle::ConeModel</a>.</p>

</div>
</div>
<a id="a2b51cd1178e391e38b8eebc091c4e11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b51cd1178e391e38b8eebc091c4e11a">&#9670;&nbsp;</a></span>eval_function()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ConicBundle::BundleModel::eval_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>ub_fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> &amp;&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a>&#160;</td>
          <td class="paramname"><em>y_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a>&#160;</td>
          <td class="paramname"><em>nullstep_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a>&#160;</td>
          <td class="paramname"><em>relprec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>evaluates the objective function in <em>y</em> and returns an upper bound in <em>ub</em> within relative precision <em>relprec</em>. </p>
<p>If evaluated by an iterative method that provides upper (<em>ub</em>) and lower bounds (lb), the method may stop when the lower bound is above the <em>nullstep_bound</em>. Evalutation may also stop, if (ub-lb)&lt;<em>relprec*</em>(|ub|+1) is satisfied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ub_fid</td><td>gives the modification id of the function for which the value <em>ub</em> was computed</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ub</td><td>(relprec-tight) upper bound on the function value in y</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_id</td><td>the identification number of the point to evaluate at (to ensure consistency in routines like <a class="el" href="classConicBundle_1_1BundleModel.html#a394097e9bd63a36046154bbce94604cf" title="after modifications of the problem the center information may have to be recomputed partially or comp...">recompute_center()</a>)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>the point to evaluate at.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nullstep_bound</td><td>(<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type ">CH_Matrix_Classes::Real</a>) if a lower bound on the function value by a minorant is above this value, a null step will be made and any minorant above this bound suffices to ensure convergence</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relprec</td><td>(<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type ">CH_Matrix_Classes::Real</a>) if the nullstep_bound is not reached, then evalutation may stop, if (ub-lb)&lt;relprec*(|ub|+1) is satisfied for an upper bound ub and a lower bound lb on the objective</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 ... if all is ok</li>
<li>&gt;0 ... if solution could not be computed due to fatal errors</li>
<li>&lt;0 ... if solution could not be computed to desired precision </li>
</ul>
</dd></dl>

<p>Implemented in <a class="el" href="classConicBundle_1_1SumModel.html#a6c7d620e608d1510f36215193ab24cbf">ConicBundle::SumModel</a>, <a class="el" href="classConicBundle_1_1AFTModel.html#a738db98d5075bce7f093695debf1a48a">ConicBundle::AFTModel</a>, and <a class="el" href="classConicBundle_1_1ConeModel.html#ab105ce40ff20a598ab737a1944368eec">ConicBundle::ConeModel</a>.</p>

</div>
</div>
<a id="ac86d333067a02494d0ecabd977c3f711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86d333067a02494d0ecabd977c3f711">&#9670;&nbsp;</a></span>eval_model()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ConicBundle::BundleModel::eval_model </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a>&#160;</td>
          <td class="paramname"><em>y_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a>&#160;</td>
          <td class="paramname"><em>relprec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>evaluate the current cutting model in the given point </p>
<p>If evaluated by an iterative method that provides upper (ub) and lower bounds (<em>lb</em>) it may stop when (ub-lb)&lt;<em>relprec*</em>(|ub|+1) is satisfied.</p>
<p>The result <em>lb</em> is only used immediately and not used again later, therefore there is no need for passing the modification id of the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">lb</td><td>(relprec-tight) upper bound on the model value in y</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_id</td><td>the point id of the point to evaluate at</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>the point to evaluate at</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relprec</td><td>in an iterative method evalutation may stop, if (ub-lb)&lt;relprec*(|ub|+1) is satisfied for an upper bound ub and a lower bound lb on the model value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 ... if all is ok</li>
<li>&gt;0 ... if solution could not be computed due to fatal errors</li>
<li>&lt;0 ... if solution could not be computed to desired precision </li>
</ul>
</dd></dl>

<p>Implemented in <a class="el" href="classConicBundle_1_1SumModel.html#affa23e99ac4cb6fedf0783571eaa9961">ConicBundle::SumModel</a>, <a class="el" href="classConicBundle_1_1AFTModel.html#ac75f42d58d943c216c3f6f78acde1f1a">ConicBundle::AFTModel</a>, and <a class="el" href="classConicBundle_1_1ConeModel.html#ac8ca3fac7846eb76fd2d17367fec2a0c">ConicBundle::ConeModel</a>.</p>

</div>
</div>
<a id="ac97b3866698bc294b063f8d953026e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac97b3866698bc294b063f8d953026e1d">&#9670;&nbsp;</a></span>get_model_aggregate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ConicBundle::BundleModel::get_model_aggregate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>model_aggregate_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1MinorantPointer.html">MinorantPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>model_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the model aggregate if available. </p>
<p>The model aggregate is usually the best linear minorant <img class="formulaInl" alt="$(\sigma,s)$" src="form_225.png"/>=(<em>model_aggregate_offset</em>,<em>model_aggregate</em>) of the model of the objective function <img class="formulaInl" alt="$f$" src="form_5.png"/> computed in successful calls to <a class="el" href="classConicBundle_1_1BundleSolver.html#a5785f6d5a5ca006706578ae460b7fd47" title="Evaluates the augmented model with respect to the center of stability. ">BundleSolver::eval_augmodel()</a>, <a class="el" href="classConicBundle_1_1BundleSolver.html#a9a5c85245eacd3dba33d206af138ebf8" title="reevaluate the augmented model for updated groundset aggregate w.r.t. the previously called eval_augm...">BundleSolver::reeval_augmodel()</a>, see there for its precise definition as one part of the saddle point solution. It is typically not availabel initially or after problem modifications. The nonnegative counter <em>model_aggregate_id</em> serves to identify the validity of the aggregate via the routine <a class="el" href="classConicBundle_1_1BundleModel.html#a5c9eb6606477b40be0cfe11fa5b27bd4" title="returns true if the data about the aggregate minorant has changed w.r.t. old_model_aggregate_id. In this case call provide_model_aggregate and then add_model_aggregate to update the model_aggregate ">model_aggregate_modified()</a>. If no aggregate is available, calling the routine <a class="el" href="classConicBundle_1_1BundleModel.html#acfb0c746bfacb7e989b29d7f816df893" title="makes sure that the model_aggregate returned by add_model_aggregate is actually a minorant contained ...">provide_model_aggregate()</a> will generate some reasonable replacement aggregate with a larger aggregate_id that can then be retrieved with the present routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">model_aggregate_id</td><td>nonnegative counter for quickly checking validity of the aggregate</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">model_aggregate</td><td>If empty on input, model_aggregate is initialized to the aggregate, otherwise the aggregate is added to model_aggregates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if the information is available (if eval_augmodel() did not return 0, the information will not satisfy the precision requirements but may still be available)</li>
<li>1 if the desired information is not available </li>
</ul>
</dd></dl>

<p>Implemented in <a class="el" href="classConicBundle_1_1SumBlockModel.html#acd78b2f39dbd49f20af20bdeeec1a721">ConicBundle::SumBlockModel</a>.</p>

</div>
</div>
<a id="ac5b3628c5b5519bdc183c1aaaef1f3b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b3628c5b5519bdc183c1aaaef1f3b6">&#9670;&nbsp;</a></span>make_model_aggregate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ConicBundle::BundleModel::make_model_aggregate </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>penalty_parameter_increased</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keep_penalty_fixed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>after the common QP is solved, this call asks to form the new aggregate from the solution. If keep_penalty_fixed==false the model may decide to increase some internal penalty parameter, has then to report this in penalty_parameter_increased but need not form the aggregate. </p>
<p>This model has access to the solution information directly via the <a class="el" href="classConicBundle_1_1QPModelDataObject.html" title="abstract interface declaring the uniform outer appearance of general cutting models produced by the v...">QPModelDataObject</a>, of which a pointer has been generated/provided in <a class="el" href="classConicBundle_1_1BundleModel.html#a6778687ff849b5822af0089d303692c3" title="the returned blockp points to a description of the variables and constraints generating the cutting m...">start_augmodel()</a>.</p>
<p>If the model's function contains a penalty component for some constraint not represented in <a class="el" href="classConicBundle_1_1Groundset.html" title="abstract representation of the feasible convex ground set to be optimized over, provides the QP solve...">Groundset</a>, the model may find out by inspecting the solution that this penalty would need to be increased. Because increasing a penalty parameter changes the cost function on the fly, this requires a lot of attention in forming the bundle subproblem and the <a class="el" href="classConicBundle_1_1BundleSolver.html" title="This is the internal bundle solver managing descent/null steps with inner updates for approximating t...">BundleSolver</a>. Indeed, it might lead to infinite loops in the case of infeasible problems. Therefore it is only allowed to do so if <em>keep_penalty_fixed</em> == false and it has then to set <em>penalty_parameter_increased</em> to true. Increasing the parameter will always lead to a call to <a class="el" href="classConicBundle_1_1BundleModel.html#a394097e9bd63a36046154bbce94604cf" title="after modifications of the problem the center information may have to be recomputed partially or comp...">recompute_center()</a>, where the model has to ensure that the value with the new penalty is computed correctly. Furthermore, the quadratic bundle subproblem has to be resolved in this case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">penalty_parameter_increased</td><td>true if increased (only allowed if keep_penalty_fixed==false), false otherwise</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep_penalty_fixed</td><td>if true, a possibly present penalty parameter may not be changed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on succes,</li>
<li>!=0 if the necessary information for forming the aggregate is not avilable </li>
</ul>
</dd></dl>

<p>Implemented in <a class="el" href="classConicBundle_1_1SumModel.html#a2be350fbe8e9423fcf265fa5f8a64fab">ConicBundle::SumModel</a>, <a class="el" href="classConicBundle_1_1AFTModel.html#a81acb74b9d60ca25910796a9f7faea33">ConicBundle::AFTModel</a>, and <a class="el" href="classConicBundle_1_1ConeModel.html#a09a4f29c38ca1867afdb7411b23a5512">ConicBundle::ConeModel</a>.</p>

</div>
</div>
<a id="acfb0c746bfacb7e989b29d7f816df893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb0c746bfacb7e989b29d7f816df893">&#9670;&nbsp;</a></span>provide_model_aggregate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ConicBundle::BundleModel::provide_model_aggregate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a>&#160;</td>
          <td class="paramname"><em>y_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>makes sure that the model_aggregate returned by add_model_aggregate is actually a minorant contained in the next cutting model. </p>
<p>This should only be called if <a class="el" href="classConicBundle_1_1BundleModel.html#a5c9eb6606477b40be0cfe11fa5b27bd4" title="returns true if the data about the aggregate minorant has changed w.r.t. old_model_aggregate_id. In this case call provide_model_aggregate and then add_model_aggregate to update the model_aggregate ">model_aggregate_modified()</a> returned true (e.g. on intialization). The point <em>y</em> is either the last candidate or the center and should hint at where the model should be good, this should help to choose a good initial aggregate if several possibilities exist. </p>

<p>Implemented in <a class="el" href="classConicBundle_1_1SumModel.html#a741968d040c0d609d9b211037f8481d7">ConicBundle::SumModel</a>, <a class="el" href="classConicBundle_1_1AFTModel.html#ad5eb383316061ede180ca9a1c212b4cb">ConicBundle::AFTModel</a>, and <a class="el" href="classConicBundle_1_1ConeModel.html#a2c5d95fd692857db1c1f41aa5bf53551">ConicBundle::ConeModel</a>.</p>

</div>
</div>
<a id="a394097e9bd63a36046154bbce94604cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394097e9bd63a36046154bbce94604cf">&#9670;&nbsp;</a></span>recompute_center()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ConicBundle::BundleModel::recompute_center </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>new_center_ub_fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> &amp;&#160;</td>
          <td class="paramname"><em>new_center_ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a>&#160;</td>
          <td class="paramname"><em>center_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>center_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>accept_only_higher_values</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a>&#160;</td>
          <td class="paramname"><em>relprec</em> = <code>-1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>after modifications of the problem the center information may have to be recomputed partially or completely </p>
<p>The <a class="el" href="classConicBundle_1_1BundleSolver.html" title="This is the internal bundle solver managing descent/null steps with inner updates for approximating t...">BundleSolver</a> calls this routine for initialization, after problem modifications and if numerical problems indicate that the value center_ub is actually too small. Some models might call it themselves if, e.g., updates of a penalty parameter during (re)eval_augmodle() require the recomputation of the function value in the center.</p>
<p>In the cases where the center was already available before (<em>center_id</em> matches the one stored) an actual recomputation might be avoidable if the problem modifications did not affect the function and relative precision requirements did not increase (<em>relprec</em> negative is used to indicate this). Yet even in some of these cases higher precision requirements (for this <em>relprec</em> needs to be compared to the relative precision of the last center computaton, which must be stored by the class) or the requirement to produce a value at least as high as the old one (<em>accept_only_higher_values</em> is set to true in this case and new) make a reevalution necessary anyways.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">new_center_ub_fid</td><td>the function id for which the value of <em>new_center_ub</em> was now computed</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_center_ub</td><td>upper bound on the function value in center_y, hopefully in desired precision</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">center_id</td><td>the point id of the center</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">center_y</td><td>the coordinate vector of the center</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accept_only_higher_values</td><td>if false any result of the recomputation is stored as new center information, if true (in this case center_id must match the stored number) only the higher result of the previous (the value must still be available there) and the current computation is stored. It will only be recomputed, however, if the relative precision requirements have increased so that there is hope for a different result in deterministic computations.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relprec</td><td>negative values indicate that the same relative precision is used as in the stored center computation (which must include center_ub and its "personal" relprec) and may only occur if the center is still the same (center_id matches the stored value). If relprec has smaller value than in the stored computational results, then the function is reevaluated even if the center did not change.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 ... if all is ok</li>
<li>&gt;0 ... if solution could not be computed due to fatal errors</li>
<li>&lt;0 ... if solution could not be computed to desired precision </li>
</ul>
</dd></dl>

<p>Implemented in <a class="el" href="classConicBundle_1_1SumModel.html#a3fea42f0ebdadf64812372990965ecc6">ConicBundle::SumModel</a>, <a class="el" href="classConicBundle_1_1AFTModel.html#a519e9542f604ba737f65229d23c205d5">ConicBundle::AFTModel</a>, and <a class="el" href="classConicBundle_1_1ConeModel.html#afa310a0f53c3f5e5b228b10dab92f437">ConicBundle::ConeModel</a>.</p>

</div>
</div>
<a id="a6778687ff849b5822af0089d303692c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6778687ff849b5822af0089d303692c3">&#9670;&nbsp;</a></span>start_augmodel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ConicBundle::BundleModel::start_augmodel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1QPModelDataPointer.html">QPModelDataPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>blockp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a>&#160;</td>
          <td class="paramname"><em>cand_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>cand_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> *&#160;</td>
          <td class="paramname"><em>indices</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the returned <em>blockp</em> points to a description of the variables and constraints generating the cutting model as required by the current QP Sollver that provides<em>bolckp</em>, see <a class="el" href="classConicBundle_1_1QPModelDataObject.html" title="abstract interface declaring the uniform outer appearance of general cutting models produced by the v...">QPModelDataObject</a> (the object stays property of this), the constant_minorant and the bundle hold the corresponding model data </p>
<p>If indices != NULL, only the coefficients specified by indices will be retrieved from constant_minorant and bundle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">blockp</td><td>pointer for generating a bundle description object suitable for the current QP solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cand_id</td><td>the point id of the latest candidate</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cand_y</td><td>the coordinates of the latest candidate</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>if not NULL the subgradient coordinates use in the bundle subproblem will just consider these indices, the other coordinates will not be used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on succes,</li>
<li>!=0 if the necessary information for forming the aggregate is not avilable </li>
</ul>
</dd></dl>

<p>Implemented in <a class="el" href="classConicBundle_1_1SumBlockModel.html#aedbb5be449b41fd0b584131ee5848e94">ConicBundle::SumBlockModel</a>.</p>

</div>
</div>
<a id="acbaed7bd7e47811698ee12166beefd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbaed7bd7e47811698ee12166beefd63">&#9670;&nbsp;</a></span>synchronize_ids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ConicBundle::BundleModel::synchronize_ids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>new_center_ub_fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a>&#160;</td>
          <td class="paramname"><em>new_center_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a>&#160;</td>
          <td class="paramname"><em>old_center_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>new_cand_ub_fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a>&#160;</td>
          <td class="paramname"><em>new_cand_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a>&#160;</td>
          <td class="paramname"><em>old_cand_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>new_aggregate_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reset all id counters and references to zero and center_id and cand_id to the given values if consistent data is available </p>
<p>After the completion of a successful bundle iteration (null or descent) all relevant evaluation and bundle data must be available and up to date, even if typically the candidate data is not needed any more. This function is intended for being called at exactly this point in the algorithm. If data is indeed consistent with this, it resets all center and candidate ids to the predifined ids, all other current ids are passed on and if the corresponding results are still valid, the respective ids should also be set to zero (the other ids reflect "the" aggregate, the current version of a specific function or transformation, so at most one valid object of the other ids should be around and that will get the new version number 0). If not valid any more, -1 should be passed back instead. The purpose is to make generating consistent restarting information easier (this might be useful e.g. in conjunction with branch and bound or when linking in new functions at some point in time).</p>
<p>In particular, if nonnegative ids are given for center or candidate ids and their respective function value on input, a new nonnegative function id for this value is returned if all relevant data is available and consistent, otherwise the returned function id will be -1 to indicate that the old value needs to be recomputed. A negative function id on input will always result in a -1 being returned. If the target id of the center or candidate point is nonnegative, the stored ids must match the old versions or the stored versions MUST be discarded and this will automatically result in also returning -1 for the repsective function ids. If candidate and center are different they may not be assigned the same new id (checked by assert). Likewise, if they are identical they may not be assigned distinct nonnegative numbers (one negative is allowed, again checked by assert).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">new_center_ub_fid</td><td><ul>
<li>on input: the function id the value ub was computed for (in this case all point and evaluation data is expected to be consistent for the center) or -1 if it is known to be out of date</li>
<li>on output: the sychronized new function id (expected to be 0) if the value is still valid, -1 otherwise</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_center_id</td><td>the newly assigned id for the center point or -1 if the model may discard its center information. new_center_id may only be &gt;=0 if also old_center_id&gt;=0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_center_id</td><td>the previously assigned id for the center point or -1 if none is available. If old_center_id&gt;=0 and new_center_id&gt;=0 the old_center_id must match the center id stored in the model.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">new_cand_ub_fid</td><td>same as for center</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_cand_id</td><td>same as for center</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_cand_id</td><td>same as for center</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">new_aggregate_id</td><td><ul>
<li>on input: the aggregate id that was returned by get_model_aggregate or -1 if it is known to be invalid</li>
<li>on output: the sychronized aggregate id (should be 0) if the aggregate is still valid, -1 otherwise </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classConicBundle_1_1SumModel.html#a84d863eb1903a3b15ef500d083f3e3da">ConicBundle::SumModel</a>, <a class="el" href="classConicBundle_1_1SumBlockModel.html#aa81dcb3d101a9b7f71dd907c24a3ca81">ConicBundle::SumBlockModel</a>, and <a class="el" href="classConicBundle_1_1AFTModel.html#acc9761b2d7f483abff12283bdcbf51e1">ConicBundle::AFTModel</a>.</p>

</div>
</div>
<a id="a19bc8c76d59607ca388a3f15cbaf0d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19bc8c76d59607ca388a3f15cbaf0d5b">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classConicBundle_1_1BundleModel.html">BundleModel</a>* ConicBundle::BundleModel::transform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload this in order apply transformations in between. </p>
<p>The bundle solver never calls the above routines directly but always via a call to transform. This allows to insert affine function transformations, if so desired. </p>

<p>Reimplemented in <a class="el" href="classConicBundle_1_1SumBlockModel.html#aa3e1429cbb7808a806a59e5e328a460b">ConicBundle::SumBlockModel</a>.</p>

<p class="reference">Referenced by <a class="el" href="classConicBundle_1_1BundleModel.html#acbfbd8c4accfe838d9e0ff7d81b6559f">variable_metric_transform()</a>.</p>

</div>
</div>
<a id="a95125c655bbbe00c590618d739d5e59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95125c655bbbe00c590618d739d5e59a">&#9670;&nbsp;</a></span>update_model()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ConicBundle::BundleModel::update_model </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1BundleModel.html#a98559877353ac9b777b536a2e7ef4146">ModelUpdate</a>&#160;</td>
          <td class="paramname"><em>model_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a>&#160;</td>
          <td class="paramname"><em>center_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>center_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a>&#160;</td>
          <td class="paramname"><em>cand_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>cand_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a>&#160;</td>
          <td class="paramname"><em>model_maxviol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1BundleProxObject.html">BundleProxObject</a> &amp;&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>generate the next cutting model and store the center information in the case of a descent step </p>
<p>If model_update==null_step, the next model has to contain at least all convex combinations of the current subgradient of <a class="el" href="classConicBundle_1_1BundleModel.html#a2b51cd1178e391e38b8eebc091c4e11a" title="evaluates the objective function in y and returns an upper bound in ub within relative precision relp...">eval_function()</a> and the aggregate minorant of (re)eval_augmodel(). update_model may only be called if at least one of both is available.</p>
<p>The point passed in the argument is the candidate where the last function evaluation took place, its id is passed on so that some consistency check is possible without having to store the entire vector. The coordinates of the point may help in setting up a model of good quality close to this point</p>
<p>If model_upate is descent_step and the last function evaluation took place for this candidate, the function evaluation data and point identifier (not nec. the point itself) needs to be stored as the new function value of the center.</p>
<p>If model_update is new_subgradient the model may wish to use new subgradient information available in the candidate for inclusion in the model; if the modle is empty it has to include it so that the modle is initialized. The center is not moved in this case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">model_update</td><td><ul>
<li>if model_update==new_subgradient, then the latest function evaluation is due to a separate funtion evaluation; include the new subgradient but do not expect any informtion on a new aggregate (this should always be called after setting a new center, in particular on initialization so that the model contains at least one subgradient).</li>
<li>if model_update==descent step, then the next step is a descent step; in this case the model may be restarted from scratch and there is no need not include the last aggregate; move the center to the candidate</li>
<li>if mode_update==null_step, then the next tep is a null step; in this case the update has to preserve the aggregate.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">center_id</td><td>the point id of the center, so that the model can check consistency of the evaluation data in moving the center for a descent step</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">center_y</td><td>this may help to estimate the model changes relative to this point</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cand_id</td><td>the point id of the candidate, so that the model can check consistency of the evaluation data in moving the center for a descent step</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cand_y</td><td>the next model should be good close to this point</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_maxviol</td><td>a minorant violated by this ammount would have resulted in a null step</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">H</td><td>the weight intended for the proximal term of the next model. it should not be changed here, but may use computation routines of H</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 ... if the requirements on the model could be met and no errors occured</li>
<li>1 ... otherwise </li>
</ul>
</dd></dl>

<p>Implemented in <a class="el" href="classConicBundle_1_1SumModel.html#ae815043c018008defbb42039255b8368">ConicBundle::SumModel</a>, <a class="el" href="classConicBundle_1_1SumBlockModel.html#a44b2bf0651065e4463da2e7c81d9ac57">ConicBundle::SumBlockModel</a>, <a class="el" href="classConicBundle_1_1AFTModel.html#a7b97d029f52c01d1f7259b02eac63f1a">ConicBundle::AFTModel</a>, and <a class="el" href="classConicBundle_1_1ConeModel.html#ac6416fcea29d28f41bd97085dfa9af18">ConicBundle::ConeModel</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="BundleModel_8hxx_source.html">BundleModel.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
