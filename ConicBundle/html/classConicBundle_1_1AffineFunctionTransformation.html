<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ConicBundle: ConicBundle::AffineFunctionTransformation Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ConicBundle
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceConicBundle.html">ConicBundle</a></li><li class="navelem"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html">AffineFunctionTransformation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classConicBundle_1_1AffineFunctionTransformation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ConicBundle::AffineFunctionTransformation Class Reference<div class="ingroups"><a class="el" href="group__cxxmatrixinterface.html">Interface to ConicBundle for the Language C++ using Matrix Classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>transform a function f(z) to fun_coeff*f(arg_offset+arg_trafo*y)+linear_cost*y+fun_offset (scales the value, substitutes argument z=c+Ay, and adds an affine term b'y+d)  
 <a href="classConicBundle_1_1AffineFunctionTransformation.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="AffineFunctionTransformation_8hxx_source.html">AffineFunctionTransformation.hxx</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ConicBundle::AffineFunctionTransformation:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classConicBundle_1_1AffineFunctionTransformation.png" usemap="#ConicBundle::AffineFunctionTransformation_map" alt=""/>
  <map id="ConicBundle::AffineFunctionTransformation_map" name="ConicBundle::AffineFunctionTransformation_map">
<area href="classConicBundle_1_1CBout.html" title="base class for uniform use of WARNINGS and ERRORS (at some point in time) " alt="ConicBundle::CBout" shape="rect" coords="0,0,257,24"/>
<area href="classConicBundle_1_1FunctionObject.html" title="basic function object (abstract class). It serves for using the same interface on distinct oracle typ..." alt="ConicBundle::FunctionObject" shape="rect" coords="267,0,524,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeca8f4a359cc631a24442140c87ecf8f"><td class="memItemLeft" align="right" valign="top"><a id="aeca8f4a359cc631a24442140c87ecf8f"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#aeca8f4a359cc631a24442140c87ecf8f">init</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a7110f39ac8f6becd0f5ce1d0dfd7db0b">fun_coeff</a>=1., <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a8a0ed258d0d3a4d6afaac1284cc14ad8">fun_offset</a>=0., <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *<a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a24024189f0d5468007dfd5b908fb84ed">linear_cost</a>=0, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *<a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#ad07971a8ac950a2cad08edb6e814d642">arg_offset</a>=0, <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">CH_Matrix_Classes::Sparsemat</a> *<a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a0525a6e9fc81d36322f68b9cc52442ba">arg_trafo</a>=0, bool <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#ace86b937fe3f6bc72c589c057ed34d3f">model_calls_delete</a>=true)</td></tr>
<tr class="memdesc:aeca8f4a359cc631a24442140c87ecf8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the parameters of the transformation. The ownership of objects pointed to is passed to *this (they will be deleted here). If *this is entered into an <a class="el" href="classConicBundle_1_1AFTModel.html" title="mimicks the model of a function with an AffineFunctionTransformation (AFT) applied to it...">AFTModel</a>, model_calls_delete==true tells the <a class="el" href="classConicBundle_1_1AFTModel.html" title="mimicks the model of a function with an AffineFunctionTransformation (AFT) applied to it...">AFTModel</a> to delete this <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html" title="transform a function f(z) to fun_coeff*f(arg_offset+arg_trafo*y)+linear_cost*y+fun_offset (scales the...">AffineFunctionTransformation</a> at the end. <br /></td></tr>
<tr class="separator:aeca8f4a359cc631a24442140c87ecf8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ac7f58a483229e404db5509c90d7d3"><td class="memItemLeft" align="right" valign="top"><a id="a00ac7f58a483229e404db5509c90d7d3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a00ac7f58a483229e404db5509c90d7d3">AffineFunctionTransformation</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> in_fun_coeff=1., <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> in_fun_offset=0., <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *in_linear_cost=0, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *in_arg_offset=0, <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">CH_Matrix_Classes::Sparsemat</a> *in_arg_trafo=0, bool in_model_calls_delete=true, <a class="el" href="classConicBundle_1_1CBout.html">CBout</a> *cbo=0, int incr=-1)</td></tr>
<tr class="memdesc:a00ac7f58a483229e404db5509c90d7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">calls <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#aeca8f4a359cc631a24442140c87ecf8f" title="sets the parameters of the transformation. The ownership of objects pointed to is passed to *this (th...">init()</a> <br /></td></tr>
<tr class="separator:a00ac7f58a483229e404db5509c90d7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f17fec01f7869a189bd3a5e7eb6aa8b"><td class="memItemLeft" align="right" valign="top"><a id="a7f17fec01f7869a189bd3a5e7eb6aa8b"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a7f17fec01f7869a189bd3a5e7eb6aa8b">~AffineFunctionTransformation</a> ()</td></tr>
<tr class="memdesc:a7f17fec01f7869a189bd3a5e7eb6aa8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">deletes <em>linear_cost</em>, <em>arg_offset</em> and <em>arg_trafo</em> <br /></td></tr>
<tr class="separator:a7f17fec01f7869a189bd3a5e7eb6aa8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59506b31eff7cb0a6b2953408618174f"><td class="memItemLeft" align="right" valign="top"><a id="a59506b31eff7cb0a6b2953408618174f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a59506b31eff7cb0a6b2953408618174f">get_model_calls_delete</a> ()</td></tr>
<tr class="memdesc:a59506b31eff7cb0a6b2953408618174f"><td class="mdescLeft">&#160;</td><td class="mdescRight">retruns true if the model has to delete this <br /></td></tr>
<tr class="separator:a59506b31eff7cb0a6b2953408618174f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1b67c3e6005174b5dacd2f6513ee47"><td class="memItemLeft" align="right" valign="top"><a id="a6e1b67c3e6005174b5dacd2f6513ee47"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a6e1b67c3e6005174b5dacd2f6513ee47">set_model_calls_delete</a> (bool mcd)</td></tr>
<tr class="memdesc:a6e1b67c3e6005174b5dacd2f6513ee47"><td class="mdescLeft">&#160;</td><td class="mdescRight">set to true if the model has to delete this, to false if it is destructed elsewhere <br /></td></tr>
<tr class="separator:a6e1b67c3e6005174b5dacd2f6513ee47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3cc02ef5840ee6ada8f07de7aef9685"><td class="memItemLeft" align="right" valign="top"><a id="ad3cc02ef5840ee6ada8f07de7aef9685"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#ad3cc02ef5840ee6ada8f07de7aef9685">argument_changes</a> () const</td></tr>
<tr class="memdesc:ad3cc02ef5840ee6ada8f07de7aef9685"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if not the identity <br /></td></tr>
<tr class="separator:ad3cc02ef5840ee6ada8f07de7aef9685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794eb38df431aea51fe46b7cf4c692c4"><td class="memItemLeft" align="right" valign="top"><a id="a794eb38df431aea51fe46b7cf4c692c4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a794eb38df431aea51fe46b7cf4c692c4">sparse_argument_changes</a> () const</td></tr>
<tr class="memdesc:a794eb38df431aea51fe46b7cf4c692c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if arg_trafo influences at most two thirds of the entries of local_argument <br /></td></tr>
<tr class="separator:a794eb38df431aea51fe46b7cf4c692c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91475389b4c8dc0470b3c29de8761d59"><td class="memItemLeft" align="right" valign="top"><a id="a91475389b4c8dc0470b3c29de8761d59"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a91475389b4c8dc0470b3c29de8761d59">scaled_index_subset</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> *col_ind, const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> *row_ind) const</td></tr>
<tr class="memdesc:a91475389b4c8dc0470b3c29de8761d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the transformation maps each index (in col_ind if !=0) onto at most one index and vice versa (out of row_ind if !=0) <br /></td></tr>
<tr class="separator:a91475389b4c8dc0470b3c29de8761d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada28a0ffd9b046467eee7e99f2fedadd"><td class="memItemLeft" align="right" valign="top"><a id="ada28a0ffd9b046467eee7e99f2fedadd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#ada28a0ffd9b046467eee7e99f2fedadd">scaled_index</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> &amp;mapped_index, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> &amp;coeff, <a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> index) const</td></tr>
<tr class="memdesc:ada28a0ffd9b046467eee7e99f2fedadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns false if index is mapped to more than one index, otherwise true with mapped_index==-1 if mapped to zero, else &gt;=0 and <em>coeff</em> gives the coefficient <br /></td></tr>
<tr class="separator:ada28a0ffd9b046467eee7e99f2fedadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa148eda96937fa6684041c515202a8b1"><td class="memItemLeft" align="right" valign="top"><a id="aa148eda96937fa6684041c515202a8b1"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#aa148eda96937fa6684041c515202a8b1">get_fun_coeff</a> () const</td></tr>
<tr class="memdesc:aa148eda96937fa6684041c515202a8b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the factor for the function <br /></td></tr>
<tr class="separator:aa148eda96937fa6684041c515202a8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77762bf28fed93b65440eba37cbf3d09"><td class="memItemLeft" align="right" valign="top"><a id="a77762bf28fed93b65440eba37cbf3d09"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a77762bf28fed93b65440eba37cbf3d09">set_fun_coeff</a> ()</td></tr>
<tr class="memdesc:a77762bf28fed93b65440eba37cbf3d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">allows to set the factor for the function <br /></td></tr>
<tr class="separator:a77762bf28fed93b65440eba37cbf3d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36798f0bcf0b3078f66b997e4848398a"><td class="memItemLeft" align="right" valign="top"><a id="a36798f0bcf0b3078f66b997e4848398a"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a36798f0bcf0b3078f66b997e4848398a">get_fun_offset</a> () const</td></tr>
<tr class="memdesc:a36798f0bcf0b3078f66b997e4848398a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the constant offset for the funciton <br /></td></tr>
<tr class="separator:a36798f0bcf0b3078f66b997e4848398a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ca61db4c7b9946538f9f2ba6fe529a"><td class="memItemLeft" align="right" valign="top"><a id="ae0ca61db4c7b9946538f9f2ba6fe529a"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#ae0ca61db4c7b9946538f9f2ba6fe529a">set_fun_offset</a> ()</td></tr>
<tr class="memdesc:ae0ca61db4c7b9946538f9f2ba6fe529a"><td class="mdescLeft">&#160;</td><td class="mdescRight">allows to set the constant offset for the funciton <br /></td></tr>
<tr class="separator:ae0ca61db4c7b9946538f9f2ba6fe529a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa0cff1ce4af74730661e31295919ea"><td class="memItemLeft" align="right" valign="top"><a id="a9fa0cff1ce4af74730661e31295919ea"></a>
const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a9fa0cff1ce4af74730661e31295919ea">get_linear_cost</a> () const</td></tr>
<tr class="memdesc:a9fa0cff1ce4af74730661e31295919ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the pointer to the linear term added to the funciton <br /></td></tr>
<tr class="separator:a9fa0cff1ce4af74730661e31295919ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030d137dafbd503efaba9bf10e4b0bee"><td class="memItemLeft" align="right" valign="top"><a id="a030d137dafbd503efaba9bf10e4b0bee"></a>
const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a030d137dafbd503efaba9bf10e4b0bee">get_arg_offset</a> () const</td></tr>
<tr class="memdesc:a030d137dafbd503efaba9bf10e4b0bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the pointer to the constant offset added to the argument (not neeeded in the code) <br /></td></tr>
<tr class="separator:a030d137dafbd503efaba9bf10e4b0bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c2b8b0c223a469a8dec94dae3471f4"><td class="memItemLeft" align="right" valign="top"><a id="a53c2b8b0c223a469a8dec94dae3471f4"></a>
const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">CH_Matrix_Classes::Sparsemat</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a53c2b8b0c223a469a8dec94dae3471f4">get_arg_trafo</a> () const</td></tr>
<tr class="memdesc:a53c2b8b0c223a469a8dec94dae3471f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the pointer to the linear transformation of the argument (not neeeded in the code) <br /></td></tr>
<tr class="separator:a53c2b8b0c223a469a8dec94dae3471f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f514d49b3765916e517a3dbe3568193"><td class="memItemLeft" align="right" valign="top"><a id="a9f514d49b3765916e517a3dbe3568193"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a9f514d49b3765916e517a3dbe3568193">get_linear_cost</a> (<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a> i) const</td></tr>
<tr class="memdesc:a9f514d49b3765916e517a3dbe3568193"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the value of the linear cost coefficient for <em>i&gt;=0</em> and for i==-1 the constant offset <br /></td></tr>
<tr class="separator:a9f514d49b3765916e517a3dbe3568193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b9f9269ed68e04fb9c65710e15f504"><td class="memItemLeft" align="right" valign="top"><a id="a48b9f9269ed68e04fb9c65710e15f504"></a>
const <a class="el" href="classConicBundle_1_1MinorantPointer.html">MinorantPointer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a48b9f9269ed68e04fb9c65710e15f504">get_constant_minorant</a> () const</td></tr>
<tr class="memdesc:a48b9f9269ed68e04fb9c65710e15f504"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the constant linear minorant corresponding to fun_offset+&lt;*linear_cost,.&gt; <br /></td></tr>
<tr class="separator:a48b9f9269ed68e04fb9c65710e15f504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5076a130e66c0f880c8f2d42a41db65"><td class="memItemLeft" align="right" valign="top"><a id="ab5076a130e66c0f880c8f2d42a41db65"></a>
<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#ab5076a130e66c0f880c8f2d42a41db65">from_dim</a> () const</td></tr>
<tr class="memdesc:ab5076a130e66c0f880c8f2d42a41db65"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the dimension of the input argument or -1 if it is unknown <br /></td></tr>
<tr class="separator:ab5076a130e66c0f880c8f2d42a41db65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d03fcecc1a2a3f2d5a2fe9aeb4338f"><td class="memItemLeft" align="right" valign="top"><a id="a02d03fcecc1a2a3f2d5a2fe9aeb4338f"></a>
<a class="el" href="group__matop__types.html#ga325dd69690071a98f09a8d74c50edccd">CH_Matrix_Classes::Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a02d03fcecc1a2a3f2d5a2fe9aeb4338f">to_dim</a> () const</td></tr>
<tr class="memdesc:a02d03fcecc1a2a3f2d5a2fe9aeb4338f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the dimension of the output argument or -1 if it is unknown <br /></td></tr>
<tr class="separator:a02d03fcecc1a2a3f2d5a2fe9aeb4338f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e754b423800692c07ea0db95b37aa7"><td class="memItemLeft" align="right" valign="top"><a id="a40e754b423800692c07ea0db95b37aa7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a40e754b423800692c07ea0db95b37aa7">copy_traforows</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;copy_to, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;copy_from) const</td></tr>
<tr class="memdesc:a40e754b423800692c07ea0db95b37aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">only copies the elements that are effected by the image of arg_trafo <br /></td></tr>
<tr class="separator:a40e754b423800692c07ea0db95b37aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1227a8b982fbe771f795effbc4be7223"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a1227a8b982fbe771f795effbc4be7223">transform_argument</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;transformed_y, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> &amp;transformed_offset, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;input_y) const</td></tr>
<tr class="memdesc:a1227a8b982fbe771f795effbc4be7223"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes <em>transformed_offset</em> and, if <em>this</em> is not the identity,<em>transformed_y</em> and returns either <em>input_y</em> (id) or <em>transformed_y</em>  <a href="#a1227a8b982fbe771f795effbc4be7223">More...</a><br /></td></tr>
<tr class="separator:a1227a8b982fbe771f795effbc4be7223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b1cd43ec820b8221f04b86d3003441"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a59b1cd43ec820b8221f04b86d3003441">modified_transform_argument</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;transformed_y, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;input_y, const <a class="el" href="classConicBundle_1_1AFTModification.html">AFTModification</a> *aftmdf, const <a class="el" href="classConicBundle_1_1GroundsetModification.html">GroundsetModification</a> &amp;gsmdf) const</td></tr>
<tr class="memdesc:a59b1cd43ec820b8221f04b86d3003441"><td class="mdescLeft">&#160;</td><td class="mdescRight">given the modification aftmdf or if 0, gsmdf, compute the transformed argument that would arise after this modification as in <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a1227a8b982fbe771f795effbc4be7223" title="computes transformed_offset and, if this is not the identity,transformed_y and returns either input_y...">transform_argument()</a>  <a href="#a59b1cd43ec820b8221f04b86d3003441">More...</a><br /></td></tr>
<tr class="separator:a59b1cd43ec820b8221f04b86d3003441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac292d5cb84ce5a428c39100628c5f12a"><td class="memItemLeft" align="right" valign="top"><a id="ac292d5cb84ce5a428c39100628c5f12a"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#ac292d5cb84ce5a428c39100628c5f12a">objective_value</a> (<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> offset, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> function_value) const</td></tr>
<tr class="memdesc:ac292d5cb84ce5a428c39100628c5f12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">if <em>offset</em> is the value computed in transform_argument and <em>function_value</em> results form an evaluation in the respective point, the routine returns the objective value obtained by the affine transformation <br /></td></tr>
<tr class="separator:ac292d5cb84ce5a428c39100628c5f12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae391744eb677c8297e6c6d1755339f36"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#ae391744eb677c8297e6c6d1755339f36">transform_minorant</a> (<a class="el" href="classConicBundle_1_1MinorantPointer.html">MinorantPointer</a> &amp;out_minorant, const <a class="el" href="classConicBundle_1_1MinorantPointer.html">MinorantPointer</a> &amp;in_minorant, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> alpha=1., bool add_trafo_minorant=false, const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> *provided_row_indices=0, const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> *needed_column_indices=0) const</td></tr>
<tr class="memdesc:ae391744eb677c8297e6c6d1755339f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">transforms the in linear minorant (scaled by alpha) and initializes or adds it to the out linear minorant  <a href="#ae391744eb677c8297e6c6d1755339f36">More...</a><br /></td></tr>
<tr class="separator:ae391744eb677c8297e6c6d1755339f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7ab330645afcf50c784f8dc5c55cc7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a6f7ab330645afcf50c784f8dc5c55cc7">transform_minorants</a> (<a class="el" href="namespaceConicBundle.html#a4a6fea9e6a9e2452161e186d3faa1ae9">MinorantBundle</a> &amp;out_minorants, const <a class="el" href="namespaceConicBundle.html#a4a6fea9e6a9e2452161e186d3faa1ae9">MinorantBundle</a> &amp;in_minorants, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> alpha=1.) const</td></tr>
<tr class="memdesc:a6f7ab330645afcf50c784f8dc5c55cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">transforms several linear minorants (scaled by alpha) and initializes or adds them to the out linear minorants  <a href="#a6f7ab330645afcf50c784f8dc5c55cc7">More...</a><br /></td></tr>
<tr class="separator:a6f7ab330645afcf50c784f8dc5c55cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5e876211f5b1588488c55ed303e916"><td class="memItemLeft" align="right" valign="top"><a id="acd5e876211f5b1588488c55ed303e916"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#acd5e876211f5b1588488c55ed303e916">qp_cost_indices</a> (<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> &amp;provide_row_indices, const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> *needed_col_indices) const</td></tr>
<tr class="memdesc:acd5e876211f5b1588488c55ed303e916"><td class="mdescLeft">&#160;</td><td class="mdescRight">if the algorithm only requires the indices given in <em>needed_col_indices</em> (NULL means all indices) then it suffices to supply the <em>provide_row_indices</em> as <em>indices</em> in transform_minorant (a 0x0 return matrix again means all indices, while a 0x1 matrix means no indices). Any input or output indices must be in strictly increasing order. <br /></td></tr>
<tr class="separator:acd5e876211f5b1588488c55ed303e916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862ae1f627c1c69a3ffe330a20b66d6b"><td class="memItemLeft" align="right" valign="top"><a id="a862ae1f627c1c69a3ffe330a20b66d6b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a862ae1f627c1c69a3ffe330a20b66d6b">scaling_indices</a> (<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> &amp;row_indices, const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> &amp;col_indices) const</td></tr>
<tr class="memdesc:a862ae1f627c1c69a3ffe330a20b66d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">if AFTModel::add_diagonal_scaling() is called with <em>indices</em> specified by <em>col_indices</em>, then AFTmodel has to provide a diagonal scaling matrix of dimension <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a02d03fcecc1a2a3f2d5a2fe9aeb4338f" title="returns the dimension of the output argument or -1 if it is unknown ">to_dim()</a> as <em>in_diagscale</em> in <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#aa2c195010720fc18a8f4d0d99d1ee794" title="transform the scaling matrix in_diagscale of the untransformed function model and add it as described...">add_diagonal_scaling()</a> with the entries in the output vector <em>row_indices</em> computed correctly. <br /></td></tr>
<tr class="separator:a862ae1f627c1c69a3ffe330a20b66d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c195010720fc18a8f4d0d99d1ee794"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#aa2c195010720fc18a8f4d0d99d1ee794">add_diagonal_scaling</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;diagscale, const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> *indices, <a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> alpha, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;in_diagscale) const</td></tr>
<tr class="memdesc:aa2c195010720fc18a8f4d0d99d1ee794"><td class="mdescLeft">&#160;</td><td class="mdescRight">transform the scaling matrix in_diagscale of the untransformed function model and add it as described in BundleMethod::add_diagonal_scaling.  <a href="#aa2c195010720fc18a8f4d0d99d1ee794">More...</a><br /></td></tr>
<tr class="separator:aa2c195010720fc18a8f4d0d99d1ee794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24bc785fdef7af1643c2a765dddf3daf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classConicBundle_1_1GroundsetModification.html">GroundsetModification</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a24bc785fdef7af1643c2a765dddf3daf">analyze_modification</a> (bool &amp;minorant_trafo_differs, const <a class="el" href="classConicBundle_1_1AFTModification.html">AFTModification</a> *aftmdf, const <a class="el" href="classConicBundle_1_1GroundsetModification.html">GroundsetModification</a> &amp;gsmdf) const</td></tr>
<tr class="memdesc:a24bc785fdef7af1643c2a765dddf3daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns information on the changes in the ground set of the transformed arguments and checks whether after the modification the nonzero image of the transformed minorants will not differ from before; returns NULL on errors.  <a href="#a24bc785fdef7af1643c2a765dddf3daf">More...</a><br /></td></tr>
<tr class="separator:a24bc785fdef7af1643c2a765dddf3daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149cd8c0c61b04dd8d881067aa456cf7"><td class="memItemLeft" align="right" valign="top"><a id="a149cd8c0c61b04dd8d881067aa456cf7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a149cd8c0c61b04dd8d881067aa456cf7">apply_modification</a> (const <a class="el" href="classConicBundle_1_1AFTModification.html">AFTModification</a> *aftmdf, const <a class="el" href="classConicBundle_1_1GroundsetModification.html">GroundsetModification</a> &amp;gsmdf)</td></tr>
<tr class="memdesc:a149cd8c0c61b04dd8d881067aa456cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">if arg_trafo==NULL (act as identity) and if aftmdf!=NULL adds any explicit matrix parts or has modifications not consistent with maintaining the identity, arg_trafo is first set to an explicit identity before executing the modification. If arg_trafo==NULL and aftmdf==NULL, the transformations of gsmdf are applied to linear_cost and arg_offset. <br /></td></tr>
<tr class="separator:a149cd8c0c61b04dd8d881067aa456cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac157573d362213b00a544fc04739a2d3"><td class="memItemLeft" align="right" valign="top"><a id="ac157573d362213b00a544fc04739a2d3"></a>
virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#ac157573d362213b00a544fc04739a2d3">output_aft_data</a> (std::ostream &amp;<a class="el" href="classConicBundle_1_1CBout.html#a1125693307dcbd83770e4569bf99ba19">out</a>) const</td></tr>
<tr class="memdesc:ac157573d362213b00a544fc04739a2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">for testing purposes this outputs the data in mfile readable form <br /></td></tr>
<tr class="separator:ac157573d362213b00a544fc04739a2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classConicBundle_1_1CBout"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classConicBundle_1_1CBout')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classConicBundle_1_1CBout.html">ConicBundle::CBout</a></td></tr>
<tr class="memitem:aed9a878aa9f402077e1f6453c0606535 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#aed9a878aa9f402077e1f6453c0606535">set_out</a> (std::ostream *<a class="el" href="classConicBundle_1_1CBout.html#a1125693307dcbd83770e4569bf99ba19">out</a>=0, int <a class="el" href="classConicBundle_1_1CBout.html#a5ce873e4d4d6b00096d822fa65fd4d7a">print_level</a>=1)</td></tr>
<tr class="memdesc:aed9a878aa9f402077e1f6453c0606535 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the output level (out==NULL: no output at all, out!=NULL and level=0: errors and warnings, level&gt;0 increasingly detailed information)  <a href="classConicBundle_1_1CBout.html#aed9a878aa9f402077e1f6453c0606535">More...</a><br /></td></tr>
<tr class="separator:aed9a878aa9f402077e1f6453c0606535 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac4530f6a6e43d48833a16aa26358e2 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#adac4530f6a6e43d48833a16aa26358e2">set_cbout</a> (const <a class="el" href="classConicBundle_1_1CBout.html">CBout</a> *cb, int incr=-1)</td></tr>
<tr class="memdesc:adac4530f6a6e43d48833a16aa26358e2 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the output level relative to the given <a class="el" href="classConicBundle_1_1CBout.html" title="base class for uniform use of WARNINGS and ERRORS (at some point in time) ">CBout</a> class.  <a href="classConicBundle_1_1CBout.html#adac4530f6a6e43d48833a16aa26358e2">More...</a><br /></td></tr>
<tr class="separator:adac4530f6a6e43d48833a16aa26358e2 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07122b66dbab4e1e411c807079fda6b0 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="a07122b66dbab4e1e411c807079fda6b0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#a07122b66dbab4e1e411c807079fda6b0">clear_cbout</a> ()</td></tr>
<tr class="memdesc:a07122b66dbab4e1e411c807079fda6b0 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset to default settings (out=0,print_level=1) <br /></td></tr>
<tr class="separator:a07122b66dbab4e1e411c807079fda6b0 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e96394f860c57d18c7c1d096c21cf9 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="aa9e96394f860c57d18c7c1d096c21cf9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#aa9e96394f860c57d18c7c1d096c21cf9">CBout</a> (const <a class="el" href="classConicBundle_1_1CBout.html">CBout</a> *cb=0, int incr=-1)</td></tr>
<tr class="memdesc:aa9e96394f860c57d18c7c1d096c21cf9 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">calls set_cbout <br /></td></tr>
<tr class="separator:aa9e96394f860c57d18c7c1d096c21cf9 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24445af38af55dfbd25bfe3055a53d17 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="a24445af38af55dfbd25bfe3055a53d17"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#a24445af38af55dfbd25bfe3055a53d17">CBout</a> (std::ostream *outp, int pl=1)</td></tr>
<tr class="memdesc:a24445af38af55dfbd25bfe3055a53d17 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize correspondingly <br /></td></tr>
<tr class="separator:a24445af38af55dfbd25bfe3055a53d17 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4defbb041e13bf58221e54bba4554335 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="a4defbb041e13bf58221e54bba4554335"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#a4defbb041e13bf58221e54bba4554335">CBout</a> (const <a class="el" href="classConicBundle_1_1CBout.html">CBout</a> &amp;cb, int incr=0)</td></tr>
<tr class="memdesc:a4defbb041e13bf58221e54bba4554335 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor <br /></td></tr>
<tr class="separator:a4defbb041e13bf58221e54bba4554335 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04ddacb98b92a196319a2483774d4f4 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="ab04ddacb98b92a196319a2483774d4f4"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#ab04ddacb98b92a196319a2483774d4f4">cb_out</a> (int pl=-1) const</td></tr>
<tr class="memdesc:ab04ddacb98b92a196319a2483774d4f4 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if out!=0 and (pl&lt;print_level), pl&lt;0 should be used for WARNINGS and ERRORS only, pl==0 for usual output. <br /></td></tr>
<tr class="separator:ab04ddacb98b92a196319a2483774d4f4 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55dcbb4c6fff8dc3485f9dd3cb309af8 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="a55dcbb4c6fff8dc3485f9dd3cb309af8"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#a55dcbb4c6fff8dc3485f9dd3cb309af8">get_out</a> () const</td></tr>
<tr class="memdesc:a55dcbb4c6fff8dc3485f9dd3cb309af8 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="classConicBundle_1_1CBout.html#ab04ddacb98b92a196319a2483774d4f4" title="Returns true if out!=0 and (pl&lt;print_level), pl&lt;0 should be used for WARNINGS and ERRORS only...">cb_out()</a> returned true, this returns the output stream, but it will abort if called with out==0. <br /></td></tr>
<tr class="separator:a55dcbb4c6fff8dc3485f9dd3cb309af8 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b55664bdf89963b87c94e7fa69b8fd1 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="a6b55664bdf89963b87c94e7fa69b8fd1"></a>
std::ostream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#a6b55664bdf89963b87c94e7fa69b8fd1">get_out_ptr</a> () const</td></tr>
<tr class="memdesc:a6b55664bdf89963b87c94e7fa69b8fd1 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the pointer to the output stream <br /></td></tr>
<tr class="separator:a6b55664bdf89963b87c94e7fa69b8fd1 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88e5f8f443a40c6cb506e2c808525a3 inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="ad88e5f8f443a40c6cb506e2c808525a3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#ad88e5f8f443a40c6cb506e2c808525a3">get_print_level</a> () const</td></tr>
<tr class="memdesc:ad88e5f8f443a40c6cb506e2c808525a3 inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the print_level <br /></td></tr>
<tr class="separator:ad88e5f8f443a40c6cb506e2c808525a3 inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dda97ab7acdfab7e95b89a25cc9541c inherit pub_methods_classConicBundle_1_1CBout"><td class="memItemLeft" align="right" valign="top"><a id="a5dda97ab7acdfab7e95b89a25cc9541c"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBout.html#a5dda97ab7acdfab7e95b89a25cc9541c">mfile_data</a> (std::ostream &amp;<a class="el" href="classConicBundle_1_1CBout.html#a1125693307dcbd83770e4569bf99ba19">out</a>) const</td></tr>
<tr class="memdesc:a5dda97ab7acdfab7e95b89a25cc9541c inherit pub_methods_classConicBundle_1_1CBout"><td class="mdescLeft">&#160;</td><td class="mdescRight">writes problem data to the given outstream <br /></td></tr>
<tr class="separator:a5dda97ab7acdfab7e95b89a25cc9541c inherit pub_methods_classConicBundle_1_1CBout"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7110f39ac8f6becd0f5ce1d0dfd7db0b"><td class="memItemLeft" align="right" valign="top"><a id="a7110f39ac8f6becd0f5ce1d0dfd7db0b"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a7110f39ac8f6becd0f5ce1d0dfd7db0b">fun_coeff</a></td></tr>
<tr class="memdesc:a7110f39ac8f6becd0f5ce1d0dfd7db0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">function value is multiplied by this <br /></td></tr>
<tr class="separator:a7110f39ac8f6becd0f5ce1d0dfd7db0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0ed258d0d3a4d6afaac1284cc14ad8"><td class="memItemLeft" align="right" valign="top"><a id="a8a0ed258d0d3a4d6afaac1284cc14ad8"></a>
<a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a8a0ed258d0d3a4d6afaac1284cc14ad8">fun_offset</a></td></tr>
<tr class="memdesc:a8a0ed258d0d3a4d6afaac1284cc14ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">constant added in the end <br /></td></tr>
<tr class="separator:a8a0ed258d0d3a4d6afaac1284cc14ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24024189f0d5468007dfd5b908fb84ed"><td class="memItemLeft" align="right" valign="top"><a id="a24024189f0d5468007dfd5b908fb84ed"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a24024189f0d5468007dfd5b908fb84ed">linear_cost</a></td></tr>
<tr class="memdesc:a24024189f0d5468007dfd5b908fb84ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">NULL means no linear cost. <br /></td></tr>
<tr class="separator:a24024189f0d5468007dfd5b908fb84ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07971a8ac950a2cad08edb6e814d642"><td class="memItemLeft" align="right" valign="top"><a id="ad07971a8ac950a2cad08edb6e814d642"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#ad07971a8ac950a2cad08edb6e814d642">arg_offset</a></td></tr>
<tr class="memdesc:ad07971a8ac950a2cad08edb6e814d642"><td class="mdescLeft">&#160;</td><td class="mdescRight">NULL means no offset. <br /></td></tr>
<tr class="separator:ad07971a8ac950a2cad08edb6e814d642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0525a6e9fc81d36322f68b9cc52442ba"><td class="memItemLeft" align="right" valign="top"><a id="a0525a6e9fc81d36322f68b9cc52442ba"></a>
<a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">CH_Matrix_Classes::Sparsemat</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a0525a6e9fc81d36322f68b9cc52442ba">arg_trafo</a></td></tr>
<tr class="memdesc:a0525a6e9fc81d36322f68b9cc52442ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">NULL means identity (!!!) <br /></td></tr>
<tr class="separator:a0525a6e9fc81d36322f68b9cc52442ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070ac5f7d3d0b42287ebc2b3672184e7"><td class="memItemLeft" align="right" valign="top"><a id="a070ac5f7d3d0b42287ebc2b3672184e7"></a>
<a class="el" href="classConicBundle_1_1MinorantPointer.html">MinorantPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a070ac5f7d3d0b42287ebc2b3672184e7">constant_minorant</a></td></tr>
<tr class="memdesc:a070ac5f7d3d0b42287ebc2b3672184e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">corresponds to fun_offset + &lt;*linear_cost,.&gt; <br /></td></tr>
<tr class="separator:a070ac5f7d3d0b42287ebc2b3672184e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4e360e9b165ab279409d60f93de974"><td class="memItemLeft" align="right" valign="top"><a id="aaf4e360e9b165ab279409d60f93de974"></a>
<a class="el" href="classConicBundle_1_1GroundsetModification.html">GroundsetModification</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#aaf4e360e9b165ab279409d60f93de974">local_gsmdf</a></td></tr>
<tr class="memdesc:aaf4e360e9b165ab279409d60f93de974"><td class="mdescLeft">&#160;</td><td class="mdescRight">this describes the effect of the last modification on the image space (if there was one at all) <br /></td></tr>
<tr class="separator:aaf4e360e9b165ab279409d60f93de974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace86b937fe3f6bc72c589c057ed34d3f"><td class="memItemLeft" align="right" valign="top"><a id="ace86b937fe3f6bc72c589c057ed34d3f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#ace86b937fe3f6bc72c589c057ed34d3f">model_calls_delete</a></td></tr>
<tr class="memdesc:ace86b937fe3f6bc72c589c057ed34d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">tells the model whether it should delete this at the end of its use or just leave it alone (i.e., this AFT is then owned by someone else) <br /></td></tr>
<tr class="separator:ace86b937fe3f6bc72c589c057ed34d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>transform a function f(z) to fun_coeff*f(arg_offset+arg_trafo*y)+linear_cost*y+fun_offset (scales the value, substitutes argument z=c+Ay, and adds an affine term b'y+d) </p>
<p>The <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html" title="transform a function f(z) to fun_coeff*f(arg_offset+arg_trafo*y)+linear_cost*y+fun_offset (scales the...">AffineFunctionTransformation</a> (AFT for short) allows to use an implemented function oracle for <img class="formulaInl" alt="$f\colon\mathbf{R}^n\to\mathbf{R},\quad z\mapsto f(z)$" src="form_245.png"/> as a function oracle of the function</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ g:\mathbf{R}^m\to\mathbf{R},\quad y\mapsto g(y)=\sigma f(c+Ay)+b^\top y+\delta \]" src="form_246.png"/>
</p>
<p>where</p><ul>
<li><img class="formulaInl" alt="$\sigma\ge 0$" src="form_247.png"/> (Real <em>fun_coeff</em>, default value 1) scales the function value (0 is allowed to cancel the function for cases where removing it might cause difficulties)</li>
<li><img class="formulaInl" alt="$c+Ay$" src="form_248.png"/> specifies an affine transformation of the argument with<ul>
<li><img class="formulaInl" alt="$c\in\mathbf{R}^n$" src="form_249.png"/> (Matrix pointed to by <em>arg_offset</em>, NULL pointer represents <img class="formulaInl" alt="$c=0$" src="form_250.png"/>)</li>
<li><img class="formulaInl" alt="$A\in\mathbf{R}^{n\times m}$" src="form_251.png"/> (Sparsemat pointed to by <em>arg_trafo</em>, NULL pointer represents <img class="formulaInl" alt="$A=I_n$" src="form_252.png"/>, so indeed the IDENTITY and NOT the zero matrix)</li>
</ul>
</li>
<li><img class="formulaInl" alt="$b\in\mathbf{R}^m$" src="form_253.png"/> (Matrix pointed to by <em>linear_cost</em>, NULL pointer represents <img class="formulaInl" alt="$b=0$" src="form_254.png"/>) adds a linear cost term <img class="formulaInl" alt="$b^\top y$" src="form_255.png"/></li>
<li><img class="formulaInl" alt="$\delta\in\mathbf{R}$" src="form_256.png"/> (Real <em>fun_offset</em>, default value=0) adds a constant offset</li>
</ul>
<p>If (some of) the pointers to matrices are specified, ownership of the matrix objects pointed to will be taken over by the AFT and the objects will be deleted by this class at the end of their use.</p>
<p>Note, if <em>arg_offset</em> and <em>arg_trafo</em> are both zero, then the argument does not change at all. If all three matrix pointers are zero, there is no information on the dimension of the transformation, so it will be determined by the arguments supplied.</p>
<p>Using value 0. for <em>fun_coeff</em> is allowed and removes the influence of the function completely, leaving only the affine function in y specified by <em>fun_offset</em> and <em>linear_cost</em>.</p>
<p>Internally, the <a class="el" href="classConicBundle_1_1SumBlockModel.html" title="abstract interface extending BundleModel so that any such model can be used alone or within SumModel ...">SumBlockModel</a> realization of the AFT is achieved by <a class="el" href="classConicBundle_1_1AFTModel.html" title="mimicks the model of a function with an AffineFunctionTransformation (AFT) applied to it...">AFTModel</a>. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aa2c195010720fc18a8f4d0d99d1ee794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c195010720fc18a8f4d0d99d1ee794">&#9670;&nbsp;</a></span>add_diagonal_scaling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::AffineFunctionTransformation::add_diagonal_scaling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>diagscale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a>&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>in_diagscale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>transform the scaling matrix in_diagscale of the untransformed function model and add it as described in BundleMethod::add_diagonal_scaling. </p>
<p>If indices are given, they must be sorted in striclty increasing order. </p>

<p class="reference">Referenced by <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#ac292d5cb84ce5a428c39100628c5f12a">objective_value()</a>.</p>

</div>
</div>
<a id="a24bc785fdef7af1643c2a765dddf3daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24bc785fdef7af1643c2a765dddf3daf">&#9670;&nbsp;</a></span>analyze_modification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classConicBundle_1_1GroundsetModification.html">GroundsetModification</a>* ConicBundle::AffineFunctionTransformation::analyze_modification </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>minorant_trafo_differs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1AFTModification.html">AFTModification</a> *&#160;</td>
          <td class="paramname"><em>aftmdf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1GroundsetModification.html">GroundsetModification</a> &amp;&#160;</td>
          <td class="paramname"><em>gsmdf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns information on the changes in the ground set of the transformed arguments and checks whether after the modification the nonzero image of the transformed minorants will not differ from before; returns NULL on errors. </p>
<p>If arg_trafo==NULL (act as identity) and if aftmdf!=NULL adds any explicit matrix parts or has modifications not consistent with maintaining the identity, arg_trafo is virtually first set to an explicit identity before executing the modification. If arg_trafo==NULL and aftmdf==NULL, the transformations of gsmdf are applied to linear_cost and arg_offset.</p>
<p>If the input <em>gsmdf</em> and the AFT modifications in <em>aftmdf</em> result in a different <a class="el" href="classConicBundle_1_1GroundsetModification.html" title="Collects modifications for the unconstrained Groundset for appending, deleting or reassigning variabl...">GroundsetModification</a> of the transformed space, this is computed into the member <em>local_gsmdf</em> and the returned pointer points to this <em>local_gsmdf</em>. If all transformations are passed on exactly as in <em>gsmdf</em> (because the trafo still acts as the identity), the returned pointer points to <em>gsmdf</em>.</p>
<p>If the changes affect the transformation at all in its effect on the nonzero image of transformed minorants, <em>minorant_trafo_differs</em> will be set to true otherwise to false. </p>

<p class="reference">Referenced by <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#ac292d5cb84ce5a428c39100628c5f12a">objective_value()</a>.</p>

</div>
</div>
<a id="a59b1cd43ec820b8221f04b86d3003441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b1cd43ec820b8221f04b86d3003441">&#9670;&nbsp;</a></span>modified_transform_argument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a>&amp; ConicBundle::AffineFunctionTransformation::modified_transform_argument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>transformed_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>input_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1AFTModification.html">AFTModification</a> *&#160;</td>
          <td class="paramname"><em>aftmdf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1GroundsetModification.html">GroundsetModification</a> &amp;&#160;</td>
          <td class="paramname"><em>gsmdf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>given the modification aftmdf or if 0, gsmdf, compute the transformed argument that would arise after this modification as in <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a1227a8b982fbe771f795effbc4be7223" title="computes transformed_offset and, if this is not the identity,transformed_y and returns either input_y...">transform_argument()</a> </p>
<p>On input <em>transformed_y</em> is supposed to be of dimension zero. The matrix returned is transformed_y unless the modification preserves the identity transformation. In this case, the returned matrix is input_y. </p>

<p class="reference">Referenced by <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a02d03fcecc1a2a3f2d5a2fe9aeb4338f">to_dim()</a>.</p>

</div>
</div>
<a id="a1227a8b982fbe771f795effbc4be7223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1227a8b982fbe771f795effbc4be7223">&#9670;&nbsp;</a></span>transform_argument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a>&amp; ConicBundle::AffineFunctionTransformation::transform_argument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>transformed_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a> &amp;&#160;</td>
          <td class="paramname"><em>transformed_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>input_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes <em>transformed_offset</em> and, if <em>this</em> is not the identity,<em>transformed_y</em> and returns either <em>input_y</em> (id) or <em>transformed_y</em> </p>
<p>On input <em>transformed_y</em> is supposed to be of dimension zero, unless it was already the result of a previous transformation for exactly this AFT with this data (no intermediate modifications). This is important, because if <em>transformed_y</em> has the correct size, only the data changed by the transformation is overwritten and the constant parts are assumed to be already initialized. On output it is again of dimension 0 if the transformation is the identity.</p>
<p>The <em>transformed_offset</em> = fun_offset+ip(linear_cost,<em>input_y</em>) is the value needed in <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#ac292d5cb84ce5a428c39100628c5f12a" title="if offset is the value computed in transform_argument and function_value results form an evaluation i...">objective_value()</a> together with the result of the evaluation of the function for <em>transformed_y</em> in order to compute the transformed objective value. </p>

<p class="reference">Referenced by <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#a02d03fcecc1a2a3f2d5a2fe9aeb4338f">to_dim()</a>.</p>

</div>
</div>
<a id="ae391744eb677c8297e6c6d1755339f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae391744eb677c8297e6c6d1755339f36">&#9670;&nbsp;</a></span>transform_minorant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::AffineFunctionTransformation::transform_minorant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1MinorantPointer.html">MinorantPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>out_minorant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1MinorantPointer.html">MinorantPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>in_minorant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a>&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add_trafo_minorant</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> *&#160;</td>
          <td class="paramname"><em>provided_row_indices</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> *&#160;</td>
          <td class="paramname"><em>needed_column_indices</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>transforms the in linear minorant (scaled by alpha) and initializes or adds it to the out linear minorant </p>
<p>if out_minorant.empty()==true, the out_minorant is initialized, otherwise the information is added.</p>
<p>the constant_minorant of the transformation is only added if add_trafo_minorant is set to true.</p>
<p>If given, provided_row_indices and needed_column_indices must be as specified in qp_cost_indices, i.e. of in_minorant only the provided_row_indices (all if NULL) will be used to compute only the needed_column_indices (as rows, all if NULL) of out_minorant. </p>

<p class="reference">Referenced by <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#ac292d5cb84ce5a428c39100628c5f12a">objective_value()</a>.</p>

</div>
</div>
<a id="a6f7ab330645afcf50c784f8dc5c55cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7ab330645afcf50c784f8dc5c55cc7">&#9670;&nbsp;</a></span>transform_minorants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::AffineFunctionTransformation::transform_minorants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceConicBundle.html#a4a6fea9e6a9e2452161e186d3faa1ae9">MinorantBundle</a> &amp;&#160;</td>
          <td class="paramname"><em>out_minorants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceConicBundle.html#a4a6fea9e6a9e2452161e186d3faa1ae9">MinorantBundle</a> &amp;&#160;</td>
          <td class="paramname"><em>in_minorants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#ga531d7da3afa69ae831131bfe00f57f03">CH_Matrix_Classes::Real</a>&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>transforms several linear minorants (scaled by alpha) and initializes or adds them to the out linear minorants </p>
<p>for out_minorant[i].empty()==true the out_minorant is initialized, otherwise the information is added. </p>

<p class="reference">Referenced by <a class="el" href="classConicBundle_1_1AffineFunctionTransformation.html#ac292d5cb84ce5a428c39100628c5f12a">objective_value()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="AffineFunctionTransformation_8hxx_source.html">AffineFunctionTransformation.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
