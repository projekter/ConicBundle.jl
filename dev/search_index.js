var documenterSearchIndex = {"docs":
[{"location":"cppexample.html#Example-for-the-C-interface","page":"Example for the C++ interface","title":"Example for the C++ interface","text":"","category":"section"},{"location":"cppexample.html","page":"Example for the C++ interface","title":"Example for the C++ interface","text":"Here, we outline the MAXCUT example, although we don't implement all the custom triangle functionality (though it would certainly be possible).","category":"page"},{"location":"cppexample.html","page":"Example for the C++ interface","title":"Example for the C++ interface","text":"using ConicBundle\nimport MutableArithmetics as MA\n\n# warning: we have to take care of garbage collection by ourselves!\ngarbage = [];\nadd_gc(x) = (push!(garbage, x); x);\n\nSTDIN = open(\"samplegraph.dat\", \"r\")\n# read the graph into (indi,indj,val) triples (replace val by 1.)\nnnodes = parse(Int, readuntil(STDIN, \" \"))\nmedges = parse(Int, readuntil(STDIN, \"\\n\"))\n\nindi = add_gc(CBIndexmatrix(medges, 1, 0))\nindj = add_gc(CBIndexmatrix(medges, 1, 0))\nval = add_gc(CBMatrix(medges, 1, 1.))\n\nfor i in 0:medges-1\n    head = parse(Int, readuntil(STDIN, \" \"))\n    tail = parse(Int, readuntil(STDIN, \" \"))\n    d = parse(Float64, readuntil(STDIN, \"\\n\"))\n    indi[i] = tail -1\n    indj[i] = head -1\n    # val[i] = d # edge weight d could be plugged in here\nend\n\nclose(STDIN)\n\nL = add_gc(CBSparsesym(nnodes, medges, indi, indj, val))\nLdiag = add_gc(CBMatrix(cb_diag(L)))\nL = MA.operate!(-, L, add_gc(cb_sparseDiag(Ldiag, 1e-60)))\ncb_init!(Ldiag, nnodes, 1, cb_sum(L) / nnodes)\nL = MA.operate!(*, L, -1)\nL = MA.operate!(+, L, add_gc(cb_sparseDiag(Ldiag, 1e-60)))\nL = MA.operate!(/, L, 4.)\nbestcut = add_gc(CBMatrix(nnodes, 1, 1.))\nbestcut_val = cb_ip(bestcut, L * bestcut)\n\n# form the Affine Matrix Function Oracle\nXdim = add_gc(CBIndexmatrix(1, 1, nnodes))\nC = add_gc(CBSparseCoeffmatMatrix(Xdim, 1))\n\ncb_set!(C, 0, 0, CBCMsymsparse(L)) # by default, ownership is managed by the coeffmat\nopAt = add_gc(CBSparseCoeffmatMatrix(Xdim, nnodes))\nfor i in 0:nnodes-1\n    cb_set!(opAt, 0, i, CBCMsingleton(nnodes, i, i, -1.)) # by default, the singletons are deleted by the coeffmat\nend\nmc = add_gc(CBPSCAffineFunction(C, opAt, CBGramSparsePSCPrimal(L))) # ownership of third argument passes to the function\ncb_set_out!(mc, 0)\n\n# initialize the solver and the problem\ncbsolver = add_gc(CBMatrixCBSolver(1))\nlb = add_gc(CBMatrix(nnodes, 1, cb_minus_infinity))\nub = add_gc(CBMatrix(nnodes, 1, cb_plus_infinity))\nrhs = add_gc(CBMatrix(nnodes, 1, 1.))\ncb_init_problem!(cbsolver, nnodes, lb, ub, nothing, rhs)\ncb_add_function!(cbsolver, mc, nnodes, cbft_objective_function, nothing, true)\n\n# call the solver\ncb_set_active_bounds_fixing!(cbsolver, true)\ncb_solve!(cbsolver) # here we could do all the rounding from the example\ncb_print_termination_code(cbsolver)\n\ncb_destroy!(@view(garbage[end:-1:1])...)","category":"page"},{"location":"cppref.html","page":"Reference of C++ interface","title":"Reference of C++ interface","text":"CurrentModule = ConicBundle","category":"page"},{"location":"cppref.html#Reference-of-C-interface","page":"Reference of C++ interface","title":"Reference of C++ interface","text":"","category":"section"},{"location":"cppref.html","page":"Reference of C++ interface","title":"Reference of C++ interface","text":"The C++ interface was semi-automatically ported to Julia, for which a parser was written. It aims to bring almost the full functionality of ConicBundle to Julia; however, the way of implementation is neither efficient nor always in a Julian style. The documentation was extracted verbatim from the CPP code, hence no markdown profits will be available. This basic interface can be improved in the future for example by exploiting memory alignment of structs in Julia and C++, which would allow to inline lots of setters and getters instead of having to call external functions.","category":"page"},{"location":"cppref.html","page":"Reference of C++ interface","title":"Reference of C++ interface","text":"Note that the C++ interface requires you to manually keep track of memory. Every allocated object must be freed by an appropriate call to cb_destroy!. This is in contrast to the automatically managed CBProblem from the C interface.","category":"page"},{"location":"cppref.html","page":"Reference of C++ interface","title":"Reference of C++ interface","text":"CBAFTData\nCBAFTModel\nCBAFTModification\nCBAffineFunctionTransformation\nCBBlockPSCPrimal\nCBBoxData\nCBBoxModel\nCBBoxModelParameters\nCBBoxOracle\nCBBundleDLRTrustRegionProx\nCBBundleDenseTrustRegionProx\nCBBundleDiagonalTrustRegionProx\nCBBundleHKWeight\nCBBundleIdProx\nCBBundleLowRankTrustRegionProx\nCBBundleRQBWeight\nCBBundleSolver\nCBBundleTerminator\nCBCFunction\nCBCFunctionMinorantExtender\nCBCMgramdense\nCBCMgramsparse\nCBCMgramsparse_withoutdiag\nCBCMlowrankdd\nCBCMlowranksd\nCBCMlowrankss\nCBCMsingleton\nCBCMsymdense\nCBCMsymsparse\nCBClock\nCBCoeffmatInfo\nCBDensePSCPrimal\nCBGB_rand\nCBGramSparsePSCPrimal\nCBGroundsetModification\nCBIndexmatrix\nCBLPGroundset\nCBMatrix\nCBMatrixCBSolver\nCBMicroseconds\nCBMinRes\nCBMinorant\nCBMinorantPointer\nCBMinorantUseData\nCBMode\nCBModelUpdate\nCBNNCBoxSupportFunction\nCBNNCBoxSupportMinorantExtender\nCBNNCBoxSupportModification\nCBNNCData\nCBNNCModel\nCBNNCModelParameters\nCBPCG\nCBPSCAffineFunction\nCBPSCAffineMinorantExtender\nCBPSCAffineModification\nCBPSCBundleParameters\nCBPSCData\nCBPSCModel\nCBPSCModelParameters\nCBPSCVariableMetricSelection\nCBPrimalMatrix\nCBPsqmr\nCBQPConeModelBlock\nCBQPDirectKKTSolver\nCBQPIterativeKKTHASolver\nCBQPIterativeKKTHAeqSolver\nCBQPKKTSolverComparison\nCBQPKKTSubspaceHPrecond\nCBQPSolver\nCBQPSolverParameters\nCBQPSumModelBlock\nCBSOCData\nCBSOCModel\nCBSOCModelParameters\nCBSOCSupportFunction\nCBSOCSupportMinorantExtender\nCBSOCSupportModification\nCBSparseCoeffmatMatrix\nCBSparsePSCPrimal\nCBSparsemat\nCBSparsesym\nCBSumBundle\nCBSumBundleParameters\nCBSumModel\nCBSymmatrix\nCBUQPConeModelBlock\nCBUQPSolver\nCBUQPSumModelBlock\nCBUnconstrainedGroundset\nCBVariableMetricSVDSelection\ncb_Aasen_Lsolve\ncb_Aasen_Ltsolve\ncb_Aasen_factor!\ncb_Aasen_solve\ncb_Aasen_tridiagsolve\ncb_B_times!\ncb_Chol_Lmult\ncb_Chol_Lsolve\ncb_Chol_Ltmult\ncb_Chol_Ltsolve\ncb_Chol_factor!\ncb_Chol_inverse\ncb_Chol_scaleLi\ncb_Chol_scaleLt\ncb_Chol_solve\ncb_Diag\ncb_Gram_ip\ncb_ItSys_mult!\ncb_LDLfactor!\ncb_LDLinverse\ncb_LDLsolve\ncb_QPallow_UQPSolver!\ncb_QPapply_modification!\ncb_QPclear!\ncb_QPconstrained\ncb_QPensure_feasibility!\ncb_QPget_KKTsolver!\ncb_QPget_blockA_norm!\ncb_QPget_blockH_norm!\ncb_QPget_dual_infeasibility_eps\ncb_QPget_lower_bound\ncb_QPget_lower_bound!\ncb_QPget_lower_bound_gap_eps\ncb_QPget_maxiter\ncb_QPget_min_objective_relprec\ncb_QPget_nbh_lb\ncb_QPget_nbh_ub\ncb_QPget_objective_gap_eps\ncb_QPget_primal_infeasibility_eps\ncb_QPget_solution!\ncb_QPget_system_size!\ncb_QPget_upper_bound\ncb_QPget_upper_bound_gap_eps\ncb_QPget_use_neighborhood\ncb_QPget_use_predictor_corrector\ncb_QPget_use_socqp\ncb_QPinit_KKTdata!\ncb_QPinit_KKTsystem!\ncb_QPis_feasible!\ncb_QPprefer_UQPSolver\ncb_QPprint_statistics!\ncb_QPresolve!\ncb_QPset_KKTsolver!\ncb_QPset_allow_UQPSolver!\ncb_QPset_dual_infeasibility_eps!\ncb_QPset_lower_and_upper_bounds!\ncb_QPset_lower_bound_gap_eps!\ncb_QPset_maxiter!\ncb_QPset_min_objective_relprec!\ncb_QPset_nbh_bounds!\ncb_QPset_objective_gap_eps!\ncb_QPset_parameters!\ncb_QPset_primal_infeasibility_eps!\ncb_QPset_upper_bound_gap_eps!\ncb_QPset_use_neighborhood!\ncb_QPset_use_predictor_corrector!\ncb_QPset_use_socqp!\ncb_QPsolve!\ncb_QPsolve_KKTsystem!\ncb_QPstart_modification!\ncb_QPsupports_updates!\ncb_QPsupports_yfixing!\ncb_QPupdate!\ncb_QR_concat_right!\ncb_QR_factor\ncb_QR_factor!\ncb_QR_factor_relpiv!\ncb_QR_solve!\ncb_Q_times\ncb_Qt_times\ncb_abs\ncb_abs!\ncb_active\ncb_add_BCSchur_diagonal!\ncb_add_BDBt!\ncb_add_Bs\ncb_add_BtinvsysB!\ncb_add_H\ncb_add_Hx\ncb_add_Schur_mult!\ncb_add_Schur_rhs!\ncb_add_append_blocks!\ncb_add_append_rows!\ncb_add_append_variables!\ncb_add_append_vars!\ncb_add_apply_factor!\ncb_add_coeff!\ncb_add_coeffs!\ncb_add_contributions!\ncb_add_delete_blocks!\ncb_add_delete_rows!\ncb_add_delete_vars!\ncb_add_diagonal_scaling\ncb_add_function!(::CBMatrixCBSolver, ::CBFunctionObject, ::Real, ::CBFunctionTask, ::Union{<:CBAffineFunctionTransformation,Nothing}, ::Bool)\ncb_add_local_sys!\ncb_add_localrhs!\ncb_add_localsys!\ncb_add_model!\ncb_add_modelx_aggregate!\ncb_add_offset!\ncb_add_projection\ncb_add_reassign_blocks!\ncb_add_reassign_rows!\ncb_add_reassign_variables!\ncb_add_reassign_vars!\ncb_add_reset_generating_primal!\ncb_add_solver!\ncb_add_variable_metric!\ncb_add_xinv_kron_z!\ncb_addmeto\ncb_addprodto\ncb_adjust_multiplier!\ncb_adjust_trace!\ncb_aggregate\ncb_aggregate!\ncb_aggregate_Gram_matrix!\ncb_aggregate_primal_data!\ncb_aggregated!\ncb_analyze_modification\ncb_append!\ncb_append_blocks!\ncb_append_columns!\ncb_append_constraints!\ncb_append_to_old\ncb_append_variables!(::CBMatrixCBSolver, ::Integer, ::Union{<:CBMatrix,Nothing}, ::Union{<:CBMatrix,Nothing}, ::Union{<:CBSparsemat,Nothing}, ::Union{<:CBMatrix,Nothing}, ::Union{<:CBMatrix,Nothing})\ncb_appended_blockdim\ncb_appended_rowdim\ncb_appended_vardim\ncb_apply_Hinv\ncb_apply_modification!\ncb_apply_modified_transform\ncb_apply_to_PSCAffine\ncb_apply_to_bounds\ncb_apply_to_costs\ncb_apply_to_factor\ncb_apply_to_offset\ncb_apply_to_vars\ncb_apply_variable_metric!\ncb_argument_changes\ncb_assign_Gram_matrix!\ncb_block\ncb_block_modifications\ncb_blockdim\ncb_bundle_size\ncb_call_primal_extender!\ncb_candidate!\ncb_ceil\ncb_ceil!\ncb_center_modified!\ncb_check_center_validity_by_candidate!\ncb_check_correctness\ncb_check_support\ncb_clear!(::CBAFTData, ::Integer)\ncb_clear!(::CBAFTModel)\ncb_clear!(::CBAFTModel, ::Union{<:CBAffineFunctionTransformation,Nothing}, ::Integer)\ncb_clear!(::CBAFTModification, ::Integer, ::Integer)\ncb_clear!(::CBBoxData, ::Integer)\ncb_clear!(::CBBoxModel)\ncb_clear!(::CBBundleHKWeight)\ncb_clear!(::CBBundleRQBWeight)\ncb_clear!(::CBBundleSolver)\ncb_clear!(::CBBundleTerminator)\ncb_clear!(::CBGroundsetModification, ::Integer)\ncb_clear!(::CBLPGroundset, ::Integer, ::Integer)\ncb_clear!(::CBMatrixCBSolver)\ncb_clear!(::CBMinorantPointer)\ncb_clear!(::CBNNCBoxSupportModification, ::Integer)\ncb_clear!(::CBNNCData, ::Integer)\ncb_clear!(::CBNNCModel)\ncb_clear!(::CBPSCAffineModification, ::Integer, ::CBIndexmatrix)\ncb_clear!(::CBPSCData, ::Integer)\ncb_clear!(::CBPSCModel)\ncb_clear!(::CBQPConeModelBlock)\ncb_clear!(::CBQPDirectKKTSolver)\ncb_clear!(::CBQPKKTSolverComparison)\ncb_clear!(::CBQPSumModelBlock)\ncb_clear!(::CBSOCData, ::Integer)\ncb_clear!(::CBSOCModel)\ncb_clear!(::CBSOCSupportModification, ::Integer)\ncb_clear!(::CBSparseCoeffmatMatrix)\ncb_clear!(::CBSumModel)\ncb_clear!(::CBUQPConeModelBlock)\ncb_clear!(::CBUQPSolver)\ncb_clear!(::CBUQPSumModelBlock)\ncb_clear!(::CBUnconstrainedGroundset, ::Integer, ::Integer)\ncb_clear_aggregates!\ncb_clear_cand_minorants!\ncb_clear_fail_counts!(::CBMatrixCBSolver)\ncb_clear_fails!\ncb_clear_model!\ncb_clear_terminated!\ncb_clone\ncb_clone!\ncb_clone_BundleParameters\ncb_clone_VariableMetricSelection!\ncb_clone_minorant\ncb_coeff\ncb_coeff!\ncb_col\ncb_col_nonzeros\ncb_coldim\ncb_colhouse\ncb_colip\ncb_cols\ncb_colsip\ncb_compute!\ncb_compute_QP_costs!\ncb_compute_local_directions!\ncb_compute_step!\ncb_computed_Schur_step!\ncb_computed_step!\ncb_concat_below\ncb_concat_below!\ncb_concat_right\ncb_concat_right!\ncb_cond_number_mult!\ncb_constrained\ncb_constraints_cost!\ncb_contains_nan!\ncb_contains_support\ncb_contribute_initial_bundle!\ncb_contribute_new_minorants!\ncb_copy_traforows\ncb_delete_blocks!\ncb_delete_cols!\ncb_delete_columns!\ncb_delete_principal_submatrix!\ncb_delete_rows!\ncb_delete_variables!(::CBMatrixCBSolver, ::CBIndexmatrix, ::CBIndexmatrix)\ncb_deleted_block_indices\ncb_deleted_row_indices\ncb_deleted_var_indices\ncb_deleted_variables_are_zero\ncb_dense\ncb_descent_update!\ncb_destroy!\ncb_diag\ncb_diagonal_bounds_scaling_update!\ncb_diagonal_scaling_heuristic_update!\ncb_dim\ncb_dim2\ncb_dim_constraints!\ncb_dim_model!\ncb_display\ncb_display_model_values!\ncb_dnorm_sqr\ncb_do_step!\ncb_dual_norm_squared\ncb_dualviol_2normsqr!\ncb_eig\ncb_elapsed_time\ncb_empty\ncb_enlarge_below!\ncb_enlarge_right!\ncb_ensure_feasibility!\ncb_equal\ncb_equals\ncb_eval_function!\ncb_eval_model\ncb_eval_model!\ncb_evaluate\ncb_evaluate_projection!\ncb_evaluate_trace\ncb_extend!\ncb_extend_Box!\ncb_extend_Ritz!\ncb_extend_SOC!\ncb_extract_SOCvector!\ncb_find\ncb_find_number\ncb_floor\ncb_floor!\ncb_form_bundlevecs!\ncb_from_dim\ncb_generate_minorant!\ncb_genmult\ncb_get_A\ncb_get_Ab\ncb_get_Bt!\ncb_get_C!\ncb_get_D\ncb_get_H\ncb_get_Hchol\ncb_get_Q\ncb_get_QPcoeff_time\ncb_get_QPsolve_time\ncb_get_Ritz_values\ncb_get_UVlambda!\ncb_get_X!\ncb_get_Z!\ncb_get_activedim\ncb_get_add_offset\ncb_get_additional_factor\ncb_get_additional_offset\ncb_get_aft\ncb_get_aggr_dnormsqr\ncb_get_aggregate\ncb_get_aggregate_offset\ncb_get_append_cols\ncb_get_append_costs\ncb_get_append_rhs\ncb_get_append_rows\ncb_get_appended_vardim\ncb_get_approximate_primal\ncb_get_approximate_slacks(::CBMatrixCBSolver, ::CBMatrix)\ncb_get_arg_offset\ncb_get_arg_trafo\ncb_get_augvalfails\ncb_get_augvalfailslimit\ncb_get_avg_reduction\ncb_get_block_append\ncb_get_boxx!\ncb_get_bundle\ncb_get_bundle_data\ncb_get_bundle_parameters(::CBAFTModel)\ncb_get_bundle_parameters(::CBBoxModel)\ncb_get_bundle_parameters(::CBMatrixCBSolver, ::Union{<:CBFunctionObject,Nothing})\ncb_get_bundle_parameters(::CBNNCModel)\ncb_get_bundle_parameters(::CBPSCModel)\ncb_get_bundle_parameters(::CBSOCModel)\ncb_get_bundle_parameters(::CBSumModel)\ncb_get_bundleweight\ncb_get_c\ncb_get_cand_gs_val\ncb_get_cand_minorant\ncb_get_cand_objval\ncb_get_cand_ub\ncb_get_cand_y\ncb_get_candidate(::CBMatrixCBSolver, ::CBMatrix)\ncb_get_candidate_primal\ncb_get_candidate_value(::CBMatrixCBSolver)\ncb_get_center(::CBMatrixCBSolver, ::CBMatrix)\ncb_get_center_gs_val\ncb_get_center_minorant!\ncb_get_center_objval\ncb_get_center_primal\ncb_get_center_ub\ncb_get_center_y\ncb_get_cntobjeval\ncb_get_coeff\ncb_get_colindex\ncb_get_colinfo\ncb_get_colval\ncb_get_constant_minorant\ncb_get_contributed_model_aggregate\ncb_get_corr!\ncb_get_costs\ncb_get_cutval\ncb_get_data\ncb_get_data!\ncb_get_dense_cnt\ncb_get_dense_coeff_store!\ncb_get_descent_step\ncb_get_descent_steps\ncb_get_dim(::CBLPGroundset)\ncb_get_dim(::CBMatrixCBSolver)\ncb_get_dim(::CBUnconstrainedGroundset)\ncb_get_do_variable_metric\ncb_get_dualval\ncb_get_edge\ncb_get_edge_rep\ncb_get_err\ncb_get_eval_time\ncb_get_evalaugmodel_time\ncb_get_factored\ncb_get_fixed_active_bounds(::CBMatrixCBSolver)\ncb_get_fun_coeff\ncb_get_fun_offset\ncb_get_function_factor\ncb_get_function_minorant!\ncb_get_function_status(::CBMatrixCBSolver, ::CBFunctionObject)\ncb_get_generating_primal\ncb_get_generating_primal!\ncb_get_grammatrix\ncb_get_groundset\ncb_get_groundset_id\ncb_get_gs_aggregate\ncb_get_gs_minorant\ncb_get_ijval\ncb_get_increase_factor\ncb_get_infinity\ncb_get_innerit\ncb_get_iter\ncb_get_keepsize\ncb_get_last_alpha!\ncb_get_last_weight(::CBMatrixCBSolver)\ncb_get_latest_minorants!\ncb_get_lbindex\ncb_get_lbounds\ncb_get_lby\ncb_get_linear_cost\ncb_get_lmin_invM1!\ncb_get_local_dualcost\ncb_get_local_model_aggregate\ncb_get_local_primalcost\ncb_get_lower_bounds!\ncb_get_make_aggr_time\ncb_get_map_to_old_variables\ncb_get_maxeigval_factor\ncb_get_maxit\ncb_get_maxiter\ncb_get_maxweight\ncb_get_mineigval_factor\ncb_get_minorant\ncb_get_minweight\ncb_get_mode\ncb_get_model\ncb_get_model_aggregate\ncb_get_model_aggregate!\ncb_get_model_calls_delete!\ncb_get_model_data\ncb_get_modeldcstr!\ncb_get_modeldx!\ncb_get_modeleps\ncb_get_modelfails\ncb_get_modelfailslimit\ncb_get_modelval\ncb_get_modelx!\ncb_get_modification_id\ncb_get_mu!\ncb_get_mu_info\ncb_get_mu_stats!\ncb_get_n_contributors\ncb_get_n_descent_steps\ncb_get_n_functions(::CBMatrixCBSolver)\ncb_get_n_inner_iterations\ncb_get_n_inner_updates\ncb_get_n_latest_minorants\ncb_get_n_oracle_calls\ncb_get_nbh_info\ncb_get_nblocks\ncb_get_new_index\ncb_get_new_vardim\ncb_get_next_weight\ncb_get_next_weight_set\ncb_get_nmult\ncb_get_nncx!\ncb_get_nncz!\ncb_get_null_step\ncb_get_objevallimit\ncb_get_objval(::CBMatrixCBSolver)\ncb_get_offset\ncb_get_offset_append\ncb_get_old_X!\ncb_get_old_Z!\ncb_get_old_mu!\ncb_get_old_nncx!\ncb_get_old_nncz!\ncb_get_old_s!\ncb_get_old_socx!\ncb_get_old_socz!\ncb_get_old_vardim\ncb_get_old_y!\ncb_get_oldfactor\ncb_get_opAt!\ncb_get_oracle_object!\ncb_get_oraclefails\ncb_get_oraclefailslimit\ncb_get_positive\ncb_get_posteval_time\ncb_get_precond_rank!\ncb_get_preeval_time\ncb_get_primal\ncb_get_primal!\ncb_get_primaleigs\ncb_get_primalval\ncb_get_primalvecs\ncb_get_prob_stats!\ncb_get_prox\ncb_get_pscx!\ncb_get_qp_solver!\ncb_get_qpfails\ncb_get_qpfailslimit\ncb_get_recomp\ncb_get_recomplimit\ncb_get_reset_primal\ncb_get_residual_norm\ncb_get_ret_code\ncb_get_rhslb\ncb_get_rhslbind\ncb_get_rhsub\ncb_get_rhsubind\ncb_get_rowindex\ncb_get_rowinfo\ncb_get_rowval\ncb_get_s!\ncb_get_scalefactor\ncb_get_selection_method\ncb_get_sgnorm(::CBMatrixCBSolver)\ncb_get_shallowcut\ncb_get_skip_extension\ncb_get_skippedsize\ncb_get_socdim!\ncb_get_socx!\ncb_get_socz!\ncb_get_solver\ncb_get_starting_point\ncb_get_status\ncb_get_store\ncb_get_subgradient(::CBMatrixCBSolver, ::CBMatrix)\ncb_get_sumaugvalfails\ncb_get_sumbundle\ncb_get_suminnerit\ncb_get_summodelfails\ncb_get_sumoraclefails\ncb_get_sumqpfails\ncb_get_sumrecomp\ncb_get_sumupdatecnt\ncb_get_suppcol\ncb_get_suppind\ncb_get_sysviol_constraints!\ncb_get_sysviol_model!\ncb_get_t_precond_mult!\ncb_get_term_corr\ncb_get_termeps\ncb_get_terminate\ncb_get_terminated\ncb_get_terminator\ncb_get_termprec\ncb_get_timelimit\ncb_get_topvecs\ncb_get_trace!\ncb_get_ubindex\ncb_get_ubounds\ncb_get_uby\ncb_get_upper_bounds!\ncb_get_use_linval\ncb_get_use_variable_metric\ncb_get_use_yfixing\ncb_get_var_append\ncb_get_variable_metric_selection\ncb_get_weight\ncb_get_weightu\ncb_get_x!\ncb_get_y!\ncb_get_yfixed\ncb_gramip\ncb_groundset_changes_suffice_for_identity!\ncb_guess_curvature\ncb_handles!\ncb_has_bundle_data\ncb_has_bundle_for\ncb_has_contributions\ncb_has_roots\ncb_has_working_roots\ncb_hhmmss\ncb_hhmmssdd\ncb_house\ncb_ignore_groundset_modification\ncb_incorporate!\ncb_init!\ncb_init_data!\ncb_init_diag!\ncb_init_problem!(::CBMatrixCBSolver, ::Integer, ::Union{<:CBMatrix,Nothing}, ::Union{<:CBMatrix,Nothing}, ::Union{<:CBMatrix,Nothing}, ::Union{<:CBMatrix,Nothing}, ::Real)\ncb_init_size!\ncb_init_support!\ncb_init_svec!\ncb_init_system!\ncb_initialization_needed\ncb_initialize!\ncb_inner_line_search!\ncb_insert_col!\ncb_insert_row!\ncb_install_external_aggregate!\ncb_inv\ncb_inv!\ncb_ip\ncb_ip_min_max\ncb_is_DLR\ncb_is_feasible!\ncb_lb_function!\ncb_lb_model\ncb_left_genmult\ncb_left_right_prod\ncb_left_right_product!\ncb_line_search!\ncb_linesearch\ncb_localsys_mult!\ncb_ls!\ncb_make_model_aggregate!\ncb_make_symmatrix\ncb_map_to_old_blocks\ncb_map_to_old_rows\ncb_map_to_old_variables\ncb_mapped_variables_are_equal\ncb_max\ncb_maxcols\ncb_maxrows\ncb_mfile_data\ncb_mfile_output\ncb_min\ncb_mincols\ncb_minrows\ncb_model\ncb_model_aggregate_modified!\ncb_modified_transform_argument\ncb_multiply!\ncb_new_block_indices\ncb_new_blockdim\ncb_new_initial_oraclemodification\ncb_new_row_indices\ncb_new_rowdim\ncb_new_var_indices\ncb_new_vardim\ncb_new_variables_are_zero\ncb_newsize!\ncb_next!\ncb_nnls\ncb_no_additions_or_deletions_in_rows\ncb_no_additions_or_deletions_in_vars\ncb_no_modification\ncb_nonzeros\ncb_nonzeros!\ncb_norm\ncb_norm2\ncb_normDsquared\ncb_norm_sqr\ncb_norm_squared\ncb_normalize_sumbundle!\ncb_nsubmodels\ncb_nullstep_update!\ncb_number_aggregated\ncb_nzcoldim\ncb_objective_value\ncb_offset\ncb_offset_gives_value_at_origin\ncb_offset_gives_value_at_origin!\ncb_old_blockdim\ncb_old_rowdim\ncb_old_vardim\ncb_one_user\ncb_only_scalars_change\ncb_out\ncb_output_aft_data\ncb_output_bundle_data\ncb_pivot_permute!\ncb_pivot_permute_cols!\ncb_pivot_permute_rows!\ncb_pop_aft!\ncb_postgenmult\ncb_precondM1!\ncb_precond_invG1!\ncb_precond_invG1tran!\ncb_precond_size!\ncb_pregenmult\ncb_prepare_BCSchur_JLprecond!\ncb_preserves_identity\ncb_primal_ip\ncb_primalviol_2normsqr!\ncb_principal_submatrix\ncb_print_id\ncb_print_line_summary\ncb_print_problem_data\ncb_print_problem_data_to_mfile\ncb_print_statistics\ncb_print_status\ncb_print_termination_code(::CBMatrixCBSolver)\ncb_print_time\ncb_prodvec_flops\ncb_project\ncb_projected_clone!\ncb_projection!\ncb_propose_BCSchur_pcsubspace!\ncb_provide_model_aggregate!\ncb_push_aft!\ncb_qp_cost_indices\ncb_qp_mfile_data\ncb_rand\ncb_rand!\ncb_rand_normal!\ncb_rank2add\ncb_rankadd\ncb_reassign_blocks!\ncb_reassign_coeffs!\ncb_reassign_columns!\ncb_reassign_variables!(::CBMatrixCBSolver, ::CBIndexmatrix)\ncb_recompute_center!\ncb_recursive_copy_data_of!\ncb_recursive_delete_and_clear!\ncb_reduce_length!\ncb_reinit_function_model!(::CBMatrixCBSolver, ::Union{<:CBFunctionObject,Nothing})\ncb_remove_contributions!\ncb_remove_model!\ncb_reset_function_factor!\ncb_reset_starting_point!\ncb_reset_t_precond_mult!\ncb_resolve!\ncb_restart_x!\ncb_restart_y!\ncb_right_genmult\ncb_rint\ncb_rint!\ncb_round\ncb_round!\ncb_roundhundredths\ncb_roundsecs\ncb_row\ncb_row_nonzeros\ncb_rowdim\ncb_rowhouse\ncb_rowip\ncb_rows\ncb_rowsip\ncb_save\ncb_scale!\ncb_scale_cols!\ncb_scale_minorant!\ncb_scale_primal_data!\ncb_scale_rows!\ncb_scaled_index\ncb_scaled_index_subset\ncb_scaledrankadd\ncb_scaling_indices\ncb_select_model!\ncb_set!\ncb_set_D!\ncb_set_active_bounds_fixing!(::CBMatrixCBSolver, ::Bool)\ncb_set_aggr_dnormsqr!\ncb_set_append_to_old!\ncb_set_augvalfailslimit!\ncb_set_bundle_parameters!\ncb_set_bundleweight!\ncb_set_cand_minorant!\ncb_set_cbout!\ncb_set_check_correctness!\ncb_set_clock!\ncb_set_data!\ncb_set_defaults!\ncb_set_do_yfixing!\ncb_set_eval_limit!(::CBMatrixCBSolver, ::Integer)\ncb_set_fun_coeff!\ncb_set_fun_offset!\ncb_set_groundset_id!\ncb_set_infinity!\ncb_set_inner_update_limit!(::CBMatrixCBSolver, ::Integer)\ncb_set_lower_bound!(::CBMatrixCBSolver, ::Integer, ::Real)\ncb_set_mL!\ncb_set_mN!\ncb_set_max_Ritzvecs!\ncb_set_max_bundlesize!(::CBMatrixCBSolver, ::Integer, ::Union{<:CBFunctionObject,Nothing})\ncb_set_max_modelsize!(::CBMatrixCBSolver, ::Integer, ::Union{<:CBFunctionObject,Nothing})\ncb_set_max_new!\ncb_set_max_updates!\ncb_set_max_weight!(::CBMatrixCBSolver, ::Real)\ncb_set_maxeigval_factor!\ncb_set_maxit!\ncb_set_maxiter!\ncb_set_maxweight!\ncb_set_min_weight!(::CBMatrixCBSolver, ::Real)\ncb_set_mineigval_factor!\ncb_set_minweight!\ncb_set_model!\ncb_set_model_calls_delete!\ncb_set_modeleps!\ncb_set_modelfailslimit!\ncb_set_modification_id!\ncb_set_n_latest_minorants!\ncb_set_new_center!\ncb_set_new_center_point!(::CBMatrixCBSolver, ::CBMatrix)\ncb_set_next_weight!(::CBBundleHKWeight, ::Real)\ncb_set_next_weight!(::CBBundleRQBWeight, ::Real)\ncb_set_next_weight!(::CBMatrixCBSolver, ::Real)\ncb_set_nullstep_updates!\ncb_set_objevallimit!\ncb_set_offset!\ncb_set_oldfactor!\ncb_set_oracle!\ncb_set_oraclefailslimit!\ncb_set_out!\ncb_set_parent_information!\ncb_set_point!\ncb_set_primal!\ncb_set_prox!\ncb_set_prox_diagonal!\ncb_set_qp_solver!\ncb_set_qp_solver_parameters!\ncb_set_qp_xstart!\ncb_set_qp_ystart!\ncb_set_qpfailslimit!\ncb_set_qpsolver!\ncb_set_recomplimit!\ncb_set_scalefactor!\ncb_set_selection_method!\ncb_set_skip_extension!\ncb_set_starting_point!\ncb_set_subspace!\ncb_set_sumbundle!\ncb_set_sumbundle_parameters!\ncb_set_term_relprec!(::CBMatrixCBSolver, ::Real)\ncb_set_termbounds!\ncb_set_termeps!\ncb_set_terminator!\ncb_set_time_limit!\ncb_set_timelimit!\ncb_set_tol!\ncb_set_upper_bound!(::CBMatrixCBSolver, ::Integer, ::Real)\ncb_set_use_linval!\ncb_set_use_yfixing!\ncb_set_variable_metric!(::CBBundleSolver, ::Integer)\ncb_set_variable_metric!(::CBMatrixCBSolver, ::Integer)\ncb_set_variable_metric_selection!\ncb_set_weight_update!\ncb_set_weightu!\ncb_set_yfixed!\ncb_shift_diag!\ncb_shuffle!\ncb_sign\ncb_sign!\ncb_skron\ncb_solve!(::CBBundleSolver, ::Integer, ::Bool)\ncb_solve!(::CBMatrixCBSolver, ::Integer, ::Bool)\ncb_solve!(::CBQPSolver, ::Union{<:CBBundleProxObject,Nothing}, ::CBMatrix, ::Real, ::Real, ::Real, ::Real, ::Real)\ncb_solve!(::CBUQPSolver, ::CBSymmatrix, ::CBMatrix, ::Real)\ncb_solve_constrsys!\ncb_sortindex\ncb_sparse\ncb_sparseDiag\ncb_sparse_argument_changes\ncb_sparsemult\ncb_sparsify!\ncb_sqr\ncb_sqr!\ncb_sqrt\ncb_sqrt!\ncb_start!\ncb_start_augmodel!\ncb_start_modification!\ncb_start_sumaugmodel!\ncb_starting_x!\ncb_starting_y!\ncb_store_SOCvec!\ncb_store_svec\ncb_subassign!\ncb_subspace\ncb_subtract_z\ncb_suggest_mu!\ncb_sum\ncb_sumbundle_mode!\ncb_sumcols\ncb_sumrows\ncb_support_in\ncb_support_rankadd\ncb_support_xbpeya!\ncb_supports_dense_variable_metric\ncb_supports_diagonal_bounds_scaling\ncb_supports_diagonal_variable_metric\ncb_supports_lowrank_variable_metric\ncb_svec\ncb_svec_projection!\ncb_sveci\ncb_swap\ncb_swap_colsij!\ncb_swap_rowsij!\ncb_swapij!\ncb_symscale\ncb_synchronize_ids!\ncb_termination_code(::CBMatrixCBSolver)\ncb_time\ncb_times_B!\ncb_times_Q\ncb_to_dim\ncb_trace\ncb_tracedual\ncb_transform_argument\ncb_transform_minorant\ncb_transform_minorants\ncb_transpose\ncb_transpose!\ncb_tril\ncb_tril!\ncb_tril_solve!\ncb_triu\ncb_triu!\ncb_triu_solve!\ncb_unif_long!\ncb_update!\ncb_update_QP_costs!\ncb_update_model!\ncb_valid\ncb_variable_modifications\ncb_wall_time\ncb_weight_changed\ncb_xbpeya\ncb_xdim\ncb_xetriu_yza!\ncb_xeya!\ncb_xeyapzb\ncb_xpetriu_yza!\ncb_xpeya!\ncb_ydim\ncb_zero\ncbm_child\ncbm_inactive\ncbm_root\ncbm_unavailable\ncbmu_descent_step\ncbmu_new_subgradient\ncbmu_null_step","category":"page"},{"location":"cppref.html#ConicBundle.CBAFTData","page":"Reference of C++ interface","title":"ConicBundle.CBAFTData","text":"CBAFTData(start_modification_id::Integer = 0)\n\ncalls clear()\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBAFTModel","page":"Reference of C++ interface","title":"ConicBundle.CBAFTModel","text":"CBAFTModel(in_model::Union{<:CBSumBlockModel,Nothing}, inaft::Union{<:CBAffineFunctionTransformation,Nothing} = nothing, start_modification_id::Integer = 0, in_model_is_owner::Bool = false)\n\nsets @a model to @a inmodel and  @a modelisowner to @a inmodelisowner (or false if @a inmodel==0) and calls clear with parameters (inaft,startmodification_id)\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBAFTModification","page":"Reference of C++ interface","title":"ConicBundle.CBAFTModification","text":"CBAFTModification(var_olddim::Integer = 0, row_olddim::Integer = 0, ignore_groundset_modification::Bool = false)\n\ninitialize and reset to an unmodified object currently having varolddim columns and rowolddim rows\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBAffineFunctionTransformation","page":"Reference of C++ interface","title":"ConicBundle.CBAffineFunctionTransformation","text":"CBAffineFunctionTransformation(in_fun_coeff::Real = 1., in_fun_offset::Real = 0., in_linear_cost::Union{<:CBMatrix,Nothing} = nothing, in_arg_offset::Union{<:CBMatrix,Nothing} = nothing, in_arg_trafo::Union{<:CBSparsemat,Nothing} = nothing, in_model_calls_delete::Bool = true, incr::Integer = -1)\n\ncalls init()\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBBlockPSCPrimal","page":"Reference of C++ interface","title":"ConicBundle.CBBlockPSCPrimal","text":"CBBlockPSCPrimal(pr::CBBlockPSCPrimal, factor::Real = 1.)\n\ncopy constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBBoxData","page":"Reference of C++ interface","title":"ConicBundle.CBBoxData","text":"CBBoxData(fun_factor::Real = 1., fun_task::CBFunctionTask = cbft_objective_function)\n\ninitializes BundleData, sets center_primal to NULL and calls clear()\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBBoxModel","page":"Reference of C++ interface","title":"ConicBundle.CBBoxModel","text":"CBBoxModel(fo::Union{<:CBBoxOracle,Nothing}, fun_factor::Real = 1., fun_task::CBFunctionTask = cbft_objective_function, cbinc::Integer = -1)\n\nconstruct a model for the MatrixBoxOracle pointed to by @a fo\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBBoxModelParameters","page":"Reference of C++ interface","title":"ConicBundle.CBBoxModelParameters","text":"CBBoxModelParameters(cbinc::Integer = -1)\n\ndefault constructor\n\n\n\n\n\nCBBoxModelParameters(bp::CBBundleParameters, cbinc::Integer = -1)\n\ncopy constructor for BundleParameters\n\n\n\n\n\nCBBoxModelParameters(sms::CBBoxModelParameters)\n\ncopy constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBBoxOracle","page":"Reference of C++ interface","title":"ConicBundle.CBBoxOracle","text":"CBBoxOracle(in_lb::CBMatrix, in_ub::CBMatrix)\n\nconstructor initializing lower and upper bounds (must have the same dimesnion, not checked)\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBBundleDLRTrustRegionProx","page":"Reference of C++ interface","title":"ConicBundle.CBBundleDLRTrustRegionProx","text":"CBBundleDLRTrustRegionProx(dim::Integer = 0, vp::Union{<:CBVariableMetricSelection,Nothing} = nothing, local_metric::Bool = false, inc::Integer = -1)\n\ndefault constructor with empty H (equal to zero) and the dimension as argument\n\n\n\n\n\nCBBundleDLRTrustRegionProx(in_D::CBMatrix, in_vecH::CBMatrix, vp::Union{<:CBVariableMetricSelection,Nothing} = nothing, local_metric::Bool = false, inc::Integer = -1)\n\nconstructs H=(D+weightu)+vecH*transpose(vecH) with weightu=1., so inD must be a column vector with same dimension as rows in invecH\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBBundleDenseTrustRegionProx","page":"Reference of C++ interface","title":"ConicBundle.CBBundleDenseTrustRegionProx","text":"CBBundleDenseTrustRegionProx(Hin::CBSymmatrix, vp::Union{<:CBVariableMetricSelection,Nothing} = nothing, local_metric::Bool = false, bounds_scaling::Bool = false, cbinc::Integer = -1)\n\ninitialize to this Matrix and set the variable_metric option (false by default)\n\n\n\n\n\nCBBundleDenseTrustRegionProx(dim::Integer = 0, vp::Union{<:CBVariableMetricSelection,Nothing} = nothing, local_metric::Bool = false, bounds_scaling::Bool = false, cbinc::Integer = -1)\n\ninitialize H to the zero Matrix of this dimension (on the diagonal the weight will be added)  and set the variable_metric option (false by default)\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBBundleDiagonalTrustRegionProx","page":"Reference of C++ interface","title":"ConicBundle.CBBundleDiagonalTrustRegionProx","text":"CBBundleDiagonalTrustRegionProx(Din::CBMatrix, vp::Union{<:CBVariableMetricSelection,Nothing} = nothing, local_scaling::Bool = false, bounds_scaling::Bool = false, cbinc::Integer = -1)\n\ninitialize to this diagonal matrix\n\n\n\n\n\nCBBundleDiagonalTrustRegionProx(dim::Integer, d::Real, vp::Union{<:CBVariableMetricSelection,Nothing} = nothing, local_scaling::Bool = false, bounds_scaling::Bool = false, cbinc::Integer = -1)\n\ninitialize to a diaognal matrix d*identity of dimesion dim\n\n\n\n\n\nCBBundleDiagonalTrustRegionProx(dim::Integer = 0, vp::Union{<:CBVariableMetricSelection,Nothing} = nothing, local_scaling::Bool = false, bounds_scaling::Bool = false, cbinc::Integer = -1)\n\ninitialize to a zero diaognal matrix of dimesion dim\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBBundleHKWeight","page":"Reference of C++ interface","title":"ConicBundle.CBBundleHKWeight","text":"CBBundleHKWeight(mRin::Real = .5, bwp::Union{<:CBBundleWeight,Nothing} = nothing, incr::Integer = -1)\n\nthe parameter mRin gets the value for accepting descent steps, bwp may be used to communicate the previous values use by another routine\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBBundleIdProx","page":"Reference of C++ interface","title":"ConicBundle.CBBundleIdProx","text":"CBBundleIdProx(d::Integer = 0, w::Real = 1., cbinc::Integer = -1)\n\ninitialize with dimension and weight\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBBundleLowRankTrustRegionProx","page":"Reference of C++ interface","title":"ConicBundle.CBBundleLowRankTrustRegionProx","text":"CBBundleLowRankTrustRegionProx(dim::Integer = 0, vp::Union{<:CBVariableMetricSelection,Nothing} = nothing, local_metric::Bool = false, inc::Integer = -1)\n\ndefault constructor with empty H (equal to zero) and the dimension as argument\n\n\n\n\n\nCBBundleLowRankTrustRegionProx(in_vecH::CBMatrix, in_lamH::CBMatrix, vp::Union{<:CBVariableMetricSelection,Nothing} = nothing, local_metric::Bool = false, inc::Integer = -1)\n\nconstructs H=vecHDiag(lamH)transpose(vecH), so inlamH must be a column vector with same dimension as columns in invecH and the row dimension of invecH must match the design space, invecH is assumed orthogonal\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBBundleRQBWeight","page":"Reference of C++ interface","title":"ConicBundle.CBBundleRQBWeight","text":"CBBundleRQBWeight(bwp::Union{<:CBBundleWeight,Nothing} = nothing, incr::Integer = -1)\n\nbwp may be used to communicate the previous values used by another routine\n\n\n\n\n\nCBBundleRQBWeight(m1::Real, m2::Real = .2, m3::Real = 1., eta::Real = 1e-6, bwp::Union{<:CBBundleWeight,Nothing} = nothing, incr::Integer = -1)\n\nbwp may be used to communicate the previous values used by another routine\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBBundleSolver","page":"Reference of C++ interface","title":"ConicBundle.CBBundleSolver","text":"CBBundleSolver(dim::Integer, bp::Union{<:CBBundleModel,Nothing} = nothing, incr::Integer = -1)\n\ncalls initialize(CHMatrixClasses::Integer, BundleModel*)\n\n\n\n\n\nCBBundleSolver(gs::Union{<:CBGroundset,Nothing}, bp::Union{<:CBBundleModel,Nothing} = nothing, incr::Integer = -1)\n\ncalls initialize(Groundset,BundleModel)\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBBundleTerminator","page":"Reference of C++ interface","title":"ConicBundle.CBBundleTerminator","text":"CBBundleTerminator(incr::Integer = -1)\n\ncalls set_defaults() and clear()\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBCFunction","page":"Reference of C++ interface","title":"ConicBundle.CBCFunction","text":"CBCFunction(fk::Union{<:AbstractVector{Nothing},Nothing}, fp::Ptr{Cvoid}, se::Ptr{Cvoid} = 0, prdim::Integer = 0)\n\nconstructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBCFunctionMinorantExtender","page":"Reference of C++ interface","title":"ConicBundle.CBCFunctionMinorantExtender","text":"CBCFunctionMinorantExtender(fk::Union{<:AbstractVector{Nothing},Nothing}, se::Ptr{Cvoid})\n\nconstructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBCMgramdense","page":"Reference of C++ interface","title":"ConicBundle.CBCMgramdense","text":"CBCMgramdense(Ain::CBMatrix, pos::Bool = true, cip::Union{<:CBCoeffmatInfo,Nothing} = nothing)\n\ncopy Ain and possibly, the flag for positive/negative and store the user information\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBCMgramsparse","page":"Reference of C++ interface","title":"ConicBundle.CBCMgramsparse","text":"CBCMgramsparse(Ain::CBSparsemat, pos::Bool = true, cip::Union{<:CBCoeffmatInfo,Nothing} = nothing)\n\ncopy Ain, the flag for positive/negative and store the user information\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBCMgramsparse_withoutdiag","page":"Reference of C++ interface","title":"ConicBundle.CBCMgramsparse_withoutdiag","text":"CBCMgramsparse_withoutdiag(Ain::CBSparsemat, pos::Bool = true, cip::Union{<:CBCoeffmatInfo,Nothing} = nothing)\n\ncopy Ain, the flag for positive/negative and store the user information\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBCMlowrankdd","page":"Reference of C++ interface","title":"ConicBundle.CBCMlowrankdd","text":"CBCMlowrankdd(Ain::CBMatrix, Bin::CBMatrix, cip::Union{<:CBCoeffmatInfo,Nothing} = nothing)\n\ncopy Ain, Bin and store the user information\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBCMlowranksd","page":"Reference of C++ interface","title":"ConicBundle.CBCMlowranksd","text":"CBCMlowranksd(Ain::CBSparsemat, Bin::CBMatrix, cip::Union{<:CBCoeffmatInfo,Nothing} = nothing)\n\ncopy Ain, Bin and store the user information\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBCMlowrankss","page":"Reference of C++ interface","title":"ConicBundle.CBCMlowrankss","text":"CBCMlowrankss(Ain::CBSparsemat, Bin::CBSparsemat, cip::Union{<:CBCoeffmatInfo,Nothing} = nothing)\n\ncopy Ain, Bin and store the user information\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBCMsingleton","page":"Reference of C++ interface","title":"ConicBundle.CBCMsingleton","text":"CBCMsingleton(innr::Integer, ini::Integer, inj::Integer, inval::Real, cip::Union{<:CBCoeffmatInfo,Nothing} = nothing)\n\nthe order is innr and the nonzero element (ini,inj) has values inval\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBCMsymdense","page":"Reference of C++ interface","title":"ConicBundle.CBCMsymdense","text":"CBCMsymdense(Ain::CBSymmatrix, cip::Union{<:CBCoeffmatInfo,Nothing} = nothing)\n\ncopy Ain and possibly store the user information\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBCMsymsparse","page":"Reference of C++ interface","title":"ConicBundle.CBCMsymsparse","text":"CBCMsymsparse(Ain::CBSparsesym, cip::Union{<:CBCoeffmatInfo,Nothing} = nothing)\n\ncopy Ain and possibly store the user information, set use_sparsemult to true if at least half the rows will be zero\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBClock","page":"Reference of C++ interface","title":"ConicBundle.CBClock","text":"CBClock()\n\ncalls start()\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBCoeffmatInfo","page":"Reference of C++ interface","title":"ConicBundle.CBCoeffmatInfo","text":"CBCoeffmatInfo(sf::Real = 1.)\n\ndefault value is 1 for no scaling\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBDensePSCPrimal","page":"Reference of C++ interface","title":"ConicBundle.CBDensePSCPrimal","text":"CBDensePSCPrimal()\n\ninitialize to a symmetric matrix of size 0\n\n\n\n\n\nCBDensePSCPrimal(symmat::CBDensePSCPrimal, factor::Real = 1.)\n\ncopy constructor\n\n\n\n\n\nCBDensePSCPrimal(symmat::CBSymmatrix, factor::Real = 1.)\n\ncopy constructor from a CHMatrixClasses::Symmatrix\n\n\n\n\n\nCBDensePSCPrimal(n::Integer)\n\ndirect size initialization to a zero matrix\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBGB_rand","page":"Reference of C++ interface","title":"ConicBundle.CBGB_rand","text":"CBGB_rand(seed::Integer = 1)\n\ncalls  init(seed)\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBGramSparsePSCPrimal","page":"Reference of C++ interface","title":"ConicBundle.CBGramSparsePSCPrimal","text":"CBGramSparsePSCPrimal(sps::CBSparsesym, factor::Real = 1.)\n\ninitialize to the given sparse symmetric matrix, the gram part is zero\n\n\n\n\n\nCBGramSparsePSCPrimal(pr::CBGramSparsePSCPrimal, factor::Real = 1.)\n\ncopy constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBGroundsetModification","page":"Reference of C++ interface","title":"ConicBundle.CBGroundsetModification","text":"CBGroundsetModification(var_olddim::Integer = 0, incr::Integer = -1)\n\nconstructor, calls modification constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBIndexmatrix","page":"Reference of C++ interface","title":"ConicBundle.CBIndexmatrix","text":"CBIndexmatrix()\n\nempty matrix\n\n\n\n\n\nCBIndexmatrix(A::CBIndexmatrix, d::Integer = 1)\n\ncopy constructor, this=dA\n\n\n\n\n\nCBIndexmatrix(param0::AbstractRange{<:Integer})\n\ngenerate a column vector holding the indices of this #CHMatrixClasses::Range\n\n\n\n\n\nCBIndexmatrix(nr::Integer, nc::Integer)\n\n@brief generate a matrix of size nr x nc but WITHOUT initializing the memory\n  If initializing the memory externally and CONICBUNDLE_DEBUG is defined, please use\n  set_init() via matrix.set_init(true) in order to avoid warnings concerning improper\n  initialization\n\n\n\n\n\nCBIndexmatrix(nr::Integer, nc::Integer, d::Integer)\n\ngenerate a matrix of size nr x nc initializing all elements to the value d\n\n\n\n\n\nCBIndexmatrix(nr::Integer, nc::Integer, dp::Union{<:AbstractVector{Cint},Nothing})\n\ngenerate a matrix of size nr x nc initializing the elements from the (one dimensional) array dp with increment incr\n\n\n\n\n\nCBIndexmatrix(param0::CBMatrix)\n\ncopy with rounding\n\n\n\n\n\nCBIndexmatrix(param0::CBSparsemat)\n\ncopy with rounding\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBLPGroundset","page":"Reference of C++ interface","title":"ConicBundle.CBLPGroundset","text":"CBLPGroundset()\n\ncalls clear() with the same parameters\n\n\n\n\n\nCBLPGroundset(dim::Integer, lbyp::Union{<:CBMatrix,Nothing} = nothing, ubyp::Union{<:CBMatrix,Nothing} = nothing, Gp::Union{<:CBSparsemat,Nothing} = nothing, rhslbp::Union{<:CBMatrix,Nothing} = nothing, rhsubp::Union{<:CBMatrix,Nothing} = nothing, start_val::Union{<:CBMatrix,Nothing} = nothing, costs::Union{<:CBMatrix,Nothing} = nothing, offset::Real = 0., in_groundset_id::Integer = 0)\n\nallows to specify the groundset in the constructor, zero is allowed everywhere\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBMatrix","page":"Reference of C++ interface","title":"ConicBundle.CBMatrix","text":"CBMatrix()\n\nempty matrix\n\n\n\n\n\nCBMatrix(param0::CBMatrix, d::Real = 1., atrans::Integer = 0)\n\ncopy constructor, this=dA\n\n\n\n\n\nCBMatrix(param0::AbstractRange{<:Real}, param0_tol::Real = 1e-8)\n\ngenerate a column vector holding the elements of this Realrange\n\n\n\n\n\nCBMatrix(nr::Integer, nc::Integer)\n\n@brief generate a matrix of size nr x nc but WITHOUT initializing the memory\n  If initializing the memory externally and CONICBUNDLE_DEBUG is defined, please use\n  set_init() via matrix.set_init(true) in order to avoid warnings concerning improper\n  initialization\n\n\n\n\n\nCBMatrix(nr::Integer, nc::Integer, d::Real)\n\ngenerate a matrix of size nr x nc initializing all elements to the value d\n\n\n\n\n\nCBMatrix(nr::Integer, nc::Integer, dp::Union{<:AbstractVector{Cdouble},Nothing}, d::Real = 1.)\n\ngenerate a matrix of size nr x nc initializing the elements from the (one dimensional) array dp with increment incr and scaled by d\n\n\n\n\n\nCBMatrix(A::CBIndexmatrix, d::Real = 1.)\n\n(this)=dA\n\n\n\n\n\nCBMatrix(A::CBSparsemat, d::Real = 1.)\n\n(this)=dA\n\n\n\n\n\nCBMatrix(S::CBSymmatrix, d::Real = 1.)\n\n(this)=dA\n\n\n\n\n\nCBMatrix(param0::CBSparsesym, d::Real = 1.)\n\n(this)=dA\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBMatrixCBSolver","page":"Reference of C++ interface","title":"ConicBundle.CBMatrixCBSolver","text":"CBMatrixCBSolver(print_level::Integer = 0)\n\ndefault constructor allows to set output level options from start (see also set_out())\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBMicroseconds","page":"Reference of C++ interface","title":"ConicBundle.CBMicroseconds","text":"CBMicroseconds()\n\ndefault constructor, value 0\n\n\n\n\n\nCBMicroseconds(infty::Bool)\n\nconstructor for setting value to 0 or infinity\n\n\n\n\n\nCBMicroseconds(m::CBMicroseconds)\n\ncopy constructor\n\n\n\n\n\nCBMicroseconds(secs::Integer, msecs::Integer = 0)\n\nspecify directly seconds and microseconds (in [0,10^6], no range check!)\n\n\n\n\n\nCBMicroseconds(hours::Integer, minutes::Integer, secs::Integer, micros::Integer)\n\nconvert hours, minutes, secs, micros to Microseconds (no range check!)\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBMinRes","page":"Reference of C++ interface","title":"ConicBundle.CBMinRes","text":"CBMinRes(pril::Integer = -1)\n\ndefault constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBMinorant","page":"Reference of C++ interface","title":"ConicBundle.CBMinorant","text":"CBMinorant(offset::Real, subg::CBDVector, primal::Union{<:CBPrimalData,Nothing} = nothing, offset_at_origin::Bool = false)\n\n@brief Minorant constructor for a dense subgradient specified via a DVector\nSuppose in the evaluation of your oracle at the current point \\f$y\\f$ you determine a subgradient \\f$s\\f$ for the subgradient inequality\n\n\\f[ f(z)\\ge f(y)+\\langle s,z-y\\rangle\\quad\\forall z\\in\\mathbf{R}^m, \\f]\n\nthen use \\f$f(y)\\f$ for @a offset and \\f$s\\f$ in the form of a DVector in @a subg and keep the default value @a offset_at_origin == false.\n\nIf, on the other hand, your oracle implements a support function for some compact set \\f$\\mathcal{X}\\subset\\mathbf{R}^m\\f$ like\n\n\\f[ f(y) = \\max_{x\\in\\mathcal{X}} x^\\top y\\f]\n\nthen it is actually more efficient to return 0 for @a offset,\na maximizing \\f$x\\f$ in @ subg and to put @a offset_at_origin = true.\n\nYou may also pass over a PrimalData object in primal that will be then be\nowned and later deleted by the minorant and aggregated along with the minornat\n\n\n\n\n\nCBMinorant(offset::Real, subg_val::CBDVector, subg_ind::CBIVector, primal::Union{<:CBPrimalData,Nothing} = nothing, offset_at_origin::Bool = false)\n\n@brief Minorant constructor for a sparse subgradient where the nonzero values are specified by DVector and the corresponding indices by an IVector\nSuppose in the evaluation of your oracle at the current point \\f$y\\f$ you determine a subgradient \\f$s\\f$ with few nonzeros for the subgradient inequality\n\n\\f[ f(z)\\ge f(y)+\\langle s,z-y\\rangle\\quad\\forall z\\in\\mathbf{R}^m, \\f]\n\nthen use \\f$f(y)\\f$ for @a offset and pass \\f$s\\f$ by giving the nonzeros in the DVector @a subg_val, the corresponding indices in a IVector of the same length in @a subg_ind and keep the default value @a offset_at_origin == false.\n\nIf, on the other hand, your oracle implements a support function for some compact set \\f$\\mathcal{X}\\subset\\mathbf{R}^m\\f$ like\n\n\\f[ f(y) = \\max_{x\\in\\mathcal{X}} x^\\top y\\f]\n\nthen it is actually more efficient to return 0 for @a offset,\na sparse maximizing \\f$x\\f$ in @a subg_val and @a subg_ind  and to put @a offset_at_origin = true.\n\nYou may also pass over a PrimalData object in primal that will be then be\nowned and later deleted by the minorant and aggregated along with the minornat\n\n\n\n\n\nCBMinorant(offset_at_origin::Bool = true, offset::Real = 0., n_elementes::Integer = 0, coeffs::Union{<:AbstractVector{Real},Nothing} = nothing, indices::Union{<:AbstractVector{Integer},Nothing} = nothing, scale_val::Real = 1., primal::Union{<:CBPrimalData,Nothing} = nothing)\n\n@brief default initializes a zero minorant, see full explanation otherwise; NOTE: if the offset supplied by the minorant refers to the evaluation point (i.e., if it is the function value at the point of evaluation), set @a offsetatorigin = false !\nIn many applications, in particular for Lagrangian relaxation,   the offset is more naturally given for the origin, and giving it this way   also reduces computational cost a bit, so @a offsetatorigin = true   is the suggested default. If, however, the minorant arises from a subgradient   inequality by evaluation in the current point, you may as well give the function   value as offset directly and set @a offsetatorigin=false;\nThe data specifying the minorant may be set here or (part of) it may be   entered/added later. The meaning of the other parameters is as follows.\n@a offset gives the constant value (if offsetatorigin = false then relative to   the evaluation point)\n@a n_elements gives the number of elements specified by @a coeffs   (and possibly indices), but if @a coeffs == NULL it just asks to reserve space   for that many coefficients\nIf @a coeffs is not NULL, it points to an array of doubles of size   at least @a nelements. If @a indices == NULL then coeff[i] belongs to position   i for i=0 to nelements-1, otherwise coeff[i] belongs to position indices[i].   All data is copied, the arrays are not modified, not used later and not   deleted here.\nThe entire input data (offset and coefficients) is multplied by @a scaleval   to give the final minorant (scaleval is not memorized internally but executed   immediately).\nIf the minorant arises from @a PrimalData and the primal data should be aggregated   along, it may be entered here or in the routine Minorant::set_primal(). The   object pointed to is then owned by Minorant and will be deleted by Minorant on its   destruction.\n\n\n\n\n\nCBMinorant(mnrt::Union{<:CBMinorant,Nothing}, factor::Real = 1., with_primal::Bool = false)\n\nthey main purpose of this constructor is to allow easy cloning for derived classes\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBMinorantPointer","page":"Reference of C++ interface","title":"ConicBundle.CBMinorantPointer","text":"CBMinorantPointer()\n\ndeclares the pointer empty\n\n\n\n\n\nCBMinorantPointer(in_md::Union{<:CBMinorantUseData,Nothing})\n\ninitialize this to point to in_md\n\n\n\n\n\nCBMinorantPointer(mp::CBMinorantPointer)\n\ncalls new_data\n\n\n\n\n\nCBMinorantPointer(mp::CBMinorantPointer, factor::Real)\n\ncalls init(const MinorantPointer&,CHMatrixClasses::Real)\n\n\n\n\n\nCBMinorantPointer(mnrt::Union{<:CBMinorant,Nothing}, modification_id::Integer, factor::Real = 1.)\n\ncalls init(Minorant*,CHMatrixClasses::Integer,CHMatrixClasses::Real)\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBMinorantUseData","page":"Reference of C++ interface","title":"ConicBundle.CBMinorantUseData","text":"CBMinorantUseData(mp::Union{<:CBMinorant,Nothing}, sval::Real, modif_id::Integer)\n\nconstructor for a new minorant with scaling @a sval and modification id @a modfi_id\n\n\n\n\n\nCBMinorantUseData(mdp::Union{<:CBMinorantUseData,Nothing}, sval::Real)\n\nconstructor for a recursively containing further MinorantUseData with an additional scaling factor @a sval\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBMode","page":"Reference of C++ interface","title":"ConicBundle.CBMode","text":"enum CBMode\n\ncbm_root\ncbm_child\ncbm_inactive\ncbm_unavailable\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBModelUpdate","page":"Reference of C++ interface","title":"ConicBundle.CBModelUpdate","text":"enum CBModelUpdate\n\ncbmu_new_subgradient\ncbmu_descent_step\ncbmu_null_step\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBNNCBoxSupportFunction","page":"Reference of C++ interface","title":"ConicBundle.CBNNCBoxSupportFunction","text":"CBNNCBoxSupportFunction(lb::CBMatrix, ub::CBMatrix, incr::Integer = -1)\n\nintialize with lower bounds vector lb and upper bounds vector ub (and output options), both must be column vectors of the same length and lb<=ub componentwise, length 0 results in objective value 0\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBNNCBoxSupportMinorantExtender","page":"Reference of C++ interface","title":"ConicBundle.CBNNCBoxSupportMinorantExtender","text":"CBNNCBoxSupportMinorantExtender(fun::Union{<:CBNNCBoxSupportFunction,Nothing})\n\nthe NNCBoxSupportFunction pointed to has to be valid for the livetime of this object\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBNNCBoxSupportModification","page":"Reference of C++ interface","title":"ConicBundle.CBNNCBoxSupportModification","text":"CBNNCBoxSupportModification(var_olddim::Integer = 0, incr::Integer = -1)\n\nconstructor, calls modification constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBNNCData","page":"Reference of C++ interface","title":"ConicBundle.CBNNCData","text":"CBNNCData(fun_factor::Real = 1., fun_task::CBFunctionTask = cbft_objective_function)\n\ninitializes BundleData, sets center_primal to NULL and calls clear()\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBNNCModel","page":"Reference of C++ interface","title":"ConicBundle.CBNNCModel","text":"CBNNCModel(fo::Union{<:CBMatrixFunctionOracle,Nothing}, fun_factor::Real = 1., fun_task::CBFunctionTask = cbft_objective_function, cbinc::Integer = -1)\n\nconstruct a model for the MatrixFunctionOracle pointed to by @a fo\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBNNCModelParameters","page":"Reference of C++ interface","title":"ConicBundle.CBNNCModelParameters","text":"CBNNCModelParameters(modelsize::Integer, bundlesize::Integer = 10, updaterule::Integer = 0, incr::Integer = -1)\n\nconstructor for size parameters\n\n\n\n\n\nCBNNCModelParameters(bp::CBBundleParameters, incr::Integer = -1)\n\ncopy constructor for BundleParameters\n\n\n\n\n\nCBNNCModelParameters(sms::CBNNCModelParameters)\n\ncopy constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBPCG","page":"Reference of C++ interface","title":"ConicBundle.CBPCG","text":"CBPCG(pril::Integer = -1)\n\ndefault constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBPSCAffineFunction","page":"Reference of C++ interface","title":"ConicBundle.CBPSCAffineFunction","text":"CBPSCAffineFunction(C::CBSparseCoeffmatMatrix, opAt::CBSparseCoeffmatMatrix, generating_primal::Union{<:CBPSCPrimal,Nothing} = nothing, incr::Integer = -1)\n\n@brief initialize the PSCAffineFunction with its matrices and possible a generating_primal\nC and opAt define the constant (block-)offset and the linear (block-)matrix function as described in the general text of PSCAffineFunction\ngenerating_primal defines in what form primal matrices should be aggregated. If the argument is NULL then no primal aggregation will take place.  The control over the generating primal is passed over to this. This will delete an existing generating primal whenever a new generating primal is set or upon destruction.\nThe final two arguments allow to set the output, see CBout.\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBPSCAffineMinorantExtender","page":"Reference of C++ interface","title":"ConicBundle.CBPSCAffineMinorantExtender","text":"CBPSCAffineMinorantExtender(amf::Union{<:CBPSCAffineFunction,Nothing})\n\nthe PSCAffineFunction pointed to has to be valid for the livetime of this object\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBPSCAffineModification","page":"Reference of C++ interface","title":"ConicBundle.CBPSCAffineModification","text":"CBPSCAffineModification(var_olddim::Integer, block_olddim::CBIndexmatrix, incr::Integer = 0)\n\ncalls clear() with these parameters\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBPSCBundleParameters","page":"Reference of C++ interface","title":"ConicBundle.CBPSCBundleParameters","text":"CBPSCBundleParameters()\n\ndefault constructor\n\n\n\n\n\nCBPSCBundleParameters(bp::CBBundleParameters)\n\n\"copy\" constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBPSCData","page":"Reference of C++ interface","title":"ConicBundle.CBPSCData","text":"CBPSCData(fun_factor::Real = 1., fun_task::CBFunctionTask = cbft_objective_function)\n\ncalls clear()\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBPSCModel","page":"Reference of C++ interface","title":"ConicBundle.CBPSCModel","text":"CBPSCModel(fo::Union{<:CBPSCOracle,Nothing}, fun_factor::Real = 1., fun_task::CBFunctionTask = cbft_objective_function, cbinc::Integer = -1)\n\nconstruct a model for the MatrixFunctionOracle pointed to by @a fo\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBPSCModelParameters","page":"Reference of C++ interface","title":"ConicBundle.CBPSCModelParameters","text":"CBPSCModelParameters(modelsize::Integer, bundlesize::Integer = 10, updaterule::Integer = 0, incr::Integer = -1)\n\nconstructor for size parameters\n\n\n\n\n\nCBPSCModelParameters(bp::CBBundleParameters, incr::Integer = -1)\n\ncopy constructor for BundleParameters\n\n\n\n\n\nCBPSCModelParameters(sms::CBPSCModelParameters)\n\ncopy constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBPSCVariableMetricSelection","page":"Reference of C++ interface","title":"ConicBundle.CBPSCVariableMetricSelection","text":"CBPSCVariableMetricSelection(cbincr::Integer = -1)\n\ndefault constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBPrimalMatrix","page":"Reference of C++ interface","title":"ConicBundle.CBPrimalMatrix","text":"CBPrimalMatrix()\n\nempty matrix\n\n\n\n\n\nCBPrimalMatrix(nr::Integer, nc::Integer)\n\n@brief generate a matrix of size nr x nc but WITHOUT initializing the memory\n  If initializing the memory externally and CONICBUNDLE_DEBUG is defined, please use\n  set_init() via matrix.set_init(true) in order to avoid warnings concerning improper\n  initialization\n\n\n\n\n\nCBPrimalMatrix(r::Integer, c::Integer, d::Real)\n\ngenerate a matrix of size nr x nc initializing all elements to the value d\n\n\n\n\n\nCBPrimalMatrix(pm::CBPrimalMatrix)\n\ncopy constructor, *this=pm\n\n\n\n\n\nCBPrimalMatrix(pm::CBMatrix)\n\ncopy constructor, *this=pm\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBPsqmr","page":"Reference of C++ interface","title":"ConicBundle.CBPsqmr","text":"CBPsqmr(pril::Integer = -1)\n\ndefault constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBQPConeModelBlock","page":"Reference of C++ interface","title":"ConicBundle.CBQPConeModelBlock","text":"CBQPConeModelBlock(cbinc::Integer = -1)\n\ndefault constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBQPDirectKKTSolver","page":"Reference of C++ interface","title":"ConicBundle.CBQPDirectKKTSolver","text":"CBQPDirectKKTSolver(in_factorize_ABC::Bool = false, cbinc::Integer = -1)\n\ndefault constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBQPIterativeKKTHASolver","page":"Reference of C++ interface","title":"ConicBundle.CBQPIterativeKKTHASolver","text":"CBQPIterativeKKTHASolver(insolver::Union{<:CBIterativeSolverObject,Nothing}, inprecond::Union{<:CBQPKKTPrecondObject,Nothing} = nothing, cbinc::Integer = -1)\n\ndefault constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBQPIterativeKKTHAeqSolver","page":"Reference of C++ interface","title":"ConicBundle.CBQPIterativeKKTHAeqSolver","text":"CBQPIterativeKKTHAeqSolver(insolver::Union{<:CBIterativeSolverObject,Nothing}, inprecond::Union{<:CBQPKKTPrecondObject,Nothing} = nothing, cbinc::Integer = -1)\n\ndefault constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBQPKKTSolverComparison","page":"Reference of C++ interface","title":"ConicBundle.CBQPKKTSolverComparison","text":"CBQPKKTSolverComparison(cbinc::Integer = -1)\n\ndefault constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBQPKKTSubspaceHPrecond","page":"Reference of C++ interface","title":"ConicBundle.CBQPKKTSubspaceHPrecond","text":"CBQPKKTSubspaceHPrecond(inmethod::Integer = 0, cbinc::Integer = -1)\n\ndefault constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBQPSolver","page":"Reference of C++ interface","title":"ConicBundle.CBQPSolver","text":"CBQPSolver(cbinc::Integer = -1)\n\ndefault constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBQPSolverParameters","page":"Reference of C++ interface","title":"ConicBundle.CBQPSolverParameters","text":"CBQPSolverParameters(incr::Integer = -1)\n\ndefault constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBQPSumModelBlock","page":"Reference of C++ interface","title":"ConicBundle.CBQPSumModelBlock","text":"CBQPSumModelBlock(cbincr::Integer = -1)\n\ndefault constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBSOCData","page":"Reference of C++ interface","title":"ConicBundle.CBSOCData","text":"CBSOCData(fun_factor::Real = 1., fun_task::CBFunctionTask = cbft_objective_function)\n\ncalls clear()\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBSOCModel","page":"Reference of C++ interface","title":"ConicBundle.CBSOCModel","text":"CBSOCModel(fo::Union{<:CBSOCOracle,Nothing}, fun_factor::Real = 1., fun_task::CBFunctionTask = cbft_objective_function, cbinc::Integer = -1)\n\nconstruct a model for the MatrixFunctionOracle pointed to by @a fo\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBSOCModelParameters","page":"Reference of C++ interface","title":"ConicBundle.CBSOCModelParameters","text":"CBSOCModelParameters(modelsize::Integer, bundlesize::Integer = 10, updaterule::Integer = 0, incr::Integer = -1)\n\nconstructor for size parameters\n\n\n\n\n\nCBSOCModelParameters(bp::CBBundleParameters, incr::Integer = -1)\n\ncopy constructor for BundleParameters\n\n\n\n\n\nCBSOCModelParameters(sms::CBSOCModelParameters)\n\ncopy constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBSOCSupportFunction","page":"Reference of C++ interface","title":"ConicBundle.CBSOCSupportFunction","text":"CBSOCSupportFunction(socdim::Integer, incr::Integer = -1)\n\ninitialize with dimension >= 1 (and output options)\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBSOCSupportMinorantExtender","page":"Reference of C++ interface","title":"ConicBundle.CBSOCSupportMinorantExtender","text":"CBSOCSupportMinorantExtender(fun::Union{<:CBSOCSupportFunction,Nothing})\n\nthe SOCSupportFunction pointed to has to be valid for the livetime of this object\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBSOCSupportModification","page":"Reference of C++ interface","title":"ConicBundle.CBSOCSupportModification","text":"CBSOCSupportModification(var_olddim::Integer = 0, incr::Integer = -1)\n\nconstructor, calls modification constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBSparseCoeffmatMatrix","page":"Reference of C++ interface","title":"ConicBundle.CBSparseCoeffmatMatrix","text":"CBSparseCoeffmatMatrix(incr::Integer = -1)\n\nset the output and call clear()\n\n\n\n\n\nCBSparseCoeffmatMatrix(S::CBSparseCoeffmatMatrix, incr::Integer = -1)\n\nset the output and call clear()\n\n\n\n\n\nCBSparseCoeffmatMatrix(in_block_dim::CBIndexmatrix, in_col_dim::Integer, block_ind::Union{<:CBIndexmatrix,Nothing} = nothing, col_ind::Union{<:CBIndexmatrix,Nothing} = nothing, coeff_vec::Union{<:CBCoeffmatVector,Nothing} = nothing, incr::Integer = -1)\n\nset the output and call init() for the given sparse information\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBSparsePSCPrimal","page":"Reference of C++ interface","title":"ConicBundle.CBSparsePSCPrimal","text":"CBSparsePSCPrimal(sps::CBSparsesym, factor::Real = 1.)\n\ncopy constructor from a CHMatrixClasses::Sparssym, only the support of this matrix  will be used in all Gram operations\n\n\n\n\n\nCBSparsePSCPrimal(pr::CBSparsePSCPrimal, factor::Real = 1.)\n\ncopy constructor, only the same support will be used in all Gram operations\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBSparsemat","page":"Reference of C++ interface","title":"ConicBundle.CBSparsemat","text":"CBSparsemat()\n\nempty matrix\n\n\n\n\n\nCBSparsemat(A::CBSparsemat, d::Real = 1.)\n\ncopy constructor, this=dA, abs(values)<tol are removed from the support\n\n\n\n\n\nCBSparsemat(nr::Integer, nc::Integer)\n\ninitialize to zero-matrix of size nr*nc\n\n\n\n\n\nCBSparsemat(nr::Integer, nc::Integer, nz::Integer, ini::Union{<:AbstractVector{Cint},Nothing}, inj::Union{<:AbstractVector{Cint},Nothing}, va::Union{<:AbstractVector{Cdouble},Nothing})\n\ninitialize to size nr*nc and nz nonzeros so that this(ini[i],inj[i])=val[i] for i=0,..,nz-1; multiple elements are summed up.\n\n\n\n\n\nCBSparsemat(nr::Integer, nc::Integer, nz::Integer, ini::CBIndexmatrix, inj::CBIndexmatrix, va::CBMatrix)\n\ninitialize to size nr*nc and nz nonzeros so that this(ini(i),inj(i))=val(i) for i=0,..,nz-1; multiple elements are summed up.\n\n\n\n\n\nCBSparsemat(A::CBMatrix, d::Real = 1.)\n\ninitialize to this=dA, abs(values)<tol are removed from the support\n\n\n\n\n\nCBSparsemat(A::CBIndexmatrix, d::Real = 1.)\n\ninitialize to this=dA, zeros are removed from the support\n\n\n\n\n\nCBSparsemat(A::CBSymmatrix, d::Real = 1.)\n\ninitialize to this=dA, abs(values)<tol are removed from the support\n\n\n\n\n\nCBSparsemat(A::CBSparsesym, d::Real = 1.)\n\ninitialize to this=dA\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBSparsesym","page":"Reference of C++ interface","title":"ConicBundle.CBSparsesym","text":"CBSparsesym()\n\nempty matrix\n\n\n\n\n\nCBSparsesym(A::CBSparsesym, d::Real = 1.)\n\ncopy constructor, this=dA\n\n\n\n\n\nCBSparsesym(nr::Integer)\n\ninitialize to zero-matrix of size nr*nr\n\n\n\n\n\nCBSparsesym(nr::Integer, nz::Integer, ini::Union{<:AbstractVector{Cint},Nothing}, inj::Union{<:AbstractVector{Cint},Nothing}, va::Union{<:AbstractVector{Cdouble},Nothing})\n\ninitialize to size nr*nr and nz nonzeros so that this(ini[i],inj[i])=val[i] for i=0,..,nz-1; specify only one of (i,j) and (j,i), multiple elements are summed up.\n\n\n\n\n\nCBSparsesym(nr::Integer, nz::Integer, ini::CBIndexmatrix, inj::CBIndexmatrix, va::CBMatrix)\n\ninitialize to size nr*nr and nz nonzeros so that this(ini(i),inj(i))=val[i] for i=0,..,nz-1; specify only one of (i,j) and (j,i), multiple elements are summed up.\n\n\n\n\n\nCBSparsesym(param0::CBMatrix, d::Real = 1.)\n\ninitialize to this=d(A+transpose(A))/2., abs(values)<tol are removed from the support\n\n\n\n\n\nCBSparsesym(param0::CBIndexmatrix, d::Real = 1.)\n\ninitialize to this=d(A+transpose(A))/2., zeros are removed from the support\n\n\n\n\n\nCBSparsesym(param0::CBSymmatrix, d::Real = 1.)\n\ninitialize to this=Ad, abs(values)<tol are removed from the support\n\n\n\n\n\nCBSparsesym(param0::CBSparsemat, d::Real = 1.)\n\ninitialize to this=d(A+transpose(A))/2.\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBSumBundle","page":"Reference of C++ interface","title":"ConicBundle.CBSumBundle","text":"CBSumBundle(sb::CBSumBundle)\n\ncopy constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBSumBundleParameters","page":"Reference of C++ interface","title":"ConicBundle.CBSumBundleParameters","text":"CBSumBundleParameters(modelsize::Integer, bundlesize::Integer = 10, updaterule::Integer = 0, incr::Integer = -1)\n\nconstructor for customized parameters\n\n\n\n\n\nCBSumBundleParameters(sbp::CBSumBundleParameters)\n\ncopy constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBSumModel","page":"Reference of C++ interface","title":"ConicBundle.CBSumModel","text":"CBSumModel()\n\nconstructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBSymmatrix","page":"Reference of C++ interface","title":"ConicBundle.CBSymmatrix","text":"CBSymmatrix()\n\nempty matrix\n\n\n\n\n\nCBSymmatrix(A::CBSymmatrix, d::Real = 1.)\n\ncopy constructor, this=dA\n\n\n\n\n\nCBSymmatrix(nr::Integer)\n\n@brief generate a matrix of size nr x nr but WITHOUT initializing the memory\n  If initializing the memory externally and CONICBUNDLE_DEBUG is defined, please use\n  set_init() via matrix.set_init(true) in order to avoid warnings concerning improper\n  initialization\n\n\n\n\n\nCBSymmatrix(nr::Integer, d::Real)\n\ngenerate a matrix of size nr x nr initializing all elements to the value d\n\n\n\n\n\nCBSymmatrix(nr::Integer, dp::Union{<:AbstractVector{Cdouble},Nothing})\n\ngenerate a matrix of size nr x nr initializing the elements from the (one dimensional) array dp, which must have the elements arranged consecutively in internal order\n\n\n\n\n\nCBSymmatrix(param0::CBMatrix, d::Real = 1.)\n\n(this)=d(A+transpose(A))/2.\n\n\n\n\n\nCBSymmatrix(param0::CBIndexmatrix, d::Real = 1.)\n\n(this)=d(A+transpose(A))/2.\n\n\n\n\n\nCBSymmatrix(A::CBSparsesym, d::Real = 1.)\n\n(this)=dA\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBUQPConeModelBlock","page":"Reference of C++ interface","title":"ConicBundle.CBUQPConeModelBlock","text":"CBUQPConeModelBlock(cbinc::Integer = -1)\n\ndefault constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBUQPSolver","page":"Reference of C++ interface","title":"ConicBundle.CBUQPSolver","text":"CBUQPSolver(cbinc::Integer = -1)\n\ndefault constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBUQPSumModelBlock","page":"Reference of C++ interface","title":"ConicBundle.CBUQPSumModelBlock","text":"CBUQPSumModelBlock(incr::Integer = -1)\n\ndefault constructor\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBUnconstrainedGroundset","page":"Reference of C++ interface","title":"ConicBundle.CBUnconstrainedGroundset","text":"CBUnconstrainedGroundset(indim::Integer = 0, start_val::Union{<:CBMatrix,Nothing} = nothing, costs::Union{<:CBMatrix,Nothing} = nothing, offset::Real = 0., in_groundset_id::Integer = 0)\n\ncalls clear() with the same parameters\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.CBVariableMetricSVDSelection","page":"Reference of C++ interface","title":"ConicBundle.CBVariableMetricSVDSelection","text":"CBVariableMetricSVDSelection(cbincr::Integer = -1)\n\ndefault constructor\n\n\n\n\n\nCBVariableMetricSVDSelection(in_n_latest_minorants::Integer, in_selection_method::Integer, in_oldfactor::Real = 0., cbincr::Integer = -1)\n\nconstructor for specifying values for nlatestminorants and selection_method\n\n\n\n\n\n","category":"type"},{"location":"cppref.html#ConicBundle.cb_Aasen_Lsolve","page":"Reference of C++ interface","title":"ConicBundle.cb_Aasen_Lsolve","text":"cb_Aasen_Lsolve(self::CBSymmatrix, x::CBMatrix)\n\ncomputes, after Aasen_factor into LTL^T was executed, the solution to Lx=rhs; rhs is overwritten by the solution; always returns 0;\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_Aasen_Ltsolve","page":"Reference of C++ interface","title":"ConicBundle.cb_Aasen_Ltsolve","text":"cb_Aasen_Ltsolve(self::CBSymmatrix, x::CBMatrix)\n\ncomputes, after Aasen_factor into LTL^T was executed, the solution to L^Tx=rhs; rhs is overwritten by the solution; always returns 0;\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_Aasen_factor!","page":"Reference of C++ interface","title":"ConicBundle.cb_Aasen_factor!","text":"cb_Aasen_factor!(self::CBSymmatrix, piv::CBIndexmatrix)\n\ncomputes Aasen factorization LTL^T with pivoting, where L is unit lower triangular with first colum e_1 and T is tridiagonal; (this) is overwritten by the factorization, with column i of L being stored in column i-1 of (this); always returns 0;\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_Aasen_solve","page":"Reference of C++ interface","title":"ConicBundle.cb_Aasen_solve","text":"cb_Aasen_solve(self::CBSymmatrix, x::CBMatrix, piv::CBIndexmatrix)\n\ncomputes, after Aasenfactor into LTL^T was executed, the solution to (*oldthis)x=rhs; rhs is overwritten by the solution; if the solution fails due to division by zero (=system not solvable) the return value is -(rowindex+1) where this occured in the backsolve\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_Aasen_tridiagsolve","page":"Reference of C++ interface","title":"ConicBundle.cb_Aasen_tridiagsolve","text":"cb_Aasen_tridiagsolve(self::CBSymmatrix, x::CBMatrix)\n\ncomputes, after Aasen_factor into LTL^T was executed, the solution to Tx=rhs; rhs is overwritten by the solution;if the solution fails due to division by zero (=system not solvable) the return value is -(rowindex+1) where this occured in the backsolve\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_B_times!","page":"Reference of C++ interface","title":"ConicBundle.cb_B_times!","text":"cb_B_times!(self::CBQPConeModelBlock, A::CBMatrix, C::CBMatrix, alpha::Real, beta::Real, Btrans::Integer, Atrans::Integer, startindex_model::Integer, globalbundle::CBMinorantBundle, startindex_bundle::Integer)\n\nC=betaC+alphaB*A where B and A may be transposed; carry out the model part of this beginning at startindex_model and beta for the part, that is added to (the calling routine has to make sure beta is not executed repeatedly if the same part is affected by other models as well)\n\n\n\n\n\ncb_B_times!(self::CBQPSumModelBlock, A::CBMatrix, C::CBMatrix, alpha::Real, beta::Real, Btrans::Integer, Atrans::Integer, startindex_model::Integer, globalbundle::CBMinorantBundle, startindex_bundle::Integer)\n\nC=betaC+alphaB*A where B and A may be transposed; carry out the model part of this beginning at startindex_model and beta for the part, that is added to (the calling routine has to make sure beta is not executed repeatedly if the same part is affected by other models as well)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_Chol_Lmult","page":"Reference of C++ interface","title":"ConicBundle.cb_Chol_Lmult","text":"cb_Chol_Lmult(self::CBSymmatrix, rhs::CBMatrix)\n\ncomputes, after Chol_factor into LL^T was executed succesfully,  L*rhs, overwriting rhs by the result; always returns 0;\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_Chol_Lsolve","page":"Reference of C++ interface","title":"ConicBundle.cb_Chol_Lsolve","text":"cb_Chol_Lsolve(self::CBSymmatrix, rhs::CBMatrix)\n\ncomputes, after Chol_factor into LL^T was executed succesfully, the solution to Lx=rhs; rhs is overwritten by the solution; always returns 0; NOTE: there is NO check against division by zero\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_Chol_Ltmult","page":"Reference of C++ interface","title":"ConicBundle.cb_Chol_Ltmult","text":"cb_Chol_Ltmult(self::CBSymmatrix, rhs::CBMatrix)\n\ncomputes, after Chol_factor into LL^T was executed succesfully,  L^Trhs, overwriting rhs by the result; always returns 0;\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_Chol_Ltsolve","page":"Reference of C++ interface","title":"ConicBundle.cb_Chol_Ltsolve","text":"cb_Chol_Ltsolve(self::CBSymmatrix, rhs::CBMatrix)\n\ncomputes, after Chol_factor into LL^T was executed succesfully, the solution to L^Tx=rhs; rhs is overwritten by the solution; always returns 0; NOTE: there is NO check against division by zero\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_Chol_factor!","page":"Reference of C++ interface","title":"ConicBundle.cb_Chol_factor!","text":"cb_Chol_factor!(self::CBSymmatrix, tol::Real = 1e-10)\n\ncomputes the Cholesky factorization, for positive definite matrices only, (*this) is overwritten by the factorization; there is no pivoting; returns 1 if diagonal elements go below tol\n\n\n\n\n\ncb_Chol_factor!(self::CBSymmatrix, piv::CBIndexmatrix, tol::Real = 1e-10)\n\ncomputes the Cholesky factorization with pivoting, for positive semidefinite matrices only, (*this) is overwritten by the factorization; on termination piv.dim() is the number of positive pivots>=tol; returns 1 if negative diagonal element is encountered during computations, 0 otherwise.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_Chol_inverse","page":"Reference of C++ interface","title":"ConicBundle.cb_Chol_inverse","text":"cb_Chol_inverse(self::CBSymmatrix, S::CBSymmatrix)\n\ncomputes, after Cholfactor was executed succesfully, the inverse to (*oldthis) and stores it in S (numerically not too wise); always returns 0; NOTE: there is NO check against division by zero\n\n\n\n\n\ncb_Chol_inverse(self::CBSymmatrix, S::CBSymmatrix, piv::CBIndexmatrix)\n\ncomputes, after Cholfactor(Indexmatrix&,Real) with pivoting was executed succesfully, the inverse to (*oldthis) and stores it in S (the pivoting permutation is undone in S); NOTE: there is NO check against division by zero\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_Chol_scaleLi","page":"Reference of C++ interface","title":"ConicBundle.cb_Chol_scaleLi","text":"cb_Chol_scaleLi(self::CBSymmatrix, S::CBSymmatrix)\n\ncomputes, after Chol_factor into LL^T was executed succesfully, L^{-1}SL^{-T} overwriting S\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_Chol_scaleLt","page":"Reference of C++ interface","title":"ConicBundle.cb_Chol_scaleLt","text":"cb_Chol_scaleLt(self::CBSymmatrix, S::CBSymmatrix)\n\ncomputes, after Chol_factor into LL^T was executed succesfully, L^TSL overwriting S\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_Chol_solve","page":"Reference of C++ interface","title":"ConicBundle.cb_Chol_solve","text":"cb_Chol_solve(self::CBSymmatrix, x::CBMatrix)\n\ncomputes, after Cholfactor was executed succesfully, the solution to (*oldthis)x=rhs; rhs is overwritten by the solution; always returns 0; NOTE: there is NO check against division by zero\n\n\n\n\n\ncb_Chol_solve(self::CBSymmatrix, x::CBMatrix, piv::CBIndexmatrix)\n\ncomputes, after Cholfactor(Indexmatrix&,Real) with pivoting was executed succesfully, the solution to (*oldthis)*x=rhs(piv); rhs is overwritten by the solution arranged in original unpermuted order; always returns 0; NOTE: there is NO check against division by zero\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_Diag","page":"Reference of C++ interface","title":"ConicBundle.cb_Diag","text":"cb_Diag(A::CBMatrix)\n\nreturns a symmetric diagonal matrix S of order A.dim() with vec(A) on the diagonal, i.e., S(i,i)=A(i) for all i and S(i,j)=0 for i!=j\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_Gram_ip","page":"Reference of C++ interface","title":"ConicBundle.cb_Gram_ip","text":"cb_Gram_ip(self::CBSparseCoeffmatMatrix, ipvec::CBMatrix, P::CBMatrix, Lam::Union{<:CBMatrix,Nothing} = nothing, ind::Union{<:CBIndexmatrix,Nothing} = nothing)\n\ncomputes the inner products of (selected) columns (which represent block diagonal symmetric matrices) with the Gram matrix PP^T (or, if Lam is given, PDiag(Lam)P^T) into the column vector ipvec(j)=ip(PP^T,A.column((*ind)(j)}) (j=0,...,ind->dim()-1); if ind==NULL, use all columns\n\n\n\n\n\ncb_Gram_ip(self::CBSparseCoeffmatMatrix, P::CBMatrix, j::Integer)\n\ncomputes the inner product of the block diagonal symmetric matrix stored in colummn j with the Gram matrix PP^T into ipval=ip(PP^T,A.column(j))\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_ItSys_mult!","page":"Reference of C++ interface","title":"ConicBundle.cb_ItSys_mult!","text":"cb_ItSys_mult!(self::CBQPIterativeKKTHAeqSolver, in_vec::CBMatrix, out_vec::CBMatrix)\n\nreturns outvec=(system matrix)*invec\n\n\n\n\n\ncb_ItSys_mult!(self::CBQPIterativeKKTHASolver, in_vec::CBMatrix, out_vec::CBMatrix)\n\nreturns outvec=(system matrix)*invec\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_LDLfactor!","page":"Reference of C++ interface","title":"ConicBundle.cb_LDLfactor!","text":"cb_LDLfactor!(self::CBSymmatrix, tol::Real = 1e-10)\n\ncomputes LDLfactorization (implemented only for positive definite matrices so far, no pivoting), (*this) is overwritten by the factorization; returns 1 if diagonal elements go below tol\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_LDLinverse","page":"Reference of C++ interface","title":"ConicBundle.cb_LDLinverse","text":"cb_LDLinverse(self::CBSymmatrix, S::CBSymmatrix)\n\ncomputes, after LDLfactor was executed succesfully, the inverse to (*old_this) and stores it in S (numerically not too wise); always returns 0; NOTE: there is NO check against division by zero\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_LDLsolve","page":"Reference of C++ interface","title":"ConicBundle.cb_LDLsolve","text":"cb_LDLsolve(self::CBSymmatrix, x::CBMatrix)\n\ncomputes, after LDLfactor was executed succesfully, the solution to (*old_this)x=rhs; rhs is overwritten by the solution; always returns 0; NOTE: there is NO check against division by zero\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPallow_UQPSolver!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPallow_UQPSolver!","text":"cb_QPallow_UQPSolver!(self::CBQPSolverParameters)\n\nset to true/false if switching to the unconstrained solver is allowed or not\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPapply_modification!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPapply_modification!","text":"cb_QPapply_modification!(self::CBQPSolver, mdf::CBGroundsetModification)\n\ngroundset changes are communicated to the solver here\n\n\n\n\n\ncb_QPapply_modification!(self::CBUQPSolver, param0::CBGroundsetModification)\n\nno modifications need to be carried out here as there is no data to be modified, so any modification succeeds\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPclear!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPclear!","text":"cb_QPclear!(self::CBQPSolver)\n\n(re)initialize to empty\n\n\n\n\n\ncb_QPclear!(self::CBUQPSolver)\n\ncalls clear(), i.e. reinitialize completely\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPconstrained","page":"Reference of C++ interface","title":"ConicBundle.cb_QPconstrained","text":"cb_QPconstrained(self::CBQPSolver)\n\nreturns false if the feasible set is the entire space (unconstrained optimization), true otherwise.\n\n\n\n\n\ncb_QPconstrained(self::CBUQPSolver)\n\nit is always unconstrained\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPensure_feasibility!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPensure_feasibility!","text":"cb_QPensure_feasibility!(self::CBQPSolver, y::CBMatrix, ychanged::Bool, inHp::Union{<:CBQPSolverProxObject,Nothing}, relprec::Real = 1e-10)\n\nmakes y feasible if not so, see Groundset::ensure_feasibility()\n\n\n\n\n\ncb_QPensure_feasibility!(self::CBUQPSolver, param0::CBMatrix, ychanged::Bool, param2::Union{<:CBQPSolverProxObject,Nothing}, param3::Real = 1e-10)\n\nfor the unconstrained solver any point is feasible, because it cannot even check the dimension of the design space, so any y is left unchanged\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPget_KKTsolver!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPget_KKTsolver!","text":"cb_QPget_KKTsolver!(self::CBQPSolverParameters)\n\nget this variable value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPget_blockA_norm!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPget_blockA_norm!","text":"cb_QPget_blockA_norm!(self::CBQPKKTSolverComparison)\n\nfor judging violation this returns (an estimate of) the norm of the A-row in the latest system\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPget_blockH_norm!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPget_blockH_norm!","text":"cb_QPget_blockH_norm!(self::CBQPKKTSolverComparison)\n\nfor judging violation this returns (an estimate of) the norm of the H-row in the latest system\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPget_dual_infeasibility_eps","page":"Reference of C++ interface","title":"ConicBundle.cb_QPget_dual_infeasibility_eps","text":"cb_QPget_dual_infeasibility_eps(self::CBQPSolverParameters)\n\nget this variable value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPget_lower_bound","page":"Reference of C++ interface","title":"ConicBundle.cb_QPget_lower_bound","text":"cb_QPget_lower_bound(self::CBQPSolverParameters)\n\nget this variable value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPget_lower_bound!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPget_lower_bound!","text":"cb_QPget_lower_bound!(self::CBQPSolver)\n\nreturns the current lower bound on the optimal value (if feasibility is good enough)\n\n\n\n\n\ncb_QPget_lower_bound!(self::CBUQPSolver)\n\nreturn the lower bound on the objective value of the bundle subproblem\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPget_lower_bound_gap_eps","page":"Reference of C++ interface","title":"ConicBundle.cb_QPget_lower_bound_gap_eps","text":"cb_QPget_lower_bound_gap_eps(self::CBQPSolverParameters)\n\nget this variable value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPget_maxiter","page":"Reference of C++ interface","title":"ConicBundle.cb_QPget_maxiter","text":"cb_QPget_maxiter(self::CBQPSolverParameters)\n\nget this variable value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPget_min_objective_relprec","page":"Reference of C++ interface","title":"ConicBundle.cb_QPget_min_objective_relprec","text":"cb_QPget_min_objective_relprec(self::CBQPSolverParameters)\n\nget this variable value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPget_nbh_lb","page":"Reference of C++ interface","title":"ConicBundle.cb_QPget_nbh_lb","text":"cb_QPget_nbh_lb(self::CBQPSolverParameters)\n\nget this variable value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPget_nbh_ub","page":"Reference of C++ interface","title":"ConicBundle.cb_QPget_nbh_ub","text":"cb_QPget_nbh_ub(self::CBQPSolverParameters)\n\nget this variable value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPget_objective_gap_eps","page":"Reference of C++ interface","title":"ConicBundle.cb_QPget_objective_gap_eps","text":"cb_QPget_objective_gap_eps(self::CBQPSolverParameters)\n\nget this variable value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPget_primal_infeasibility_eps","page":"Reference of C++ interface","title":"ConicBundle.cb_QPget_primal_infeasibility_eps","text":"cb_QPget_primal_infeasibility_eps(self::CBQPSolverParameters)\n\nget this variable value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPget_solution!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPget_solution!","text":"cb_QPget_solution!(self::CBQPSolver, new_point::CBMatrix, gsaggr_gradient::CBMatrix)\n\nretrieve the solution produced (see \\ref InternalQPSolverInterface)\n\n\n\n\n\ncb_QPget_solution!(self::CBUQPSolver, new_point::CBMatrix, gsaggr_gradient::CBMatrix)\n\nthe unconstrained solver can only provide this information if the references to the input data of QPsolve() and QPudate() are still available and unchanged, otherwise the behavior is undefined and will hopefully return 1 if not valid\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPget_system_size!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPget_system_size!","text":"cb_QPget_system_size!(self::CBQPIterativeKKTHAeqSolver)\n\nfor evaluation purposes with iterative solvers, return the size of the system matrix\n\n\n\n\n\ncb_QPget_system_size!(self::CBQPIterativeKKTHASolver)\n\nfor evaluation purposes with iterative solvers, return the size of the system matrix\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPget_upper_bound","page":"Reference of C++ interface","title":"ConicBundle.cb_QPget_upper_bound","text":"cb_QPget_upper_bound(self::CBQPSolverParameters)\n\nget this variable value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPget_upper_bound_gap_eps","page":"Reference of C++ interface","title":"ConicBundle.cb_QPget_upper_bound_gap_eps","text":"cb_QPget_upper_bound_gap_eps(self::CBQPSolverParameters)\n\nget this variable value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPget_use_neighborhood","page":"Reference of C++ interface","title":"ConicBundle.cb_QPget_use_neighborhood","text":"cb_QPget_use_neighborhood(self::CBQPSolverParameters)\n\nget this variable value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPget_use_predictor_corrector","page":"Reference of C++ interface","title":"ConicBundle.cb_QPget_use_predictor_corrector","text":"cb_QPget_use_predictor_corrector(self::CBQPSolverParameters)\n\nget this variable value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPget_use_socqp","page":"Reference of C++ interface","title":"ConicBundle.cb_QPget_use_socqp","text":"cb_QPget_use_socqp(self::CBQPSolverParameters)\n\nget this variable value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPinit_KKTdata!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPinit_KKTdata!","text":"cb_QPinit_KKTdata!(self::CBQPDirectKKTSolver, Hp::Union{<:CBQPSolverProxObject,Nothing}, model::Union{<:CBQPModelBlockObject,Nothing}, A::Union{<:CBSparsemat,Nothing}, eq_indices::Union{<:CBIndexmatrix,Nothing})\n\nreturns 1 if this class is not applicable in the current data situation, otherwise it stores the data pointers and these need to stay valid throught the use of the other routines but are not deleted here\n\n\n\n\n\ncb_QPinit_KKTdata!(self::CBQPIterativeKKTHAeqSolver, Hp::Union{<:CBQPSolverProxObject,Nothing}, model::Union{<:CBQPModelBlockObject,Nothing}, A::Union{<:CBSparsemat,Nothing}, eq_indices::Union{<:CBIndexmatrix,Nothing})\n\nreturns 1 if this class is not applicable in the current data situation, otherwise it stores the data pointers and these need to stay valid throught the use of the other routines but are not deleted here\n\n\n\n\n\ncb_QPinit_KKTdata!(self::CBQPKKTSolverComparison, Hp::Union{<:CBQPSolverProxObject,Nothing}, model::Union{<:CBQPModelBlockObject,Nothing}, A::Union{<:CBSparsemat,Nothing}, eq_indices::Union{<:CBIndexmatrix,Nothing})\n\nreturns 1 if this class is not applicable in the current data situation, otherwise it stores the data pointers and these need to stay valid throught the use of the other routines but are not deleted here\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPinit_KKTsystem!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPinit_KKTsystem!","text":"cb_QPinit_KKTsystem!(self::CBQPDirectKKTSolver, KKTdiagx::CBMatrix, KKTdiagy::CBMatrix, Hfactor::Real, prec::Real, params::Union{<:CBQPSolverParameters,Nothing})\n\nset up the primal dual KKT system for being solved for predictor and corrector rhs in QPsolve_KKTsystem\n\n\n\n\n\ncb_QPinit_KKTsystem!(self::CBQPKKTSolverComparison, KKTdiagx::CBMatrix, KKTdiagy::CBMatrix, Hfactor::Real, prec::Real, params::Union{<:CBQPSolverParameters,Nothing})\n\nset up the primal dual KKT system for being solved for predictor and corrector rhs in QPsolve_KKTsystem\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPis_feasible!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPis_feasible!","text":"cb_QPis_feasible!(self::CBQPSolver, y::CBMatrix, relprec::Real = 1e-10)\n\ncheck feasiblity of y for the current groundset constraints\n\n\n\n\n\ncb_QPis_feasible!(self::CBUQPSolver, param0::CBMatrix, param1::Real = 1e-10)\n\nfor the unconstrained solver any point is feasible, because it cannot even check the dimension of the design space\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPprefer_UQPSolver","page":"Reference of C++ interface","title":"ConicBundle.cb_QPprefer_UQPSolver","text":"cb_QPprefer_UQPSolver(self::CBQPSolver, param0::Union{<:CBQPSolverProxObject,Nothing})\n\nreturns true if, for the current constraints and the requested ProxObject, it might be better to use the internal unconstrained QP solver (which can deal with box constraints by a work-around)\n\n\n\n\n\ncb_QPprefer_UQPSolver(self::CBUQPSolver, param0::Union{<:CBQPSolverProxObject,Nothing})\n\nas this IS the internal UQPSolver, the answer doesn't matter, but the solver would certainly say yes\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPprint_statistics!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPprint_statistics!","text":"cb_QPprint_statistics!(self::CBQPSolver, param1::Integer = 0)\n\ncurrently it does nothing\n\n\n\n\n\ncb_QPprint_statistics!(self::CBUQPSolver, param1::Integer = 0)\n\noutputs some statistical data about solver performance\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPresolve!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPresolve!","text":"cb_QPresolve!(self::CBQPSolver, lower_bound::Real, upper_bound::Real, relprec::Real)\n\nresolve the bundle subproblem (usually because of modified penalty parameters) so that precision requirements are met (see \\ref InternalQPSolverInterface)\n\n\n\n\n\ncb_QPresolve!(self::CBUQPSolver, lower_bound::Real, upper_bound::Real, relprec::Real)\n\nsee QPSolverObject::QPresolve() and  \\ref UnconstrainedQPSolver\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPset_KKTsolver!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPset_KKTsolver!","text":"cb_QPset_KKTsolver!(self::CBQPSolverParameters, in_KKTsolver::Union{<:CBQPKKTSolverObject,Nothing})\n\ndelete previous solver and replace by the new one (should not be zero when calling the solver)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPset_allow_UQPSolver!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPset_allow_UQPSolver!","text":"cb_QPset_allow_UQPSolver!(self::CBQPSolverParameters, allow::Bool)\n\nset to true/false if switching to the unconstrained solver is allowed or not\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPset_dual_infeasibility_eps!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPset_dual_infeasibility_eps!","text":"cb_QPset_dual_infeasibility_eps!(self::CBQPSolverParameters, eps::Real)\n\nset this variable value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPset_lower_and_upper_bounds!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPset_lower_and_upper_bounds!","text":"cb_QPset_lower_and_upper_bounds!(self::CBQPSolverParameters, lb::Real, ub::Real)\n\nset this variable value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPset_lower_bound_gap_eps!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPset_lower_bound_gap_eps!","text":"cb_QPset_lower_bound_gap_eps!(self::CBQPSolverParameters, eps::Real)\n\nset this variable value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPset_maxiter!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPset_maxiter!","text":"cb_QPset_maxiter!(self::CBQPSolverParameters, mi::Integer)\n\nset this variable value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPset_min_objective_relprec!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPset_min_objective_relprec!","text":"cb_QPset_min_objective_relprec!(self::CBQPSolverParameters, eps::Real)\n\nset this variable value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPset_nbh_bounds!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPset_nbh_bounds!","text":"cb_QPset_nbh_bounds!(self::CBQPSolverParameters, nbhlb::Real, nbhub::Real)\n\nset the upper bound on the neighborhood that should be ensured in curve searches; ensures eps_Real<=nbhlb<=nbhub (nbhub should be < 1. and <=.35 is safe)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPset_objective_gap_eps!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPset_objective_gap_eps!","text":"cb_QPset_objective_gap_eps!(self::CBQPSolverParameters, eps::Real)\n\nset this variable value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPset_parameters!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPset_parameters!","text":"cb_QPset_parameters!(self::CBQPSolver, params::Union{<:CBQPSolverParametersObject,Nothing})\n\ncheck whether the parameters are QPSolverParameters and set them if so\n\n\n\n\n\ncb_QPset_parameters!(self::CBUQPSolver, param0::Union{<:CBQPSolverParametersObject,Nothing})\n\ndoes nothing here\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPset_primal_infeasibility_eps!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPset_primal_infeasibility_eps!","text":"cb_QPset_primal_infeasibility_eps!(self::CBQPSolverParameters, eps::Real)\n\nset this variable value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPset_upper_bound_gap_eps!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPset_upper_bound_gap_eps!","text":"cb_QPset_upper_bound_gap_eps!(self::CBQPSolverParameters, eps::Real)\n\nset this variable value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPset_use_neighborhood!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPset_use_neighborhood!","text":"cb_QPset_use_neighborhood!(self::CBQPSolverParameters, nbh::Bool)\n\nif set to true (default: false), the lines search is carried out with respect to the neighborhood polynomial ensuring the afte this step the point is again inside the neighborhood of the central path\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPset_use_predictor_corrector!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPset_use_predictor_corrector!","text":"cb_QPset_use_predictor_corrector!(self::CBQPSolverParameters, upc::Bool)\n\nif set to true (=default), a predictor corrector approach is used for solving the KKT system (solve for barrier parameter mu=0, guess mu, solve again for this mu including some bilinear perturbation) otherwise the barrier parameter is set apriori and the step computed in one solve\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPset_use_socqp!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPset_use_socqp!","text":"cb_QPset_use_socqp!(self::CBQPSolverParameters, s::Bool)\n\nif set to true (default: false), the quadratic term is modelled via a second order cone approach\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPsolve!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPsolve!","text":"cb_QPsolve!(self::CBQPSolver, center_y::CBMatrix, lower_bound::Real, upper_bound::Real, relprec::Real, Hp::Union{<:CBQPSolverProxObject,Nothing}, gs_aggr::CBMinorantPointer, yfixed::Union{<:CBIndexmatrix,Nothing})\n\nsolve the current bundle subproblem so that precision requirements are met (see \\ref InternalQPSolverInterface)\n\n\n\n\n\ncb_QPsolve!(self::CBUQPSolver, center_y::CBMatrix, lower_bound::Real, upper_bound::Real, relprec::Real, Hp::Union{<:CBQPSolverProxObject,Nothing}, gs_aggr::CBMinorantPointer, yfixed::Union{<:CBIndexmatrix,Nothing})\n\nsee QPSolverObject::QPsolve() and  \\ref UnconstrainedQPSolver\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPsolve_KKTsystem!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPsolve_KKTsystem!","text":"cb_QPsolve_KKTsystem!(self::CBQPDirectKKTSolver, solx::CBMatrix, soly::CBMatrix, primalrhs::CBMatrix, dualrhs::CBMatrix, rhsmu::Real, rhscorr::Real, prec::Real, params::Union{<:CBQPSolverParameters,Nothing})\n\nsolve the KKTsystem to precision prec for the given right hand sides that have been computed for the value rhsmu of the barrier parameter and in which a rhscorr fraction (out of [0,1] of the corrector term have been included; in iterative solvers solx and soly may be used as starting points\n\n\n\n\n\ncb_QPsolve_KKTsystem!(self::CBQPIterativeKKTHAeqSolver, solx::CBMatrix, soly::CBMatrix, primalrhs::CBMatrix, dualrhs::CBMatrix, rhsmu::Real, rhscorr::Real, prec::Real, params::Union{<:CBQPSolverParameters,Nothing})\n\nsolve the KKTsystem to precision prec for the given right hand sides that have been computed for the value rhsmu of the barrier parameter and in which a rhscorr fraction (out of [0,1] of the corrector term have been included; in iterative solvers solx and soly may be used as starting points\n\n\n\n\n\ncb_QPsolve_KKTsystem!(self::CBQPIterativeKKTHASolver, solx::CBMatrix, soly::CBMatrix, primalrhs::CBMatrix, dualrhs::CBMatrix, rhsmu::Real, rhscorr::Real, prec::Real, params::Union{<:CBQPSolverParameters,Nothing})\n\nsolve the KKTsystem to precision prec for the given right hand sides that have been computed for the value rhsmu of the barrier parameter and in which a rhscorr fraction (out of [0,1] of the corrector term have been included; in iterative solvers solx and soly may be used as starting points\n\n\n\n\n\ncb_QPsolve_KKTsystem!(self::CBQPKKTSolverComparison, solx::CBMatrix, soly::CBMatrix, primalrhs::CBMatrix, dualrhs::CBMatrix, rhsmu::Real, rhscorr::Real, prec::Real, params::Union{<:CBQPSolverParameters,Nothing})\n\nsolve the KKTsystem to precision prec for the given right hand sides that have been computed for the value rhsmu of the barrier parameter and in which a rhscorr fraction (out of [0,1] of the corrector term have been included; in iterative solvers solx and soly may be used as starting points\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPstart_modification!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPstart_modification!","text":"cb_QPstart_modification!(self::CBQPSolver)\n\nreturn a new modification object on the heap that is initialized for modification of *this\n\n\n\n\n\ncb_QPstart_modification!(self::CBUQPSolver)\n\nreturns 0 because no modifications are applicable\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPsupports_updates!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPsupports_updates!","text":"cb_QPsupports_updates!(self::CBQPSolver)\n\n@brief return true iff the code supports QPupdate(), i.e., it supports external updates of the groundset aggregate in order to model constraints not included explicitly in the QP's model\n\n\n\n\n\ncb_QPsupports_updates!(self::CBUQPSolver)\n\n@brief return true iff the code supports QPupdate(), i.e., it supports external updates of the groundset aggregate in order to model constraints not included explicitly in the QP's model\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPsupports_yfixing!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPsupports_yfixing!","text":"cb_QPsupports_yfixing!(self::CBQPSolver)\n\nyfixing is currently not supported, this returns false.\n\n\n\n\n\ncb_QPsupports_yfixing!(self::CBUQPSolver)\n\nno difficulty if the BundleProxObject does it\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QPupdate!","page":"Reference of C++ interface","title":"ConicBundle.cb_QPupdate!","text":"cb_QPupdate!(self::CBQPSolver, center_y::CBMatrix, lower_bound::Real, upper_bound::Real, relprec::Real, Hp::Union{<:CBQPSolverProxObject,Nothing}, gs_aggr::CBMinorantPointer, yfixed::Union{<:CBIndexmatrix,Nothing}, delta_gs_aggr::CBMinorantPointer, delta_index::CBIndexmatrix)\n\nsolve the bundle subproblem for updated box multipliers so that precision requirements are met (see \\ref InternalQPSolverInterface). This routine is typically not called for this solver, because box constraints are included explicitly.\n\n\n\n\n\ncb_QPupdate!(self::CBUQPSolver, center_y::CBMatrix, lower_bound::Real, upper_bound::Real, relprec::Real, Hp::Union{<:CBQPSolverProxObject,Nothing}, gs_aggr::CBMinorantPointer, yfixed::Union{<:CBIndexmatrix,Nothing}, delta_gs_subg::CBMinorantPointer, delta_index::CBIndexmatrix)\n\nsee QPSolverObject::QPupdate() and  \\ref UnconstrainedQPSolver\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QR_concat_right!","page":"Reference of C++ interface","title":"ConicBundle.cb_QR_concat_right!","text":"cb_QR_concat_right!(self::CBMatrix, A::CBMatrix, piv::CBIndexmatrix, r::Integer, tol::Real = 1e-10)\n\nextend the current Householder QR-factorization stored in this by appending       and factorizing the columns of A yielding a new QR_factorization\n  @param[in] A contains the addtionial columns to be factorized\n\n  @param[in,out] piv contains on input, the permution vector returned by QR_factor\n      with pivoting, and on output the new entire permutation\n\n  @param[in] r gives the initial rank of *this as returned by QR_factor with pviaton\n\n  @param[in] tol gives the tolerance for regarding a vector as having norm zero\n\n  @return the rank of the new QR-facotrization\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QR_factor","page":"Reference of C++ interface","title":"ConicBundle.cb_QR_factor","text":"cb_QR_factor(self::CBMatrix, Q::CBMatrix, R::CBMatrix, tol::Real)\n\ncomputes a Householder QR_factorization computing matrices Q and R explicitly and leaving (*this) unchanged; it always returns 0\n\n\n\n\n\ncb_QR_factor(self::CBMatrix, Q::CBMatrix, R::CBMatrix, piv::CBIndexmatrix, tol::Real)\n\ncomputes a Householder QR_factorization with pivoting computing matrices Q and R explicitly and leaving (*this) unchanged; the pivoting permutation is stored in piv; returns the rank\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QR_factor!","page":"Reference of C++ interface","title":"ConicBundle.cb_QR_factor!","text":"cb_QR_factor!(self::CBMatrix, tol::Real = 1e-10)\n\ncomputes a Householder QR_factorization overwriting (*this); returns 0 on success, otherwise column index +1 if the norm of the column is below tol when reaching it.\n\n\n\n\n\ncb_QR_factor!(self::CBMatrix, Q::CBMatrix, tol::Real = 1e-10)\n\ncomputes a Householder QR_factorization computing the Q matrix explicitly and setting (*this)=R; it always returns 0\n\n\n\n\n\ncb_QR_factor!(self::CBMatrix, piv::CBIndexmatrix, tol::Real = 1e-10)\n\ncomputes a Householder QR_factorization with pivoting  and overwriting (*this); the pivoting permutation is stored in piv; returns the rank\n\n\n\n\n\ncb_QR_factor!(self::CBMatrix, Q::CBMatrix, piv::CBIndexmatrix, tol::Real = 1e-10)\n\nComputes a Householder QR_factorization with pivoting computing the Q matrix explicitly and setting (*this)=R; the pivoting permutation is stored in piv; returns the rank\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QR_factor_relpiv!","page":"Reference of C++ interface","title":"ConicBundle.cb_QR_factor_relpiv!","text":"cb_QR_factor_relpiv!(self::CBMatrix, piv::CBIndexmatrix, tol::Real = 1e-10)\n\ncomputes a Householder QR_factorization with pivoting on those with tolerable norm and tolerable reduction in norm and overwriting (*this); the pivoting permutation is stored in piv; returns the rank\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_QR_solve!","page":"Reference of C++ interface","title":"ConicBundle.cb_QR_solve!","text":"cb_QR_solve!(self::CBMatrix, rhs::CBMatrix, tol::Real = 1e-10)\n\n@brief solves (this)x=rhs by factorizing and overwriting (this); rhs is overwritten with the solution.  Returns 0 on success, otherwise i+1 if in the backsolve abs(this)(i,i)<tol and the reduced row of rhs is nonzero.\n  To avoid overwriting (*this), use the appropriate version\n  of #QR_factor and #triu_solve.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_Q_times","page":"Reference of C++ interface","title":"ConicBundle.cb_Q_times","text":"cb_Q_times(self::CBMatrix, A::CBMatrix, r::Integer)\n\ncomputes A=QA, assuming a housholder Q is coded in the first r columns of the lower triangle of (this); it always returns 0\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_Qt_times","page":"Reference of C++ interface","title":"ConicBundle.cb_Qt_times","text":"cb_Qt_times(self::CBMatrix, A::CBMatrix, r::Integer)\n\ncomputes A=transpose(Q)A, assuming a housholder Q is coded in the first r columns of the lower triangle of (this); it always returns 0\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_abs","page":"Reference of C++ interface","title":"ConicBundle.cb_abs","text":"cb_abs(A::CBMatrix)\n\nreturns a matrix with elements (i,j)=abs((*this)(i,j)) for all i,j\n\n\n\n\n\ncb_abs(A::CBSparsemat)\n\nreturns a Sparsmat with elements abs((*this)(i,j)) for all i,j\n\n\n\n\n\ncb_abs(A::CBSymmatrix)\n\nreturns a Symmatrix with elements abs(A(i,j))\n\n\n\n\n\ncb_abs(A::CBSparsesym)\n\nreturns a Sparsesym with elements abs((*this)(i,j)) for all i,j\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_abs!","page":"Reference of C++ interface","title":"ConicBundle.cb_abs!","text":"cb_abs!(self::CBMatrix)\n\nsets (this)(i,j)=abs((this)(i,j)) for all i,j and returns *this\n\n\n\n\n\ncb_abs!(self::CBIndexmatrix)\n\nusing ::abs assign (this)(i,j)=abs((this)(i,j)) for all i,j\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_active","page":"Reference of C++ interface","title":"ConicBundle.cb_active","text":"cb_active(self::CBSumBundle)\n\nreturns true if one of its parts is not inactive\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_BCSchur_diagonal!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_BCSchur_diagonal!","text":"cb_add_BCSchur_diagonal!(self::CBQPConeModelBlock, diagonal::CBMatrix, globalbundle::CBMinorantBundle, startindex_bundle::Integer)\n\n@brief add the diagonal of the Schur complemented blocks belonging to bundle and local constraints (used for diagonal preconditioning)\n\n\n\n\n\ncb_add_BCSchur_diagonal!(self::CBQPSumModelBlock, diagonal::CBMatrix, globalbundle::CBMinorantBundle, startindex_bundle::Integer)\n\n@brief add the diagonal of the Schur complemented blocks belonging to bundle and local constraints (used for diagonal preconditioning)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_BDBt!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_BDBt!","text":"cb_add_BDBt!(self::CBQPConeModelBlock, diagvec::CBMatrix, bigS::CBSymmatrix, minus::Bool, startindex::Integer, Bt::CBMatrix, startindex_model::Integer, globalbundle::CBMinorantBundle, startindex_bundle::Integer)\n\nadd the main diagonal block tranpose(projection)diagvecprojection to bigS starting at startindex\n\n\n\n\n\ncb_add_BDBt!(self::CBQPSumModelBlock, diagvec::CBMatrix, bigS::CBSymmatrix, minus::Bool, startindex::Integer, Bt::CBMatrix, startindex_model::Integer, globalbundle::CBMinorantBundle, startindex_bundle::Integer)\n\nadd the main diagonal block tranpose(projection)diagvecprojection to bigS starting at startindex\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_Bs","page":"Reference of C++ interface","title":"ConicBundle.cb_add_Bs","text":"cb_add_Bs(self::CBUQPConeModelBlock, qp_vec::CBMatrix)\n\nadd the local product of matrices B and s in the positions corresponding to qpyrange (rows) and return qpvec; returns 0 on success, 1 on failure\n\n\n\n\n\ncb_add_Bs(self::CBUQPSumModelBlock, qp_vec::CBMatrix)\n\ndo this for all subblocks\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_BtinvsysB!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_BtinvsysB!","text":"cb_add_BtinvsysB!(self::CBQPConeModelBlock, globalsys::CBSymmatrix, bundle::CBMinorantBundle, startindex_bundle::Integer)\n\nadd the \"scaled\" minorant outer products to globalsys, where the correct minorants start at the given index\n\n\n\n\n\ncb_add_BtinvsysB!(self::CBQPSumModelBlock, globalsys::CBSymmatrix, bundle::CBMinorantBundle, startindex_bundle::Integer)\n\nadd the \"scaled\" minorant outer products to globalsys, where the correct minroants start at the given index\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_H","page":"Reference of C++ interface","title":"ConicBundle.cb_add_H","text":"cb_add_H(self::CBBundleDenseTrustRegionProx, big_sym::CBSymmatrix, start_index::Integer = 0)\n\nadd H to the dense symmetric matrix as a principal submatrix starting at position start_index\n\n\n\n\n\ncb_add_H(self::CBBundleDiagonalTrustRegionProx, big_sym::CBSymmatrix, start_index::Integer = 0)\n\nadd H to the dense symmetric matrix as a principal submatrix starting at position start_index\n\n\n\n\n\ncb_add_H(self::CBBundleDLRTrustRegionProx, big_sym::CBSymmatrix, start_index::Integer = 0)\n\nadd H to the dense symmetric matrix as a principal submatrix starting at position start_index\n\n\n\n\n\ncb_add_H(self::CBBundleIdProx, big_sym::CBSymmatrix, start_index::Integer = 0)\n\nadd H to the dense symmetric matrix as a principal submatrix starting at position start_index\n\n\n\n\n\ncb_add_H(self::CBBundleLowRankTrustRegionProx, big_sym::CBSymmatrix, start_index::Integer = 0)\n\nadd H to the dense symmetric matrix as a principal submatrix starting at position start_index\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_Hx","page":"Reference of C++ interface","title":"ConicBundle.cb_add_Hx","text":"cb_add_Hx(self::CBBundleDenseTrustRegionProx, x::CBMatrix, outplusHx::CBMatrix, alpha::Real = 1.)\n\nadds \\falpha*Hxf to outplusHx and returns this\n\n\n\n\n\ncb_add_Hx(self::CBBundleDiagonalTrustRegionProx, x::CBMatrix, outplusHx::CBMatrix, alpha::Real = 1.)\n\nadds \\falpha*Hxf to outplusHx and returns this\n\n\n\n\n\ncb_add_Hx(self::CBBundleDLRTrustRegionProx, x::CBMatrix, outplusHx::CBMatrix, alpha::Real = 1.)\n\nadds \\falpha*Hxf to outplusHx and returns this\n\n\n\n\n\ncb_add_Hx(self::CBBundleIdProx, x::CBMatrix, outplusHx::CBMatrix, alpha::Real = 1.)\n\nadds \\falpha*Hxf to outplusHx and returns this\n\n\n\n\n\ncb_add_Hx(self::CBBundleLowRankTrustRegionProx, x::CBMatrix, outplusHx::CBMatrix, alpha::Real = 1.)\n\nadds \\falpha*Hxf to outplusHx and returns this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_Schur_mult!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_Schur_mult!","text":"cb_add_Schur_mult!(self::CBQPConeModelBlock, in_vec::CBMatrix, out_vec::CBMatrix, in_cvec::Union{<:CBMatrix,Nothing}, out_cvec::Union{<:CBMatrix,Nothing}, startindex_constraints::Integer, globalbundle::CBMinorantBundle, startindex_bundle::Integer)\n\nmultiply invec with the local contribution to the global main block and add it to outvec; the other local multiplications are carried out externally with the information provide in prepareSchurprecond and are not done here.\n\n\n\n\n\ncb_add_Schur_mult!(self::CBQPSumModelBlock, in_vec::CBMatrix, out_vec::CBMatrix, in_cvec::Union{<:CBMatrix,Nothing}, out_cvec::Union{<:CBMatrix,Nothing}, startindex_constraints::Integer, globalbundle::CBMinorantBundle, startindex_bundle::Integer)\n\nmultiply invec with the local contribution to the global main block and add it to outvec; the other local multiplications are carried out externally with the information provide in prepareSchurprecond and are not done here.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_Schur_rhs!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_Schur_rhs!","text":"cb_add_Schur_rhs!(self::CBQPConeModelBlock, glob_rhs::CBMatrix, local_rhs::Union{<:CBMatrix,Nothing}, rhsmu::Real, rhscorr::Real, startindex_constraints::Integer, globalbundle::CBMinorantBundle, startindex_bundle::Integer)\n\nadd the contributions to globrhs of the Schur complemented model block, and return localrhs of the non complemented constraint block in the rows/columns/diagonal block starting at startindex_constraints\n\n\n\n\n\ncb_add_Schur_rhs!(self::CBQPSumModelBlock, glob_rhs::CBMatrix, local_rhs::Union{<:CBMatrix,Nothing}, rhsmu::Real, rhscorr::Real, startindex_constraints::Integer, globalbundle::CBMinorantBundle, startindex_bundle::Integer)\n\nadd the contributions to globrhs of the Schur complemented model block, and return localrhs of the non complemented constraint block in the rows/columns/diagonal block starting at startindex_constraints\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_append_blocks!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_append_blocks!","text":"cb_add_append_blocks!(self::CBPSCAffineModification, append_dim::CBIndexmatrix, append_offsets::Union{<:CBSparseCoeffmatMatrix,Nothing}, append_blocks::Union{<:CBSparseCoeffmatMatrix,Nothing})\n\n@brief append information on new rows at the respective ends\n @param append_dim\n        the dimension gives the number of (diagonal) blocks and each\n  entry the order of the block to be appended\n\n @param append_blocks\n        if NULL, append zero matrics, otherwise it must point\n        to a sparse matrix of size @a append_dim times new_vardim()\n        that is to be appended to the constraint matrix below.\n\n @param append_offsets\n        if NULL, append zero matrices, otherwise it must point to\n  a column vector of size @a append_dim that is to be appended\n        to the vector of offsets\n\n   @return number of errors; if errors occured, none of the new changes are performed\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_append_rows!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_append_rows!","text":"cb_add_append_rows!(self::CBAFTModification, append_dim::Integer, append_rows::Union{<:CBSparsemat,Nothing}, append_rhs::Union{<:CBMatrix,Nothing})\n\nappend @a appenddim new rows as in appendrows (if NULL, use default value) with affine offset appendrhs (if NULL use default value 0.), calls Modification::addappend_rows\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_append_variables!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_append_variables!","text":"cb_add_append_variables!(self::CBAFTModification, append_dim::Integer)\n\nappend append_dim further variables at the end of the argument vector (without specifying their effect, they may e.g. be ignored by the function)\n\n\n\n\n\ncb_add_append_variables!(self::CBGroundsetModification, append_dim::Integer)\n\nappend append_dim further variables at the end of the argument vector (without specifying their effect, they may e.g. be ignored by the function)\n\n\n\n\n\ncb_add_append_variables!(self::CBNNCBoxSupportModification, append_dim::Integer)\n\nappend append_dim further variables at the end of the argument vector (without effect on the box function, i.e., lower and upper bounds are set to 0)\n\n\n\n\n\ncb_add_append_variables!(self::CBPSCAffineModification, append_dim::Integer)\n\nappend append_dim further variables at the end of the argument vector (without specifying their effect, they may e.g. be ignored by the function)\n\n\n\n\n\ncb_add_append_variables!(self::CBSOCSupportModification, append_dim::Integer)\n\nappend append_dim further variables at the end of the argument vector (without effect on the box function, i.e., lower and upper bounds are set to 0)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_append_vars!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_append_vars!","text":"cb_add_append_vars!(self::CBAFTModification, append_dim::Integer, append_cols::Union{<:CBSparsemat,Nothing}, linear_costs::Union{<:CBMatrix,Nothing})\n\nappend @a appenddim new variables/columns with values specified by @a appendcols (NULL: default value) and @a linearcosts coefficients (NULL: default value) by calling Modification::addappend_vars\n\n\n\n\n\ncb_add_append_vars!(self::CBGroundsetModification, append_dim::Integer, start_val::Union{<:CBMatrix,Nothing} = nothing, costs::Union{<:CBMatrix,Nothing} = nothing)\n\nappend @a appenddim new variables with startval as initial values (if NULL, use default value), calls Modification::addappendvars\n\n\n\n\n\ncb_add_append_vars!(self::CBNNCBoxSupportModification, append_dim::Integer, append_lb::Union{<:CBMatrix,Nothing}, append_ub::Union{<:CBMatrix,Nothing})\n\nappend @a append_dim new variables to the box function\n\n\n\n\n\ncb_add_append_vars!(self::CBPSCAffineModification, append_dim::Integer, append_cols::Union{<:CBSparseCoeffmatMatrix,Nothing})\n\n@brief append information on new variables at the respective ends\n  @param append_dim\n         number of variables (or columns ) to\n   be appended\n\n  @param append_cols\n         if NULL, append zero matrices, otherwise it must point to\n   a sparse matrix of size new_rowdim() times @a append_dim\n         that is to be appended to the constraint matrix on the right\n\n  @return number of errors; if errors occured, none of the new changes are performed\n\n\n\n\n\ncb_add_append_vars!(self::CBSOCSupportModification, append_dim::Integer)\n\nappend @a append_dim new variables to the box function\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_apply_factor!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_apply_factor!","text":"cb_add_apply_factor!(self::CBAFTModification, times_factor::Real)\n\nmultiply the current factor by the value @a times_factor (>=0, returns 1 if <0.)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_coeff!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_coeff!","text":"cb_add_coeff!(self::CBMinorant, i::Integer, value::Real)\n\nadds the value to the coefficient in coordinate i\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_coeffs!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_coeffs!","text":"cb_add_coeffs!(self::CBMinorant, n_elements::Integer, values::Union{<:AbstractVector{Real},Nothing}, factor::Real = 1., start_pos::Integer = 0)\n\nadds the n values (possibly multiplied by factor) to consecutive coefficients starting at start_pos (by default 0); this always converts the minroant into a dense vector first and adds then\n\n\n\n\n\ncb_add_coeffs!(self::CBMinorant, n_elements::Integer, values::Union{<:AbstractVector{Real},Nothing}, indices::Union{<:AbstractVector{Integer},Nothing}, factor::Real = 1.)\n\nadds the n values (possibly multiplied by factor) to the coefficients indicated by indices (if zero, this calls the other add_coeffs for the consecutive version)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_contributions!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_contributions!","text":"cb_add_contributions!(self::CBSumBundleHandler)\n\n@brief add root parts of this sumbundle to the parent's sumbundle and set the states correspondingly\n  If the current mode is child, nothing is done, because it is\n  assumed that the sumbundle is already part of the parent. Thus,\n  only root parts are considerd new and are added. This is only\n  done, if the parenhandler accepts these kind of parts.\n\n  When a contribution is added to a parent that is currently\n  inactive or child, any respective parent's contributions to the\n  parent's parent are first removed and then the mode of the\n  parent is set to root. Thus, the parent has to call\n  add_contributions afterwards, if it still wants to contribute to\n  its own parent.\n\n  add_contribution should only be called from\n  SumBlockModel::sumbundle_contribution() with a normalized bundle,\n  i.e., normalize_sumbundle() should have been called before.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_delete_blocks!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_delete_blocks!","text":"cb_add_delete_blocks!(self::CBPSCAffineModification, del_ind::CBIndexmatrix, map_to_old::CBIndexmatrix)\n\n@brief delete the rows indexed by the vector delind and       return the index changes of the others in a vector mapto_old\n  @a del_ind need not be ordered in any way, but any index in 0 to\n  new_rowdim()-1 may appear at most once. On output the dimension\n  of the column vector @a map_to_old gives the number of remaining\n  rows and its entry i holds the index the row with new index i\n  had before the deletion. The return value is the number of\n  errors in @a del_ind. If such occured, this deletion is not\n  performed and @a map_to_old may contain garbage.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_delete_rows!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_delete_rows!","text":"cb_add_delete_rows!(self::CBAFTModification, rows_del_ind::CBIndexmatrix, rows_map_to_old::CBIndexmatrix)\n\ndelete the rows indexed by @a rowsdelind; for each new index @a rowsmaptoold returns the old one; calls Modification::adddelete_rows\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_delete_vars!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_delete_vars!","text":"cb_add_delete_vars!(self::CBAFTModification, del_ind::CBIndexmatrix, map_to_old::CBIndexmatrix)\n\ndelete the variables indexed by @a delind; for each new index @a maptoold returns the old one; calls Modification::adddelete_vars\n\n\n\n\n\ncb_add_delete_vars!(self::CBGroundsetModification, del_ind::CBIndexmatrix, map_to_old::CBIndexmatrix)\n\ndelete the variables indexed by @a delind; for each new index @a maptoold returns the old one; calls Modification::adddelete_vars\n\n\n\n\n\ncb_add_delete_vars!(self::CBNNCBoxSupportModification, del_ind::CBIndexmatrix, map_to_old::CBIndexmatrix)\n\ndelete the variables indexed by @a delind; for each new index @a maptoold returns the old one; calls Modification::adddelete_vars\n\n\n\n\n\ncb_add_delete_vars!(self::CBPSCAffineModification, del_ind::CBIndexmatrix, map_to_old::CBIndexmatrix)\n\n@brief delete the variables indexed by the vector delind and       return the index changes of the others in a vector mapto_old\n  @a del_ind need not be ordered in any way, but any index in 0 to\n  new_vardim()-1 may appear at most once. On output the dimension\n  of the column vector @a map_to_old gives the number of remaining\n  variables and its entry i holds the index the variable with new\n  index i had before the deletion. The return value is the number\n  of errors in @a del_ind. If such occured, this deletion is\n  not performed and @a map_to_old may contain garbage.\n\n\n\n\n\ncb_add_delete_vars!(self::CBSOCSupportModification, del_ind::CBIndexmatrix, map_to_old::CBIndexmatrix)\n\ndelete the variables indexed by @a delind; for each new index @a maptoold returns the old one; calls Modification::adddelete_vars\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_diagonal_scaling","page":"Reference of C++ interface","title":"ConicBundle.cb_add_diagonal_scaling","text":"cb_add_diagonal_scaling(self::CBAffineFunctionTransformation, diagscale::CBMatrix, indices::Union{<:CBIndexmatrix,Nothing}, alpha::Real, in_diagscale::CBMatrix)\n\n@brief transform the scaling matrix indiagscale of the untransformed function model and add it as described in BundleMethod::adddiagonal_scaling.\n  If indices are given, they must be sorted in striclty increasing order.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_function!-Tuple{ConicBundle.CBMatrixCBSolver, ConicBundle.CBFunctionObject, Real, ConicBundle.CBFunctionTask, Union{Nothing, ConicBundle.CBAffineFunctionTransformation}, Bool}","page":"Reference of C++ interface","title":"ConicBundle.cb_add_function!","text":"cb_add_function!(self::CBMatrixCBSolver, function_::CBFunctionObject, fun_factor::Real = 1., fun_task::CBFunctionTask = cbft_objective_function, aft::Union{<:CBAffineFunctionTransformation,Nothing} = nothing, argument_list_may_change_dynamically::Bool = false)\n\n@brief Adds a function, typically derived from ConicBundle::FunctionOracle. If the dimension does not match the current one, specify an affine function transformation to map the current ground set to the argument of the function.\nBesides the standard ConicBundle::MatrixFunctionOracle    the interface only accepts a few other prespecified derivations    of the class FunctionObject that come along with the CHMatrixClasses interface    (e.g. for semidefinite and second order cones). Functions not derived from    these will fail to be added and return a value !=0.\nThe @a funfactor allows to specify a scaling factor for the function. @a funfactor must be a strictly positive number.\nThe ConicBundle::FunctionTask @a funtask specifies whether the    function is to be used as a an ObjectiveFunction, a    ConstantPenaltyFunction with @a funfactor as maximum penalty    factor, or as an AdaptivePenaltyFunction with @a fun_factor at    initial penalty guess that might be increased or decreased over    time.\nThe AffineFunctionTransformation @a aft may be used to modify the    argument and give an additional affine term (linear term plus    offset). For adding an affine term there are several other    possibilities, e.g. in init_problem(), so there is no need to do so    here. If, however, an existing function implementation requires only    some subset of the variables, it is more convenient to supply    a corresponding @a aft instead of reimplementing the function.\n@a argumentlistmaychangedynamically sets a flag on how to    treat the function arguments when variables are added or deleted.    If the arguments may not change, any changes in the variables are    mapped to an adaptation of an internal    AffineFunctionTransformation so that the function does not notice    the changes in the variables.  If arguments may change, the    function oracle should be a ModifiableOracleObject and react    accordingly to the changes in its    ModifiableOracleObject::apply_modification() routine.\n\n@return\n  - 0 on success\n  - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_add_local_sys!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_local_sys!","text":"cb_add_local_sys!(self::CBUQPConeModelBlock, sysdy::CBSymmatrix, rhs::CBMatrix)\n\n@brief add the local system informatoin\non input:\n         sysdy= A*barQ^{-1}*A^T    (barQ as returned in add_xinv_kron_z)\n         rhs= A*barQ^{-1}*(c-Q*x-A^T*y)-(b-A*x)\n\nif the block uses additional internal variables\n(like an additional term + B*s with s>=0 in the primal feasibility constr)\nthen the corresponding block terms have now to be added to sysdy and rhs, eg,\n   sysdy +=  B*(t^{-1} kron s)*B^T     (if t is the dual variable to s)\n   rhs   +=  B*s - B*(t^{-1} kron s)*B^T*y\n\n\n\n\n\ncb_add_local_sys!(self::CBUQPSumModelBlock, sysdy::CBSymmatrix, rhs::CBMatrix)\n\nadd this for all subblocks\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_localrhs!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_localrhs!","text":"cb_add_localrhs!(self::CBQPConeModelBlock, globalrhs::CBMatrix, rhsmu::Real, rhscorr::Real, startindex_model::Integer, startindex_constraints::Integer, append::Bool, bundle::CBMinorantBundle, startindex_bundel::Integer)\n\nIf mu is not zero, always add the centering term for this mu as well, if append is false, add the Schur complement rhs for addBtinvsysB, if append is true, fill in the rhs of the local system starting at startindex for the model and at startindexconstraints for the modelconstraints\n\n\n\n\n\ncb_add_localrhs!(self::CBQPSumModelBlock, globalrhs::CBMatrix, rhsmu::Real, rhscorr::Real, startindex_model::Integer, startindex_constraints::Integer, append::Bool, bundle::CBMinorantBundle, startindex_bundel::Integer)\n\nIf mu is not zero, always add the centering term for this mu as well, if append is false, add the Schur complement rhs for addBtinvsysB, if append is true, fill in the rhs of the local system starting at startindex for the model and at startindexconstraints for the modelconstraints\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_localsys!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_localsys!","text":"cb_add_localsys!(self::CBQPConeModelBlock, globalsys::CBSymmatrix, startindex_model::Integer, startindex_constraints::Integer)\n\nadd the local system for the model at startindex, the local for the constraints at startindex_constraints\n\n\n\n\n\ncb_add_localsys!(self::CBQPSumModelBlock, globalsys::CBSymmatrix, startindex_model::Integer, startindex_constraints::Integer)\n\nvirtual int addBtinvsysB(CHMatrix_Classes::Symmatrix& globalsys);\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_model!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_model!","text":"cb_add_model!(self::CBSumModel, model::Union{<:CBSumBlockModel,Nothing})\n\nadds the @a model as submodel to this model (if this model may have submodels); if any error occurs the model is not added\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_modelx_aggregate!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_modelx_aggregate!","text":"cb_add_modelx_aggregate!(self::CBQPConeModelBlock, vec::CBMatrix, global_bundle::CBMinorantBundle, startindex_bundle::Integer)\n\nadds opB transposed times modelx (with offsets but without constant affine term) to the arguments\n\n\n\n\n\ncb_add_modelx_aggregate!(self::CBQPSumModelBlock, vec::CBMatrix, global_bundle::CBMinorantBundle, startindex_bundle::Integer)\n\nadds opB transposed times modelx (without constant affine term) to the arguments\n\n\n\n\n\ncb_add_modelx_aggregate!(self::CBUQPConeModelBlock, gradient::CBMatrix)\n\nadds opB transposed times modelx (with offsets but without constant affine term) to the arguments\n\n\n\n\n\ncb_add_modelx_aggregate!(self::CBUQPSumModelBlock, gradient::CBMatrix)\n\ndo this for all subblocks\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_offset!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_offset!","text":"cb_add_offset!(self::CBAFTModification, delta::Real)\n\nadd to the currecnt offset the value @a delta\n\n\n\n\n\ncb_add_offset!(self::CBGroundsetModification, delta::Real)\n\nadd to the current offset the value @a delta\n\n\n\n\n\ncb_add_offset!(self::CBMinorantPointer, offset::Real)\n\nadd the offset; if empty, initialize to offset with zero linear part, if not the only user (use_cnt>1), clone it first\n\n\n\n\n\ncb_add_offset!(self::CBMinorant, value::Real)\n\nadds this value to the current offset value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_projection","page":"Reference of C++ interface","title":"ConicBundle.cb_add_projection","text":"cb_add_projection(self::CBCMgramdense, S::CBSymmatrix, P::CBMatrix, alpha::Real = 1., start_row::Integer = 0)\n\ncomputes S+=Q^T(*this)Q for Q=P.rows(startrow,startrow+dim-1)\n\n\n\n\n\ncb_add_projection(self::CBCMgramsparse, S::CBSymmatrix, P::CBMatrix, alpha::Real = 1., start_row::Integer = 0)\n\ncomputes S+=Q^T(*this)Q for Q=P.rows(startrow,startrow+dim-1)\n\n\n\n\n\ncb_add_projection(self::CBCMgramsparse_withoutdiag, S::CBSymmatrix, P::CBMatrix, alpha::Real = 1., start_row::Integer = 0)\n\ncomputes S+=Q^T(*this)Q for Q=P.rows(startrow,startrow+dim-1)\n\n\n\n\n\ncb_add_projection(self::CBCMlowrankdd, S::CBSymmatrix, P::CBMatrix, alpha::Real = 1., start_row::Integer = 0)\n\ncomputes S+=Q^T(*this)Q for Q=P.rows(startrow,startrow+dim-1)\n\n\n\n\n\ncb_add_projection(self::CBCMlowranksd, S::CBSymmatrix, P::CBMatrix, alpha::Real = 1., start_row::Integer = 0)\n\ncomputes S+=Q^T(*this)Q for Q=P.rows(startrow,startrow+dim-1)\n\n\n\n\n\ncb_add_projection(self::CBCMlowrankss, S::CBSymmatrix, P::CBMatrix, alpha::Real = 1., start_row::Integer = 0)\n\ncomputes S+=Q^T(*this)Q for Q=P.rows(startrow,startrow+dim-1)\n\n\n\n\n\ncb_add_projection(self::CBCMsingleton, S::CBSymmatrix, P::CBMatrix, alpha::Real = 1., start_row::Integer = 0)\n\ncomputes S+=Q^T(*this)Q for Q=P.rows(startrow,startrow+dim-1)\n\n\n\n\n\ncb_add_projection(self::CBCMsymdense, S::CBSymmatrix, P::CBMatrix, alpha::Real = 1., start_row::Integer = 0)\n\ncomputes S+=Q^T(*this)Q for Q=P.rows(startrow,startrow+dim-1)\n\n\n\n\n\ncb_add_projection(self::CBCMsymsparse, S::CBSymmatrix, P::CBMatrix, alpha::Real = 1., start_row::Integer = 0)\n\ncomputes S+=Q^T(*this)Q for Q=P.rows(startrow,startrow+dim-1)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_reassign_blocks!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_reassign_blocks!","text":"cb_add_reassign_blocks!(self::CBPSCAffineModification, map_to_old::CBIndexmatrix)\n\n@brief reassign the current row indices (with modifications) as specified by @a maptoold\n  @a map_to_old must specify an injective map (no two values\n  match) into indices 0 up to new_rowdim()-1 (not all need to\n  appear).  The row getting index i (for i=0 to\n  map_to_old.dim()-1) is the row with current index map_to_old(i)\n  (current refers to considering all previous modifications as\n  having been carried out already). The return value is the number\n  of errors in @a map_to_old. If such occured, this reassign is\n  not performed.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_reassign_rows!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_reassign_rows!","text":"cb_add_reassign_rows!(self::CBAFTModification, map_to_old::CBIndexmatrix)\n\nreassign the rows as given in @a maptoold, calls Modification::addreassignvars\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_reassign_variables!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_reassign_variables!","text":"cb_add_reassign_variables!(self::CBAFTModification, new_dim::Integer, map_to_old_indices::Union{<:AbstractVector{Integer},Nothing})\n\nreorder and resize the variables as given by the first newdim entries of maptooldindices; each former index may appear at most once in this list, so newdim < getnew_vardim()\n\n\n\n\n\ncb_add_reassign_variables!(self::CBGroundsetModification, new_dim::Integer, map_to_old_indices::Union{<:AbstractVector{Integer},Nothing})\n\nreorder and resize the variables as given by the first newdim entries of maptooldindices; each former index may appear at most once in this list, so newdim < getnew_vardim()\n\n\n\n\n\ncb_add_reassign_variables!(self::CBNNCBoxSupportModification, new_dim::Integer, map_to_old_indices::Union{<:AbstractVector{Integer},Nothing})\n\nreorder and resize the variables as given by the first newdim entries of maptooldindices; each former index may appear at most once in this list, so newdim < getnew_vardim()\n\n\n\n\n\ncb_add_reassign_variables!(self::CBPSCAffineModification, new_dim::Integer, map_to_old_indices::Union{<:AbstractVector{Integer},Nothing})\n\nreorder and resize the variables as given by the first newdim entries of maptooldindices; each former index may appear at most once in this list, so newdim < getnew_vardim()\n\n\n\n\n\ncb_add_reassign_variables!(self::CBSOCSupportModification, new_dim::Integer, map_to_old_indices::Union{<:AbstractVector{Integer},Nothing})\n\nreorder and resize the variables as given by the first newdim entries of maptooldindices; each former index may appear at most once in this list, so newdim < getnew_vardim()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_reassign_vars!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_reassign_vars!","text":"cb_add_reassign_vars!(self::CBAFTModification, map_to_old::CBIndexmatrix)\n\nreassign the variables/columns as given in @a maptoold, calls Modification::addreassignvars\n\n\n\n\n\ncb_add_reassign_vars!(self::CBGroundsetModification, map_to_old::CBIndexmatrix)\n\nreassign the variables as given in @a maptoold, calls Modification::addreassignvars\n\n\n\n\n\ncb_add_reassign_vars!(self::CBNNCBoxSupportModification, map_to_old::CBIndexmatrix)\n\nreassign the variables as given in @a maptoold, calls Modification::addreassignvars\n\n\n\n\n\ncb_add_reassign_vars!(self::CBPSCAffineModification, map_to_old::CBIndexmatrix)\n\n@brief reassign the current variable indices (with modifications) as specified by @a maptoold\n  @a map_to_old must specify an injective map (no two values match)\n  into indices 0 up to new_vardim()-1 (not all need to appear). The variable getting index\n  i (for i=0 to map_to_old.dim()-1) is the variable with current\n  index map_to_old(i) (current refers to considering all previous\n  modifications as having been carried out already). The return\n  value is the number of errors in @a map_to_old. If such occured, this\n  reassign is not performed.\n\n\n\n\n\ncb_add_reassign_vars!(self::CBSOCSupportModification, map_to_old::CBIndexmatrix)\n\nreassign the variables as given in @a maptoold, calls Modification::addreassignvars\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_reset_generating_primal!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_reset_generating_primal!","text":"cb_add_reset_generating_primal!(self::CBPSCAffineModification, new_generating_primal::Union{<:CBPSCPrimal,Nothing})\n\n@brief replace the current generating primal by newgeneratingprimal (on the heap, will be deleted here). It may be NULL to switch of generating primals.\n  Any changes here cause the deletion of all current aggregate minorants.\n  If not NULL, the object pointed to is on the heap and control over it\n  is passed over to *this, so *this will make sure it is deleted at due\n  time.\n\n  PSCPrimal gives no information on the order of the matrices involved, so no consistency checks are done here.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_solver!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_solver!","text":"cb_add_solver!(self::CBQPKKTSolverComparison, solver::Union{<:CBQPKKTSolverObject,Nothing}, name::Union{<:AbstractVector{UInt8},Nothing})\n\nthe first solver added is the reference solver\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_variable_metric!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_variable_metric!","text":"cb_add_variable_metric!(self::CBBundleDenseTrustRegionProx, addH::CBSymmatrix)\n\nsee BundleProxObject::addvariablemetric()\n\n\n\n\n\ncb_add_variable_metric!(self::CBBundleDenseTrustRegionProx, diagH::CBMatrix, vecH::CBMatrix)\n\nsee BundleProxObject::addlowrankvariable_metric()\n\n\n\n\n\ncb_add_variable_metric!(self::CBBundleDiagonalTrustRegionProx, diagH::CBMatrix, vecH::CBMatrix)\n\nsee BundleProxObject::adddynamicscaling()\n\n\n\n\n\ncb_add_variable_metric!(self::CBBundleDLRTrustRegionProx, diagH::CBMatrix, vecH::CBMatrix)\n\nsee BundleProxObject::addvariablemetric()\n\n\n\n\n\ncb_add_variable_metric!(self::CBBundleLowRankTrustRegionProx, diagH::CBMatrix, vecH::CBMatrix)\n\nsee BundleProxObject::adddynamicscaling()\n\n\n\n\n\ncb_add_variable_metric!(self::CBLPGroundset, H::CBVariableMetric, y_id::Integer, y::CBMatrix, descent_step::Bool, weightu::Real, model_maxviol::Real, indices::Union{<:CBIndexmatrix,Nothing} = nothing)\n\nsee VariableMetric\n\n\n\n\n\ncb_add_variable_metric!(self::CBAFTModel, H::CBVariableMetric, center_id::Integer, y::CBMatrix, descent_step::Bool, weightu::Real, model_maxviol::Real, indices::Union{<:CBIndexmatrix,Nothing} = nothing)\n\nsee DynamicScaling\n\n\n\n\n\ncb_add_variable_metric!(self::CBSumModel, H::CBVariableMetric, y_id::Integer, y::CBMatrix, descent_step::Bool, weightu::Real, model_maxviol::Real, indices::Union{<:CBIndexmatrix,Nothing} = nothing)\n\nsee BundleModel::adddynamicscaling\n\n\n\n\n\ncb_add_variable_metric!(self::CBPSCVariableMetricSelection, H::CBVariableMetric, y_id::Integer, y::CBMatrix, descent_step::Bool, weightu::Real, model_maxviol::Real, indices::Union{<:CBIndexmatrix,Nothing}, bundle_data::CBVariableMetricBundleData)\n\nsee ConicBundle::VariableMetricSelection::addvariablemetric(); here it must be possible to cast bundledata to PSCData&, otherwise the routine returns an error. It only adds something after a descentstep\n\n\n\n\n\ncb_add_variable_metric!(self::CBVariableMetricSVDSelection, H::CBVariableMetric, y_id::Integer, y::CBMatrix, descent_step::Bool, weightu::Real, model_maxviol::Real, indices::Union{<:CBIndexmatrix,Nothing}, bundle_data::CBVariableMetricBundleData)\n\nsee ConicBundle::VariableMetricSelection::addvariablemetric()\n\n\n\n\n\ncb_add_variable_metric!(self::CBSumBundleHandler, ft::CBFunctionTask, H::CBVariableMetric, yid::Integer, y::CBMatrix, descent_step::Bool, weightu::Real, model_maxviol::Real, indices::Union{<:CBIndexmatrix,Nothing} = nothing)\n\nsee DynamicScaling\n\n\n\n\n\ncb_add_variable_metric!(self::CBSumBundleHandler, H::CBVariableMetric, yid::Integer, center_y::CBMatrix, descent_step::Bool, weightu::Real, model_maxviol::Real, indices::Union{<:CBIndexmatrix,Nothing} = nothing)\n\nsee DynamicScaling\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_add_xinv_kron_z!","page":"Reference of C++ interface","title":"ConicBundle.cb_add_xinv_kron_z!","text":"cb_add_xinv_kron_z!(self::CBUQPConeModelBlock, barQ::CBSymmatrix)\n\nadd the system term corresponding to (xinv kron z) (that arises from solving the linearized perturbed complementarity system xz =0 or =muI for dx in the preferred search direction) to the diagonal block corresponding to qpxrange x qpxrange\n\n\n\n\n\ncb_add_xinv_kron_z!(self::CBUQPSumModelBlock, barQ::CBSymmatrix)\n\nadd this for all subblocks\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_addmeto","page":"Reference of C++ interface","title":"ConicBundle.cb_addmeto","text":"cb_addmeto(self::CBCMgramdense, S::CBSymmatrix, d::Real = 1.)\n\ncomputes S+=d(this);\n\n\n\n\n\ncb_addmeto(self::CBCMgramsparse, S::CBSymmatrix, d::Real = 1.)\n\ncomputes S+=d(this);\n\n\n\n\n\ncb_addmeto(self::CBCMgramsparse_withoutdiag, S::CBSymmatrix, d::Real = 1.)\n\ncomputes S+=d(this);\n\n\n\n\n\ncb_addmeto(self::CBCMlowrankdd, S::CBSymmatrix, d::Real = 1.)\n\ncomputes S+=d(this);\n\n\n\n\n\ncb_addmeto(self::CBCMlowranksd, S::CBSymmatrix, d::Real = 1.)\n\ncomputes S+=d(this);\n\n\n\n\n\ncb_addmeto(self::CBCMlowrankss, S::CBSymmatrix, d::Real = 1.)\n\ncomputes S+=d(this);\n\n\n\n\n\ncb_addmeto(self::CBCMsingleton, S::CBSymmatrix, d::Real = 1.)\n\ncomputes S+=d(this);\n\n\n\n\n\ncb_addmeto(self::CBCMsymdense, S::CBSymmatrix, d::Real = 1.)\n\ncomputes S+=d(this);\n\n\n\n\n\ncb_addmeto(self::CBCMsymsparse, S::CBSymmatrix, d::Real = 1.)\n\ncomputes S+=d(this);\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_addprodto","page":"Reference of C++ interface","title":"ConicBundle.cb_addprodto","text":"cb_addprodto(self::CBCMgramdense, B::CBMatrix, C::CBMatrix, d::Real = 1.)\n\ncomputes B+=d(this)*C\n\n\n\n\n\ncb_addprodto(self::CBCMgramdense, B::CBMatrix, C::CBSparsemat, d::Real = 1.)\n\ncomputes B+=d(this)*C\n\n\n\n\n\ncb_addprodto(self::CBCMgramsparse, B::CBMatrix, C::CBMatrix, d::Real = 1.)\n\ncomputes B+=d(this)*C\n\n\n\n\n\ncb_addprodto(self::CBCMgramsparse, B::CBMatrix, C::CBSparsemat, d::Real = 1.)\n\ncomputes B+=d(this)*C\n\n\n\n\n\ncb_addprodto(self::CBCMgramsparse_withoutdiag, B::CBMatrix, C::CBMatrix, d::Real = 1.)\n\ncomputes B+=d(this)*C\n\n\n\n\n\ncb_addprodto(self::CBCMgramsparse_withoutdiag, B::CBMatrix, C::CBSparsemat, d::Real = 1.)\n\ncomputes B+=d(this)*C\n\n\n\n\n\ncb_addprodto(self::CBCMlowrankdd, D::CBMatrix, C::CBMatrix, d::Real = 1.)\n\ncomputes D+=d(this)*C\n\n\n\n\n\ncb_addprodto(self::CBCMlowrankdd, D::CBMatrix, C::CBSparsemat, d::Real = 1.)\n\ncomputes D+=d(this)*C\n\n\n\n\n\ncb_addprodto(self::CBCMlowranksd, D::CBMatrix, C::CBMatrix, d::Real = 1.)\n\ncomputes D+=d(this)*C\n\n\n\n\n\ncb_addprodto(self::CBCMlowranksd, D::CBMatrix, C::CBSparsemat, d::Real = 1.)\n\ncomputes D+=d(this)*C\n\n\n\n\n\ncb_addprodto(self::CBCMlowrankss, D::CBMatrix, C::CBMatrix, d::Real = 1.)\n\ncomputes D+=d(this)*C\n\n\n\n\n\ncb_addprodto(self::CBCMlowrankss, D::CBMatrix, C::CBSparsemat, d::Real = 1.)\n\ncomputes D+=d(this)*C\n\n\n\n\n\ncb_addprodto(self::CBCMsingleton, B::CBMatrix, C::CBMatrix, d::Real = 1.)\n\ncomutes B+=d(this)*C\n\n\n\n\n\ncb_addprodto(self::CBCMsingleton, B::CBMatrix, C::CBSparsemat, d::Real = 1.)\n\ncomputes B+=d(this)*C\n\n\n\n\n\ncb_addprodto(self::CBCMsymdense, B::CBMatrix, C::CBMatrix, d::Real = 1.)\n\ncomputes B+=d(this)*C\n\n\n\n\n\ncb_addprodto(self::CBCMsymdense, B::CBMatrix, C::CBSparsemat, d::Real = 1.)\n\ncomputes B+=d(this)*C\n\n\n\n\n\ncb_addprodto(self::CBCMsymsparse, B::CBMatrix, C::CBMatrix, d::Real = 1.)\n\ncomputes B+=d(this)*C\n\n\n\n\n\ncb_addprodto(self::CBCMsymsparse, B::CBMatrix, C::CBSparsemat, d::Real = 1.)\n\ncomputes B+=d(this)*C\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_adjust_multiplier!","page":"Reference of C++ interface","title":"ConicBundle.cb_adjust_multiplier!","text":"cb_adjust_multiplier!(self::CBMatrixCBSolver)\n\n@brief Adjusts on all conic functions the penalty parameter for conic violations to twice the trace of the primal approximation.\n  This routine is only needed for conic function objects such\n  as the nonnegative cone, the second order cone and\n  the semidefinite cone if no good upper bound on the trace of\n  feasible points is known and has to be determined automatically.\n\n  If after some time, the trace values settle, the upper bounds\n  on the trace may be way to high and can then be reset with this\n  call.\n\n@return\n  - 0 on success\n  - != 0 otherwise\n\n\n\n\n\ncb_adjust_multiplier!(self::CBAFTModel, values_may_have_changed::Bool)\n\nsee SumBlockModel::adjust_multiplier\n\n\n\n\n\ncb_adjust_multiplier!(self::CBSumModel, values_may_have_changed::Bool)\n\nsee SumBlockModel::adjust_multiplier()\n\n\n\n\n\ncb_adjust_multiplier!(self::CBSumBundleHandler, values_may_have_changed::Bool)\n\nsee SumBlockModel::adjust_multiplier\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_adjust_trace!","page":"Reference of C++ interface","title":"ConicBundle.cb_adjust_trace!","text":"cb_adjust_trace!(self::CBQPConeModelBlock, b::Real)\n\nchange the right hand side of the trace constraint to b\n\n\n\n\n\ncb_adjust_trace!(self::CBUQPConeModelBlock, b::Real)\n\nchange the right hand side of the trace constraint to b\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_aggregate","page":"Reference of C++ interface","title":"ConicBundle.cb_aggregate","text":"cb_aggregate(self::CBMinorantPointer)\n\n*@brief returns ture if it points to a combination of minorants from the same function;\n\n   A minorant is considered an aggregate if it is obtained from an aggregate\n   or it was computed by a call to aggregate(MinorantBundle&,Real);\n   It is not an aggregate if it is the sum of non aggregate minorants from\n   different functions.\n\n   An _empty_ pointer is not an aggregate.\n\n\n\n\n\ncb_aggregate(self::CBMinorantUseData)\n\nreturns true if the minorant is an aggregate of several minorants\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_aggregate!","page":"Reference of C++ interface","title":"ConicBundle.cb_aggregate!","text":"cb_aggregate!(self::CBMinorantPointer, minorants::CBMinorantBundle, coeff::CBMatrix, factor::Real = 1.)\n\n*@brief collect the aggregate as the nonnegative linear combination of the bundle minorants (here *this may not be part of the bundle!). If *this is not empty, add this aggregate to *this. Only aggregation carries along primal data!\n\n   All minorants in the bundle need to be valid. Aggregating over no minorants\n   is treated as a zero minorant without any primal information.\n\n\n\n\n\ncb_aggregate!(self::CBMinorantPointer, minorant::CBMinorantPointer, itsfactor::Real = 1.)\n\n@brief aggregate the minorantitsfactor to *this, both must be valid for this. Only aggregation carries along primal data!\n\n\n\n\n\ncb_aggregate!(self::CBMinorant, minorant::CBMinorant, factor::Real = 1.)\n\nadds factor*minorant to this and does this also for the primal if it is availabe\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_aggregate_Gram_matrix!","page":"Reference of C++ interface","title":"ConicBundle.cb_aggregate_Gram_matrix!","text":"cb_aggregate_Gram_matrix!(self::CBBlockPSCPrimal, P::CBMatrix, factor::Real = 1.)\n\n@brief add factorP*P^T to this\n\n   The rows of P corresponding to each block are passed on the\n   with a corresponding call to the PSCPrimal of this block\n\n\n\n\n\ncb_aggregate_Gram_matrix!(self::CBDensePSCPrimal, P::CBMatrix, factor::Real = 1.)\n\nadd factorPP^T to this\n\n\n\n\n\ncb_aggregate_Gram_matrix!(self::CBGramSparsePSCPrimal, P::CBMatrix, factor::Real = 1.)\n\n@brief add factorP*P^T to this, collecting        all available information only in the sparse part, even the own Gram part.\n\n   This operation more or less converts this to a SparsePSCPrimal. The point\n   is that this routine is typically only called by PSCModel when aggregating\n   the information in a single aggregate matrix over several steps and it is\n   pointless to try to keep any gram information in this case.\n\n\n\n\n\ncb_aggregate_Gram_matrix!(self::CBSparsePSCPrimal, P::CBMatrix, factor::Real = 1.)\n\nadd factorPP^T on the support to this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_aggregate_primal_data!","page":"Reference of C++ interface","title":"ConicBundle.cb_aggregate_primal_data!","text":"cb_aggregate_primal_data!(self::CBPrimalMatrix, it::CBPrimalData, itsfactor::Real)\n\nmultiply this Matrix with myfactor and add itsfactorit (it must dynamic_cast to a PrimalMatrix)\n\n\n\n\n\ncb_aggregate_primal_data!(self::CBBlockPSCPrimal, it::CBPrimalData, factor::Real = 1.)\n\nadd factor*it to this       (it must also be a BlockPSCPrimal with the same block partition) \n\n\n\n\n\ncb_aggregate_primal_data!(self::CBDensePSCPrimal, it::CBPrimalData, factor::Real = 1.)\n\nadd factor*it to this (it must also be a DensePSCPrimal)\n\n\n\n\n\ncb_aggregate_primal_data!(self::CBGramSparsePSCPrimal, it::CBPrimalData, factor::Real = 1.)\n\n@brief if it is a GramSparsePSCPrimal or SparseSDPRimal, add factorit to this on only the support of this sparsematrix\n\n   Even if it is a GramSparsePSCPrimal and it has a nontirival Gram matrix part,\n   this part is only added to the sparse part of this on the support of the\n   sparse part of this. No attempt is made to enlarge the Gram part.\n\n\n\n\n\ncb_aggregate_primal_data!(self::CBSparsePSCPrimal, it::CBPrimalData, factor::Real = 1.)\n\nif it is a SparseSDPRimal, add factor*it to this on the support of this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_aggregated!","page":"Reference of C++ interface","title":"ConicBundle.cb_aggregated!","text":"cb_aggregated!(self::CBMinorantUseData, n::Integer)\n\nadd @a n to the number couting the aggregations\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_analyze_modification","page":"Reference of C++ interface","title":"ConicBundle.cb_analyze_modification","text":"cb_analyze_modification(self::CBAffineFunctionTransformation, minorant_trafo_differs::Bool, aftmdf::Union{<:CBAFTModification,Nothing}, gsmdf::CBGroundsetModification)\n\n@brief returns information on the changes in the ground set of the       transformed arguments and checks whether after the modification the nonzero image of the transformed minorants will not differ from before;       returns NULL on errors.\nIf argtrafo==NULL (act as identity) and if aftmdf!=NULL adds any explicit matrix parts or has modifications not consistent with maintaining the identity, argtrafo is virtually first set to an explicit identity before executing the modification. If argtrafo==NULL and aftmdf==NULL, the transformations of gsmdf are applied to linearcost and arg_offset.\nIf the input @a gsmdf and the AFT modifications in @a aftmdf result in a different GroundsetModification of the transformed space, this is computed into the member @a localgsmdf and the returned pointer points to this @a localgsmdf. If all transformations are passed on exactly as in @a gsmdf (because the trafo still acts as the identity), the returned pointer points to @a gsmdf.\n  If the changes affect the transformation at all in its effect\non the nonzero image of transformed minorants,       @a minoranttrafodiffers will be set to true otherwise to false.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_append!","page":"Reference of C++ interface","title":"ConicBundle.cb_append!","text":"cb_append!(self::CBQPSumModelBlock, inblock::Union{<:CBQPModelDataObject,Nothing})\n\nadd another model at the end of the list\n\n\n\n\n\ncb_append!(self::CBUQPSumModelBlock, inblock::Union{<:CBQPModelDataObject,Nothing})\n\nadd another model at the end of the list\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_append_blocks!","page":"Reference of C++ interface","title":"ConicBundle.cb_append_blocks!","text":"cb_append_blocks!(self::CBSparseCoeffmatMatrix, append_mat::CBSparseCoeffmatMatrix, blocks::Union{<:CBIndexmatrix,Nothing} = nothing, cols::Union{<:CBIndexmatrix,Nothing} = nothing)\n\n@brief append append_mat (or its submatrix given by blocks and/or cols) below\n  If blocks or cols have negative entries, each of these represent a row of blocks of zeros whose order is the negative of the given value or a column of zeros of appropriate size (the size of the negative value does not matter for columns)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_append_columns!","page":"Reference of C++ interface","title":"ConicBundle.cb_append_columns!","text":"cb_append_columns!(self::CBSparseCoeffmatMatrix, append_mat::CBSparseCoeffmatMatrix, blocks::Union{<:CBIndexmatrix,Nothing} = nothing, cols::Union{<:CBIndexmatrix,Nothing} = nothing)\n\n@brief append append_mat (or its submatrix given by blocks and/or cols) to the right\n  If blocks or cols have negative entries, each of these represent a row of blocks of zeros whose order is the negative of the given value (if columns exist already, these need to match the order of the existing blocks) or a column of zeros of appropriate size (the size of the negative value does not matter for columns)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_append_constraints!","page":"Reference of C++ interface","title":"ConicBundle.cb_append_constraints!","text":"cb_append_constraints!(self::CBMatrixCBSolver, append_n_rows::Integer, append_rows::Union{<:CBSparsemat,Nothing} = nothing, append_rhslb::Union{<:CBMatrix,Nothing} = nothing, append_rhsub::Union{<:CBMatrix,Nothing} = nothing)\n\n@brief append \\frhslble Ay le rhsubf as linear constraints on the groundset variables \\fyf. \\fAf has   @a appendnrows new rows with coefficients given in  appendrows (if NULL, use default value),  lower bounds appendrhslb (if NULL use default) and upper bounds append_rhsub (if NULL use default)\n@param[in] appendnrows  (Integer)       (nonnegative) number of rows to be appended as linear constraints on the ground set\n@param[in] appendrows  (Sparsemat*)       describes the coefficients of the linear constraints; the number of rows must match appendn_rows, the number of columns must match the current dimension of the groundset; if NULL, all coefficients are considered zero.\n@param[in] appendrhslb  (Matrix*)       specifies lower bounds on the values of the constraints;       the  number of rows must match appendnrows; if NULL, all coefficients are considered CBminus_infinity.\n@param[in] appendrhsub  (Matrix*)       specifies upper bound on the values of the constraints;       the  number of rows must match appendnrows; if NULL, all coefficients are considered CBplus_infinity.\n@return       - 0 on success       - != 0 otherwise\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_append_to_old","page":"Reference of C++ interface","title":"ConicBundle.cb_append_to_old","text":"cb_append_to_old(self::CBAFTModification)\n\nreturns true if this only contains appending operations and incorporating this is done with respect to the old dimension\n\n\n\n\n\ncb_append_to_old(self::CBGroundsetModification)\n\nreturns true if this only contains appending operations and incorporating this is done with respect to the old dimension\n\n\n\n\n\ncb_append_to_old(self::CBNNCBoxSupportModification)\n\nreturns true if this only contains appending operations and incorporating this is done with respect to the old dimension\n\n\n\n\n\ncb_append_to_old(self::CBPSCAffineModification)\n\nreturns true if this only contains appending operations and incorporating this is done with respect to the old dimension\n\n\n\n\n\ncb_append_to_old(self::CBSOCSupportModification)\n\nreturns true if this only contains appending operations and incorporating this is done with respect to the old dimension\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_append_variables!-Tuple{ConicBundle.CBMatrixCBSolver, Integer, Union{Nothing, ConicBundle.CBMatrix}, Union{Nothing, ConicBundle.CBMatrix}, Union{Nothing, ConicBundle.CBSparsemat}, Union{Nothing, ConicBundle.CBMatrix}, Union{Nothing, ConicBundle.CBMatrix}}","page":"Reference of C++ interface","title":"ConicBundle.cb_append_variables!","text":"cb_append_variables!(self::CBMatrixCBSolver, n_append::Integer, lbounds::Union{<:CBMatrix,Nothing} = nothing, ubounds::Union{<:CBMatrix,Nothing} = nothing, constraint_columns::Union{<:CBSparsemat,Nothing} = nothing, startval::Union{<:CBMatrix,Nothing} = nothing, costs::Union{<:CBMatrix,Nothing} = nothing)\n\n@brief Append new variables (always in last postions in this order).\n@attention Be sure to include a desription of required changes to your      functions via @a affectedfunctionswith_modifications\n@param[in] n_append  (int)      number of variables to append (always in last position in the same order)\n@param[in] lbounds  (const Matrix*)       If NULL, all appended variables are considered unbounded below,       otherwise lbounds[i] gives the minimum feasible value for variable y[i],       use ConicBundle::CBminusinfinity for unbounded below.\n@param[in] ubounds (const Matrix*)       If NULL, all appended variables are considered unbounded above,       otherwise ubounds[i] gives the maximum feasible value for variable y[i],       use ConicBundle::CBplusinfinity for unbounded above.\n@param[in] constraintcolumns (const Sparsemat*)       This must be NULL unless appendconstraints() has been used before for specifying linear constraints on the ground set; if there are constraints, NULL is interpreted as appending zero columns to the constraints, otherwise the the number of rows of the Sparsemant has to match the current number of linear constraints and the number of columns the must equal n_append.\n@param[in] startval (const Matrix*)       If NULL, the starting values are obtained by projecting       zero onto the feasible set given by the lower and upper bounds resulting from the arguments before\n@param[in] costs (const Matrix*)        Use this in order to specify linear costs on the variables in addition  to the functions (may be convenient in Lagrangean relaxation for  the right hand side of coupling contsraints); NULL is equivalent  to costs zero.\n@param[in,out] affectedfunctionswithmodifications (const FunObjModMap*)       If NULL, default actions are performed on all functions. In       particular, those admitting dynamic argument changes will get       the new variables appended at the end of their argument vector       and (eventually) their applymodification() routines will be       called informing them about the groundset changes; for those       not admitting changes in their arguments, their corresponding       (possibly newly created) affine function transformation will       be set up to ignore the new arguments.  If !=NULL, for the       listed functions (and their parents up to the root function)       the default appending action is performed unless their       FunctionObjectModification entry gives explicit modification       instructions which are then applied instead. For all functions       NOT listed in the map and not having modified offsprings their       corresponding aft will be set up to ignore the new variables.\n@return       - 0 on success       - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_appended_blockdim","page":"Reference of C++ interface","title":"ConicBundle.cb_appended_blockdim","text":"cb_appended_blockdim(self::CBPSCAffineModification)\n\nreturns the number of rows that are appended (due to later reassignments they may no longer be located at the end)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_appended_rowdim","page":"Reference of C++ interface","title":"ConicBundle.cb_appended_rowdim","text":"cb_appended_rowdim(self::CBAFTModification)\n\nreturns the number of rows that are appended (due to later reassignments they may no longer be located at the end)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_appended_vardim","page":"Reference of C++ interface","title":"ConicBundle.cb_appended_vardim","text":"cb_appended_vardim(self::CBAFTModification)\n\nreturns the number of variables that are appended (due to later reassignmentds they may no longer be located at the end)\n\n\n\n\n\ncb_appended_vardim(self::CBGroundsetModification)\n\nreturns the number of variables that are appended (due to later reassignmentds they may no longer be located at the end)\n\n\n\n\n\ncb_appended_vardim(self::CBNNCBoxSupportModification)\n\nreturns the number of variables that are appended (due to later reassignmentds they may no longer be located at the end)\n\n\n\n\n\ncb_appended_vardim(self::CBPSCAffineModification)\n\nreturns the number of variables that are appended (due to later reassignmentds they may no longer be located at the end)\n\n\n\n\n\ncb_appended_vardim(self::CBSOCSupportModification)\n\nreturns the number of variables that are appended (due to later reassignmentds they may no longer be located at the end)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_apply_Hinv","page":"Reference of C++ interface","title":"ConicBundle.cb_apply_Hinv","text":"cb_apply_Hinv(self::CBBundleDenseTrustRegionProx, x::CBMatrix)\n\nreturns \\fH^-1xf\n\n\n\n\n\ncb_apply_Hinv(self::CBBundleDiagonalTrustRegionProx, x::CBMatrix)\n\nreturns \\fH^-1xf\n\n\n\n\n\ncb_apply_Hinv(self::CBBundleDLRTrustRegionProx, x::CBMatrix)\n\nreturns \\fH^-1xf where \\fH^-1=frac1u(I-V(Lambda(Lambda+u))V^top)f\n\n\n\n\n\ncb_apply_Hinv(self::CBBundleIdProx, x::CBMatrix)\n\nreturns \\fH^-1xf\n\n\n\n\n\ncb_apply_Hinv(self::CBBundleLowRankTrustRegionProx, x::CBMatrix)\n\nreturns \\fH^-1xf where \\fH^-1=frac1u(I-V(Lambda(Lambda+u))V^top)f\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_apply_modification!","page":"Reference of C++ interface","title":"ConicBundle.cb_apply_modification!","text":"cb_apply_modification!(self::CBAffineFunctionTransformation, aftmdf::Union{<:CBAFTModification,Nothing}, gsmdf::CBGroundsetModification)\n\n@brief if argtrafo==NULL (act as identity) and if aftmdf!=NULL adds any explicit matrix parts or has modifications not consistent with maintaining the identity, argtrafo is first set to an explicit identity before executing the modification. If argtrafo==NULL and aftmdf==NULL, the transformations of gsmdf are applied to linearcost and arg_offset.\n\n\n\n\n\ncb_apply_modification!(self::CBMinorantPointer, gsmdf::CBGroundsetModification, mod_id::Integer, mex::Union{<:CBMinorantExtender,Nothing}, apply_gsmdf_costs::Bool = false)\n\nif valid and the local modificationid is smaller than modid, it modifies the coefficients as described by GroundsetModification; if successful, the modid is assigend and the function returns 0; otherwise it is invalidated and returns !=0; the costs of gsmdf are used only if applygsmdf_costs=false in whic case mex must be NULL\n\n\n\n\n\ncb_apply_modification!(self::CBBoxData, param0::CBGroundsetModification, mex::Union{<:CBMinorantExtender,Nothing})\n\nrearrange/extend the minorants according to the given groundset modifications\n\n\n\n\n\ncb_apply_modification!(self::CBNNCData, param0::CBGroundsetModification, mex::Union{<:CBMinorantExtender,Nothing})\n\nrearrange/extend the minorants according to the given groundset modifications\n\n\n\n\n\ncb_apply_modification!(self::CBPSCData, param0::CBGroundsetModification, mex::Union{<:CBMinorantExtender,Nothing})\n\nrearrange/extend the minorants according to the given groundset modifications\n\n\n\n\n\ncb_apply_modification!(self::CBSOCData, param0::CBGroundsetModification, mex::Union{<:CBMinorantExtender,Nothing})\n\nrearrange/extend the minorants according to the given groundset modifications\n\n\n\n\n\ncb_apply_modification!(self::CBBundleHKWeight, gsmdf::CBGroundsetModification)\n\nreinitialize after modifications\n\n\n\n\n\ncb_apply_modification!(self::CBBundleRQBWeight, gsmdf::CBGroundsetModification)\n\nreinitialize after modifications\n\n\n\n\n\ncb_apply_modification!(self::CBBundleDenseTrustRegionProx, gsmdf::CBGroundsetModification)\n\nwhen BundleSolver is called to modify the groundset it also calls this\n\n\n\n\n\ncb_apply_modification!(self::CBBundleDiagonalTrustRegionProx, gsmdf::CBGroundsetModification)\n\nwhen BundleSolver is called to modify the groundset it also calls this\n\n\n\n\n\ncb_apply_modification!(self::CBBundleDLRTrustRegionProx, gsmdf::CBGroundsetModification)\n\nwhen BundleSolver is called to modify the groundset it also calls this\n\n\n\n\n\ncb_apply_modification!(self::CBBundleIdProx, gsmdf::CBGroundsetModification)\n\nwhen BundleSolver is called to modify the groundset it also calls this\n\n\n\n\n\ncb_apply_modification!(self::CBBundleLowRankTrustRegionProx, gsmdf::CBGroundsetModification)\n\nwhen BundleSolver is called to modify the groundset it also calls this\n\n\n\n\n\ncb_apply_modification!(self::CBUQPSolver, param0::CBGroundsetModification)\n\ndoes nothing here (unconstrained case)\n\n\n\n\n\ncb_apply_modification!(self::CBLPGroundset, mdf::CBGroundsetModification)\n\nchange the groundset description as specified by the argument\n\n\n\n\n\ncb_apply_modification!(self::CBUnconstrainedGroundset, mdf::CBGroundsetModification)\n\nchange the groundset description as specified by the argument\n\n\n\n\n\ncb_apply_modification!(self::CBSumBundle, gsmdf::CBGroundsetModification, mod_id::Integer, mex::Union{<:CBMinorantExtender,Nothing}, ft::CBFunctionTask)\n\nrearrange/extend the minorants according to the given groundset modifications\n\n\n\n\n\ncb_apply_modification!(self::CBBundleSolver, gsmdf::CBGroundsetModification)\n\nmodify the groundset as described by GroundsetModification and inform the oracle function(s) about this change (calls the other apply_modification for an empty FunObjModMap)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_apply_modified_transform","page":"Reference of C++ interface","title":"ConicBundle.cb_apply_modified_transform","text":"cb_apply_modified_transform(self::CBAFTModification, out_y::CBMatrix, in_y::CBMatrix, arg_trafo::Union{<:CBSparsemat,Nothing}, arg_offset::Union{<:CBMatrix,Nothing})\n\ntransform the vector as if the Modification had been carried out\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_apply_to_PSCAffine","page":"Reference of C++ interface","title":"ConicBundle.cb_apply_to_PSCAffine","text":"cb_apply_to_PSCAffine(self::CBPSCAffineModification, offset::Union{<:CBSparseCoeffmatMatrix,Nothing}, matrix::Union{<:CBSparseCoeffmatMatrix,Nothing})\n\n@brief carry out the collected modifications on the data describing the PSCAffineFunction\n   If a specific parameter is NULL, no changes are performed on it,\n   if it is not null, it must point to a SparseCoeffmatMatrix\n   whose sizes correspond to the \"old\" data. Then the following\n   operations will be performed on it in this sequence:\n\n   1. new variables (columns) are appended to the matrix\n\n   2. if reassignment information is given, the columns are\n      mapped/reorderd as given by *map_to_old_variables()\n\n   3. new blocks (rows) are appended to the offset and the matrix\n\n   4. if reassignment information is given, the rows are\n      mappen/reorderd as given by *map_to_old_blocks()\n\n   @param[in,out] offset\n      if not NULL, this points to the offset vector.\n\n   @param[in,out] matrix\n      if not NULL, this points to the old matrix.\n\n   @return the number of dimension errors of non NULL inputs,\n      if any, no modifications are made to any inputs.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_apply_to_bounds","page":"Reference of C++ interface","title":"ConicBundle.cb_apply_to_bounds","text":"cb_apply_to_bounds(self::CBNNCBoxSupportModification, lb::CBMatrix, ub::CBMatrix)\n\ncarry out the collected modifications on the given vectors of lower and upper bounds on the variables by calling Modification::applytovars\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_apply_to_costs","page":"Reference of C++ interface","title":"ConicBundle.cb_apply_to_costs","text":"cb_apply_to_costs(self::CBGroundsetModification, costs::CBMatrix)\n\ncarry out the collected modifications on the given vector by calling Modification::applytovars\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_apply_to_factor","page":"Reference of C++ interface","title":"ConicBundle.cb_apply_to_factor","text":"cb_apply_to_factor(self::CBAFTModification)\n\nmultiply @a f by the factor\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_apply_to_offset","page":"Reference of C++ interface","title":"ConicBundle.cb_apply_to_offset","text":"cb_apply_to_offset(self::CBAFTModification)\n\nadd to @a o the offset\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_apply_to_vars","page":"Reference of C++ interface","title":"ConicBundle.cb_apply_to_vars","text":"cb_apply_to_vars(self::CBGroundsetModification, vars::CBMatrix)\n\ncarry out the collected modifications on the given vector by calling Modification::applytovars\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_apply_variable_metric!","page":"Reference of C++ interface","title":"ConicBundle.cb_apply_variable_metric!","text":"cb_apply_variable_metric!(self::CBBundleDenseTrustRegionProx, groundset::Union{<:CBVariableMetricModel,Nothing}, model::Union{<:CBVariableMetricModel,Nothing}, aggr::CBMatrix, y_id::Integer, y::CBMatrix, descent_step::Bool, model_maxviol::Real, new_indices::Union{<:CBIndexmatrix,Nothing} = nothing)\n\nsee DynamicScaling\n\n\n\n\n\ncb_apply_variable_metric!(self::CBBundleDiagonalTrustRegionProx, groundset::Union{<:CBVariableMetricModel,Nothing}, model::Union{<:CBVariableMetricModel,Nothing}, aggr::CBMatrix, y_id::Integer, y::CBMatrix, descent_step::Bool, model_maxviol::Real, new_indices::Union{<:CBIndexmatrix,Nothing} = nothing)\n\nsee VariableMetric\n\n\n\n\n\ncb_apply_variable_metric!(self::CBBundleDLRTrustRegionProx, groundset::Union{<:CBVariableMetricModel,Nothing}, model::Union{<:CBVariableMetricModel,Nothing}, aggr::CBMatrix, y_id::Integer, y::CBMatrix, descent_step::Bool, model_maxviol::Real, new_indices::Union{<:CBIndexmatrix,Nothing} = nothing)\n\nsee DynamicScaling\n\n\n\n\n\ncb_apply_variable_metric!(self::CBBundleLowRankTrustRegionProx, groundset::Union{<:CBVariableMetricModel,Nothing}, model::Union{<:CBVariableMetricModel,Nothing}, aggr::CBMatrix, y_id::Integer, y::CBMatrix, descent_step::Bool, model_maxviol::Real, new_indices::Union{<:CBIndexmatrix,Nothing} = nothing)\n\nsee DynamicProx\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_argument_changes","page":"Reference of C++ interface","title":"ConicBundle.cb_argument_changes","text":"cb_argument_changes(self::CBAffineFunctionTransformation)\n\nreturns true if not the identity\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_assign_Gram_matrix!","page":"Reference of C++ interface","title":"ConicBundle.cb_assign_Gram_matrix!","text":"cb_assign_Gram_matrix!(self::CBBlockPSCPrimal, P::CBMatrix)\n\n*@brief for each element aij in the support set aij=<P.row(i),P.row(j)>\n\n   The rows of P corresponding to each block are passed on the\n   with a corresponding call to the PSCPrimal of this block\n\n\n\n\n\ncb_assign_Gram_matrix!(self::CBDensePSCPrimal, P::CBMatrix)\n\nassign P*P^T to this\n\n\n\n\n\ncb_assign_Gram_matrix!(self::CBGramSparsePSCPrimal, P::CBMatrix)\n\nSet the grammatrix part to \\fPf and set all values on the sparse support to zero (but keep this support even if it is zero now!)\n\n\n\n\n\ncb_assign_Gram_matrix!(self::CBSparsePSCPrimal, P::CBMatrix)\n\nfor each element aij in the support set aij=<P.row(i),P.row(j)>\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_block","page":"Reference of C++ interface","title":"ConicBundle.cb_block","text":"cb_block(self::CBBlockPSCPrimal, i::Integer)\n\nreturns the PSCPrimal of block i if there is one, 0 otherwise\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_block_modifications","page":"Reference of C++ interface","title":"ConicBundle.cb_block_modifications","text":"cb_block_modifications(self::CBPSCAffineModification)\n\nreturns true if some modifications are performed on the block structure\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_blockdim","page":"Reference of C++ interface","title":"ConicBundle.cb_blockdim","text":"cb_blockdim(self::CBSparseCoeffmatMatrix)\n\nreturns a column vector with row i giving the order of block i\n\n\n\n\n\ncb_blockdim(self::CBSparseCoeffmatMatrix, i::Integer)\n\nreturns the order of block i\n\n\n\n\n\ncb_blockdim(self::CBBlockPSCPrimal, i::Integer)\n\nreturns the size of block i\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_bundle_size","page":"Reference of C++ interface","title":"ConicBundle.cb_bundle_size","text":"cb_bundle_size(self::CBSumBundle, ft::CBFunctionTask)\n\nif BData exists for this mode it returns its bundle_size (possibly 0), otherwise 0\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_call_primal_extender!","page":"Reference of C++ interface","title":"ConicBundle.cb_call_primal_extender!","text":"cb_call_primal_extender!(self::CBMatrixCBSolver, function_::CBFunctionObject, primal_extender::CBPrimalExtender)\n\n@brief Asks @a function to call @a primal_extender for each of its primal objects (see    also FunctionOracle::evaluate() )\nIf the function is the Lagrangian dual of a primal problem and primaldata    returned previous calls to the oracle has now to be updated due to changes    in the primal problem  e.g., this may happen in column generation  the    call causes updates of all internally stored primaldata objects by calling    PrimalExtender::extend on each of these.\n@param[in] function (const FunctionObject&)\n  the function added in add_function()\n\n@param[in] primal_extender (PrimalExtender&)\n  the object holding the extension function for primal_data\n\n@return\n  - 0 on success\n  - 1 if for this function it is not possible to use a primal_extender\n  - 2 if the primal_extender would be applicable but there is no primal_data\n\n\n\n\n\ncb_call_primal_extender!(self::CBMinorantPointer, prex::CBPrimalExtender, prex_id::Integer)\n\nexecutes prex on the primal if its id is smaller then prex_id; returns != if this fails or not primal data is available\n\n\n\n\n\ncb_call_primal_extender!(self::CBMinorantUseData, prex::CBPrimalExtender, in_prex_id::Integer)\n\napply the primal extender to the minorant if @a inprexid indicates a new extension\n\n\n\n\n\ncb_call_primal_extender!(self::CBBoxData, prex::CBPrimalExtender, include_candidates::Bool = true)\n\nsee the last argument of BoxOracle::evaluate()\n\n\n\n\n\ncb_call_primal_extender!(self::CBNNCData, prex::CBPrimalExtender, include_candidates::Bool = true)\n\nsee the last argument of FunctionOracle::evaluate()\n\n\n\n\n\ncb_call_primal_extender!(self::CBPSCData, param0::CBPrimalExtender, include_candidates::Bool = true)\n\nsee the last argument of FunctionOracle::evaluate()\n\n\n\n\n\ncb_call_primal_extender!(self::CBSOCData, param0::CBPrimalExtender, include_candidates::Bool = true)\n\nsee the last argument of FunctionOracle::evaluate()\n\n\n\n\n\ncb_call_primal_extender!(self::CBAFTModel, param0::CBPrimalExtender)\n\nan AFT has no primals, so it returns 1, see SumBlockModel::callprimalextender\n\n\n\n\n\ncb_call_primal_extender!(self::CBBoxModel, prex::CBPrimalExtender)\n\nsee SumBlockModel::callprimalextender\n\n\n\n\n\ncb_call_primal_extender!(self::CBNNCModel, prex::CBPrimalExtender)\n\nsee SumBlockModel::callprimalextender\n\n\n\n\n\ncb_call_primal_extender!(self::CBPSCModel, prex::CBPrimalExtender)\n\nsee SumBlockModel::callprimalextender\n\n\n\n\n\ncb_call_primal_extender!(self::CBSOCModel, prex::CBPrimalExtender)\n\nsee SumBlockModel::callprimalextender\n\n\n\n\n\ncb_call_primal_extender!(self::CBSumModel, param0::CBPrimalExtender)\n\nthis has no primals, so it returns 1, see SumBlockModel::callprimalextender\n\n\n\n\n\ncb_call_primal_extender!(self::CBSumBundle, prex::CBPrimalExtender, prex_id::Integer, ft::CBFunctionTask)\n\ncall this primal extender for the primals; if there minorants but no primals or if it fails, return 1\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_candidate!","page":"Reference of C++ interface","title":"ConicBundle.cb_candidate!","text":"cb_candidate!(self::CBLPGroundset, newy::CBMatrix, center_y::CBMatrix, center_value::Real, model_minorant::CBMinorantPointer, Hp::Union{<:CBBundleProxObject,Nothing}, delta_groundset_minorant::Union{<:CBMinorantPointer,Nothing} = nothing, delta_index::Union{<:CBIndexmatrix,Nothing} = nothing, relprec::Real = 1e-2)\n\ncomputes the next ground set minorant and candidate, see Groundset::candidate()\n\n\n\n\n\ncb_candidate!(self::CBUnconstrainedGroundset, newy::CBMatrix, center_y::CBMatrix, center_value::Real, model_minorant::CBMinorantPointer, Hp::Union{<:CBBundleProxObject,Nothing}, delta_groundset_minorant::Union{<:CBMinorantPointer,Nothing} = nothing, delta_index::Union{<:CBIndexmatrix,Nothing} = nothing, relprec::Real = 1e-2)\n\n@brief for a given model aggregate compute the groundset aggregate and the resulting (feasible) candidate\nLet \\f$ (\\sigma,s) \\f$ be the aggregate minorant \\fsigma+s^top yle f(y)f of the cost function described by @a modelsubgoffset and @a modelsubg, let \\fhat yf be the center of stability given by @a centery, let \\fHf denote the positive definite scaling matrix with weight \\fuf given by @a Hp, let \\fYf denote this (convex) feasible ground set and \\fi_Yf its indicator function, then this computes a saddle point \\f(y(gammag))f of\n\\f[ \\max{(\\gamma,g)\\in\\partial iY}\\min{y\\in\\mathbf{R}^n} [(s+g)^\\top y + \\gamma+\\sigma +\\frac{u}2\\|y-\\hat y\\|H^2],\\f]\nThe resulting \\fyf is feasible and stored in @a newy.      @a linval gets \\fgamma+sigma+(g+s)^top yf,      @a subgnorm2 gets \\fuy-hat x_H^2f,      @a augval gets @a linval+@a subgnorm2 /2.\nIf @a deltagroundsetsubg is not NULL, also      @a eltagroundsetsubgoffset and @a delta index are assumed to be      not NULL. Then all changes from the previous groundset aggregate      minorant to the new groundset aggregate minorant \\f(gammag)f are      stored in @a deltagroundsetsubgoffset and @a deltagroundsetsubg      and @a deltaindex holds the indices of the nonzero changes      (mostly the groundset aggregate is sparse, e.g. due to complementarity).      This is used in BundleProxObject::updateQP_costs().\nOn input \\fvarepsilon=f @a relprec, \\fbar f=f @a      center_value, and \\funderlinef=f @a augval serve to form      appropriate stopping criteria if solving the saddle point problem      requires a nonlinear convex optimization method. The method is      then assumed to produce a primal solution \\fyin Yf of value      \\fbar sf and a dual solution \\f(gammag)f of value      \\funderlinegf with the properties \\funderline g-underline      fge 0f and \\fbar f-bar sge 0f and \\fbar      s-underlineglevarepsilon(bar s+1)f.  In particular      \\fyin Yf is assumed to hold to machine precision.\nIf useyfixing is true (the fixing heuristic is switched on),      then \\fyi=\\hat yi\\f$ is required to hold for all i with      yfixed(i)!=0, so these coordinates are not allowed to change. In      particular, this routine may also set yfixed(i)=2 for new      coordinates i, where 2 is used to indicate newly fixed      variables. These will be reset to 1 in      BundlesScaling::computeQPcosts() and      BundlesScaling::updateQP_costs()      when this information has been digested.\nIn some derived classes a scaling heuristic is called that may influence the scaling @a Hp so as to avoid going outside the feasible region too far.\n@param[out] gsid       the current groundsetid\n@param[out] newy       the next candidate y (feasible)\n@param[out] candgsval       the value of the groundset minorant in the candidate y (=groundset objective)\n@param[out] linval (CHMatrixClasses::Real&) value of linear minorant in y\n@param[in,out] augvallb (CHMatrix_Classes::Real&)       - on input: lower bound value of augmented model in previous (maybe infeasible) candidate       - on output: lower bound value of augmented model in y\n@param[out] augvalub (CHMatrix_Classes::Real&)       - on output: upper bound value of augmented model in y\n@param[out] subgnorm2 (CHMatrixClasses::Real&)       squared Hp-norm (with weight) of joint groundset and model aggregate\n@param[in] centery (const CHMatrix_Classes::Matrix&)       center of stability (feasible)\n@param[in] centervalue (CHMatrixClasses::Real)       function value in centery\n@param[in] model_minorant (const MinorantPoiner&)       aggregate linear minorant of the cost function\n@param[in,out] Hp (ConicBundle::BundleProxObject*)       pointer to scaling matrix H, may be influenced by a scaling heuristic\n@param[in,out] deltagroundsetminorant (MinorantPointer*)       if not NULL, the change in groundset aggregate will be stored here\n@param[in,out] deltaindex (CHMatrixClasses::Indexmatrix*)       must be not NULL iff deltagroundsetsubg!=NULL or yfixed has changed,       will store nonzero indices of deltagroundset_subg\n@param[in] relprec (CHMatrixClasses::Real)       relative precision for termination in QP computations\n@return 0 on success, != 0 on failure\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_ceil","page":"Reference of C++ interface","title":"ConicBundle.cb_ceil","text":"cb_ceil(A::CBMatrix)\n\nreturns a matrix with elements (i,j)=ceil((*this)(i,j)) for all i,j\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_ceil!","page":"Reference of C++ interface","title":"ConicBundle.cb_ceil!","text":"cb_ceil!(self::CBMatrix)\n\nsets (this)(i,j)=ceil((this)(i,j)) for all i,j and returns *this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_center_modified!","page":"Reference of C++ interface","title":"ConicBundle.cb_center_modified!","text":"cb_center_modified!(self::CBAFTData, center_id::Integer)\n\ncheck whether center computation is still valid for this point and modification id\n\n\n\n\n\ncb_center_modified!(self::CBAFTModel, center_id::Integer)\n\nsee BundleModel::center_modified\n\n\n\n\n\ncb_center_modified!(self::CBSumModel, center_id::Integer)\n\nsee BundleModel::center_modified\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_check_center_validity_by_candidate!","page":"Reference of C++ interface","title":"ConicBundle.cb_check_center_validity_by_candidate!","text":"cb_check_center_validity_by_candidate!(self::CBAFTModel, cand_minorant_is_below::Bool, center_id::Integer, center_y::CBMatrix)\n\nsee BundleModel::checkcentervaliditybycandidate\n\n\n\n\n\ncb_check_center_validity_by_candidate!(self::CBSumModel, cand_minorant_is_below::Bool, center_id::Integer, center_y::CBMatrix)\n\nsee BundleModel::checkcentervaliditybycandidate\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_check_correctness","page":"Reference of C++ interface","title":"ConicBundle.cb_check_correctness","text":"cb_check_correctness(self::CBBoxOracle)\n\n*@brief switch on/off some correctnes checks on the oracle \n\n\n\n\n\ncb_check_correctness(self::CBNNCBoxSupportFunction)\n\nsee MatrixFunctionOracle::check_correctness()   (true only needed for debugging)\n\n\n\n\n\ncb_check_correctness(self::CBPSCAffineFunction)\n\nsee PSCOracle::check_correctness()\n\n\n\n\n\ncb_check_correctness(self::CBSOCSupportFunction)\n\nsee SOCOracle::check_correctness() (true only needed for debugging)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_check_support","page":"Reference of C++ interface","title":"ConicBundle.cb_check_support","text":"cb_check_support(self::CBSparsesym, i::Integer, j::Integer)\n\nreturns 0 if (i,j) is not in the support, 1 otherwise\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBAFTData, Integer}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBAFTData, start_modification_id::Integer = 0)\n\nreset to initial state (also used by the default constructor)\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBAFTModel}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBAFTModel)\n\noverloads the SumBlockModel::clear calling the other clear with parameter 0\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBAFTModel, Union{Nothing, ConicBundle.CBAffineFunctionTransformation}, Integer}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBAFTModel, inaft::Union{<:CBAffineFunctionTransformation,Nothing}, start_modification_id::Integer = 0)\n\nresets all data to the inital state, except for aft which is unchanged unless @a inaft ist not NULL, which then replaces aft\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBAFTModification, Integer, Integer}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBAFTModification, var_olddim::Integer, row_olddim::Integer)\n\nreset modifications to an unmodified object currently having varolddim columns and rowolddim rows,  calls Modification::clear\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBBoxData, Integer}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBBoxData, start_modification_id::Integer = 0)\n\nreset to initial state (also used by the default constructor)\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBBoxModel}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBBoxModel)\n\nresets all data to initial status of this class, also the bundle parameters\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBBundleHKWeight}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBBundleHKWeight)\n\nreset all adaptive variables and parameters\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBBundleRQBWeight}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBBundleRQBWeight)\n\nreset all adaptive variables and parameters\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBBundleSolver}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBBundleSolver)\n\nresets all variables and pointers to classes to initial state and calls set_defaults()\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBBundleTerminator}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBBundleTerminator)\n\nresets @a terminated\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBGroundsetModification, Integer}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBGroundsetModification, var_olddim::Integer)\n\nreset modifications to an unmodified object currently having var_olddim variables, calls Modification::clear\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBLPGroundset, Integer, Integer}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBLPGroundset, indim::Integer = 0, in_groundset_id::Integer = 0)\n\nresets all values as described in Groundset::clear()\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBMatrixCBSolver}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBMatrixCBSolver)\n\n@brief Clears all data structures and problem information       but keeps ouptut settings and algorithmic parameter settings\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBMinorantPointer}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBMinorantPointer)\n\nafterwards the pointer is empty (calls delete_data())\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBNNCBoxSupportModification, Integer}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBNNCBoxSupportModification, var_olddim::Integer)\n\nreset modifications to an unmodified object currently having var_olddim variables, calls Modification::clear\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBNNCData, Integer}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBNNCData, start_modification_id::Integer = 0)\n\nreset to initial state (also used by the default constructor)\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBNNCModel}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBNNCModel)\n\nresets all data to initial status of this class, also the bundle parameters\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBPSCAffineModification, Integer, ConicBundle.CBIndexmatrix}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBPSCAffineModification, var_olddim::Integer, block_olddim::CBIndexmatrix)\n\n@brief resets all variables so that the object to be modified has       starting size varolddim (number of variables) and blockolddim       (number of rows) and no modifications\n  The actual old data is not needed at this point,\n  the changes on it will be collected and excuted in the\n  routines apply_to_vars and apply_to_blocks\n\n  Setting the parameter ensure_start_val_box_feasibility to true\n  will cause the algorithm to check in add_append_vars() whether\n  the input values are within the given bounds and in\n  apply_to_vars() it will project all start_values onto the bounds\n  for all, old and new, indices (which might have been changed by\n  then).  If it is false (default), all values will be accepted as\n  given.\n\n  Setting the parameter ensure_bounds_consistency to true\n  (default) will raise errors in add_append_vars() and in\n  apply_to_vars() whenever there are lower bounds greater than the\n  respective upper bounds so as to avoid trivial\n  infeasibilities. This check is omitted if set to false.\n\n  The remaining values give the values of plus and minus infinity\n  the no bounds should exceed. These are the default values at the\n  same time (maybe it might be good to have a separate default value,\n  but this is not implemented here).\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBPSCData, Integer}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBPSCData, start_modification_id::Integer = 0)\n\nreset to initial state (also used by the default constructor)\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBPSCModel}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBPSCModel)\n\nresets all data to initial status of this class, also the bundle parameters\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBQPConeModelBlock}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBQPConeModelBlock)\n\nreset to \"empty/no\" model\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBQPDirectKKTSolver}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBQPDirectKKTSolver)\n\nreset data to empty\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBQPKKTSolverComparison}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBQPKKTSolverComparison)\n\nreset data to empty\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBQPSumModelBlock}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBQPSumModelBlock)\n\nreset to \"empty/no\" model\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBSOCData, Integer}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBSOCData, start_modification_id::Integer = 0)\n\nreset to initial state (also used by the default constructor)\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBSOCModel}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBSOCModel)\n\nresets all data to initial status of this class, also the bundle parameters\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBSOCSupportModification, Integer}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBSOCSupportModification, var_olddim::Integer)\n\nreset modifications to an unmodified object currently having var_olddim variables, calls Modification::clear\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBSparseCoeffmatMatrix}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBSparseCoeffmatMatrix)\n\nclears all (empty 0 times 0 matrix)\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBSumModel}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBSumModel)\n\nresets the SumModel to its initial state, in particular it removes but does not delete any Models added in add_model() (their AFTs are deleted if not explicitly denied)\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBUQPConeModelBlock}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBUQPConeModelBlock)\n\nreinitialize to \"empty/no\" model\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBUQPSolver}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBUQPSolver)\n\nreset to \"empty/no\" model\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBUQPSumModelBlock}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBUQPSumModelBlock)\n\nreset to \"empty/no\" model\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBUnconstrainedGroundset, Integer, Integer}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(self::CBUnconstrainedGroundset, indim::Integer = 0, in_groundset_id::Integer = 0)\n\n@brief reset everything to initial state for an unconstrained ground set of dimension @a indim\n  Note that a ground set is allowed to have dimension zero. This\n  will lead to evaluating a function without arguments and is\n  a realistic scenario in Lagrangean relaxation of cutting plane\n  approaches if no cutting planes have been added yet.\n\n  If the changes to the ground set are to be counted by groundset_id,\n  then it makes sense to enter the appropriate value in in_groundset_id.\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear_aggregates!","page":"Reference of C++ interface","title":"ConicBundle.cb_clear_aggregates!","text":"cb_clear_aggregates!(self::CBMatrixCBSolver, function_::Union{<:CBFunctionObject,Nothing} = nothing)\n\n@brief Clears the aggregate parts of the cutting model of this @a function      (but only for the given one, not recursively)\n There should be no need to call this if the modification\n routines of this interface were used correctly. If, however,\n the oracle is modified by other means outside this interface,\n this has to be called whenever the specified function was\n modified so that the old aggregate subgradients and/or primal\n generators are no longer valid.\n\n@param[in] function (const FunctionObject&)\n  the function added in add_function()\n\n@return\n  - 0 on success\n  - != 0 otherwise\n\n\n\n\n\ncb_clear_aggregates!(self::CBAFTData)\n\ndelete all kinds of aggregates but keep explicit parts of the cutting model\n\n\n\n\n\ncb_clear_aggregates!(self::CBBoxData)\n\nremove all aggregate minorants\n\n\n\n\n\ncb_clear_aggregates!(self::CBNNCData)\n\nremove all aggregate minorants\n\n\n\n\n\ncb_clear_aggregates!(self::CBPSCData)\n\ndelete all kinds of aggregates but keep explicit parts of the cutting model\n\n\n\n\n\ncb_clear_aggregates!(self::CBSOCData)\n\ndelete all kinds of aggregates but keep explicit parts of the cutting model\n\n\n\n\n\ncb_clear_aggregates!(self::CBAFTModel)\n\nsee SumBlockModel::clear_aggregates\n\n\n\n\n\ncb_clear_aggregates!(self::CBSumModel)\n\nsee SumBlockModel::clear_aggregates\n\n\n\n\n\ncb_clear_aggregates!(self::CBSumBundleHandler)\n\nfirst calls remove_contributions(), then discards all aggregate minorants in the current model\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_clear_cand_minorants!","page":"Reference of C++ interface","title":"ConicBundle.cb_clear_cand_minorants!","text":"cb_clear_cand_minorants!(self::CBSumBundleHandler)\n\nbefore contributing the new evaluation results, the candidates have to be cleared\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_clear_fail_counts!-Tuple{ConicBundle.CBMatrixCBSolver}","page":"Reference of C++ interface","title":"ConicBundle.cb_clear_fail_counts!","text":"cb_clear_fail_counts!(self::CBMatrixCBSolver)\n\n@brief clears all fail counts on numerical function oder model failures, may be useful if this caused premature termination.\n@return\n  - 0 on success\n  - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_clear_fails!","page":"Reference of C++ interface","title":"ConicBundle.cb_clear_fails!","text":"cb_clear_fails!(self::CBBundleSolver)\n\nresets all fail counts to zero (call this to resume computations\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_clear_model!","page":"Reference of C++ interface","title":"ConicBundle.cb_clear_model!","text":"cb_clear_model!(self::CBAFTData, discard_minorants_only::Bool = false)\n\nclear the cutting modle and all function evaluatoins\n\n\n\n\n\ncb_clear_model!(self::CBBoxData, discard_minorants_only::Bool = false)\n\nclear the cutting model and all function evaluations\n\n\n\n\n\ncb_clear_model!(self::CBNNCData, discard_minorants_only::Bool = false)\n\nclear the cutting model and all function evaluations\n\n\n\n\n\ncb_clear_model!(self::CBPSCData, discard_minorants_only::Bool = false)\n\nclear the cutting model and all function evaluations\n\n\n\n\n\ncb_clear_model!(self::CBSOCData, discard_minorants_only::Bool = false)\n\nclear the cutting model and all function evaluations\n\n\n\n\n\ncb_clear_model!(self::CBAFTModel, discard_minorants_only::Bool = false)\n\nsee SumBlockModel::clear_model\n\n\n\n\n\ncb_clear_model!(self::CBSumModel, discard_minorants_only::Bool = false)\n\nsee SumBlockModel::clear_model\n\n\n\n\n\ncb_clear_model!(self::CBSumBundleHandler)\n\nfirst calls remove_contributions(), then discards all current models\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_clear_terminated!","page":"Reference of C++ interface","title":"ConicBundle.cb_clear_terminated!","text":"cb_clear_terminated!(self::CBBundleTerminator)\n\nreset the termination code to zero (this does not remove the reason for the termination; for this, set other bounds or clear the numbers supplied by BundleTerminationData)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_clone","page":"Reference of C++ interface","title":"ConicBundle.cb_clone","text":"cb_clone(self::CBCMgramdense)\n\nmakes an explicit copy of itself and returns a pointer to it\n\n\n\n\n\ncb_clone(self::CBCMgramsparse)\n\nmakes an explicit copy of itself and returns a pointer to it\n\n\n\n\n\ncb_clone(self::CBCMgramsparse_withoutdiag)\n\nmakes an explicit copy of itself and returns a pointer to it\n\n\n\n\n\ncb_clone(self::CBCMlowrankdd)\n\nmakes an explicit copy of itself and returns a pointer to it\n\n\n\n\n\ncb_clone(self::CBCMlowranksd)\n\nmakes an explicit copy of itself and returns a pointer to it\n\n\n\n\n\ncb_clone(self::CBCMlowrankss)\n\nmakes an explicit copy of itself and returns a pointer to it\n\n\n\n\n\ncb_clone(self::CBCMsingleton)\n\nmakes an explicit copy of itself and returns a pointer to it\n\n\n\n\n\ncb_clone(self::CBCMsymdense)\n\nmakes an explicit copy of itself and returns a pointer to it\n\n\n\n\n\ncb_clone(self::CBCMsymsparse)\n\nmakes an explicit copy of itself and returns a pointer to it\n\n\n\n\n\ncb_clone(self::CBCoeffmatInfo)\n\ngenerates a new copy of itself on the heap\n\n\n\n\n\ncb_clone(self::CBAFTData)\n\nreturn a pointer to a clone of this\n\n\n\n\n\ncb_clone(self::CBBoxData)\n\nreturn a pointer to a clone of this\n\n\n\n\n\ncb_clone(self::CBNNCData)\n\nreturn a pointer to a clone of this\n\n\n\n\n\ncb_clone(self::CBPSCData)\n\nreturn a pointer to a clone of this\n\n\n\n\n\ncb_clone(self::CBSOCData)\n\nreturn a pointer to a clone of this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_clone!","page":"Reference of C++ interface","title":"ConicBundle.cb_clone!","text":"cb_clone!(self::CBQPConeModelBlock)\n\nreturn a cloned object on the heap\n\n\n\n\n\ncb_clone!(self::CBQPSumModelBlock)\n\nreturn a cloned object on the heap\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_clone_BundleParameters","page":"Reference of C++ interface","title":"ConicBundle.cb_clone_BundleParameters","text":"cb_clone_BundleParameters(self::CBBoxModelParameters)\n\nclone\n\n\n\n\n\ncb_clone_BundleParameters(self::CBNNCModelParameters)\n\nclone\n\n\n\n\n\ncb_clone_BundleParameters(self::CBPSCModelParameters)\n\nclone\n\n\n\n\n\ncb_clone_BundleParameters(self::CBSOCModelParameters)\n\nclone\n\n\n\n\n\ncb_clone_BundleParameters(self::CBSumBundleParameters)\n\nclone\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_clone_VariableMetricSelection!","page":"Reference of C++ interface","title":"ConicBundle.cb_clone_VariableMetricSelection!","text":"cb_clone_VariableMetricSelection!(self::CBPSCVariableMetricSelection)\n\nclone: the values are only preserved for those contained in the constructor: nlatestminorants, selection_method and oldfactor\n\n\n\n\n\ncb_clone_VariableMetricSelection!(self::CBVariableMetricSVDSelection)\n\nclone: the values are only preserved for those contained in the constructor: nlatestminorants, selection_method and oldfactor\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_clone_minorant","page":"Reference of C++ interface","title":"ConicBundle.cb_clone_minorant","text":"cb_clone_minorant(self::CBMinorant, factor::Real = 1., with_primal::Bool = true)\n\ngenerates a full copy (multiplied by factor) on the heap and returns a pointer to it (it also includes a clone of the primal data if with_primal==true, otherwise the copy will have no primal data)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_coeff","page":"Reference of C++ interface","title":"ConicBundle.cb_coeff","text":"cb_coeff(self::CBMinorantPointer, i::Integer)\n\nreturns coefficient i of the minorant (including the internal scalings) or 0. if empty\n\n\n\n\n\ncb_coeff(self::CBMinorantUseData, i::Integer)\n\nreturn coefficient @a i of the minorant\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_coeff!","page":"Reference of C++ interface","title":"ConicBundle.cb_coeff!","text":"cb_coeff!(self::CBMinorant, i::Integer)\n\nreturns the value of the coefficient in coordinate i\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_col","page":"Reference of C++ interface","title":"ConicBundle.cb_col","text":"cb_col(self::CBMatrix, i::Integer)\n\nreturns column i copied to a new matrix\n\n\n\n\n\ncb_col(self::CBIndexmatrix, i::Integer)\n\nreturns column i copied to a new matrix\n\n\n\n\n\ncb_col(self::CBSparsemat, i::Integer)\n\nreturns column i copied to a new sparse matrix\n\n\n\n\n\ncb_col(self::CBSymmatrix, i::Integer)\n\nreturns column i copied to a new Matrix\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_col_nonzeros","page":"Reference of C++ interface","title":"ConicBundle.cb_col_nonzeros","text":"cb_col_nonzeros(self::CBSparsemat, i::Integer, startind::Union{<:AbstractVector{Cint},Nothing} = nothing)\n\nreturns the number of nonzeros in column i; if nonzeros>0 and startind!=0 then the index of the first nonzero in colindex/colval is stored there\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_coldim","page":"Reference of C++ interface","title":"ConicBundle.cb_coldim","text":"cb_coldim(self::CBMatrix)\n\nreturns the column dimension\n\n\n\n\n\ncb_coldim(self::CBIndexmatrix)\n\nreturns the column dimension\n\n\n\n\n\ncb_coldim(self::CBSparsemat)\n\nreturns the column dimension\n\n\n\n\n\ncb_coldim(self::CBSymmatrix)\n\nreturns the column dimension\n\n\n\n\n\ncb_coldim(self::CBSparsesym)\n\nreturns the column dimension\n\n\n\n\n\ncb_coldim(self::CBSparseCoeffmatMatrix)\n\nreturns the number of columns (i.e. of blockdiagonal matrices)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_colhouse","page":"Reference of C++ interface","title":"ConicBundle.cb_colhouse","text":"cb_colhouse(A::CBMatrix, v::CBMatrix, i::Integer, j::Integer)\n\nHousholder post-multiplication of A with Householder vector v; the first nonzero of v is index i, the multplication is applied to all rows of A with index >=j; always returns 0\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_colip","page":"Reference of C++ interface","title":"ConicBundle.cb_colip","text":"cb_colip(A::CBMatrix, j::Integer, scaling::Union{<:CBMatrix,Nothing})\n\nreturns the squared Frobenius norm of column j of A, i.e., the sum of A(i,j)A(i,j) over all i with possibly (if scaling!=0) each term i multiplied by (scaling)(i)\n\n\n\n\n\ncb_colip(A::CBSparsemat, j::Integer, scaling::Union{<:CBMatrix,Nothing})\n\nreturns the squared Frobenius norm of col i of A, i.e., the sum of A(i,j)A(i,j) over all i with possibly (if scaling!=0) each term i multiplied by (scaling)(i)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_cols","page":"Reference of C++ interface","title":"ConicBundle.cb_cols","text":"cb_cols(self::CBMatrix, vec::CBIndexmatrix)\n\nreturns a matrix of size this->rowdim() x vec.dim(), with column i a copy of column vec(i) of *this\n\n\n\n\n\ncb_cols(self::CBIndexmatrix, vec::CBIndexmatrix)\n\nreturns a matrix of size this->rowdim() x vec.dim(), with column i a copy of column vec(i) of *this\n\n\n\n\n\ncb_cols(self::CBSparsemat, ind::CBIndexmatrix)\n\nreturns a sparse matrix of size this->rowdim() x vec.dim(), with column i a copy of column vec(i) of *this\n\n\n\n\n\ncb_cols(self::CBSymmatrix, vec::CBIndexmatrix)\n\nreturns a matrix of size this->rowdim() x vec.dim(), with column i a copy of column vec(i) of *this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_colsip","page":"Reference of C++ interface","title":"ConicBundle.cb_colsip","text":"cb_colsip(A::CBMatrix)\n\nreturns the column vector of the squared Frobenius norm of all columns j of A, i.e., the sum of A(i,j)*A(i,j) over all i for each j\n\n\n\n\n\ncb_colsip(A::CBSparsemat, scaling::Union{<:CBMatrix,Nothing})\n\nreturns the column vector of the squared Frobenius norm of all columns j of A, i.e., the sum of A(i,j)A(i,j) over all i for each j with possibly (if scaling~=0) each term i multiplied by (scaling)(i)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_compute!","page":"Reference of C++ interface","title":"ConicBundle.cb_compute!","text":"cb_compute!(self::CBMinRes, system::CBIterativeSystemObject, x::CBMatrix, termprec::Real, storex::Union{<:CBMatrix,Nothing} = nothing, storestep::Integer = 0)\n\ncompute the solution for system into x with (absolute) residual precision termprec\n\n\n\n\n\ncb_compute!(self::CBPCG, system::CBIterativeSystemObject, x::CBMatrix, termprec::Real, storex::Union{<:CBMatrix,Nothing} = nothing, storestep::Integer = 0)\n\ncompute the solution for system into x with (absolute) residual precision termprec\n\n\n\n\n\ncb_compute!(self::CBPsqmr, system::CBIterativeSystemObject, x::CBMatrix, termprec::Real, storex::Union{<:CBMatrix,Nothing} = nothing, storestep::Integer = 0)\n\ncompute the solution for system into x with (absolute) residual precision termprec\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_compute_QP_costs!","page":"Reference of C++ interface","title":"ConicBundle.cb_compute_QP_costs!","text":"cb_compute_QP_costs!(self::CBBundleDenseTrustRegionProx, Q::CBSymmatrix, d::CBMatrix, constant_minorant::CBMinorantPointer, bundle::CBMinorantBundle, y::CBMatrix, groundset_minorant::CBMinorantPointer, yfixed::Union{<:CBIndexmatrix,Nothing})\n\ncomputes the dual QP costs Q, d, and the constant offset to the bundle subproblem, see BundleProxObject::computeQPcosts\n\n\n\n\n\ncb_compute_QP_costs!(self::CBBundleDiagonalTrustRegionProx, Q::CBSymmatrix, d::CBMatrix, constant_minorant::CBMinorantPointer, bundle::CBMinorantBundle, y::CBMatrix, groundset_minorant::CBMinorantPointer, yfixed::Union{<:CBIndexmatrix,Nothing})\n\ncomputes the dual QP costs Q, d, and the constant offset to the bundle subproblem, see BundleProxObject::computeQPcosts\n\n\n\n\n\ncb_compute_QP_costs!(self::CBBundleDLRTrustRegionProx, Q::CBSymmatrix, d::CBMatrix, constant_minorant::CBMinorantPointer, bundle::CBMinorantBundle, y::CBMatrix, groundset_minorant::CBMinorantPointer, yfixed::Union{<:CBIndexmatrix,Nothing})\n\ncomputes the dual QP costs Q, d, and the constant offset to the bundle subproblem, see BundleProxObject::computeQPcosts\n\n\n\n\n\ncb_compute_QP_costs!(self::CBBundleIdProx, Q::CBSymmatrix, d::CBMatrix, constant_minorant::CBMinorantPointer, bundle::CBMinorantBundle, y::CBMatrix, groundset_minorant::CBMinorantPointer, yfixed::Union{<:CBIndexmatrix,Nothing})\n\ncomputes the dual QP costs Q, d, and the constant offset to the bundle subproblem, see BundleProxObject::computeQPcosts\n\n\n\n\n\ncb_compute_QP_costs!(self::CBBundleLowRankTrustRegionProx, Q::CBSymmatrix, d::CBMatrix, constant_minorant::CBMinorantPointer, bundle::CBMinorantBundle, y::CBMatrix, groundset_minorant::CBMinorantPointer, yfixed::Union{<:CBIndexmatrix,Nothing})\n\ncomputes the dual QP costs Q, d, and the constant offset to the bundle subproblem, see BundleProxObject::computeQPcosts\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_compute_local_directions!","page":"Reference of C++ interface","title":"ConicBundle.cb_compute_local_directions!","text":"cb_compute_local_directions!(self::CBUQPConeModelBlock, qp_dx::CBMatrix, qp_dy::CBMatrix, rhs_resid::CBMatrix, dz::CBMatrix, duz::CBMatrix)\n\ngiven the steps of the global part, compute the step of the local part\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_compute_step!","page":"Reference of C++ interface","title":"ConicBundle.cb_compute_step!","text":"cb_compute_step!(self::CBQPConeModelBlock, ystep::CBMatrix, global_bundle::CBMinorantBundle, startindex_bundle::Integer)\n\ncompute the step in the model space given the step in the design space\n\n\n\n\n\ncb_compute_step!(self::CBQPSumModelBlock, ystep::CBMatrix, global_bundle::CBMinorantBundle, startindex_bundle::Integer)\n\ncompute the step in the model space given the step in the design space\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_computed_Schur_step!","page":"Reference of C++ interface","title":"ConicBundle.cb_computed_Schur_step!","text":"cb_computed_Schur_step!(self::CBQPConeModelBlock, xstep::CBMatrix, local_step::CBMatrix, startindex_model::Integer, globalbundle::CBMinorantBundle, startindex_bundle::Integer)\n\nuse the computed step information to also compute the steps of the complemented parts\n\n\n\n\n\ncb_computed_Schur_step!(self::CBQPSumModelBlock, xstep::CBMatrix, local_step::CBMatrix, startindex_model::Integer, globalbundle::CBMinorantBundle, startindex_bundle::Integer)\n\nfor passing on the solution information after solvin the system\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_computed_step!","page":"Reference of C++ interface","title":"ConicBundle.cb_computed_step!","text":"cb_computed_step!(self::CBQPConeModelBlock, modelxstep::CBMatrix, startindex_model::Integer, modelconstrstep::CBMatrix, startindex_constr::Integer)\n\nstore this computed step locally and compute the missing local dual step information\n\n\n\n\n\ncb_computed_step!(self::CBQPSumModelBlock, modelxstep::CBMatrix, startindex_model::Integer, modelconstrstep::CBMatrix, startindex_constr::Integer)\n\nstore this computed step locally and compute the missing local dual step information\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_concat_below","page":"Reference of C++ interface","title":"ConicBundle.cb_concat_below","text":"cb_concat_below(A::CBMatrix, B::CBMatrix)\n\nreturns a bew matrix [A; B], i.e., it concats matrices A and B columnwise; A or B may be a 0x0 matrix\n\n\n\n\n\ncb_concat_below(A::CBIndexmatrix, B::CBIndexmatrix)\n\nreturns the matrix [A; B], i.e., it concats matrices A and B columnwise; A or B may be a 0x0 matrix\n\n\n\n\n\ncb_concat_below(A::CBSparsemat, B::CBSparsemat)\n\nreturns a new sparse matrix [A; B], i.e., it concats matrices A and B columnwise; A or B may be a 0x0 matrix\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_concat_below!","page":"Reference of C++ interface","title":"ConicBundle.cb_concat_below!","text":"cb_concat_below!(self::CBMatrix, A::CBMatrix)\n\nconcats matrix A to the bottom of *this, A or *this may be the 0x0 matrix initally, returns *this\n\n\n\n\n\ncb_concat_below!(self::CBMatrix, d::Real)\n\nconcat value d at the right of *this, *this must be a row vector or the 0x0 matrix, returns *this\n\n\n\n\n\ncb_concat_below!(self::CBIndexmatrix, A::CBIndexmatrix)\n\nconcats matrix A to the bottom of *this, A or *this may be the 0x0 matrix initally, returns *this\n\n\n\n\n\ncb_concat_below!(self::CBIndexmatrix, d::Integer)\n\nconcat value d at the bottom of *this, *this must be a column vector or the 0x0 matrix, returns *this\n\n\n\n\n\ncb_concat_below!(self::CBSparsemat, A::CBSparsemat)\n\nconcats sparse matrix A to the bottom of *this, A or *this may be the 0x0 matrix initally, returns *this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_concat_right","page":"Reference of C++ interface","title":"ConicBundle.cb_concat_right","text":"cb_concat_right(A::CBMatrix, B::CBMatrix)\n\nreturns a new matrix [A, B], i.e., it concats matrices A and B rowwise; A or B may be a 0x0 matrix\n\n\n\n\n\ncb_concat_right(A::CBIndexmatrix, B::CBIndexmatrix)\n\nreturns a new matrix [A, B], i.e., it concats matrices A and B rowwise; A or B may be a 0x0 matrix\n\n\n\n\n\ncb_concat_right(A::CBSparsemat, B::CBSparsemat)\n\nreturns a new sparse matrix [A, B], i.e., it concats matrices A and B rowwise; A or B may be a 0x0 matrix\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_concat_right!","page":"Reference of C++ interface","title":"ConicBundle.cb_concat_right!","text":"cb_concat_right!(self::CBMatrix, A::CBMatrix, Atrans::Integer = 0)\n\nconcats matrix A (or its tranpose) to the right of *this, A or *this may be the 0x0 matrix initally, returns *this\n\n\n\n\n\ncb_concat_right!(self::CBMatrix, d::Real)\n\nconcat value d at the bottom of *this, *this must be a column vector or the 0x0 matrix, returns *this\n\n\n\n\n\ncb_concat_right!(self::CBIndexmatrix, A::CBIndexmatrix)\n\nconcats matrix A to the right of *this, A or *this may be the 0x0 matrix initally, returns *this\n\n\n\n\n\ncb_concat_right!(self::CBIndexmatrix, d::Integer)\n\nconcat value d at the right of *this, *this must be a row vector or the 0x0 matrix, returns *this\n\n\n\n\n\ncb_concat_right!(self::CBSparsemat, A::CBSparsemat)\n\nconcats sparse matrix A to the right of *this, A or *this may be the 0x0 matrix initally, returns *this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_cond_number_mult!","page":"Reference of C++ interface","title":"ConicBundle.cb_cond_number_mult!","text":"cb_cond_number_mult!(self::CBQPKKTSubspaceHPrecond, vec::CBMatrix, KKTdiagx::CBMatrix, KKTdiagy::CBMatrix)\n\nfor estimating the condition number directly for the preconditioned part only\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_constrained","page":"Reference of C++ interface","title":"ConicBundle.cb_constrained","text":"cb_constrained(self::CBLPGroundset)\n\nreturns false if the feasible set is the entire space (unconstrained optimization), true otherwise.\n\n\n\n\n\ncb_constrained(self::CBUnconstrainedGroundset)\n\n@brief returns false if the feasible set is the entire space (unconstrained optimization), true otherwise.\n  The current class implements the unconstrained case and always returns false.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_constraints_cost!","page":"Reference of C++ interface","title":"ConicBundle.cb_constraints_cost!","text":"cb_constraints_cost!(self::CBQPConeModelBlock)\n\nreturns the dual upper bound to the model value (the trace weighted sum of the dual trace variables); it returns 0. if no model is contained\n\n\n\n\n\ncb_constraints_cost!(self::CBQPSumModelBlock)\n\nreturns the dual upper bound to the model value (the trace weighted sum of the dual trace variables); it returns 0. if no model is contained\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_contains_nan!","page":"Reference of C++ interface","title":"ConicBundle.cb_contains_nan!","text":"cb_contains_nan!(self::CBMatrix)\n\nreturns true if any matrix element returns true on std::isnan\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_contains_support","page":"Reference of C++ interface","title":"ConicBundle.cb_contains_support","text":"cb_contains_support(self::CBSparsemat, A::CBSparsemat)\n\nreturns 1 if A is of the same dimension and the support of A is contained in the support of *this, 0 otherwise\n\n\n\n\n\ncb_contains_support(self::CBSparsesym, A::CBSparsesym)\n\nreturns 1 if A is of the same dimension and the support of A is contained in the support of *this, 0 otherwise\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_contribute_initial_bundle!","page":"Reference of C++ interface","title":"ConicBundle.cb_contribute_initial_bundle!","text":"cb_contribute_initial_bundle!(self::CBSumBundleHandler, ft::CBFunctionTask, bundle_minorants::CBMinorantBundle, coeff::CBMatrix)\n\n@brief (re)initialize the bundle of the respective part\n This is only possible, if the handler handles a bundle for this.\n If not this causes an error. The main purpose is really\n to start the bundle on the fly if a parent starts a sumbundle\n in the middle of the computation. The information in coeff\n is assumed to yield the current aggregate.\n\n If this bundle part has been contributed berfore (its mode is child), the\n contribution is first removed from the parent. Then any existing\n information except for the function factor is discarded and replaced by\n the new bundle information with the number of contributions set to 1.\n\n If the size of primals is not zero, it must have one nonzero entry per\n column of minorants and all future calls via set_cand_minorant() also have\n to provide exactly one primal for each update.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_contribute_new_minorants!","page":"Reference of C++ interface","title":"ConicBundle.cb_contribute_new_minorants!","text":"cb_contribute_new_minorants!(self::CBSumBundleHandler)\n\nonce all new minorants have been collected at this level, they are passed to the next if required\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_copy_traforows","page":"Reference of C++ interface","title":"ConicBundle.cb_copy_traforows","text":"cb_copy_traforows(self::CBAffineFunctionTransformation, copy_to::CBMatrix, copy_from::CBMatrix)\n\nonly copies the elements that are effected by the image of arg_trafo\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_delete_blocks!","page":"Reference of C++ interface","title":"ConicBundle.cb_delete_blocks!","text":"cb_delete_blocks!(self::CBSparseCoeffmatMatrix, delete_indices::CBIndexmatrix, map_to_old::Union{<:CBIndexmatrix,Nothing} = nothing)\n\ngenerates a maptoold by deleting the specified indices and calls reassignblocks; this mapto_old will be returned if the corresponding pointer is not NULL\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_delete_cols!","page":"Reference of C++ interface","title":"ConicBundle.cb_delete_cols!","text":"cb_delete_cols!(self::CBMatrix, ind::CBIndexmatrix, sorted_increasingly::Bool = false)\n\nall colmuns indexed by vector ind are deleted, no column should appear twice in ind, remaining columns are moved left keeping their order, returns *this\n\n\n\n\n\ncb_delete_cols!(self::CBIndexmatrix, ind::CBIndexmatrix, sorted_increasingly::Bool = false)\n\nall colmuns indexed by vector ind are deleted, no column should appear twice in ind, remaining columns are moved up keeping their order, returns *this\n\n\n\n\n\ncb_delete_cols!(self::CBSparsemat, ind::CBIndexmatrix)\n\nall colmuns indexed by vector ind are deleted, no column should appear twice in ind, remaining columns are moved up keeping their order, returns *this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_delete_columns!","page":"Reference of C++ interface","title":"ConicBundle.cb_delete_columns!","text":"cb_delete_columns!(self::CBSparseCoeffmatMatrix, delete_indices::CBIndexmatrix, map_to_old::Union{<:CBIndexmatrix,Nothing} = nothing)\n\ngenerates a maptoold by deleting the specified indices and calls reassigncolumns; this mapto_old will be returned if the corresponding pointer is not NULL\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_delete_principal_submatrix!","page":"Reference of C++ interface","title":"ConicBundle.cb_delete_principal_submatrix!","text":"cb_delete_principal_submatrix!(self::CBSymmatrix, ind::CBIndexmatrix, sorted_increasingly::Bool = false)\n\nreturns this afte deleting the principal submatrix indexed by ind (no repetitions!);\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_delete_rows!","page":"Reference of C++ interface","title":"ConicBundle.cb_delete_rows!","text":"cb_delete_rows!(self::CBMatrix, ind::CBIndexmatrix, sorted_increasingly::Bool = false)\n\nall rows indexed by vector ind are deleted, no row should appear twice in ind, remaining rows are moved up keeping their order, returns *this\n\n\n\n\n\ncb_delete_rows!(self::CBIndexmatrix, ind::CBIndexmatrix, sorted_increasingly::Bool = false)\n\nall rows indexed by vector ind are deleted, no row should appear twice in ind, remaining rows are moved up keeping their order, returns *this\n\n\n\n\n\ncb_delete_rows!(self::CBSparsemat, ind::CBIndexmatrix)\n\nall rows indexed by vector ind are deleted, no row should appear twice in ind, remaining rows are moved up keeping their order, returns *this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_delete_variables!-Tuple{ConicBundle.CBMatrixCBSolver, ConicBundle.CBIndexmatrix, ConicBundle.CBIndexmatrix}","page":"Reference of C++ interface","title":"ConicBundle.cb_delete_variables!","text":"cb_delete_variables!(self::CBMatrixCBSolver, delete_indices::CBIndexmatrix, map_to_old::CBIndexmatrix)\n\n@brief Deletes variables corresponding to the specified indices.\n  The indices of the remaining variables are reassigned so that they\n  are consecutive again, the routine returns in @a map_to_old\n  a vector giving for each new index of these remaining variables\n  the old coordinate.\n@attention Be sure to include a desription of required changes to your      functions via @a affectedfunctionswith_modifications\n@param[in] deleteindices  (const Indexmatrix&)       the entries deleteindices[i] specify the indices of the variables       to be deleted\n@param[out] maptoold  (Indexmatrix&)       after the call, element maptoold[i] gives the old index (before the call)       of the variable that now has index position i.\n@param[in] affectedfunctionswith_modifications (const FunObjModMap*)       If NULL, default actions are performed on all functions. In       particular, for those admitting dynamic argument changes all those variables will be deleted whose row in a corresponding updated affine function transformation (so after deletion of the columns of the incoming variables) corresponds to the zero map (i.e., offset and matrix row are both zero), furthermore identity transformations will be preserved. For those       not admitting changes in their arguments, their corresponding       (possibly newly created) affine function transformation will       only get the columns deleted, but there will be no row deleltions. If !=NULL, for the listed functions (and their parents up to the root function) the default deletion action is performed unless their       FunctionObjectModification entry gives explicit modification       instructions which are then applied instead. For all functions       NOT listed in the map and not having modified offsprings their       corresponding aft will be set up to keep the arguments unchanged.\n@return       - 0 on success       - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_deleted_block_indices","page":"Reference of C++ interface","title":"ConicBundle.cb_deleted_block_indices","text":"cb_deleted_block_indices(self::CBPSCAffineModification)\n\nreturns null if there were no deletions, otherwise the Indexmatrix pointed to is a vector holding the deleted old row indices in increasing order\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_deleted_row_indices","page":"Reference of C++ interface","title":"ConicBundle.cb_deleted_row_indices","text":"cb_deleted_row_indices(self::CBAFTModification)\n\nreturns null if there were no deletions, otherwise the Indexmatrix pointed to is a vector holding the deleted old row indices in increasing order\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_deleted_var_indices","page":"Reference of C++ interface","title":"ConicBundle.cb_deleted_var_indices","text":"cb_deleted_var_indices(self::CBAFTModification)\n\nreturns null if there were no deletions, otherwise the Indexmatrix pointed to is a vector holding the deleted old variable indices in increasing order\n\n\n\n\n\ncb_deleted_var_indices(self::CBGroundsetModification)\n\nreturns null if there were no deletions, otherwise the Indexmatrix pointed to is a vector holding the deleted old variable indices in increasing order\n\n\n\n\n\ncb_deleted_var_indices(self::CBNNCBoxSupportModification)\n\nreturns null if there were no deletions, otherwise the Indexmatrix pointed to is a vector holding the deleted old variable indices in increasing order\n\n\n\n\n\ncb_deleted_var_indices(self::CBPSCAffineModification)\n\nreturns null if there were no deletions, otherwise the Indexmatrix pointed to is a vector holding the deleted old variable indices in increasing order\n\n\n\n\n\ncb_deleted_var_indices(self::CBSOCSupportModification)\n\nreturns null if there were no deletions, otherwise the Indexmatrix pointed to is a vector holding the deleted old variable indices in increasing order\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_deleted_variables_are_zero","page":"Reference of C++ interface","title":"ConicBundle.cb_deleted_variables_are_zero","text":"cb_deleted_variables_are_zero(self::CBAFTModification, oldpoint::CBMatrix)\n\nreturns true if all entries deleted in @a oldpoint (must be a vector of length old_vardim()) are 0,  false otherwise\n\n\n\n\n\ncb_deleted_variables_are_zero(self::CBGroundsetModification, oldpoint::CBMatrix)\n\nreturns true if all entries deleted in @a oldpoint (must be a vector of length old_vardim()) are 0,  false otherwise\n\n\n\n\n\ncb_deleted_variables_are_zero(self::CBNNCBoxSupportModification, oldpoint::CBMatrix)\n\nreturns true if all entries deleted in @a oldpoint (must be a vector of length old_vardim()) are 0,  false otherwise\n\n\n\n\n\ncb_deleted_variables_are_zero(self::CBPSCAffineModification, oldpoint::CBMatrix, oldmat::CBSparseCoeffmatMatrix)\n\nreturns true if all entries deleted in @a oldpoint (must be a vector of length old_vardim()) or the corresponding entries in the old matrix are 0 and false otherwise\n\n\n\n\n\ncb_deleted_variables_are_zero(self::CBSOCSupportModification, oldpoint::CBMatrix)\n\nreturns true if all entries deleted in @a oldpoint (must be a vector of length old_vardim()) are 0,  false otherwise\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_dense","page":"Reference of C++ interface","title":"ConicBundle.cb_dense","text":"cb_dense(self::CBCMgramdense)\n\nreturns 1 if its structure is as bad as its dense symmetric representation, otherwise 0\n\n\n\n\n\ncb_dense(self::CBCMgramsparse)\n\nreturns 1 if its structure is as bad as its dense symmetric representation, otherwise 0\n\n\n\n\n\ncb_dense(self::CBCMgramsparse_withoutdiag)\n\nreturns 1 if its structure is as bad as its dense symmetric representation, otherwise 0\n\n\n\n\n\ncb_dense(self::CBCMlowrankdd)\n\nreturns 1 if its structure is as bad as its dense symmetric representation, otherwise 0\n\n\n\n\n\ncb_dense(self::CBCMlowranksd)\n\nreturns 1 if its structure is as bad as its dense symmetric representation, otherwise 0\n\n\n\n\n\ncb_dense(self::CBCMlowrankss)\n\nreturns 1 if its structure is as bad as its dense symmetric representation, otherwise 0\n\n\n\n\n\ncb_dense(self::CBCMsingleton)\n\nreturns 1 if its structure is as bad as its dense symmetric representation, otherwise 0\n\n\n\n\n\ncb_dense(self::CBCMsymdense)\n\nreturns 1 if its structure is as bad as its dense symmetric representation, otherwise 0\n\n\n\n\n\ncb_dense(self::CBCMsymsparse)\n\nreturns 1 if its structure is as bad as its dense symmetric representation, otherwise 0\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_descent_update!","page":"Reference of C++ interface","title":"ConicBundle.cb_descent_update!","text":"cb_descent_update!(self::CBBundleHKWeight, newval::Real, oldval::Real, modelval::Real, y::CBMatrix, newy::CBMatrix, normsubg2::Real, Hp::Union{<:CBBundleProxObject,Nothing})\n\ndetermine next weight after a descent step\n\n\n\n\n\ncb_descent_update!(self::CBBundleRQBWeight, newval::Real, oldval::Real, modelval::Real, y::CBMatrix, newy::CBMatrix, normsubg2::Real, Hp::Union{<:CBBundleProxObject,Nothing})\n\ndetermine next weight after a descent step\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_destroy!","page":"Reference of C++ interface","title":"ConicBundle.cb_destroy!","text":"cb_destroy!(obj::CBMatrix)\n\n\n\n\n\ncb_destroy!(obj::CBIndexmatrix)\n\n\n\n\n\ncb_destroy!(obj::CBSparsemat)\n\n\n\n\n\ncb_destroy!(obj::CBSymmatrix)\n\n\n\n\n\ncb_destroy!(obj::CBSparsesym)\n\n\n\n\n\ncb_destroy!(obj::CBCMgramdense)\n\n\n\n\n\ncb_destroy!(obj::CBCMgramsparse)\n\n\n\n\n\ncb_destroy!(obj::CBCMgramsparse_withoutdiag)\n\n\n\n\n\ncb_destroy!(obj::CBCMlowrankdd)\n\n\n\n\n\ncb_destroy!(obj::CBCMlowranksd)\n\n\n\n\n\ncb_destroy!(obj::CBCMlowrankss)\n\n\n\n\n\ncb_destroy!(obj::CBCMsingleton)\n\n\n\n\n\ncb_destroy!(obj::CBCMsymdense)\n\n\n\n\n\ncb_destroy!(obj::CBCMsymsparse)\n\n\n\n\n\ncb_destroy!(obj::CBSparseCoeffmatMatrix)\n\n\n\n\n\ncb_destroy!(obj::CBGB_rand)\n\n\n\n\n\ncb_destroy!(obj::CBCoeffmatInfo)\n\n\n\n\n\ncb_destroy!(obj::CBPrimalMatrix)\n\n\n\n\n\ncb_destroy!(obj::CBMatrixCBSolver)\n\n\n\n\n\ncb_destroy!(obj::CBBlockPSCPrimal)\n\n\n\n\n\ncb_destroy!(obj::CBDensePSCPrimal)\n\n\n\n\n\ncb_destroy!(obj::CBGramSparsePSCPrimal)\n\n\n\n\n\ncb_destroy!(obj::CBSparsePSCPrimal)\n\n\n\n\n\ncb_destroy!(obj::CBAFTModification)\n\n\n\n\n\ncb_destroy!(obj::CBGroundsetModification)\n\n\n\n\n\ncb_destroy!(obj::CBNNCBoxSupportModification)\n\n\n\n\n\ncb_destroy!(obj::CBPSCAffineModification)\n\n\n\n\n\ncb_destroy!(obj::CBSOCSupportModification)\n\n\n\n\n\ncb_destroy!(obj::CBAffineFunctionTransformation)\n\n\n\n\n\ncb_destroy!(obj::CBMinorantPointer)\n\n\n\n\n\ncb_destroy!(obj::CBMinorantUseData)\n\n\n\n\n\ncb_destroy!(obj::CBMinorant)\n\n\n\n\n\ncb_destroy!(obj::CBBoxPrimalExtender)\n\n\n\n\n\ncb_destroy!(obj::CBBoxOracle)\n\n\n\n\n\ncb_destroy!(obj::CBPSCPrimalExtender)\n\n\n\n\n\ncb_destroy!(obj::CBPSCBundleParameters)\n\n\n\n\n\ncb_destroy!(obj::CBSOCPrimalExtender)\n\n\n\n\n\ncb_destroy!(obj::CBSOCBundleParameters)\n\n\n\n\n\ncb_destroy!(obj::CBCFunctionMinorantExtender)\n\n\n\n\n\ncb_destroy!(obj::CBCFunction)\n\n\n\n\n\ncb_destroy!(obj::CBNNCBoxSupportMinorantExtender)\n\n\n\n\n\ncb_destroy!(obj::CBNNCBoxSupportFunction)\n\n\n\n\n\ncb_destroy!(obj::CBPSCAffineMinorantExtender)\n\n\n\n\n\ncb_destroy!(obj::CBPSCAffineFunction)\n\n\n\n\n\ncb_destroy!(obj::CBSOCSupportMinorantExtender)\n\n\n\n\n\ncb_destroy!(obj::CBSOCSupportFunction)\n\n\n\n\n\ncb_destroy!(obj::CBBoxModelParameters)\n\n\n\n\n\ncb_destroy!(obj::CBNNCModelParameters)\n\n\n\n\n\ncb_destroy!(obj::CBPSCModelParameters)\n\n\n\n\n\ncb_destroy!(obj::CBSOCModelParameters)\n\n\n\n\n\ncb_destroy!(obj::CBSumBundleParameters)\n\n\n\n\n\ncb_destroy!(obj::CBAFTData)\n\n\n\n\n\ncb_destroy!(obj::CBBoxData)\n\n\n\n\n\ncb_destroy!(obj::CBNNCData)\n\n\n\n\n\ncb_destroy!(obj::CBPSCData)\n\n\n\n\n\ncb_destroy!(obj::CBSOCData)\n\n\n\n\n\ncb_destroy!(obj::CBBundleHKWeight)\n\n\n\n\n\ncb_destroy!(obj::CBBundleRQBWeight)\n\n\n\n\n\ncb_destroy!(obj::CBBundleDenseTrustRegionProx)\n\n\n\n\n\ncb_destroy!(obj::CBBundleDiagonalTrustRegionProx)\n\n\n\n\n\ncb_destroy!(obj::CBBundleDLRTrustRegionProx)\n\n\n\n\n\ncb_destroy!(obj::CBBundleIdProx)\n\n\n\n\n\ncb_destroy!(obj::CBBundleLowRankTrustRegionProx)\n\n\n\n\n\ncb_destroy!(obj::CBQPSolverParameters)\n\n\n\n\n\ncb_destroy!(obj::CBQPSolver)\n\n\n\n\n\ncb_destroy!(obj::CBUQPSolver)\n\n\n\n\n\ncb_destroy!(obj::CBLPGroundset)\n\n\n\n\n\ncb_destroy!(obj::CBUnconstrainedGroundset)\n\n\n\n\n\ncb_destroy!(obj::CBAFTModel)\n\n\n\n\n\ncb_destroy!(obj::CBBoxModel)\n\n\n\n\n\ncb_destroy!(obj::CBNNCModel)\n\n\n\n\n\ncb_destroy!(obj::CBPSCModel)\n\n\n\n\n\ncb_destroy!(obj::CBSOCModel)\n\n\n\n\n\ncb_destroy!(obj::CBSumModel)\n\n\n\n\n\ncb_destroy!(obj::CBPSCVariableMetricSelection)\n\n\n\n\n\ncb_destroy!(obj::CBVariableMetricSVDSelection)\n\n\n\n\n\ncb_destroy!(obj::CBQPDirectKKTSolver)\n\n\n\n\n\ncb_destroy!(obj::CBQPIterativeKKTHAeqSolver)\n\n\n\n\n\ncb_destroy!(obj::CBQPIterativeKKTHASolver)\n\n\n\n\n\ncb_destroy!(obj::CBQPKKTSolverComparison)\n\n\n\n\n\ncb_destroy!(obj::CBSumBundleHandler)\n\n\n\n\n\ncb_destroy!(obj::CBQPConeModelBlock)\n\n\n\n\n\ncb_destroy!(obj::CBQPSumModelBlock)\n\n\n\n\n\ncb_destroy!(obj::CBUQPConeModelBlock)\n\n\n\n\n\ncb_destroy!(obj::CBUQPSumModelBlock)\n\n\n\n\n\ncb_destroy!(obj::CBMinRes)\n\n\n\n\n\ncb_destroy!(obj::CBPCG)\n\n\n\n\n\ncb_destroy!(obj::CBPsqmr)\n\n\n\n\n\ncb_destroy!(obj::CBQPKKTSubspaceHPrecond)\n\n\n\n\n\ncb_destroy!(obj::CBSumBundle)\n\n\n\n\n\ncb_destroy!(obj::CBBundleSolver)\n\n\n\n\n\ncb_destroy!(obj::CBBundleTerminator)\n\n\n\n\n\ncb_destroy!(obj::CBClock)\n\n\n\n\n\ncb_destroy!(obj::CBMicroseconds)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_diag","page":"Reference of C++ interface","title":"ConicBundle.cb_diag","text":"cb_diag(A::CBMatrix)\n\nreturns a column vector v consisting of the elements v(i)=(*this)(i,i), 0<=i<min(row dimension,column dimension)\n\n\n\n\n\ncb_diag(A::CBIndexmatrix)\n\nreturns a column vector v consisting of the elements v(i)=A(i,i), 0<=i<min(row dimension,column dimension)\n\n\n\n\n\ncb_diag(A::CBSymmatrix)\n\nreturns a column vector v consisting of the elements v(i)=(*this)(i,i), 0<=i<row dimension\n\n\n\n\n\ncb_diag(A::CBSparsesym)\n\nreturns the diagonal of A as a dense Matrix vector\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_diagonal_bounds_scaling_update!","page":"Reference of C++ interface","title":"ConicBundle.cb_diagonal_bounds_scaling_update!","text":"cb_diagonal_bounds_scaling_update!(self::CBBundleDenseTrustRegionProx, param0::CBMatrix)\n\n@brief if supported, Dupdate has to contain nonnegative numbers that       are permanently added to the diagonal here. It is important to keep       track of this change only if afterwards updateQPcosts is called before       computeQPcosts. In this case the only nonzero enries in Dupdate must       be those of delta_index\n\n\n\n\n\ncb_diagonal_bounds_scaling_update!(self::CBBundleDiagonalTrustRegionProx, D_update::CBMatrix)\n\n@brief if supported, Dupdate has to contain nonnegative numbers that       are permanently added to the diagonal here. It is important to keep       track of this change only if afterwards updateQPcosts is called before       computeQPcosts. In this case the only nonzero enries in Dupdate must       be those of delta_index\n\n\n\n\n\ncb_diagonal_bounds_scaling_update!(self::CBBundleDLRTrustRegionProx, param0::CBMatrix)\n\n@brief if supported, Dupdate has to contain nonnegative numbers that       are permanently added to the diagonal here. It is important to keep       track of this change only if afterwards updateQPcosts is called before       computeQPcosts. In this case the only nonzero enries in Dupdate must       be those of delta_index\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_diagonal_scaling_heuristic_update!","page":"Reference of C++ interface","title":"ConicBundle.cb_diagonal_scaling_heuristic_update!","text":"cb_diagonal_scaling_heuristic_update!(self::CBBundleLowRankTrustRegionProx, param0::CBMatrix)\n\n@brief if supported, Dupdate has to contain nonnegative numbers that       are permanently added to the diagonal here. It is important to keep       track of this change only if afterwards updateQPcosts is called before       computeQPcosts. In this case the only nonzero enries in Dupdate must       be those of delta_index\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_dim","page":"Reference of C++ interface","title":"ConicBundle.cb_dim","text":"cb_dim(self::CBMatrix)\n\nreturns the dimension rows * columns when the matrix is regarded as a vector\n\n\n\n\n\ncb_dim(self::CBIndexmatrix)\n\nreturns the dimension rows * columns when the matrix is regarded as a vector\n\n\n\n\n\ncb_dim(self::CBSparsemat)\n\nreturns the dimension rows * columns when the matrix is regarded as a vector\n\n\n\n\n\ncb_dim(self::CBSymmatrix)\n\nreturns the dimension rows * columns when the matrix is regarded as a vector\n\n\n\n\n\ncb_dim(self::CBSparsesym)\n\nreturns the dimension rows * columns when the matrix is regarded as a vector\n\n\n\n\n\ncb_dim(self::CBCMgramdense)\n\nreturns the order of the represented symmetric matrix\n\n\n\n\n\ncb_dim(self::CBCMgramsparse)\n\nreturns the order of the represented symmetric matrix\n\n\n\n\n\ncb_dim(self::CBCMgramsparse_withoutdiag)\n\nreturns the order of the represented symmetric matrix\n\n\n\n\n\ncb_dim(self::CBCMlowrankdd)\n\nreturns the order of the represented symmetric matrix\n\n\n\n\n\ncb_dim(self::CBCMlowranksd)\n\nreturns the order of the represented symmetric matrix\n\n\n\n\n\ncb_dim(self::CBCMlowrankss)\n\nreturns the order of the represented symmetric matrix\n\n\n\n\n\ncb_dim(self::CBCMsingleton)\n\nreturns the order of the represented symmetric matrix\n\n\n\n\n\ncb_dim(self::CBCMsymdense)\n\nreturns the order of the represented symmetric matrix\n\n\n\n\n\ncb_dim(self::CBCMsymsparse)\n\nreturns the order of the represented symmetric matrix\n\n\n\n\n\ncb_dim(self::CBBundleDenseTrustRegionProx)\n\nreturns the order of the matrix\n\n\n\n\n\ncb_dim(self::CBBundleDiagonalTrustRegionProx)\n\nreturns the dimension of the diagonal\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_dim2","page":"Reference of C++ interface","title":"ConicBundle.cb_dim2","text":"cb_dim2(self::CBMatrix)\n\nreturns the number of rows in _nr and the number of columns in _nc\n\n\n\n\n\ncb_dim2(self::CBIndexmatrix)\n\nreturns the number of rows in _nr and the number of columns in _nc\n\n\n\n\n\ncb_dim2(self::CBSparsemat)\n\nreturns the number of rows in _nr and the number of columns in _nc\n\n\n\n\n\ncb_dim2(self::CBSymmatrix)\n\nreturns the number of rows in _nr and _nc\n\n\n\n\n\ncb_dim2(self::CBSparsesym)\n\nreturns the number of rows in _nr and the number of columns in _nc\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_dim_constraints!","page":"Reference of C++ interface","title":"ConicBundle.cb_dim_constraints!","text":"cb_dim_constraints!(self::CBQPConeModelBlock)\n\nreturns the dimension of the system describing the model set (may contain further constraints)\n\n\n\n\n\ncb_dim_constraints!(self::CBQPSumModelBlock)\n\nreturns the dimension of the system describing the model set (may contain further constraints)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_dim_model!","page":"Reference of C++ interface","title":"ConicBundle.cb_dim_model!","text":"cb_dim_model!(self::CBQPConeModelBlock)\n\nreturns the dimension of the model set (here the same as the bundle size)\n\n\n\n\n\ncb_dim_model!(self::CBQPSumModelBlock)\n\nreturns the dimension of the model set (here the same as the bundle size)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_display","page":"Reference of C++ interface","title":"ConicBundle.cb_display","text":"cb_display(self::CBMatrix, precision::Integer = 0, width::Integer = 0, screenwidth::Integer = 0)\n\n@brief displays a matrix in a pretty way for bounded screen widths; for variables of value zero default values are used.\n\n\n\n\n\ncb_display(self::CBIndexmatrix, precision::Integer = 0, width::Integer = 0, screenwidth::Integer = 0)\n\n@brief displays a matrix in a pretty way for bounded screen widths; for variables of value zero default values are used.\n\n\n\n\n\ncb_display(self::CBSparsemat, precision::Integer = 0, width::Integer = 0, screenwidth::Integer = 0)\n\n@brief displays a matrix in a pretty way for bounded screen widths; for variables of value zero default values are used.\n\n\n\n\n\ncb_display(self::CBSymmatrix, precision::Integer = 0, width::Integer = 0, screenwidth::Integer = 0)\n\n@brief displays a matrix in a pretty way for bounded screen widths; for variables of value zero default values are used.\n\n\n\n\n\ncb_display(self::CBSparsesym, precision::Integer = 0, width::Integer = 0, screenwidth::Integer = 0)\n\n@brief displays a matrix in a pretty way for bounded screen widths; for variables of value zero default values are used.\n\n\n\n\n\ncb_display(self::CBCMgramdense)\n\ndisplay constraint information\n\n\n\n\n\ncb_display(self::CBCMgramsparse)\n\ndisplay constraint information\n\n\n\n\n\ncb_display(self::CBCMgramsparse_withoutdiag)\n\ndisplay constraint information\n\n\n\n\n\ncb_display(self::CBCMlowrankdd)\n\ndisplay constraint information\n\n\n\n\n\ncb_display(self::CBCMlowranksd)\n\ndisplay constraint information\n\n\n\n\n\ncb_display(self::CBCMlowrankss)\n\ndisplay constraint information\n\n\n\n\n\ncb_display(self::CBCMsingleton)\n\ndisplay constraint information\n\n\n\n\n\ncb_display(self::CBCMsymdense)\n\ndisplay constraint information\n\n\n\n\n\ncb_display(self::CBCMsymsparse)\n\ndisplay constraint information\n\n\n\n\n\ncb_display(self::CBMinorantPointer, precision::Integer = 8)\n\noutput the Minorant in a nice format\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_display_model_values!","page":"Reference of C++ interface","title":"ConicBundle.cb_display_model_values!","text":"cb_display_model_values!(self::CBQPSumModelBlock, y::CBMatrix, global_bundle::CBMinorantBundle, startindex_bundle::Integer)\n\noutput for debbuging purposes\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_dnorm_sqr","page":"Reference of C++ interface","title":"ConicBundle.cb_dnorm_sqr","text":"cb_dnorm_sqr(self::CBBundleDenseTrustRegionProx, B::CBMinorantPointer)\n\nreturns B^2_H^-1 (with weightu included in H)\n\n\n\n\n\ncb_dnorm_sqr(self::CBBundleDiagonalTrustRegionProx, B::CBMinorantPointer)\n\nreturns \\fB^2_H^-1f\n\n\n\n\n\ncb_dnorm_sqr(self::CBBundleDLRTrustRegionProx, B::CBMinorantPointer)\n\nreturns B^2_H^-1 (with weight included)\n\n\n\n\n\ncb_dnorm_sqr(self::CBBundleIdProx, B::CBMinorantPointer)\n\nreturns \\fB^2_H^-1f\n\n\n\n\n\ncb_dnorm_sqr(self::CBBundleLowRankTrustRegionProx, B::CBMinorantPointer)\n\nreturns B^2_H^-1 (with weight included)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_do_step!","page":"Reference of C++ interface","title":"ConicBundle.cb_do_step!","text":"cb_do_step!(self::CBAFTData, point_id::Integer)\n\nif the candidate information is available and consitent for point_id, copy it from cand to center and return 0, otherwise return 1\n\n\n\n\n\ncb_do_step!(self::CBBoxData, point_id::Integer)\n\nif the candidate information is available and consitent for point_id, copy it from cand to center and return 0, otherwise return 1\n\n\n\n\n\ncb_do_step!(self::CBNNCData, point_id::Integer)\n\nif the candidate information is available and consitent for point_id, copy it from cand to center and return 0, otherwise return 1\n\n\n\n\n\ncb_do_step!(self::CBPSCData, point_id::Integer)\n\nif the candidate information is available and consitent for point_id, copy it from cand to center and return 0, otherwise return 1\n\n\n\n\n\ncb_do_step!(self::CBSOCData, point_id::Integer)\n\nif the candidate information is available and consitent for point_id, copy it from cand to center and return 0, otherwise return 1\n\n\n\n\n\ncb_do_step!(self::CBQPConeModelBlock, alpha::Real, y::CBMatrix, global_bundle::CBMinorantBundle, startindex_bundle::Integer)\n\nmove in the last computed step direction by a step of length alpha and compute and store the violation in this point for later use in\n\n\n\n\n\ncb_do_step!(self::CBQPSumModelBlock, alpha::Real, y::CBMatrix, global_bundle::CBMinorantBundle, startindex_bundle::Integer)\n\nmove in the last computed step direction by a step of length alpha and compute and store the violation in this point for later use in\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_dual_norm_squared","page":"Reference of C++ interface","title":"ConicBundle.cb_dual_norm_squared","text":"cb_dual_norm_squared(self::CBMinorantPointer, D::Union{<:CBMatrix,Nothing} = nothing)\n\nCompute the dual norm squared of this for the given diagonal matrix D (identity if not given), i.e. \\f(*this)^2_D^-1f\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_dualviol_2normsqr!","page":"Reference of C++ interface","title":"ConicBundle.cb_dualviol_2normsqr!","text":"cb_dualviol_2normsqr!(self::CBQPConeModelBlock)\n\nreturn the squared Euclidean norm of the model violation\n\n\n\n\n\ncb_dualviol_2normsqr!(self::CBQPSumModelBlock)\n\nreturn the squared Euclidean norm of the dual model violation\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_eig","page":"Reference of C++ interface","title":"ConicBundle.cb_eig","text":"cb_eig(self::CBSymmatrix, P::CBMatrix, d::CBMatrix, sort_non_decreasingly::Bool = true)\n\ncomputes an eigenvalue decomposition PDiag(d)tranpose(P)=(*this) by symmetric QR; returns 0 on success,\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_elapsed_time","page":"Reference of C++ interface","title":"ConicBundle.cb_elapsed_time","text":"cb_elapsed_time(self::CBClock)\n\ncall time() and print the result in format \"hh:mm:ss\", togehter with current date and time, to out\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_empty","page":"Reference of C++ interface","title":"ConicBundle.cb_empty","text":"cb_empty(self::CBMinorantPointer)\n\nreturns true if the pointer is empty\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_enlarge_below!","page":"Reference of C++ interface","title":"ConicBundle.cb_enlarge_below!","text":"cb_enlarge_below!(self::CBMatrix, addnr::Integer)\n\nenlarge the matrix by addnr>=0 rows without intializaton of the new rows, returns *this (marked as not initialized if addnr>0)\n\n\n\n\n\ncb_enlarge_below!(self::CBMatrix, addnr::Integer, d::Real)\n\nenlarge the matrix by addnr>=0 rows intializing the new rows by value d, returns *this\n\n\n\n\n\ncb_enlarge_below!(self::CBMatrix, addnr::Integer, dp::Union{<:AbstractVector{Cdouble},Nothing}, d::Real = 1.)\n\nenlarge the matrix by addnr>=0 rows intializing the new rows by the values pointed to by dp times d, returns *this\n\n\n\n\n\ncb_enlarge_below!(self::CBIndexmatrix, addnr::Integer)\n\nenlarge the matrix by addnr>=0 rows without intializaton of the new rows, returns *this (marked as not initialized if nc>0)\n\n\n\n\n\ncb_enlarge_below!(self::CBIndexmatrix, addnr::Integer, d::Integer)\n\nenlarge the matrix by addnr>=0 rows intializing the new rows by value d, returns *this\n\n\n\n\n\ncb_enlarge_below!(self::CBIndexmatrix, addnr::Integer, dp::Union{<:AbstractVector{Cint},Nothing}, d::Integer = 1)\n\nenlarge the matrix by addnr>=0 rows intializing the new rows by the values pointed to by dp times d, returns *this\n\n\n\n\n\ncb_enlarge_below!(self::CBSymmatrix, addn::Integer)\n\nincreases the order of the matrix by appending storage for further addn rows and columns (marked as not initiliazed if addn>0, no changes if addn<=0)\n\n\n\n\n\ncb_enlarge_below!(self::CBSymmatrix, addn::Integer, d::Real)\n\nincreases the order of the matrix by appending storage for further addn rows and columns initialized to d (no changes if addn<=0);\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_enlarge_right!","page":"Reference of C++ interface","title":"ConicBundle.cb_enlarge_right!","text":"cb_enlarge_right!(self::CBMatrix, addnc::Integer)\n\nenlarge the matrix by addnc>=0 columns without intializaton of the new columns, returns *this (marked as not initialized if nr>0)\n\n\n\n\n\ncb_enlarge_right!(self::CBMatrix, addnc::Integer, d::Real)\n\nenlarge the matrix by addnc>=0 columns intializing the new columns by value d, returns *this\n\n\n\n\n\ncb_enlarge_right!(self::CBMatrix, addnc::Integer, dp::Union{<:AbstractVector{Cdouble},Nothing}, d::Real = 1.)\n\nenlarge the matrix by addnc>=0 columns intializing the new columns by the values pointed to by dp times d, returns *this\n\n\n\n\n\ncb_enlarge_right!(self::CBIndexmatrix, addnc::Integer)\n\nenlarge the matrix by addnc>=0 columns without intializaton of the new columns, returns *this (marked as not initialized if nr>0)\n\n\n\n\n\ncb_enlarge_right!(self::CBIndexmatrix, addnc::Integer, d::Integer)\n\nenlarge the matrix by addnc>=0 columns intializing the new columns by value d, returns *this\n\n\n\n\n\ncb_enlarge_right!(self::CBIndexmatrix, addnc::Integer, dp::Union{<:AbstractVector{Cint},Nothing}, d::Integer = 1)\n\nenlarge the matrix by addnc>=0 columns intializing the new columns by the values pointed to by dp times d, returns *this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_ensure_feasibility!","page":"Reference of C++ interface","title":"ConicBundle.cb_ensure_feasibility!","text":"cb_ensure_feasibility!(self::CBLPGroundset, y::CBMatrix, ychanged::Bool, Hp::Union{<:CBBundleProxObject,Nothing}, relprec::Real = 1e-10)\n\nmakes y feasible if not so, see Groundset::ensure_feasibility()\n\n\n\n\n\ncb_ensure_feasibility!(self::CBUnconstrainedGroundset, y::CBMatrix, ychanged::Bool, Hp::Union{<:CBBundleProxObject,Nothing} = nothing, relprec::Real = 1e-10)\n\n@brief if the groundset_id changed, it checks feasibility of y with respect to the given precision. If infeasible it replaces y by its projection with respect to the norm of Hp and sets ychanged to true.\nThe routine is called by the internal bundle solver to check    whether the given center is still valid (in some applications the    groundset might change during the runtime of the bundle method),    where, if @a ychanged is false on input, validity of @a y was    already checked at a point in time when the groundset had    the @a ingroundsetid. If @a ychanged==false and the groundsetid is    still the same, then @a y is simply assumed to be still correct    (the precision is not even looked at in this case).  Otherwise    the routine checks the validitiy of @a y with respect to the given    precision. If feasible, it returns the new    groundsetid in @a ingroundsetid and keeps @a ychanged unaltered.    If @a y is infeasible, the rountine computes its projection    onto the feasible set with respect to the norm of @a Hp (if ==0 then    the Euclidean norm is used), stores it in @a y, sets @a ychanged to    true, sets @a ingroundsetid to the current groundset_id and returns\nShould anything go wrong, it returns 1.\nThis concrete base class represents the unconstrained case, so    feasiblity only checks the dimension and never requires projections.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_equal","page":"Reference of C++ interface","title":"ConicBundle.cb_equal","text":"cb_equal(A::CBMatrix, B::CBMatrix)\n\nreturns true if both matrices have the same size and the same elements\n\n\n\n\n\ncb_equal(A::CBIndexmatrix, b::CBIndexmatrix)\n\nreturns true if both matrices have the same size and the same elements\n\n\n\n\n\ncb_equal(A::CBSparsemat, B::CBSparsemat, eqtol::Real)\n\nreturns 1 if both matrices are identical, 0 otherwise\n\n\n\n\n\ncb_equal(A::CBSparsesym, B::CBSparsesym, eqtol::Real)\n\nreturns 1 if both matrices are identical, 0 otherwise\n\n\n\n\n\ncb_equal(self::CBCMgramdense, p::Union{<:CBCoeffmat,Nothing}, tol::Real = 1e-6)\n\nreturns 1, if p is the same derived class and entries differ by less than tol, otherwise zero\n\n\n\n\n\ncb_equal(self::CBCMgramsparse, p::Union{<:CBCoeffmat,Nothing}, tol::Real = 1e-6)\n\nreturns 1, if p is the same derived class and entries differ by less than tol, otherwise zero\n\n\n\n\n\ncb_equal(self::CBCMgramsparse_withoutdiag, p::Union{<:CBCoeffmat,Nothing}, tol::Real = 1e-6)\n\nreturns 1, if p is the same derived class and entries differ by less than tol, otherwise zero\n\n\n\n\n\ncb_equal(self::CBCMlowrankdd, p::Union{<:CBCoeffmat,Nothing}, tol::Real = 1e-6)\n\nreturns 1, if p is the same derived class and entries differ by less than tol, otherwise zero\n\n\n\n\n\ncb_equal(self::CBCMlowranksd, p::Union{<:CBCoeffmat,Nothing}, tol::Real = 1e-6)\n\nreturns 1, if p is the same derived class and entries differ by less than tol, otherwise zero\n\n\n\n\n\ncb_equal(self::CBCMlowrankss, p::Union{<:CBCoeffmat,Nothing}, tol::Real = 1e-6)\n\nreturns 1, if p is the same derived class and entries differ by less than tol, otherwise zero\n\n\n\n\n\ncb_equal(self::CBCMsingleton, p::Union{<:CBCoeffmat,Nothing}, tol::Real = 1e-6)\n\nreturns 1, if p is the same derived class and entries differ by less than tol, otherwise zero\n\n\n\n\n\ncb_equal(self::CBCMsymdense, p::Union{<:CBCoeffmat,Nothing}, tol::Real = 1e-6)\n\nreturns 1, if p is the same derived class and entries differ by less than tol, otherwise zero\n\n\n\n\n\ncb_equal(self::CBCMsymsparse, p::Union{<:CBCoeffmat,Nothing}, tol::Real = 1e-6)\n\nreturns 1, if p is the same derived class and entries differ by less than tol, otherwise zero\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_equals","page":"Reference of C++ interface","title":"ConicBundle.cb_equals","text":"cb_equals(self::CBMinorantPointer, mp::CBMinorantPointer, tol::Real = 1e-10)\n\nthey are equal if they point to the same object or are both 0. If not, they differ if their matrix representations differ; if not, they differ if the entries differ by at least tol*(1.+fabs(this->offset())\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_eval_function!","page":"Reference of C++ interface","title":"ConicBundle.cb_eval_function!","text":"cb_eval_function!(self::CBAFTModel, y_id::Integer, y::CBMatrix, nullstep_bound::Real, relprec::Real)\n\nsee BundleModel::eval_function\n\n\n\n\n\ncb_eval_function!(self::CBSumModel, y_id::Integer, y::CBMatrix, nullstep_bound::Real, relprec::Real)\n\nsee BundleModel::eval_function\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_eval_model","page":"Reference of C++ interface","title":"ConicBundle.cb_eval_model","text":"cb_eval_model(self::CBSumBundleHandler, yid::Integer, y::CBMatrix)\n\nevaluate the model value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_eval_model!","page":"Reference of C++ interface","title":"ConicBundle.cb_eval_model!","text":"cb_eval_model!(self::CBAFTModel, y_id::Integer, y::CBMatrix, relprec::Real)\n\nsee BundleModel::eval_model\n\n\n\n\n\ncb_eval_model!(self::CBSumModel, y_id::Integer, y::CBMatrix, relprec::Real)\n\nsee BundleModel::eval_model\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_evaluate","page":"Reference of C++ interface","title":"ConicBundle.cb_evaluate","text":"cb_evaluate(self::CBMinorantPointer, yid::Integer, y::CBMatrix, with_constant::Bool = true)\n\nnegative ids are allowed and indicate there is no need to memorize this result, returns CBminusinfinity if empty, otherwise offset+ip(minorant,y)\n\n\n\n\n\ncb_evaluate(self::CBMinorantUseData, yid::Integer, y::CBMatrix, with_constant::Bool = true)\n\nevaluate the minorant for @a y unluess @a yid allows to retrieve a previous evaluation\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_evaluate_projection!","page":"Reference of C++ interface","title":"ConicBundle.cb_evaluate_projection!","text":"cb_evaluate_projection!(self::CBPSCAffineFunction, current_point::CBMatrix, P::CBMatrix, relprec::Real, projected_Ritz_vectors::CBMatrix, projected_Ritz_values::CBMatrix)\n\nsee PSCOracle::evaluate_projection()\n\n\n\n\n\ncb_evaluate_projection!(self::CBSOCSupportFunction, current_point::CBMatrix, P::CBMatrix, relprec::Real)\n\nsee SOCOracle::evaluate()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_evaluate_trace","page":"Reference of C++ interface","title":"ConicBundle.cb_evaluate_trace","text":"cb_evaluate_trace(self::CBQPConeModelBlock)\n\nevaluate the left hand side of the trace constraint for modelx\n\n\n\n\n\ncb_evaluate_trace(self::CBUQPConeModelBlock)\n\nevaluate the left hand side of the trace constraint for modelx\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_extend!","page":"Reference of C++ interface","title":"ConicBundle.cb_extend!","text":"cb_extend!(self::CBBoxPrimalExtender, param0::CBPrimalData)\n\nlike in PrimalExtender, called by ConicBundle to update internal PrimalData objects, has to return 0 on success\n\n\n\n\n\ncb_extend!(self::CBPSCPrimalExtender, param0::CBPrimalData)\n\nlike in PrimalExtender, called by ConicBundle to update internal PrimalData objects, has to return 0 on success\n\n\n\n\n\ncb_extend!(self::CBSOCPrimalExtender, param0::CBPrimalData)\n\nlike in PrimalExtender, called by ConicBundle to update internal PrimalData objects, has to return 0 on success\n\n\n\n\n\ncb_extend!(self::CBCFunctionMinorantExtender, minorant::CBMinorant, n_coords::Integer, indices::Union{<:AbstractVector{Integer},Nothing})\n\nsee MinorantExtender::extend() for explanations\n\n\n\n\n\ncb_extend!(self::CBNNCBoxSupportMinorantExtender, minorant::CBMinorant, n_coords::Integer, indices::Union{<:AbstractVector{Integer},Nothing})\n\n@brief called by ConicBundle to update internal Minorant objects, has to return 0 on success\n\n    for each relevant index i the minorant value is set to the projection\n\nof 0 onto the interval [lowerbound(i),upperbound(i)]\n\n    @param[in,out] minorant  (Minorant&)\n        it holds a (possibly aggregated) minorant that was generated\n        from minorants returned by oracle calls, e.g. as in\n  FunctionOracle::evaluate()\n\n    @param[in] n_coords (int)\n        the number of coordinate positions that have to be filled in\n\n    @param[out] new_subgradient_values  (DVector &)\n  the indices of these coordinate positions (sorted in\n  strictly increasing order)\n\n@return            -  0 on success,            -  1 if extension/update is impossible\n\n\n\n\n\ncb_extend!(self::CBPSCAffineMinorantExtender, minorant::CBMinorant, n_coords::Integer, indices::Union{<:AbstractVector{Integer},Nothing})\n\n@brief called by ConicBundle to update internal Minorant objects, has to return 0 on success\n\n    @param[in,out] minorant  (Minorant&)\n        it holds a (possibly aggregated) minorant that was generated\n        from minorants returned by oracle calls, e.g. as in\n  FunctionOracle::evaluate() If PrimalData was provided in these\n  minorants, this will be aggregated along and will also be\n  available in this minorant.\n\n    @param[in] n_coords (int)\n        the number of coordinate positions that have to be filled in\n\n    @param[out] new_subgradient_values  (DVector &)\n  the indices of these coordinate positions (sorted in\n  strictly increasing order)\n\n@return            -  0 on success,            -  1 if extension/update is impossible\n\n\n\n\n\ncb_extend!(self::CBSOCSupportMinorantExtender, minorant::CBMinorant, n_coords::Integer, indices::Union{<:AbstractVector{Integer},Nothing})\n\n@brief called by ConicBundle to update internal Minorant objects, has to return 0 on success\n\n    for each relevant index i the minorant value is set to the projection\n\nof 0 onto the interval [lowerbound(i),upperbound(i)]\n\n    @param[in,out] minorant  (Minorant&)\n        it holds a (possibly aggregated) minorant that was generated\n        from minorants returned by oracle calls, e.g. as in\n  FunctionOracle::evaluate()\n\n    @param[in] n_coords (int)\n        the number of coordinate positions that have to be filled in\n\n    @param[out] new_subgradient_values  (DVector &)\n  the indices of these coordinate positions (sorted in\n  strictly increasing order)\n\n@return            -  0 on success,            -  1 if extension/update is impossible\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_extend_Box!","page":"Reference of C++ interface","title":"ConicBundle.cb_extend_Box!","text":"cb_extend_Box!(self::CBBoxPrimalExtender, param0::CBMatrix)\n\ncalled by ConicBundle to update internal Ritz_vectors, has to return 0 on success\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_extend_Ritz!","page":"Reference of C++ interface","title":"ConicBundle.cb_extend_Ritz!","text":"cb_extend_Ritz!(self::CBPSCPrimalExtender, param0::CBMatrix)\n\ncalled by ConicBundle to update internal Ritz_vectors, has to return 0 on success\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_extend_SOC!","page":"Reference of C++ interface","title":"ConicBundle.cb_extend_SOC!","text":"cb_extend_SOC!(self::CBSOCPrimalExtender, param0::CBMatrix)\n\ncalled by ConicBundle to update internal SOC vectors, has to return 0 on success\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_extract_SOCvector!","page":"Reference of C++ interface","title":"ConicBundle.cb_extract_SOCvector!","text":"cb_extract_SOCvector!(self::CBSOCSupportFunction, SOCvec::CBMatrix, SOCminorant::Union{<:CBMinorant,Nothing})\n\nsee SOCOracle::extract_SOCvector()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_find","page":"Reference of C++ interface","title":"ConicBundle.cb_find","text":"cb_find(self::CBMatrix, tol::Real = 1e-10)\n\nreturns an Indexmatrix ind so that (*this)(ind(i)) 0<=i<ind.dim() runs through all nonzero elements\n\n\n\n\n\ncb_find(self::CBIndexmatrix)\n\nreturns an Indexmatrix ind so that (*this)(ind(i)) 0<=i<ind.dim() runs through all nonzero elements\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_find_number","page":"Reference of C++ interface","title":"ConicBundle.cb_find_number","text":"cb_find_number(self::CBMatrix, num::Real = 0., tol::Real = 1e-10)\n\nreturns an Indexmatrix ind so that (*this)(ind(i)) 0<=i<ind.dim() runs through all elements of value num\n\n\n\n\n\ncb_find_number(self::CBIndexmatrix, num::Integer = 0)\n\nreturns an Indexmatrix ind so that (*this)(ind(i)) 0<=i<ind.dim() runs through all elements having value num\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_floor","page":"Reference of C++ interface","title":"ConicBundle.cb_floor","text":"cb_floor(A::CBMatrix)\n\nreturns a matrix with elements (i,j)=floor((*this)(i,j)) for all i,j\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_floor!","page":"Reference of C++ interface","title":"ConicBundle.cb_floor!","text":"cb_floor!(self::CBMatrix)\n\nsets (this)(i,j)=floor((this)(i,j)) for all i,j and returns *this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_form_bundlevecs!","page":"Reference of C++ interface","title":"ConicBundle.cb_form_bundlevecs!","text":"cb_form_bundlevecs!(self::CBSOCData, max_columns::Integer)\n\nstarting with aggregate and cand_SOCvec add further ones as needed\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_from_dim","page":"Reference of C++ interface","title":"ConicBundle.cb_from_dim","text":"cb_from_dim(self::CBAffineFunctionTransformation)\n\nreturns the dimension of the input argument or -1 if it is unknown\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_generate_minorant!","page":"Reference of C++ interface","title":"ConicBundle.cb_generate_minorant!","text":"cb_generate_minorant!(self::CBPSCAffineFunction, P::CBMatrix)\n\nsee PSCOracle::generate_minorant()\n\n\n\n\n\ncb_generate_minorant!(self::CBSOCSupportFunction, SOCvec::CBMatrix)\n\nsee SOCOracle::generate_minorant()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_genmult","page":"Reference of C++ interface","title":"ConicBundle.cb_genmult","text":"cb_genmult(A::CBMatrix, B::CBMatrix, C::CBMatrix, alpha::Real, beta::Real, atrans::Integer, btrans::Integer)\n\nreturns C=betaC+alphaA*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size\n\n\n\n\n\ncb_genmult(A::CBSymmatrix, B::CBMatrix, C::CBMatrix, alpha::Real, beta::Real, btrans::Integer)\n\nreturns C=betaC+alphaA*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size\n\n\n\n\n\ncb_genmult(A::CBMatrix, B::CBSymmatrix, C::CBMatrix, alpha::Real, beta::Real, atrans::Integer)\n\nreturns C=betaC+alphaA*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size\n\n\n\n\n\ncb_genmult(A::CBSparsesym, B::CBMatrix, C::CBMatrix, alpha::Real, beta::Real, btrans::Integer)\n\nreturns C=betaC+alphaA*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size\n\n\n\n\n\ncb_genmult(A::CBMatrix, B::CBSparsesym, C::CBMatrix, alpha::Real, beta::Real, atrans::Integer)\n\nreturns C=betaC+alphaA*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size\n\n\n\n\n\ncb_genmult(A::CBSparsemat, B::CBMatrix, C::CBMatrix, alpha::Real, beta::Real, atrans::Integer, btrans::Integer)\n\nreturns C=betaC+alphaA*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size\n\n\n\n\n\ncb_genmult(A::CBSparsemat, B::CBMatrix, colB::Integer, C::CBMatrix, colC::Integer, alpha::Real, beta::Real, atrans::Integer, btrans::Integer)\n\nreturns C.col(colC)=betaC.col(colC)+alphaA*B.col(colB), where A and B may be transposed first; C must not be equal to A and B; if beta==0. then C is initialized, but the size of C must be correct already\n\n\n\n\n\ncb_genmult(A::CBMatrix, B::CBSparsemat, C::CBMatrix, alpha::Real, beta::Real, atrans::Integer, btrans::Integer)\n\nreturns C=betaC+alphaA*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size\n\n\n\n\n\ncb_genmult(A::CBIndexmatrix, B::CBIndexmatrix, C::CBIndexmatrix, alpha::Integer, beta::Integer, atrans::Integer, btrans::Integer)\n\nreturns C=betaC+alphaA*B, where A and B may be transposed; C must not be equal to A and B; if beta==0 then C is initialized to the correct size\n\n\n\n\n\ncb_genmult(A::CBSparsemat, B::CBSparsemat, C::CBMatrix, alpha::Real, beta::Real, atrans::Integer, btrans::Integer)\n\nreturns C=betaC+alphaA*B, where A and B may be transposed; C must not be equal to A and B; if beta==0. then C is initialized to the correct size\n\n\n\n\n\ncb_genmult(A::CBSymmatrix, B::CBSparsemat, C::CBMatrix, alpha::Real, beta::Real, btrans::Integer)\n\nreturns C=betaC+alphaA*B, where B may be transposed; if beta==0. then C is initialized to the correct size\n\n\n\n\n\ncb_genmult(A::CBSparsemat, B::CBSymmatrix, C::CBMatrix, alpha::Real, beta::Real, atrans::Integer)\n\nreturns C=betaC+alphaA*B, where A may be transposed; if beta==0. then C is initialized to the correct size\n\n\n\n\n\ncb_genmult(A::CBSparsesym, B::CBSparsemat, C::CBMatrix, alpha::Real, beta::Real, btrans::Integer)\n\nreturns C=betaC+alphaA*B, where B may be transposed; if beta==0. then C is initialized to the correct size\n\n\n\n\n\ncb_genmult(A::CBSparsemat, B::CBSparsesym, C::CBMatrix, alpha::Real, beta::Real, atrans::Integer)\n\nreturns C=betaC+alphaA*B, where A may be transposed; if beta==0. then C is initialized to the correct size\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_A","page":"Reference of C++ interface","title":"ConicBundle.cb_get_A","text":"cb_get_A(self::CBCMgramdense)\n\nreturns the const reference to the internal matrix A forming the Gram matrix\n\n\n\n\n\ncb_get_A(self::CBCMgramsparse)\n\nreturns the const reference to the internal matrix A forming the Gram matrix\n\n\n\n\n\ncb_get_A(self::CBCMgramsparse_withoutdiag)\n\nreturns the const reference to the internal matrix A forming the Gram matrix\n\n\n\n\n\ncb_get_A(self::CBCMsymdense)\n\nreturns the const reference to the internal symmetric matrix\n\n\n\n\n\ncb_get_A(self::CBCMsymsparse)\n\nreturn the const reference to the internal sparse matrix\n\n\n\n\n\ncb_get_A(self::CBQPSolver)\n\nreturns the constraint matrix of the feasible set\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_Ab","page":"Reference of C++ interface","title":"ConicBundle.cb_get_Ab","text":"cb_get_Ab(self::CBUQPConeModelBlock, qp_A::CBMatrix, qp_b::CBMatrix)\n\nstore the local coefficients of matrices A and b in the positions corresponding to qpyrange (rows) and qpxrange (columns); returns 0 on success, 1 on failure\n\n\n\n\n\ncb_get_Ab(self::CBUQPSumModelBlock, qp_A::CBMatrix, qp_b::CBMatrix)\n\nget the A matrix of all subblocks and store it consistently\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_Bt!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_Bt!","text":"cb_get_Bt!(self::CBQPConeModelBlock, Bt::CBMatrix, startindex_model::Integer, global_bundle::CBMinorantBundle, startindex_bundle::Integer)\n\nget the current matrix for the coupling matrix Bt in the first row of blocks\n\n\n\n\n\ncb_get_Bt!(self::CBQPSumModelBlock, Bt::CBMatrix, startindex_model::Integer, global_bundle::CBMinorantBundle, startindex_bundle::Integer)\n\nget the current matrix for the coupling matrix Bt in the first row of blocks\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_C!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_C!","text":"cb_get_C!(self::CBPSCAffineFunction)\n\nreturns the block representation of the coefficient matrices    (each entry of the map represents a block by a SparseCoeffmatVector).\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_D","page":"Reference of C++ interface","title":"ConicBundle.cb_get_D","text":"cb_get_D(self::CBBundleDiagonalTrustRegionProx)\n\nreturns the diagonal D of the diagonal scaling matrix\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_H","page":"Reference of C++ interface","title":"ConicBundle.cb_get_H","text":"cb_get_H(self::CBBundleDenseTrustRegionProx)\n\nreturns the metric matrix without weightu\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_Hchol","page":"Reference of C++ interface","title":"ConicBundle.cb_get_Hchol","text":"cb_get_Hchol(self::CBBundleDenseTrustRegionProx)\n\nreturns the stored factorization of H with weightu (up to date if get_factored()==true)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_Q","page":"Reference of C++ interface","title":"ConicBundle.cb_get_Q","text":"cb_get_Q(self::CBUQPSolver)\n\nreturns the quadratic cost matrix\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_QPcoeff_time","page":"Reference of C++ interface","title":"ConicBundle.cb_get_QPcoeff_time","text":"cb_get_QPcoeff_time(self::CBBundleSolver)\n\nreturn time spent in computing the cost coefficients of the quadratic bundle subproblem\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_QPsolve_time","page":"Reference of C++ interface","title":"ConicBundle.cb_get_QPsolve_time","text":"cb_get_QPsolve_time(self::CBBundleSolver)\n\nreturn time spent in solving the quadratic bundle subproblem\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_Ritz_values","page":"Reference of C++ interface","title":"ConicBundle.cb_get_Ritz_values","text":"cb_get_Ritz_values(self::CBPSCData)\n\nreturns Ritz_values\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_UVlambda!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_UVlambda!","text":"cb_get_UVlambda!(self::CBVariableMetricSVDSelection, U::CBMatrix, V::CBMatrix, lam::CBMatrix, cand::CBMatrix)\n\nfor current ongoing experiments with variable metric routines\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_X!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_X!","text":"cb_get_X!(self::CBUQPConeModelBlock, i::Integer, X::CBSymmatrix)\n\nget the current primal positive semidefinite cone point to cone i (of the solution)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_Z!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_Z!","text":"cb_get_Z!(self::CBUQPConeModelBlock, i::Integer, Z::CBSymmatrix)\n\nget the current dual positive semidefinite cone point to cone i (of the solution)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_activedim","page":"Reference of C++ interface","title":"ConicBundle.cb_get_activedim","text":"cb_get_activedim(self::CBPSCData)\n\nreturns acitvedim\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_add_offset","page":"Reference of C++ interface","title":"ConicBundle.cb_get_add_offset","text":"cb_get_add_offset(self::CBGroundsetModification)\n\nreturns the change in the offste value of the groundset minorant\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_additional_factor","page":"Reference of C++ interface","title":"ConicBundle.cb_get_additional_factor","text":"cb_get_additional_factor(self::CBAFTModification)\n\nreturns null if nothing or default values have to be appended, otherwise it points to a sparse matrix whose columns need to be appended to the matrix\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_additional_offset","page":"Reference of C++ interface","title":"ConicBundle.cb_get_additional_offset","text":"cb_get_additional_offset(self::CBAFTModification)\n\nreturns the value to be added to the offset\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_aft","page":"Reference of C++ interface","title":"ConicBundle.cb_get_aft","text":"cb_get_aft(self::CBAFTModel)\n\nallows to inspect the current AffineFunctionTransformation\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_aggr_dnormsqr","page":"Reference of C++ interface","title":"ConicBundle.cb_get_aggr_dnormsqr","text":"cb_get_aggr_dnormsqr(self::CBBundleSolver)\n\nreturns the dual norm squared of the current aggregate (dual w.r.t. the quadratic proximal term)\n\n\n\n\n\ncb_get_aggr_dnormsqr(self::CBBundleTerminator)\n\nreturns the current bound for the dual norm squared of the aggregate\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_aggregate","page":"Reference of C++ interface","title":"ConicBundle.cb_get_aggregate","text":"cb_get_aggregate(self::CBSumBundle, ft::CBFunctionTask)\n\ngets the corresponding aggregate (call only if a hasbundlefor(ft)==true)\n\n\n\n\n\ncb_get_aggregate(self::CBBundleSolver, aggregate::CBMatrix)\n\nreturns the linear term of the current aggregate linear minorant (this should be called before any modifications, otherwise this may no longer be correct or may even cause an error)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_aggregate_offset","page":"Reference of C++ interface","title":"ConicBundle.cb_get_aggregate_offset","text":"cb_get_aggregate_offset(self::CBBundleSolver)\n\nreturns the offset of the current aggregate linear minorant (should be called before any modifications, otherwise this may no longer be correct)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_append_cols","page":"Reference of C++ interface","title":"ConicBundle.cb_get_append_cols","text":"cb_get_append_cols(self::CBAFTModification)\n\nreturns null if nothing or default values have to be appended, otherwise it points to a sparse matrix whose columns need to be appended to the matrix\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_append_costs","page":"Reference of C++ interface","title":"ConicBundle.cb_get_append_costs","text":"cb_get_append_costs(self::CBAFTModification)\n\nreturns null if nothing or default values have to be appended, otherwise it points to a matrix whose entries need to be appended to the cost vector\n\n\n\n\n\ncb_get_append_costs(self::CBGroundsetModification)\n\nreturns the change in the offste value of the groundset minorant\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_append_rhs","page":"Reference of C++ interface","title":"ConicBundle.cb_get_append_rhs","text":"cb_get_append_rhs(self::CBAFTModification)\n\nreturns null if nothing or default values have to be appended, otherwise it points to a matrix whose rows need to be appended to the argument offset\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_append_rows","page":"Reference of C++ interface","title":"ConicBundle.cb_get_append_rows","text":"cb_get_append_rows(self::CBAFTModification)\n\nreturns null if nothing or default values have to be appended, otherwise it points to a sparse matrix whose rows need to be appended to the matrix\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_appended_vardim","page":"Reference of C++ interface","title":"ConicBundle.cb_get_appended_vardim","text":"cb_get_appended_vardim(self::CBAFTModification)\n\nreturns the number of variables that are appended (due to later reassignmentds they may no longer be located at the end)\n\n\n\n\n\ncb_get_appended_vardim(self::CBGroundsetModification)\n\nreturns the number of variables that are appended (due to later reassignmentds they may no longer be located at the end)\n\n\n\n\n\ncb_get_appended_vardim(self::CBNNCBoxSupportModification)\n\nreturns the number of variables that are appended (due to later reassignmentds they may no longer be located at the end)\n\n\n\n\n\ncb_get_appended_vardim(self::CBPSCAffineModification)\n\nreturns the number of variables that are appended (due to later reassignmentds they may no longer be located at the end)\n\n\n\n\n\ncb_get_appended_vardim(self::CBSOCSupportModification)\n\nreturns the number of variables that are appended (due to later reassignmentds they may no longer be located at the end)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_approximate_primal","page":"Reference of C++ interface","title":"ConicBundle.cb_get_approximate_primal","text":"cb_get_approximate_primal(self::CBMatrixCBSolver, function_::CBFunctionObject)\n\n@brief returns the current approximate primal solution corresponding       to the aggregate subgradient of the specified @a function.\n  PrimalData solutions must have been supplied in all previous\n  calls to evaluate; In this case it returns the current approximate\n  primal solution aggregated alongside with the aggregate subgradient.\n  A primal solution may not be available after addition of constraints,\n  if extension of the aggregate subgradient to the new coordinates failed.\nIf no primal data is availalbe, the function returns NULL.\n@return       - pointer to the primal data of the aggregate of this function object       - 0 if no primal is available\n\n\n\n\n\ncb_get_approximate_primal(self::CBBoxData)\n\nreturn the PrimalData corresponding to the aggregate\n\n\n\n\n\ncb_get_approximate_primal(self::CBNNCData)\n\nreturn the PrimalData corresponding to the aggregate\n\n\n\n\n\ncb_get_approximate_primal(self::CBPSCData)\n\nreturn the PrimalData corresponding to the aggregate\n\n\n\n\n\ncb_get_approximate_primal(self::CBSOCData)\n\nreturn the PrimalData corresponding to the aggregate\n\n\n\n\n\ncb_get_approximate_primal(self::CBAFTModel)\n\nan AFT has no primals, so it returns 1, see SumBlockModel::getapproximateprimal\n\n\n\n\n\ncb_get_approximate_primal(self::CBBoxModel)\n\nsee SumBlockModel::getapproximateprimal\n\n\n\n\n\ncb_get_approximate_primal(self::CBNNCModel)\n\nsee SumBlockModel::getapproximateprimal\n\n\n\n\n\ncb_get_approximate_primal(self::CBPSCModel)\n\nsee SumBlockModel::getapproximateprimal\n\n\n\n\n\ncb_get_approximate_primal(self::CBSOCModel)\n\nsee SumBlockModel::getapproximateprimal\n\n\n\n\n\ncb_get_approximate_primal(self::CBSumModel)\n\nthis has no primals, so it returns 1, see SumBlockModel::getapproximateprimal\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_approximate_slacks-Tuple{ConicBundle.CBMatrixCBSolver, ConicBundle.CBMatrix}","page":"Reference of C++ interface","title":"ConicBundle.cb_get_approximate_slacks","text":"cb_get_approximate_slacks(self::CBMatrixCBSolver, param0::CBMatrix)\n\n@brief Returns the multipliers for the box constraints on the design variables;      in Lagrangean relaxation they may be interpreted as primal slacks\n\nfor inequality constraints.     @return        - 0 on success        - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_get_arg_offset","page":"Reference of C++ interface","title":"ConicBundle.cb_get_arg_offset","text":"cb_get_arg_offset(self::CBAffineFunctionTransformation)\n\nreturns the pointer to the constant offset added to the argument (not neeeded in the code)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_arg_trafo","page":"Reference of C++ interface","title":"ConicBundle.cb_get_arg_trafo","text":"cb_get_arg_trafo(self::CBAffineFunctionTransformation)\n\nreturns the pointer to the linear transformation of the argument (not neeeded in the code)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_augvalfails","page":"Reference of C++ interface","title":"ConicBundle.cb_get_augvalfails","text":"cb_get_augvalfails(self::CBBundleSolver)\n\nreturns the number of failures to increase the augmented model value since the last null/descent step\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_augvalfailslimit","page":"Reference of C++ interface","title":"ConicBundle.cb_get_augvalfailslimit","text":"cb_get_augvalfailslimit(self::CBBundleTerminator)\n\nreturns the current value of this parameter\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_avg_reduction","page":"Reference of C++ interface","title":"ConicBundle.cb_get_avg_reduction","text":"cb_get_avg_reduction(self::CBMinRes)\n\nreturns the average of the achieved reduction factor per iteration\n\n\n\n\n\ncb_get_avg_reduction(self::CBPCG)\n\nreturns the average of the achieved reduction factor per iteration\n\n\n\n\n\ncb_get_avg_reduction(self::CBPsqmr)\n\nreturns the average of the achieved reduction factor per iteration\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_block_append","page":"Reference of C++ interface","title":"ConicBundle.cb_get_block_append","text":"cb_get_block_append(self::CBPSCAffineModification)\n\nreturns null if nothing or default values have to be appended, otherwise it points to a sparse matrix whose rows need to be appended to the matrix\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_boxx!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_boxx!","text":"cb_get_boxx!(self::CBQPConeModelBlock, boxx::CBMatrix, linx_activity::Union{<:CBMatrix,Nothing} = nothing, cautious::Bool = false)\n\nget the box part of modelx (and a guess, which of the bounds are active, in {0.,1.})\n\n\n\n\n\ncb_get_boxx!(self::CBUQPConeModelBlock, param0::CBMatrix, param1::Union{<:CBMatrix,Nothing} = nothing, cautious::Bool = false)\n\nget the box part of modelx (and a guess, which of the bounds are active, in {0.,1.})\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_bundle","page":"Reference of C++ interface","title":"ConicBundle.cb_get_bundle","text":"cb_get_bundle(self::CBSumBundle, ft::CBFunctionTask)\n\ngets the corresponding minorants (call only if a hasbundlefor(ft)==true)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_bundle_data","page":"Reference of C++ interface","title":"ConicBundle.cb_get_bundle_data","text":"cb_get_bundle_data(self::CBMatrixCBSolver, function_::Union{<:CBFunctionObject,Nothing} = nothing)\n\n@brief Returns all current bundle data of the cutting       model of the specified @a function.\nThis may differ for predefined special functions with derived classes.\n@param[in] function      if the aggregate subgradient of a particular function is desired,      provide the pointer here, otherwise this referrs to the root function      (if there is only one function to be optimized over, this is this single      function, otherwise it is the sum of functions)\n@return      - 0 on success      - != 0 otherwise\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_bundle_parameters-Tuple{ConicBundle.CBAFTModel}","page":"Reference of C++ interface","title":"ConicBundle.cb_get_bundle_parameters","text":"cb_get_bundle_parameters(self::CBAFTModel)\n\nan AFT has no bundle, so it returns 1, see SumBlockModel::getbundleparameters\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_get_bundle_parameters-Tuple{ConicBundle.CBBoxModel}","page":"Reference of C++ interface","title":"ConicBundle.cb_get_bundle_parameters","text":"cb_get_bundle_parameters(self::CBBoxModel)\n\nsee SumBlockModel::getbundleparameters\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_get_bundle_parameters-Tuple{ConicBundle.CBMatrixCBSolver, Union{Nothing, ConicBundle.CBFunctionObject}}","page":"Reference of C++ interface","title":"ConicBundle.cb_get_bundle_parameters","text":"cb_get_bundle_parameters(self::CBMatrixCBSolver, function_::Union{<:CBFunctionObject,Nothing} = nothing)\n\n@brief Retrieves current bundle parameters (not the actual size in use!)      as set for the cutting model of the specified @a function.\n\nThis may differ for predefined special  functions with derived BundleParameter classes.\n\nIf the code is asked to optimize over the sum of several functions,  it usually does this with a separate model for each function. If there  are too many function for this, it may be worth to consider using  the SumBundle features. For this see also setsumbundleparameters().  If the root function is a sum of functions, passing a        SumModelParametersObject here allows to specify how many local models  should be kept by SumModelParametersObject::setmaxlocal_models()        and how these should be selected. A possible implementation for this  is given in SumModelParameters.\n\n@param[in] function\n  if the aggregate subgradient of a particular function is desired,\n  provide the pointer here, otherwise this referrs to the root function\n  (if there is only one function to be optimized over, this is this single\n  function, otherwise it is the sum of functions)\n\n@return\n  - 0 on success\n  - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_get_bundle_parameters-Tuple{ConicBundle.CBNNCModel}","page":"Reference of C++ interface","title":"ConicBundle.cb_get_bundle_parameters","text":"cb_get_bundle_parameters(self::CBNNCModel)\n\nsee SumBlockModel::getbundleparameters\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_get_bundle_parameters-Tuple{ConicBundle.CBPSCModel}","page":"Reference of C++ interface","title":"ConicBundle.cb_get_bundle_parameters","text":"cb_get_bundle_parameters(self::CBPSCModel)\n\nsee SumBlockModel::getbundleparameters\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_get_bundle_parameters-Tuple{ConicBundle.CBSOCModel}","page":"Reference of C++ interface","title":"ConicBundle.cb_get_bundle_parameters","text":"cb_get_bundle_parameters(self::CBSOCModel)\n\nsee SumBlockModel::getbundleparameters\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_get_bundle_parameters-Tuple{ConicBundle.CBSumModel}","page":"Reference of C++ interface","title":"ConicBundle.cb_get_bundle_parameters","text":"cb_get_bundle_parameters(self::CBSumModel)\n\nsee SumBlockModel::getbundleparameters()\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_get_bundleweight","page":"Reference of C++ interface","title":"ConicBundle.cb_get_bundleweight","text":"cb_get_bundleweight(self::CBBundleSolver)\n\nreturn a pointer to the class for updating the weightu of the proximal term\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_c","page":"Reference of C++ interface","title":"ConicBundle.cb_get_c","text":"cb_get_c(self::CBUQPSolver)\n\nreturns the linear cost vector\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_cand_gs_val","page":"Reference of C++ interface","title":"ConicBundle.cb_get_cand_gs_val","text":"cb_get_cand_gs_val(self::CBBundleSolver)\n\nreturns the groundset objective value in @a cand_y\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_cand_minorant","page":"Reference of C++ interface","title":"ConicBundle.cb_get_cand_minorant","text":"cb_get_cand_minorant(self::CBSumBundle, ft::CBFunctionTask)\n\ngets the corresponding candidate minorant (call only if a hasbundlefor(ft)==true)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_cand_objval","page":"Reference of C++ interface","title":"ConicBundle.cb_get_cand_objval","text":"cb_get_cand_objval(self::CBBundleSolver)\n\nreturns the upper bound on the objective in @a cand_y\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_cand_ub","page":"Reference of C++ interface","title":"ConicBundle.cb_get_cand_ub","text":"cb_get_cand_ub(self::CBBundleSolver)\n\nreturns the upper bound on the objective in @a cand_y returned by the oracle\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_cand_y","page":"Reference of C++ interface","title":"ConicBundle.cb_get_cand_y","text":"cb_get_cand_y(self::CBBundleSolver)\n\nreturns the most recent candidate @a cand_y (after a descent step this is the same as the candidate)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_candidate-Tuple{ConicBundle.CBMatrixCBSolver, ConicBundle.CBMatrix}","page":"Reference of C++ interface","title":"ConicBundle.cb_get_candidate","text":"cb_get_candidate(self::CBMatrixCBSolver, center::CBMatrix)\n\n@brief Returns the last point, the \"candidate\", at which the function       was evaluated in solve().\n  If this evaluation lead to a descent step, it is the same point as\nin get_center().\n@return\n  - 0 on success\n  - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_get_candidate_primal","page":"Reference of C++ interface","title":"ConicBundle.cb_get_candidate_primal","text":"cb_get_candidate_primal(self::CBMatrixCBSolver, function_::CBFunctionObject)\n\n@brief Returns the primal solution corresponding to the best epsilon subgradient returned in the evaluation of the specified @a function       at the point get_candidate. If no primal data is availalbe, the function returns NULL.\n@return       - pointer to the primal data of the minorant returned on evaluation   of this function object at the current candidate       - 0 if no primal is available\n\n\n\n\n\ncb_get_candidate_primal(self::CBBoxData)\n\nreturn the PrimalData delivered by the last call of BoxOracle::evaluate()\n\n\n\n\n\ncb_get_candidate_primal(self::CBNNCData)\n\nreturn the PrimalData delivered by the last call of FunctionOracle::evaluate()\n\n\n\n\n\ncb_get_candidate_primal(self::CBPSCData)\n\nreturn the PrimalData delivered by the last call of FunctionOracle::evaluate()\n\n\n\n\n\ncb_get_candidate_primal(self::CBSOCData)\n\nreturn the PrimalData delivered by the last call of FunctionOracle::evaluate()\n\n\n\n\n\ncb_get_candidate_primal(self::CBAFTModel)\n\nan AFT has no primals, so it returns 1, see SumBlockModel::getcandidateprimal\n\n\n\n\n\ncb_get_candidate_primal(self::CBBoxModel)\n\nsee SumBlockModel::getcandidateprimal\n\n\n\n\n\ncb_get_candidate_primal(self::CBNNCModel)\n\nsee SumBlockModel::getcandidateprimal\n\n\n\n\n\ncb_get_candidate_primal(self::CBPSCModel)\n\nsee SumBlockModel::getcandidateprimal\n\n\n\n\n\ncb_get_candidate_primal(self::CBSOCModel)\n\nsee SumBlockModel::getcandidateprimal\n\n\n\n\n\ncb_get_candidate_primal(self::CBSumModel)\n\nthis has no primals, so it returns 1, see SumBlockModel::getcandidateprimal\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_candidate_value-Tuple{ConicBundle.CBMatrixCBSolver}","page":"Reference of C++ interface","title":"ConicBundle.cb_get_candidate_value","text":"cb_get_candidate_value(self::CBMatrixCBSolver)\n\n@brief Returns the objective value computed in the last step of solve(),       independent of whether this was a descent step or a null step (initially undefined).\n  If no problem modification routines were called since then, it is the\n  objective value at the point returned by get_candidate(). If this\n  last evaluation led to a descent step, then it is the same value as\n  in get_objval().\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_get_center-Tuple{ConicBundle.CBMatrixCBSolver, ConicBundle.CBMatrix}","page":"Reference of C++ interface","title":"ConicBundle.cb_get_center","text":"cb_get_center(self::CBMatrixCBSolver, center::CBMatrix)\n\n@brief Returns the next center point that was produced by the latest call to solve (in some problem modification routines the center point may be updated immediately, in others the center point will be corrected automatically directly before starting the next descent step and its values may be infeasible till then).\n@return\n  - 0 on success\n  - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_get_center_gs_val","page":"Reference of C++ interface","title":"ConicBundle.cb_get_center_gs_val","text":"cb_get_center_gs_val(self::CBBundleSolver)\n\nreturns the groundset objective in @a center_y r\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_center_minorant!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_center_minorant!","text":"cb_get_center_minorant!(self::CBAFTModel, minorant::CBMinorantPointer, aft::Union{<:CBAffineFunctionTransformation,Nothing} = nothing)\n\nsee SumBlockModel::getcenterminorant\n\n\n\n\n\ncb_get_center_minorant!(self::CBSumModel, minorant::CBMinorantPointer, aft::Union{<:CBAffineFunctionTransformation,Nothing} = nothing)\n\nsee SumBlockModel::getcenterminorant()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_center_objval","page":"Reference of C++ interface","title":"ConicBundle.cb_get_center_objval","text":"cb_get_center_objval(self::CBBundleSolver)\n\nreturns the upper bound on the objective value in @a center_y\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_center_primal","page":"Reference of C++ interface","title":"ConicBundle.cb_get_center_primal","text":"cb_get_center_primal(self::CBMatrixCBSolver, function_::CBFunctionObject)\n\n@brief Returns the primal solution corresponding to the best epsilon subgradient returned in the evaluation of the specified @a function       at the current center point. If no primal data is availalbe, the function returns NULL.\n@return       - pointer to the primal data of the minorant returned on evaluation   of this function object at the current center       - 0 if no primal is available\n\n\n\n\n\ncb_get_center_primal(self::CBBoxData)\n\nreturn the PrimalData corresponding to the aggregate\n\n\n\n\n\ncb_get_center_primal(self::CBNNCData)\n\nreturn the PrimalData corresponding to the aggregate\n\n\n\n\n\ncb_get_center_primal(self::CBPSCData)\n\nreturn the PrimalData corresponding to the aggregate\n\n\n\n\n\ncb_get_center_primal(self::CBSOCData)\n\nreturn the PrimalData corresponding to the aggregate\n\n\n\n\n\ncb_get_center_primal(self::CBAFTModel)\n\nan AFT has no primals, so it returns 1, see SumBlockModel::getcenterprimal\n\n\n\n\n\ncb_get_center_primal(self::CBBoxModel)\n\nsee SumBlockModel::getcneterprimal\n\n\n\n\n\ncb_get_center_primal(self::CBNNCModel)\n\nsee SumBlockModel::getcenterprimal\n\n\n\n\n\ncb_get_center_primal(self::CBPSCModel)\n\nsee SumBlockModel::getcenterprimal\n\n\n\n\n\ncb_get_center_primal(self::CBSOCModel)\n\nsee SumBlockModel::getcenterprimal\n\n\n\n\n\ncb_get_center_primal(self::CBSumModel)\n\nthis has no primals, so it returns 1, see SumBlockModel::getcenterprimal\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_center_ub","page":"Reference of C++ interface","title":"ConicBundle.cb_get_center_ub","text":"cb_get_center_ub(self::CBBundleSolver)\n\nreturns the upper bound on the objective in @a center_y returned by the oracle\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_center_y","page":"Reference of C++ interface","title":"ConicBundle.cb_get_center_y","text":"cb_get_center_y(self::CBBundleSolver)\n\nreturns the current center of stability @a center_y (after a descent step this is the same as the candidate)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_cntobjeval","page":"Reference of C++ interface","title":"ConicBundle.cb_get_cntobjeval","text":"cb_get_cntobjeval(self::CBBundleSolver)\n\nreturns the number of calls to the oracle since the last clear()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_coeff","page":"Reference of C++ interface","title":"ConicBundle.cb_get_coeff","text":"cb_get_coeff(self::CBSumBundle, ft::CBFunctionTask)\n\ngets the corresponding aggregation coefficients (call only if a hasbundlefor(ft)==true)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_colindex","page":"Reference of C++ interface","title":"ConicBundle.cb_get_colindex","text":"cb_get_colindex(self::CBSparsemat)\n\nreturns the index vector of the column representation holding the row index for each element\n\n\n\n\n\ncb_get_colindex(self::CBSparsesym)\n\nreturns the index vector of the column representation holding the row index for each element\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_colinfo","page":"Reference of C++ interface","title":"ConicBundle.cb_get_colinfo","text":"cb_get_colinfo(self::CBSparsemat)\n\nreturns information on nonzero columns, k by 3, listing: index, %#nonzeros, first index in colindex/colval\n\n\n\n\n\ncb_get_colinfo(self::CBSparsesym)\n\nreturns information on nozero diagonal/columns, k by 4, listing: index (<0 for diagonal), # nonzeros, first index in colindex/colval, index in suppport submatrix\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_colval","page":"Reference of C++ interface","title":"ConicBundle.cb_get_colval","text":"cb_get_colval(self::CBSparsemat)\n\nreturns the value vector of the column representation holding the value for each element\n\n\n\n\n\ncb_get_colval(self::CBSparsesym)\n\nreturns the value vector of the column representation holding the value for each element\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_constant_minorant","page":"Reference of C++ interface","title":"ConicBundle.cb_get_constant_minorant","text":"cb_get_constant_minorant(self::CBAffineFunctionTransformation)\n\nreturn the constant linear minorant corresponding to funoffset+<*linearcost,.>\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_contributed_model_aggregate","page":"Reference of C++ interface","title":"ConicBundle.cb_get_contributed_model_aggregate","text":"cb_get_contributed_model_aggregate(self::CBSumBundle, aggregate::CBMinorantPointer, factor::Real = 1., aft::Union{<:CBAffineFunctionTransformation,Nothing} = nothing)\n\nget the aggregate that is due to child parts of the sumbundle, which are contributed to parents\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_corr!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_corr!","text":"cb_get_corr!(self::CBUQPConeModelBlock, xcorr::CBMatrix, rhs::CBMatrix, mu::Real)\n\n@brief supply the information for the corrector\non input (w.r.t. corresponding positions)         xcorr = 0         rhs as on output of addlocalsys\non output the corresponding positions of xcorr should hold the corrector    term of the search direction, eg,  xcorr = mux^{-1} - x^{-1}dx*dz,    and if the block holds additional local variables as in addlocalsys then\n       rhs += B*(mu * t^{-1}- t^{-1}*dt*ds)\nhas to be called after suggest_mu which computes the other directions\n\n\n\n\n\ncb_get_corr!(self::CBUQPSumModelBlock, xcorr::CBMatrix, rhs::CBMatrix, mu::Real)\n\nget this from all subblocks\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_costs","page":"Reference of C++ interface","title":"ConicBundle.cb_get_costs","text":"cb_get_costs(self::CBMatrixCBSolver, costs::CBMatrix)\n\n@brief If a linear cost vector was specified, costs will hold these values, otherwise the vector is initialized to zero (for the current dimension)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_cutval","page":"Reference of C++ interface","title":"ConicBundle.cb_get_cutval","text":"cb_get_cutval(self::CBMatrixCBSolver)\n\n@brief Returns the cutting model value resulting from last call to       solve() (initially undefined).\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_data","page":"Reference of C++ interface","title":"ConicBundle.cb_get_data","text":"cb_get_data(self::CBAFTModel)\n\nsee SumBlockModel::get_data\n\n\n\n\n\ncb_get_data(self::CBBoxModel)\n\nsee SumBlockModel::get_data\n\n\n\n\n\ncb_get_data(self::CBNNCModel)\n\nsee SumBlockModel::get_data\n\n\n\n\n\ncb_get_data(self::CBPSCModel)\n\nsee SumBlockModel::get_data\n\n\n\n\n\ncb_get_data(self::CBSOCModel)\n\nsee SumBlockModel::get_data\n\n\n\n\n\ncb_get_data(self::CBSumModel)\n\nsee SumBlockModel::get_data()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_data!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_data!","text":"cb_get_data!(self::CBAFTModel)\n\nsee SumBlockModel::get_data\n\n\n\n\n\ncb_get_data!(self::CBBoxModel)\n\nsee SumBlockModel::get_data\n\n\n\n\n\ncb_get_data!(self::CBNNCModel)\n\nsee SumBlockModel::get_data\n\n\n\n\n\ncb_get_data!(self::CBPSCModel)\n\nsee SumBlockModel::get_data\n\n\n\n\n\ncb_get_data!(self::CBSOCModel)\n\nsee SumBlockModel::get_data\n\n\n\n\n\ncb_get_data!(self::CBSumModel)\n\nsee SumBlockModel::get_data()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_dense_cnt","page":"Reference of C++ interface","title":"ConicBundle.cb_get_dense_cnt","text":"cb_get_dense_cnt(self::CBSparseCoeffmatMatrix, i::Integer)\n\nreturns the number of dense matrices in block i\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_dense_coeff_store!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_dense_coeff_store!","text":"cb_get_dense_coeff_store!(self::CBMinorant, n_elements::Integer)\n\n*@brief If the returned pointer is not NULL it gives direct access to the array of current coefficient values with indices 0 up to n_elements-1;\n\n  If the return value is NULL, the representation may not be\n  available or access to the store may not be granted; in this case\n  other routines like get_coeffs and add_coeffs have to be used.\n\n  This routine is mainly intended for increasing efficiency in\n  some internal computations; the validity of the pointer returned\n  may get lost with any call to any other routine of this Minorant,\n  so during manipulations of the stored values no other routines\n  should be called. Needless to say, this routine should only be\n  used by experts.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_descent_step","page":"Reference of C++ interface","title":"ConicBundle.cb_get_descent_step","text":"cb_get_descent_step(self::CBMatrixCBSolver)\n\n@brief returns true if the last evaluation of the last call to solve() resulted in a descent step\nMind: if there was no (succesdful) evaluation, neither getdescentstep() nor getnullstep() will return true;\n\n\n\n\n\ncb_get_descent_step(self::CBBundleSolver)\n\nreturns true if the latest iteration resulted in a descent step (note, getdescentstep() and getnullstep() may both return false e.g. if termination occurs)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_descent_steps","page":"Reference of C++ interface","title":"ConicBundle.cb_get_descent_steps","text":"cb_get_descent_steps(self::CBBundleSolver)\n\nreturns the number of descent steps since the last clear()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_dim-Tuple{ConicBundle.CBLPGroundset}","page":"Reference of C++ interface","title":"ConicBundle.cb_get_dim","text":"cb_get_dim(self::CBLPGroundset)\n\nreturns the dimension of the ground set, i.e., the length of the variables vector y\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_get_dim-Tuple{ConicBundle.CBMatrixCBSolver}","page":"Reference of C++ interface","title":"ConicBundle.cb_get_dim","text":"cb_get_dim(self::CBMatrixCBSolver)\n\n@brief Returns the current dimension of the design space/argument          or -1 if no dimension is set.\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_get_dim-Tuple{ConicBundle.CBUnconstrainedGroundset}","page":"Reference of C++ interface","title":"ConicBundle.cb_get_dim","text":"cb_get_dim(self::CBUnconstrainedGroundset)\n\nreturns the dimension of the ground set, i.e., the length of the variables vector y\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_get_do_variable_metric","page":"Reference of C++ interface","title":"ConicBundle.cb_get_do_variable_metric","text":"cb_get_do_variable_metric(self::CBBundleSolver)\n\nreturns true if the proximal term is not of the type BundleIdProx, i.e. if it is not simply the squared Euclidean norm\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_dualval","page":"Reference of C++ interface","title":"ConicBundle.cb_get_dualval","text":"cb_get_dualval(self::CBUQPSolver)\n\nreturn the dual objective value (upper bound) of the last solve\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_edge","page":"Reference of C++ interface","title":"ConicBundle.cb_get_edge","text":"cb_get_edge(self::CBSparsemat, i::Integer)\n\nstores element i of the getedgerep() function (ordered as in row representation); returns 1 if i is out of range, 0 otherwise.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_edge_rep","page":"Reference of C++ interface","title":"ConicBundle.cb_get_edge_rep","text":"cb_get_edge_rep(self::CBSparsemat, I::CBIndexmatrix, J::CBIndexmatrix, val::CBMatrix)\n\nstores the nz nonzero values of *this in I,J,val so that this(I(i),J(i))=val(i) for i=0,...,nz-1 and dim(I)=dim(J)=dim(val)=nz (ordered as in row representation)\n\n\n\n\n\ncb_get_edge_rep(self::CBSparsesym, I::CBIndexmatrix, J::CBIndexmatrix, val::CBMatrix)\n\nstores the nz nonzero values of the lower triangle of *this in I,J,val so that this(I(i),J(i))=val(i) for i=0,...,nz-1 and dim(I)=dim(J)=dim(val)=nz (ordered as in row representation)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_err","page":"Reference of C++ interface","title":"ConicBundle.cb_get_err","text":"cb_get_err(self::CBMinRes)\n\nreturns the error code of the last call\n\n\n\n\n\ncb_get_err(self::CBPCG)\n\nreturns the error code of the last call\n\n\n\n\n\ncb_get_err(self::CBPsqmr)\n\nreturns the error code of the last call\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_eval_time","page":"Reference of C++ interface","title":"ConicBundle.cb_get_eval_time","text":"cb_get_eval_time(self::CBAFTModel)\n\nsee SumBlockModel::getevaltime()\n\n\n\n\n\ncb_get_eval_time(self::CBSumModel)\n\nsee SumBlockModel::getevaltime()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_evalaugmodel_time","page":"Reference of C++ interface","title":"ConicBundle.cb_get_evalaugmodel_time","text":"cb_get_evalaugmodel_time(self::CBBundleSolver)\n\nreturn time spent in total for the quadratic bundle subproblem\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_factored","page":"Reference of C++ interface","title":"ConicBundle.cb_get_factored","text":"cb_get_factored(self::CBBundleDenseTrustRegionProx)\n\nreturns true iff get_Hchol() returns the factord matrix of H with weightu\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_fixed_active_bounds-Tuple{ConicBundle.CBMatrixCBSolver}","page":"Reference of C++ interface","title":"ConicBundle.cb_get_fixed_active_bounds","text":"cb_get_fixed_active_bounds(self::CBMatrixCBSolver)\n\n@brief Returns NULL or (iff active bound fixing is turned on in setactivebounds_fixing()) the indicator vector of variables temporarily fixed to the center value due to significantly positive multipliers for the box constraints.\n  A variable gets fixed to the bound only if the center is\nalready a the bound and in some iteration the dual variables to the bound constraint indicate that the bound is strongly active also for the candidate. Of course this migh just hold for one candidate and there is no guarantee that the bound is also strongly active in an optimal solution. Thus, this mainly a heuristic to eliminate less important variables quickly from entering the subproblem.\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_get_fun_coeff","page":"Reference of C++ interface","title":"ConicBundle.cb_get_fun_coeff","text":"cb_get_fun_coeff(self::CBAffineFunctionTransformation)\n\nreturns the factor for the function\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_fun_offset","page":"Reference of C++ interface","title":"ConicBundle.cb_get_fun_offset","text":"cb_get_fun_offset(self::CBAffineFunctionTransformation)\n\nreturns the constant offset for the funciton\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_function_factor","page":"Reference of C++ interface","title":"ConicBundle.cb_get_function_factor","text":"cb_get_function_factor(self::CBSumBundle, ft::CBFunctionTask)\n\ngets the corresponding function factor (call only if a hasbundlefor(ft)==true)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_function_minorant!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_function_minorant!","text":"cb_get_function_minorant!(self::CBAFTModel, minorant::CBMinorantPointer, aft::Union{<:CBAffineFunctionTransformation,Nothing} = nothing)\n\nsee SumBlockModel::getfunctionminorant\n\n\n\n\n\ncb_get_function_minorant!(self::CBSumModel, minorant::CBMinorantPointer, aft::Union{<:CBAffineFunctionTransformation,Nothing} = nothing)\n\nsee SumBlockModel::getfunctionminorant()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_function_status-Tuple{ConicBundle.CBMatrixCBSolver, ConicBundle.CBFunctionObject}","page":"Reference of C++ interface","title":"ConicBundle.cb_get_function_status","text":"cb_get_function_status(self::CBMatrixCBSolver, function_::CBFunctionObject)\n\n@brief Returns the return value of the latest evaluation call       to this @a function.\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_get_generating_primal","page":"Reference of C++ interface","title":"ConicBundle.cb_get_generating_primal","text":"cb_get_generating_primal(self::CBPSCAffineModification)\n\nreturns the generating primal pointer stored here (may be NULL); if getresetprimal() is true, the PSCAffineFunction should either delete its generating primal (NULL) or replace its generating primal by a clone of this one\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_generating_primal!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_generating_primal!","text":"cb_get_generating_primal!(self::CBPSCAffineFunction)\n\nreturns the current setting concerning the generation of an PSCPrimal (0 for none)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_grammatrix","page":"Reference of C++ interface","title":"ConicBundle.cb_get_grammatrix","text":"cb_get_grammatrix(self::CBGramSparsePSCPrimal)\n\nreturns the matrix \\fPf giving rise to the Gram matrix \\fPP^Tf\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_groundset","page":"Reference of C++ interface","title":"ConicBundle.cb_get_groundset","text":"cb_get_groundset(self::CBBundleSolver)\n\nreturn a pointer to the groundset\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_groundset_id","page":"Reference of C++ interface","title":"ConicBundle.cb_get_groundset_id","text":"cb_get_groundset_id(self::CBLPGroundset)\n\nreturns the current groundset_id, increased values indicate changes in the ground set\n\n\n\n\n\ncb_get_groundset_id(self::CBUnconstrainedGroundset)\n\nreturns the current groundset_id, increased values indicate changes in the ground set\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_gs_aggregate","page":"Reference of C++ interface","title":"ConicBundle.cb_get_gs_aggregate","text":"cb_get_gs_aggregate(self::CBLPGroundset)\n\nreturns the groundset aggregate computed in candidate()\n\n\n\n\n\ncb_get_gs_aggregate(self::CBUnconstrainedGroundset)\n\nreturns the groundset aggregate computed in candidate()\n\n\n\n\n\ncb_get_gs_aggregate(self::CBBundleSolver)\n\nreturns the linear term of the current groundset aggregate linear minorant\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_gs_minorant","page":"Reference of C++ interface","title":"ConicBundle.cb_get_gs_minorant","text":"cb_get_gs_minorant(self::CBLPGroundset)\n\nreturns the linear minorant valid on the entire ground set (e.g. a linear cost funciton)\n\n\n\n\n\ncb_get_gs_minorant(self::CBUnconstrainedGroundset)\n\nreturns the linear minorant valid on the entire ground set (e.g. a linear cost funciton)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_ijval","page":"Reference of C++ interface","title":"ConicBundle.cb_get_ijval","text":"cb_get_ijval(self::CBCMsingleton)\n\nreturn the nonzero entry information\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_increase_factor","page":"Reference of C++ interface","title":"ConicBundle.cb_get_increase_factor","text":"cb_get_increase_factor(self::CBSumBundleHandler)\n\nreturns the increase factor for the unbounded part of sumbundle, otherwise 1.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_infinity","page":"Reference of C++ interface","title":"ConicBundle.cb_get_infinity","text":"cb_get_infinity(self::CBMicroseconds)\n\nif true, value should be regarded as infinity\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_innerit","page":"Reference of C++ interface","title":"ConicBundle.cb_get_innerit","text":"cb_get_innerit(self::CBBundleSolver)\n\nreturns the number of bundle method iterations since the last descent step\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_iter","page":"Reference of C++ interface","title":"ConicBundle.cb_get_iter","text":"cb_get_iter(self::CBUQPSolver)\n\nreturn the number of iterations of the last solve\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_keepsize","page":"Reference of C++ interface","title":"ConicBundle.cb_get_keepsize","text":"cb_get_keepsize(self::CBPSCData)\n\nreturns keepsize\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_last_alpha!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_last_alpha!","text":"cb_get_last_alpha!(self::CBUQPConeModelBlock)\n\nget the most recent step size\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_last_weight-Tuple{ConicBundle.CBMatrixCBSolver}","page":"Reference of C++ interface","title":"ConicBundle.cb_get_last_weight","text":"cb_get_last_weight(self::CBMatrixCBSolver)\n\n@brief Returns the current weight for the quadratic term in the augmented subproblem   (may be interpreted as 1./step_size or 1./trustregion-radius).\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_get_latest_minorants!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_latest_minorants!","text":"cb_get_latest_minorants!(self::CBSOCData, latest_minorants::CBMinorantBundle, max_number::Integer)\n\nreturn the max_number latest minorants if available;\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_lbindex","page":"Reference of C++ interface","title":"ConicBundle.cb_get_lbindex","text":"cb_get_lbindex(self::CBQPSolver)\n\nreturns the indices of variable lower bounds > ConicBundle::CBminusinfinity\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_lbounds","page":"Reference of C++ interface","title":"ConicBundle.cb_get_lbounds","text":"cb_get_lbounds(self::CBMatrixCBSolver)\n\n@brief Returns a pointer to the vector of lower bounds or null if there is no such vector\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_lby","page":"Reference of C++ interface","title":"ConicBundle.cb_get_lby","text":"cb_get_lby(self::CBQPSolver)\n\nreturns the lower bounds on y\n\n\n\n\n\ncb_get_lby(self::CBLPGroundset)\n\nreturns the lower bounds vector on y if it exists\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_linear_cost","page":"Reference of C++ interface","title":"ConicBundle.cb_get_linear_cost","text":"cb_get_linear_cost(self::CBAffineFunctionTransformation)\n\nreturns the pointer to the linear term added to the funciton\n\n\n\n\n\ncb_get_linear_cost(self::CBAffineFunctionTransformation, i::Integer)\n\nreturns the value of the linear cost coefficient for @a i>=0 and for i==-1 the constant offset\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_lmin_invM1!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_lmin_invM1!","text":"cb_get_lmin_invM1!(self::CBQPKKTSubspaceHPrecond)\n\nreturn (an estimate of) the minimum eigenvalue of the preconditioner M1^{-1}; this is used, e.g., to correct the precission in MINRES\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_local_dualcost","page":"Reference of C++ interface","title":"ConicBundle.cb_get_local_dualcost","text":"cb_get_local_dualcost(self::CBUQPConeModelBlock)\n\nreturns the current local dual cost contribution\n\n\n\n\n\ncb_get_local_dualcost(self::CBUQPSumModelBlock)\n\nget joint dualcost of all subblocks\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_local_model_aggregate","page":"Reference of C++ interface","title":"ConicBundle.cb_get_local_model_aggregate","text":"cb_get_local_model_aggregate(self::CBSumBundle, aggregate::CBMinorantPointer, factor::Real = 1., aft::Union{<:CBAffineFunctionTransformation,Nothing} = nothing)\n\nget the aggregate that is due to root sumbundle parts handled here\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_local_primalcost","page":"Reference of C++ interface","title":"ConicBundle.cb_get_local_primalcost","text":"cb_get_local_primalcost(self::CBUQPConeModelBlock)\n\nreturns the current local primal cost contribution <d,s>\n\n\n\n\n\ncb_get_local_primalcost(self::CBUQPSumModelBlock)\n\nget joint primalcost of all subblocks\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_lower_bounds!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_lower_bounds!","text":"cb_get_lower_bounds!(self::CBBoxOracle)\n\n@brief returns the lower bounds vector of the box\n\n\n\n\n\ncb_get_lower_bounds!(self::CBNNCBoxSupportFunction)\n\nreturns the column vector of lower bounds\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_make_aggr_time","page":"Reference of C++ interface","title":"ConicBundle.cb_get_make_aggr_time","text":"cb_get_make_aggr_time(self::CBBundleSolver)\n\nreturn time spent in forming the model aggregate\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_map_to_old_variables","page":"Reference of C++ interface","title":"ConicBundle.cb_get_map_to_old_variables","text":"cb_get_map_to_old_variables(self::CBAFTModification)\n\nreturns null if there are no index changes, otherwise the Indexmatrix pointed to is a vector whose i-th entry holds the old index of the new i-th variable (injective!), index values exceeding old_vardim() refer to newly appended variables\n\n\n\n\n\ncb_get_map_to_old_variables(self::CBGroundsetModification)\n\nreturns null if there are no index changes, otherwise the Indexmatrix pointed to is a vector whose i-th entry holds the old index of the new i-th variable (injective!), index values exceeding old_vardim() refer to newly appended variables\n\n\n\n\n\ncb_get_map_to_old_variables(self::CBNNCBoxSupportModification)\n\nreturns null if there are no index changes, otherwise the Indexmatrix pointed to is a vector whose i-th entry holds the old index of the new i-th variable (injective!), index values exceeding old_vardim() refer to newly appended variables\n\n\n\n\n\ncb_get_map_to_old_variables(self::CBPSCAffineModification)\n\nreturns null if there are no index changes, otherwise the Indexmatrix pointed to is a vector whose i-th entry holds the old index of the new i-th variable (injective!), index values exceeding old_vardim() refer to newly appended variables\n\n\n\n\n\ncb_get_map_to_old_variables(self::CBSOCSupportModification)\n\nreturns null if there are no index changes, otherwise the Indexmatrix pointed to is a vector whose i-th entry holds the old index of the new i-th variable (injective!), index values exceeding old_vardim() refer to newly appended variables\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_maxeigval_factor","page":"Reference of C++ interface","title":"ConicBundle.cb_get_maxeigval_factor","text":"cb_get_maxeigval_factor(self::CBPSCVariableMetricSelection)\n\nreturns the parameter\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_maxit","page":"Reference of C++ interface","title":"ConicBundle.cb_get_maxit","text":"cb_get_maxit(self::CBMinRes)\n\nget maximum number of iterations\n\n\n\n\n\ncb_get_maxit(self::CBPCG)\n\nget maximum number of iterations\n\n\n\n\n\ncb_get_maxit(self::CBPsqmr)\n\nget maximum number of iterations\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_maxiter","page":"Reference of C++ interface","title":"ConicBundle.cb_get_maxiter","text":"cb_get_maxiter(self::CBUQPSolver)\n\nreturn the upper bound on interior point interations\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_mineigval_factor","page":"Reference of C++ interface","title":"ConicBundle.cb_get_mineigval_factor","text":"cb_get_mineigval_factor(self::CBPSCVariableMetricSelection)\n\nreturns the parameter\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_minorant","page":"Reference of C++ interface","title":"ConicBundle.cb_get_minorant","text":"cb_get_minorant(self::CBMinorantPointer)\n\nreturns the Minorant *this points to or 0 if empty\n\n\n\n\n\ncb_get_minorant(self::CBMinorantPointer, mat::CBMatrix, column::Integer, alpha::Real = 1., add::Bool = false, skip_fixed::Union{<:CBIndexmatrix,Nothing} = nothing, fixed_vals::Union{<:CBMatrix,Nothing} = nothing)\n\n*@brief store/add the minorant in offset and a matrix column, possibly skipping indices skip_fixed. The coordinats of the latter ones are multiplied by the given values or 0 and added to offset\n\n   The dimensions of the matrix must already fit the requirements on input.\n   If add is false (as by default), the full length of the column\n   is initialized to the gradient and filled up with zeros where needed.\n   skip_fixed and fixed_vals must both be given or both not be given.\n   If they are both given, both must have the same length.\n   If skip_fixed is given, it must have strictly increasing indices.\n   The skip part of the routine is used in implementations of BundleScaling::get_QP_costs.\n\n\n\n\n\ncb_get_minorant(self::CBMinorantPointer, mp::CBMinorantPointer, alpha::Real = 1.)\n\n*@brief store/add the minorant in/to mp, possibly scaled by alpha\n\n   If mp is empty, store it there, if mp is not empty, add it.\n\n   if *this is empty, it causes an error.\n\n\n\n\n\ncb_get_minorant(self::CBMinorantPointer, mp::CBMinorantPointer, alpha::Real, sp::Union{<:CBSparsemat,Nothing}, provided_row_indices::Union{<:CBIndexmatrix,Nothing} = nothing, needed_col_indices::Union{<:CBIndexmatrix,Nothing} = nothing, enforce_copy::Bool = false)\n\n*@brief store/add the minorant in/to mp, possibly scaled by alpha and transformed by sp, which possibly requires only the indices of providedrowindices to compute possibly only the indices in neededcolindices\n\n   If mp is empty, store it there, if mp is not empty, add it.\n\n   if sp==0, it is treated as the identity\n\n   If provided_row_indices or needed_col_indices is given, its indices must\n   be in strictly increasing order.  For sp==0 both must coincide and will\n   probably be ignored by just returning a scaled reference to *this in mp.\n\n   if *this is empty, it causes an error.\n\n\n\n\n\ncb_get_minorant(self::CBMinorantUseData)\n\nreturn the final minorant (by a recursive call) or 0 if there is none\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_mode","page":"Reference of C++ interface","title":"ConicBundle.cb_get_mode","text":"cb_get_mode(self::CBSumBundle, ft::CBFunctionTask)\n\ngets the corresponding mode (call only if a hasbundlefor(ft)==true)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_model","page":"Reference of C++ interface","title":"ConicBundle.cb_get_model","text":"cb_get_model(self::CBBundleSolver)\n\nreturn a pointer to the cutting model\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_model_aggregate","page":"Reference of C++ interface","title":"ConicBundle.cb_get_model_aggregate","text":"cb_get_model_aggregate(self::CBBundleSolver)\n\nreturns the linear term of the latest model aggregate linear minorant\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_model_aggregate!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_model_aggregate!","text":"cb_get_model_aggregate!(self::CBAFTModel, model_aggregate::CBMinorantPointer, all_parts::Bool = true, aft::Union{<:CBAffineFunctionTransformation,Nothing} = nothing)\n\nsee SumBlockModle::getmodleaggregate(CHMatrixClasses::Integer&,CHMatrixClasses::Real&,CHMatrixClasses::Matrix&,bool,bool,const AffineFunctionTransformation*)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_model_calls_delete!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_model_calls_delete!","text":"cb_get_model_calls_delete!(self::CBAffineFunctionTransformation)\n\nretruns true if the model has to delete this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_model_data","page":"Reference of C++ interface","title":"ConicBundle.cb_get_model_data","text":"cb_get_model_data(self::CBNNCData, model_minorants::CBMinorantBundle, model_coeff::CBMatrix)\n\nthe minorants currently used in the model; the list may be empty or max contain other minorants than returned in getlatestminorants(); the minorants still need to be mutliplied by function_factor\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_modeldcstr!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_modeldcstr!","text":"cb_get_modeldcstr!(self::CBQPConeModelBlock, modeldcstr::CBMatrix, startindex_constraints::Integer)\n\nset the local modeldcstr value in modeldcstr beginning with startindex (initialize it, do not add)\n\n\n\n\n\ncb_get_modeldcstr!(self::CBQPSumModelBlock, modeldcstr::CBMatrix, startindex_constraints::Integer)\n\nset the local modeldcstr value in modeldcstr beginning with startindex (initialize it, do not add)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_modeldx!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_modeldx!","text":"cb_get_modeldx!(self::CBQPConeModelBlock, modeldx::CBMatrix, startindex_model::Integer)\n\nset the local modeldx value in modeldx beginning with startindex (initialize it, do not add)\n\n\n\n\n\ncb_get_modeldx!(self::CBQPSumModelBlock, modeldx::CBMatrix, startindex_model::Integer)\n\nset the local modeldx value in modeldx beginning with startindex (initialize it, do not add)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_modeleps","page":"Reference of C++ interface","title":"ConicBundle.cb_get_modeleps","text":"cb_get_modeleps(self::CBBundleSolver)\n\nreturns the model precision @a modeleps\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_modelfails","page":"Reference of C++ interface","title":"ConicBundle.cb_get_modelfails","text":"cb_get_modelfails(self::CBBundleSolver)\n\nreturns the number of fails in model evaluatoins since the last null/descent step\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_modelfailslimit","page":"Reference of C++ interface","title":"ConicBundle.cb_get_modelfailslimit","text":"cb_get_modelfailslimit(self::CBBundleTerminator)\n\nreturns the current value of this parameter\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_modelval","page":"Reference of C++ interface","title":"ConicBundle.cb_get_modelval","text":"cb_get_modelval(self::CBBundleSolver)\n\nreturns the model value in the candidate that was used for deciding on null/descent step\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_modelx!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_modelx!","text":"cb_get_modelx!(self::CBQPConeModelBlock, modelx::CBMatrix, startindex_model::Integer)\n\nset the local modelx value in modelx beginning with startindex (initialize it, do not add)\n\n\n\n\n\ncb_get_modelx!(self::CBQPSumModelBlock, modelx::CBMatrix, startindex_model::Integer)\n\nset the local modelx value in modelx beginning with startindex (initialize it, do not add)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_modification_id","page":"Reference of C++ interface","title":"ConicBundle.cb_get_modification_id","text":"cb_get_modification_id(self::CBMinorantUseData)\n\nreturns the modification id\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_mu!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_mu!","text":"cb_get_mu!(self::CBUQPConeModelBlock)\n\nget the current barrier parameter\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_mu_info","page":"Reference of C++ interface","title":"ConicBundle.cb_get_mu_info","text":"cb_get_mu_info(self::CBQPConeModelBlock)\n\nadd dimensions of the primal-dual pairs to mudim and add the \"trace\" (the inner product with center) of the respective primal-dual pair products for the current step; update the min and max values of xi*zi\n\n\n\n\n\ncb_get_mu_info(self::CBQPSumModelBlock)\n\nadd dimensions of the primal-dual pairs to mudim and add the \"trace\" (the inner product with center) of the respective primal-dual pair products for the current step; update the min and max values of xi*zi\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_mu_stats!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_mu_stats!","text":"cb_get_mu_stats!(self::CBQPKKTSolverComparison, lbmu::Real, ubmu::Real, dims::CBIndexmatrix, mu::CBMatrix, prepsecs::CBMatrix, predsecs::CBMatrix, corrsecs::CBMatrix, predcalls::CBIndexmatrix, corrcalls::CBIndexmatrix, cond::CBMatrix, pccols::CBIndexmatrix, sysviol::CBMatrix)\n\nreturn those data columns (each a KKT system; columns are more efficient to append than lines) that fall into the given lower and upper bounds on mu\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_n_contributors","page":"Reference of C++ interface","title":"ConicBundle.cb_get_n_contributors","text":"cb_get_n_contributors(self::CBSumBundle, ft::CBFunctionTask)\n\ngets the corresponding ncontributors (call only if a hasbundle_for(ft)==true)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_n_descent_steps","page":"Reference of C++ interface","title":"ConicBundle.cb_get_n_descent_steps","text":"cb_get_n_descent_steps(self::CBMatrixCBSolver)\n\n@brief Returns the number of function descent setps\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_n_functions-Tuple{ConicBundle.CBMatrixCBSolver}","page":"Reference of C++ interface","title":"ConicBundle.cb_get_n_functions","text":"cb_get_n_functions(self::CBMatrixCBSolver)\n\n@brief Returns the current number of functions in the problem.\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_get_n_inner_iterations","page":"Reference of C++ interface","title":"ConicBundle.cb_get_n_inner_iterations","text":"cb_get_n_inner_iterations(self::CBMatrixCBSolver)\n\n@brief Returns the number of inner iterations of the bundle method\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_n_inner_updates","page":"Reference of C++ interface","title":"ConicBundle.cb_get_n_inner_updates","text":"cb_get_n_inner_updates(self::CBMatrixCBSolver)\n\n@brief Returns the number of inner multiplier updates for the box constraints\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_n_latest_minorants","page":"Reference of C++ interface","title":"ConicBundle.cb_get_n_latest_minorants","text":"cb_get_n_latest_minorants(self::CBVariableMetricSVDSelection)\n\nreturns nlatestminorants\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_n_oracle_calls","page":"Reference of C++ interface","title":"ConicBundle.cb_get_n_oracle_calls","text":"cb_get_n_oracle_calls(self::CBMatrixCBSolver)\n\n@brief Returns the number of function evaluations\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_nbh_info","page":"Reference of C++ interface","title":"ConicBundle.cb_get_nbh_info","text":"cb_get_nbh_info(self::CBQPConeModelBlock, mudim::Integer, tr_xz::Real, tr_xdzpdxz::Real, tr_dxdz::Real, nbh_ubnd::Real)\n\nfor limiting the stepsize with respect to the neighborhood this information about norms and inner products of x(.)z-trxz-trxz/mudim(.)1, x.()dz+dx(.)z-trxdzpdxz/mudim(.)1, and dx(.)dz-trdxdz/mudim(.)1 is required, each block *adds its contribution to the numbers\n\n\n\n\n\ncb_get_nbh_info(self::CBQPSumModelBlock, mudim::Integer, tr_xz::Real, tr_xdzpdxz::Real, tr_dxdz::Real, nbh_ubnd::Real)\n\nfor limiting the stepsize with respect to the neighborhood this information about norms and inner products of x(.)z-trxz-trxz/mudim(.)1, x.()dz+dx(.)z-trxdzpdxz/mudim(.)1, and dx(.)dz-trdxdz/mudim(.)1 is required, each block *adds its contribution to the numbers\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_nblocks","page":"Reference of C++ interface","title":"ConicBundle.cb_get_nblocks","text":"cb_get_nblocks(self::CBBlockPSCPrimal)\n\nreturns the number of blocks\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_new_index","page":"Reference of C++ interface","title":"ConicBundle.cb_get_new_index","text":"cb_get_new_index(self::CBSumBundleHandler, ft::CBFunctionTask)\n\nreturns the index of the newest subgradient in the bundle\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_new_vardim","page":"Reference of C++ interface","title":"ConicBundle.cb_get_new_vardim","text":"cb_get_new_vardim(self::CBAFTModification)\n\nreturns the number of variables once all stored modifications have been performed\n\n\n\n\n\ncb_get_new_vardim(self::CBGroundsetModification)\n\nreturns the number of variables once all stored modifications have been performed\n\n\n\n\n\ncb_get_new_vardim(self::CBNNCBoxSupportModification)\n\nreturns the number of variables once all stored modifications have been performed\n\n\n\n\n\ncb_get_new_vardim(self::CBPSCAffineModification)\n\nreturns the number of variables once all stored modifications have been performed\n\n\n\n\n\ncb_get_new_vardim(self::CBSOCSupportModification)\n\nreturns the number of variables once all stored modifications have been performed\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_next_weight","page":"Reference of C++ interface","title":"ConicBundle.cb_get_next_weight","text":"cb_get_next_weight(self::CBMatrixCBSolver)\n\n@brief Returns the next weight \tfor the quadratic term in the augmented subproblem       suggested by the internal weight updating heuristic\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_next_weight_set","page":"Reference of C++ interface","title":"ConicBundle.cb_get_next_weight_set","text":"cb_get_next_weight_set(self::CBBundleHKWeight)\n\ntrue if the next weight was prespecified externally\n\n\n\n\n\ncb_get_next_weight_set(self::CBBundleRQBWeight)\n\ntrue if the next weight was prespecified externally\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_nmult","page":"Reference of C++ interface","title":"ConicBundle.cb_get_nmult","text":"cb_get_nmult(self::CBMinRes)\n\nreturns the number of matrix-vector multiplications of the last call\n\n\n\n\n\ncb_get_nmult(self::CBPCG)\n\nreturns the number of matrix-vector multiplications of the last call\n\n\n\n\n\ncb_get_nmult(self::CBPsqmr)\n\nreturns the number of matrix-vector multiplications of the last call\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_nncx!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_nncx!","text":"cb_get_nncx!(self::CBQPConeModelBlock, nncx::CBMatrix, nncx_activity::Union{<:CBMatrix,Nothing} = nothing, cautious::Bool = false)\n\nget the linear part of modelx (and a guess, which of them are active, in {0.,1.})\n\n\n\n\n\ncb_get_nncx!(self::CBUQPConeModelBlock, nncx::CBMatrix, nncx_activity::Union{<:CBMatrix,Nothing} = nothing, cautious::Bool = false)\n\nget the linear part of modelx (and a guess, which of them are active, in {0.,1.})\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_nncz!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_nncz!","text":"cb_get_nncz!(self::CBUQPConeModelBlock, vecz::CBMatrix)\n\nget the current dual non negative cone point (of the solution)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_null_step","page":"Reference of C++ interface","title":"ConicBundle.cb_get_null_step","text":"cb_get_null_step(self::CBMatrixCBSolver)\n\n@brief returns true if the last evaluation of the last call to solve() resulted in a null step\nMind: if there was no (successful) evaluation, neither getdescentstep() nor getnullstep() will return true;\n\n\n\n\n\ncb_get_null_step(self::CBBundleSolver)\n\nreturns true if the latest iteration resulted in a null step (note, getdescentstep() and getnullstep() may both return false e.g. if termination occurs)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_objevallimit","page":"Reference of C++ interface","title":"ConicBundle.cb_get_objevallimit","text":"cb_get_objevallimit(self::CBBundleTerminator)\n\nreturns the current value of this parameter\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_objval-Tuple{ConicBundle.CBMatrixCBSolver}","page":"Reference of C++ interface","title":"ConicBundle.cb_get_objval","text":"cb_get_objval(self::CBMatrixCBSolver)\n\n@brief Returns the objective value resulting from last descent       step (initially undefined). If no problem modification routines       were called since then, it is the objective value at the point       returned by get_center().\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_get_offset","page":"Reference of C++ interface","title":"ConicBundle.cb_get_offset","text":"cb_get_offset(self::CBUQPSolver)\n\nreturns the constant cost offset value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_offset_append","page":"Reference of C++ interface","title":"ConicBundle.cb_get_offset_append","text":"cb_get_offset_append(self::CBPSCAffineModification)\n\nreturns null if nothing or default values have to be appended, otherwise it points to a matrix whose entries need to be appended to the right hand side lower bounds vector\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_old_X!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_old_X!","text":"cb_get_old_X!(self::CBUQPConeModelBlock, i::Integer, X::CBSymmatrix)\n\nget the previous primal positive semidefinite cone point to cone i (of the solution)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_old_Z!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_old_Z!","text":"cb_get_old_Z!(self::CBUQPConeModelBlock, i::Integer, Z::CBSymmatrix)\n\nget the previous dual positive semidefinite cone point to cone i (of the solution)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_old_mu!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_old_mu!","text":"cb_get_old_mu!(self::CBUQPConeModelBlock)\n\nget the previous barrier parameter\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_old_nncx!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_old_nncx!","text":"cb_get_old_nncx!(self::CBUQPConeModelBlock, vecx::CBMatrix)\n\nget the previous primal non negative cone point (of the solution)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_old_nncz!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_old_nncz!","text":"cb_get_old_nncz!(self::CBUQPConeModelBlock, vecz::CBMatrix)\n\nget the previous dual non negative cone point (of the solution)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_old_s!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_old_s!","text":"cb_get_old_s!(self::CBUQPConeModelBlock)\n\nget the previous slack value of the trace constraint\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_old_socx!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_old_socx!","text":"cb_get_old_socx!(self::CBUQPConeModelBlock, i::Integer, vecx::CBMatrix)\n\nget the previous primal second order cone point to cone i (of the solution)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_old_socz!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_old_socz!","text":"cb_get_old_socz!(self::CBUQPConeModelBlock, i::Integer, vecz::CBMatrix)\n\nget the previous dual second order cone point to cone i (of the solution)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_old_vardim","page":"Reference of C++ interface","title":"ConicBundle.cb_get_old_vardim","text":"cb_get_old_vardim(self::CBAFTModification)\n\nreturns the number of variables before modification\n\n\n\n\n\ncb_get_old_vardim(self::CBGroundsetModification)\n\nreturns the number of variables before modification\n\n\n\n\n\ncb_get_old_vardim(self::CBNNCBoxSupportModification)\n\nreturns the number of variables before modification\n\n\n\n\n\ncb_get_old_vardim(self::CBPSCAffineModification)\n\nreturns the number of variables before modification\n\n\n\n\n\ncb_get_old_vardim(self::CBSOCSupportModification)\n\nreturns the number of variables before modification\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_old_y!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_old_y!","text":"cb_get_old_y!(self::CBUQPConeModelBlock)\n\nget the previous dual value of the trace constraint\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_oldfactor","page":"Reference of C++ interface","title":"ConicBundle.cb_get_oldfactor","text":"cb_get_oldfactor(self::CBPSCVariableMetricSelection)\n\nreturns the parameter\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_opAt!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_opAt!","text":"cb_get_opAt!(self::CBPSCAffineFunction)\n\nreturns the row representation of the coefficient matrices    (each entry of the map represents a row by a SparseCoeffmatVector).\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_oracle_object!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_oracle_object!","text":"cb_get_oracle_object!(self::CBAFTModel)\n\nas AFTModel has no oracle of its own, this returns the dummy oracle\n\n\n\n\n\ncb_get_oracle_object!(self::CBBoxModel)\n\nreturns the oracle\n\n\n\n\n\ncb_get_oracle_object!(self::CBNNCModel)\n\nreturns the oracle\n\n\n\n\n\ncb_get_oracle_object!(self::CBPSCModel)\n\nreturns the oracle\n\n\n\n\n\ncb_get_oracle_object!(self::CBSOCModel)\n\nreturns the oracle\n\n\n\n\n\ncb_get_oracle_object!(self::CBSumModel)\n\nas AFTModel has no oracle of its own, this returns the dummy oracle\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_oraclefails","page":"Reference of C++ interface","title":"ConicBundle.cb_get_oraclefails","text":"cb_get_oraclefails(self::CBBundleSolver)\n\nreturns the number of fails in oracle evaluations since the last descent step\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_oraclefailslimit","page":"Reference of C++ interface","title":"ConicBundle.cb_get_oraclefailslimit","text":"cb_get_oraclefailslimit(self::CBBundleTerminator)\n\nreturns the current value of this parameter\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_positive","page":"Reference of C++ interface","title":"ConicBundle.cb_get_positive","text":"cb_get_positive(self::CBCMgramdense)\n\nreturns the flag on whether the Gram matrix is used in positive or negative form\n\n\n\n\n\ncb_get_positive(self::CBCMgramsparse)\n\nreturns the flag on whether the Gram matrix is used in positive or negative form\n\n\n\n\n\ncb_get_positive(self::CBCMgramsparse_withoutdiag)\n\nreturns the flag on whether the Gram matrix is used in positive or negative form\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_posteval_time","page":"Reference of C++ interface","title":"ConicBundle.cb_get_posteval_time","text":"cb_get_posteval_time(self::CBAFTModel)\n\nsee SumBlockModel::getpostevaltime()\n\n\n\n\n\ncb_get_posteval_time(self::CBSumModel)\n\nsee SumBlockModel::getpostevaltime()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_precond_rank!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_precond_rank!","text":"cb_get_precond_rank!(self::CBQPKKTSubspaceHPrecond)\n\nfor evaluation purposes with iterative solvers, return the rank of the precondiontioner used (or the number of n-vector multiplications per call)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_preeval_time","page":"Reference of C++ interface","title":"ConicBundle.cb_get_preeval_time","text":"cb_get_preeval_time(self::CBAFTModel)\n\nsee SumBlockModel::getpreevaltime()\n\n\n\n\n\ncb_get_preeval_time(self::CBSumModel)\n\nsee SumBlockModel::getpreevaltime()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_primal","page":"Reference of C++ interface","title":"ConicBundle.cb_get_primal","text":"cb_get_primal(self::CBMinorant)\n\nreturns NULL if there is no primal data and otherwise a pointer to it (const version)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_primal!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_primal!","text":"cb_get_primal!(self::CBMinorantPointer)\n\nreturns the primal of the Minorant *this points to or 0 if empty (first carrying out any pending scalings on the minorant)\n\n\n\n\n\ncb_get_primal!(self::CBMinorant)\n\nreturns NULL if there is no primal data and otherwise a pointer to it\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_primaleigs","page":"Reference of C++ interface","title":"ConicBundle.cb_get_primaleigs","text":"cb_get_primaleigs(self::CBPSCData)\n\nreturns primaleigs\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_primalval","page":"Reference of C++ interface","title":"ConicBundle.cb_get_primalval","text":"cb_get_primalval(self::CBUQPSolver)\n\nreturn the primal objective value (lower bound) of the last solve\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_primalvecs","page":"Reference of C++ interface","title":"ConicBundle.cb_get_primalvecs","text":"cb_get_primalvecs(self::CBPSCData)\n\nreturns primalvecs\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_prob_stats!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_prob_stats!","text":"cb_get_prob_stats!(self::CBQPKKTSolverComparison, dims::CBIndexmatrix, iterations::CBIndexmatrix, lastmu::CBMatrix, prepsecs::CBMatrix, predsecs::CBMatrix, corrsecs::CBMatrix, predcalls::CBIndexmatrix, corrcalls::CBIndexmatrix)\n\nreturn one data column per subproblem (more efficient to append than lines) with the sum of the time/calls/etc.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_prox","page":"Reference of C++ interface","title":"ConicBundle.cb_get_prox","text":"cb_get_prox(self::CBMatrixCBSolver)\n\n@brief Returns the pointer to the current prox term of the bundle solver\n\n\n\n\n\ncb_get_prox(self::CBBundleSolver)\n\nreturn a pointer to the quadratic term of the proximal term\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_pscx!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_pscx!","text":"cb_get_pscx!(self::CBQPConeModelBlock, i::Integer, pscx_eigs::CBMatrix, pscx_vecs::CBMatrix, pscx_primalgrowth::CBMatrix, pscx_dualgrowth::CBMatrix)\n\nget the PSC part of modelx (and a guess on the rank of the active part)\n\n\n\n\n\ncb_get_pscx!(self::CBUQPConeModelBlock, i::Integer, pscx_eigs::CBMatrix, pscx_vecs::CBMatrix, pscx_primalgrowth::CBMatrix, pscx_dualgrowth::CBMatrix)\n\nget the PSC part of modelx (and a guess on the rank of the active part)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_qp_solver!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_qp_solver!","text":"cb_get_qp_solver!(self::CBLPGroundset, solves_model_without_gs::Bool, Hp::Union{<:CBBundleProxObject,Nothing})\n\nreturns a pointer to an internal QPSolverObject that is able to solve bundle suproblems efficiently for this kind of groundset and scaling; if solvesmodelwithout_gs == true the qp solver does not include the groundset and the groundset has to be dealt with by the Gauss Seidel approach\n\n\n\n\n\ncb_get_qp_solver!(self::CBUnconstrainedGroundset, solves_model_without_gs::Bool, Hp::Union{<:CBBundleProxObject,Nothing})\n\nreturns a pointer to an internal QPSolverObject that is able to solve bundle suproblems efficiently for this kind of groundset and scaling; if solvesmodelwithout_gs == true the qp solver does not include the groundset and the groundset has to be dealt with by the Gauss Seidel approach\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_qpfails","page":"Reference of C++ interface","title":"ConicBundle.cb_get_qpfails","text":"cb_get_qpfails(self::CBBundleSolver)\n\nreturns the number of fails in qp subproblems since the last null/descent step\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_qpfailslimit","page":"Reference of C++ interface","title":"ConicBundle.cb_get_qpfailslimit","text":"cb_get_qpfailslimit(self::CBBundleTerminator)\n\nreturns the current value of this parameter\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_recomp","page":"Reference of C++ interface","title":"ConicBundle.cb_get_recomp","text":"cb_get_recomp(self::CBBundleSolver)\n\nreturns the number of oracle reevaluations for the center due to numerical problems since the last descent step\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_recomplimit","page":"Reference of C++ interface","title":"ConicBundle.cb_get_recomplimit","text":"cb_get_recomplimit(self::CBBundleTerminator)\n\nreturns the current value of this parameter\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_reset_primal","page":"Reference of C++ interface","title":"ConicBundle.cb_get_reset_primal","text":"cb_get_reset_primal(self::CBPSCAffineModification)\n\nreturns true if the generating primal is to be replaced by the one stored here\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_residual_norm","page":"Reference of C++ interface","title":"ConicBundle.cb_get_residual_norm","text":"cb_get_residual_norm(self::CBMinRes)\n\nreturns the residual norm of last call\n\n\n\n\n\ncb_get_residual_norm(self::CBPCG)\n\nreturns the residual norm of last call\n\n\n\n\n\ncb_get_residual_norm(self::CBPsqmr)\n\nreturns the residual norm of last call\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_ret_code","page":"Reference of C++ interface","title":"ConicBundle.cb_get_ret_code","text":"cb_get_ret_code(self::CBBoxModel)\n\nsee SumBlockModel::getretcode()\n\n\n\n\n\ncb_get_ret_code(self::CBNNCModel)\n\nsee SumBlockModel::getretcode()\n\n\n\n\n\ncb_get_ret_code(self::CBPSCModel)\n\nsee SumBlockModel::getretcode()\n\n\n\n\n\ncb_get_ret_code(self::CBSOCModel)\n\nsee SumBlockModel::getretcode()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_rhslb","page":"Reference of C++ interface","title":"ConicBundle.cb_get_rhslb","text":"cb_get_rhslb(self::CBQPSolver)\n\nreturns the constraint lower bounds\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_rhslbind","page":"Reference of C++ interface","title":"ConicBundle.cb_get_rhslbind","text":"cb_get_rhslbind(self::CBQPSolver)\n\nreturns the indices with constraint lower bound slacks\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_rhsub","page":"Reference of C++ interface","title":"ConicBundle.cb_get_rhsub","text":"cb_get_rhsub(self::CBQPSolver)\n\nreturns the constraint upper bounds\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_rhsubind","page":"Reference of C++ interface","title":"ConicBundle.cb_get_rhsubind","text":"cb_get_rhsubind(self::CBQPSolver)\n\nreturns the indices with constraint upper bound slacks\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_rowindex","page":"Reference of C++ interface","title":"ConicBundle.cb_get_rowindex","text":"cb_get_rowindex(self::CBSparsemat)\n\nreturns the index vector of the row representation holding the column index for each element\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_rowinfo","page":"Reference of C++ interface","title":"ConicBundle.cb_get_rowinfo","text":"cb_get_rowinfo(self::CBSparsemat)\n\nreturns information on nonzero rows, k by 3, listing: index, %#nonzeros, first index in rowindex/rowval\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_rowval","page":"Reference of C++ interface","title":"ConicBundle.cb_get_rowval","text":"cb_get_rowval(self::CBSparsemat)\n\nreturns the value vector of the row representation holding the value for each element\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_s!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_s!","text":"cb_get_s!(self::CBUQPConeModelBlock)\n\nget the current slack value of the trace constraint\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_scalefactor","page":"Reference of C++ interface","title":"ConicBundle.cb_get_scalefactor","text":"cb_get_scalefactor(self::CBCoeffmatInfo)\n\nreturns the scale factor\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_selection_method","page":"Reference of C++ interface","title":"ConicBundle.cb_get_selection_method","text":"cb_get_selection_method(self::CBPSCVariableMetricSelection)\n\nreturns selection_method\n\n\n\n\n\ncb_get_selection_method(self::CBVariableMetricSVDSelection)\n\nreturns selection_method\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_sgnorm-Tuple{ConicBundle.CBMatrixCBSolver}","page":"Reference of C++ interface","title":"ConicBundle.cb_get_sgnorm","text":"cb_get_sgnorm(self::CBMatrixCBSolver)\n\n@brief Returns Euclidean norm of the latest aggregate subgradient.\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_get_shallowcut","page":"Reference of C++ interface","title":"ConicBundle.cb_get_shallowcut","text":"cb_get_shallowcut(self::CBBundleSolver)\n\nreturns the number of oracle evaluations that returned an epsilon subgradient that improved the model by a dangerously small amount (mostly this is due to solving the QP subproblems only approximately)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_skip_extension","page":"Reference of C++ interface","title":"ConicBundle.cb_get_skip_extension","text":"cb_get_skip_extension(self::CBPSCAffineModification)\n\nreturns true if the generating primal is to be replaced by the one stored here\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_skippedsize","page":"Reference of C++ interface","title":"ConicBundle.cb_get_skippedsize","text":"cb_get_skippedsize(self::CBPSCData)\n\nreturns skippedsize\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_socdim!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_socdim!","text":"cb_get_socdim!(self::CBSOCSupportFunction)\n\nreturns the dimension of the second order cone\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_socx!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_socx!","text":"cb_get_socx!(self::CBQPConeModelBlock, i::Integer, socx::CBMatrix, socx_activity::Union{<:AbstractVector{Cdouble},Nothing}, cautious::Bool = false)\n\nget the SOC part of modelx (and a guess whether the entire cone is active\n\n\n\n\n\ncb_get_socx!(self::CBUQPConeModelBlock, i::Integer, socx::CBMatrix, socx_activity::Union{<:AbstractVector{Cdouble},Nothing}, cautious::Bool = false)\n\nget the SOC part of modelx (and a guess whether the entire cone is active\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_socz!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_socz!","text":"cb_get_socz!(self::CBUQPConeModelBlock, i::Integer, vecz::CBMatrix)\n\nget the current dual second order cone point to cone i (of the solution)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_starting_point","page":"Reference of C++ interface","title":"ConicBundle.cb_get_starting_point","text":"cb_get_starting_point(self::CBLPGroundset)\n\nreturns a stored starting point, note: this need not be feasible; if generated automatically, its dimension is correct.\n\n\n\n\n\ncb_get_starting_point(self::CBUnconstrainedGroundset)\n\nreturns a stored starting point, note: this need not be feasible; if generated automatically, its dimension is correct.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_status","page":"Reference of C++ interface","title":"ConicBundle.cb_get_status","text":"cb_get_status(self::CBUQPSolver)\n\nreturn the status of the last solve\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_store","page":"Reference of C++ interface","title":"ConicBundle.cb_get_store","text":"cb_get_store(self::CBMatrix)\n\nreturns the current address of the internal value array; use cautiously!\n\n\n\n\n\ncb_get_store(self::CBIndexmatrix)\n\nreturns the current address of the internal value array; use cautiously!\n\n\n\n\n\ncb_get_store(self::CBSymmatrix)\n\nreturns the current address of the internal value array; use cautiously!\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_subgradient-Tuple{ConicBundle.CBMatrixCBSolver, ConicBundle.CBMatrix}","page":"Reference of C++ interface","title":"ConicBundle.cb_get_subgradient","text":"cb_get_subgradient(self::CBMatrixCBSolver, subgradient::CBMatrix)\n\n@brief Returns the latest aggregate subgradient (of the entire problem with groundset as provided by the solver)\n@return     - 0 on success     - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_get_sumaugvalfails","page":"Reference of C++ interface","title":"ConicBundle.cb_get_sumaugvalfails","text":"cb_get_sumaugvalfails(self::CBBundleSolver)\n\nreturns the number of failures to increase the augmented model value since the last clear() or clear_fails()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_sumbundle","page":"Reference of C++ interface","title":"ConicBundle.cb_get_sumbundle","text":"cb_get_sumbundle(self::CBSumBundleHandler)\n\nreturns the sumbundle\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_suminnerit","page":"Reference of C++ interface","title":"ConicBundle.cb_get_suminnerit","text":"cb_get_suminnerit(self::CBBundleSolver)\n\nreturns the number of bundle method itrations since the last clear()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_summodelfails","page":"Reference of C++ interface","title":"ConicBundle.cb_get_summodelfails","text":"cb_get_summodelfails(self::CBBundleSolver)\n\nreturns the number of fails in model evaluations since the last clear() or clear_fails()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_sumoraclefails","page":"Reference of C++ interface","title":"ConicBundle.cb_get_sumoraclefails","text":"cb_get_sumoraclefails(self::CBBundleSolver)\n\nreturns the number of fails in oracle evaluations since the last clear() or clear_fails()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_sumqpfails","page":"Reference of C++ interface","title":"ConicBundle.cb_get_sumqpfails","text":"cb_get_sumqpfails(self::CBBundleSolver)\n\nreturns the number of fails in qp subproblems since the last clear() or clear_fails()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_sumrecomp","page":"Reference of C++ interface","title":"ConicBundle.cb_get_sumrecomp","text":"cb_get_sumrecomp(self::CBBundleSolver)\n\nreturns the number of oracle reevaluations for the center due to numerical problems since the last clear() or clear_fails()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_sumupdatecnt","page":"Reference of C++ interface","title":"ConicBundle.cb_get_sumupdatecnt","text":"cb_get_sumupdatecnt(self::CBBundleSolver)\n\nreturns the number of model qp subproblems since the last clear()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_suppcol","page":"Reference of C++ interface","title":"ConicBundle.cb_get_suppcol","text":"cb_get_suppcol(self::CBSparsesym)\n\nreturns the vector listing in ascending order the original column indices of the principal support submatrix\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_suppind","page":"Reference of C++ interface","title":"ConicBundle.cb_get_suppind","text":"cb_get_suppind(self::CBSparsesym)\n\nreturns the index vector of the column representation holding the row index w.r.t. the principal support submatrix for each element\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_sysviol_constraints!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_sysviol_constraints!","text":"cb_get_sysviol_constraints!(self::CBQPConeModelBlock, constrvec::CBMatrix, startindex_constr::Integer)\n\nset the constraint violation for the current system solution starting at this index\n\n\n\n\n\ncb_get_sysviol_constraints!(self::CBQPSumModelBlock, constrvec::CBMatrix, startindex_constr::Integer)\n\nset the constraint violation for the current system solution starting at this index\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_sysviol_model!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_sysviol_model!","text":"cb_get_sysviol_model!(self::CBQPConeModelBlock, modelvec::CBMatrix, startindex_model::Integer, y_plus_dy::CBMatrix, global_bundle::CBMinorantBundle, startindex_bundle::Integer)\n\nset the model violation for the current system solution\n\n\n\n\n\ncb_get_sysviol_model!(self::CBQPSumModelBlock, modelvec::CBMatrix, startindex_model::Integer, dy::CBMatrix, global_bundle::CBMinorantBundle, startindex_bundle::Integer)\n\nset the model violation for the current system solution\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_t_precond_mult!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_t_precond_mult!","text":"cb_get_t_precond_mult!(self::CBQPKKTSubspaceHPrecond)\n\nfor evaluation purposes with iterative solvers, return the time spent in the multiplication with\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_term_corr","page":"Reference of C++ interface","title":"ConicBundle.cb_get_term_corr","text":"cb_get_term_corr(self::CBBundleDenseTrustRegionProx)\n\nreturns a correction factor for termination precision if the quadratic term is strong\n\n\n\n\n\ncb_get_term_corr(self::CBBundleDiagonalTrustRegionProx)\n\nreturns a correction factor for termination precision if the quadratic term is strong\n\n\n\n\n\ncb_get_term_corr(self::CBBundleDLRTrustRegionProx)\n\nreturns a correction factor for termination precision if the quadratic term is strong\n\n\n\n\n\ncb_get_term_corr(self::CBBundleIdProx)\n\nreturns the correction factor for the termination criterion, here min(1,1/weight)\n\n\n\n\n\ncb_get_term_corr(self::CBBundleLowRankTrustRegionProx)\n\nreturns a correction factor for termination precision if the quadratic term is strong\n\n\n\n\n\ncb_get_term_corr(self::CBBundleSolver)\n\nreturns the correction factor used in the termination criterion to compensate the strength of the proximal term\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_termeps","page":"Reference of C++ interface","title":"ConicBundle.cb_get_termeps","text":"cb_get_termeps(self::CBUQPSolver)\n\nreturn the termination precision\n\n\n\n\n\ncb_get_termeps(self::CBBundleTerminator)\n\nreturns the current termination precision\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_terminate","page":"Reference of C++ interface","title":"ConicBundle.cb_get_terminate","text":"cb_get_terminate(self::CBBundleSolver)\n\nreturns the value of the last call to BundleTerminator::check_termination()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_terminated","page":"Reference of C++ interface","title":"ConicBundle.cb_get_terminated","text":"cb_get_terminated(self::CBBundleTerminator)\n\nreturn the termination code returned in the last call to check_termination()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_terminator","page":"Reference of C++ interface","title":"ConicBundle.cb_get_terminator","text":"cb_get_terminator(self::CBBundleSolver)\n\nreturn a pointer to the termination criterion\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_termprec","page":"Reference of C++ interface","title":"ConicBundle.cb_get_termprec","text":"cb_get_termprec(self::CBMinRes)\n\nreturn the (absolute) precision requirement for termination used in the last call\n\n\n\n\n\ncb_get_termprec(self::CBPCG)\n\nreturn the (absolute) precision requirement for termination used in the last call\n\n\n\n\n\ncb_get_termprec(self::CBPsqmr)\n\nreturn the (absolute) precision requirement for termination used in the last call\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_timelimit","page":"Reference of C++ interface","title":"ConicBundle.cb_get_timelimit","text":"cb_get_timelimit(self::CBBundleTerminator)\n\nreturns the timelimit value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_topvecs","page":"Reference of C++ interface","title":"ConicBundle.cb_get_topvecs","text":"cb_get_topvecs(self::CBPSCData)\n\nreturns topvecs\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_trace!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_trace!","text":"cb_get_trace!(self::CBQPConeModelBlock)\n\nget the right hand side of the trace constraint\n\n\n\n\n\ncb_get_trace!(self::CBUQPConeModelBlock)\n\nget the right hand side of the trace constraint\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_ubindex","page":"Reference of C++ interface","title":"ConicBundle.cb_get_ubindex","text":"cb_get_ubindex(self::CBQPSolver)\n\nreturns the indices of variable lower bounds < ConicBundle::CBplusinfinity\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_ubounds","page":"Reference of C++ interface","title":"ConicBundle.cb_get_ubounds","text":"cb_get_ubounds(self::CBMatrixCBSolver)\n\n@brief Returns a pointer to the vector of upper bounds or null if there is no such vector\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_uby","page":"Reference of C++ interface","title":"ConicBundle.cb_get_uby","text":"cb_get_uby(self::CBQPSolver)\n\nreturns the upper bounds on y\n\n\n\n\n\ncb_get_uby(self::CBLPGroundset)\n\nreturns the upper bounds vector on y if it exists\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_upper_bounds!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_upper_bounds!","text":"cb_get_upper_bounds!(self::CBBoxOracle)\n\n@brief returns the upper bounds vector of the box\n\n\n\n\n\ncb_get_upper_bounds!(self::CBNNCBoxSupportFunction)\n\nretunrs the column vector of upper bounds\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_use_linval","page":"Reference of C++ interface","title":"ConicBundle.cb_get_use_linval","text":"cb_get_use_linval(self::CBBundleSolver)\n\nreturns true if the aggregate linear minorant is used for the model value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_use_variable_metric","page":"Reference of C++ interface","title":"ConicBundle.cb_get_use_variable_metric","text":"cb_get_use_variable_metric(self::CBBundleSolver)\n\nreturns the value of the variable @a dodynamicscaling, see there\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_use_yfixing","page":"Reference of C++ interface","title":"ConicBundle.cb_get_use_yfixing","text":"cb_get_use_yfixing(self::CBLPGroundset)\n\ntrue if the cooridinate fixing heuristic is switched on (only constrained cases)\n\n\n\n\n\ncb_get_use_yfixing(self::CBUnconstrainedGroundset)\n\ntrue if the cooridinate fixing heuristic is switched on (only constrained cases)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_var_append","page":"Reference of C++ interface","title":"ConicBundle.cb_get_var_append","text":"cb_get_var_append(self::CBPSCAffineModification)\n\nreturns null if nothing or default values have to be appended, otherwise it points to a sparse matrix whose columns need to be appended to the matrix\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_variable_metric_selection","page":"Reference of C++ interface","title":"ConicBundle.cb_get_variable_metric_selection","text":"cb_get_variable_metric_selection(self::CBLPGroundset)\n\ndelete old selector and set a new one (0 is allowed resulting in no local selector)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_weight","page":"Reference of C++ interface","title":"ConicBundle.cb_get_weight","text":"cb_get_weight(self::CBBundleHKWeight)\n\nreturns current value of the weight\n\n\n\n\n\ncb_get_weight(self::CBBundleRQBWeight)\n\nreturns current value of the weight\n\n\n\n\n\ncb_get_weight(self::CBBundleSolver)\n\nreturns the weight for the proximal term used in the last quadratic subproblem\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_weightu","page":"Reference of C++ interface","title":"ConicBundle.cb_get_weightu","text":"cb_get_weightu(self::CBBundleDenseTrustRegionProx)\n\nreturns the current weight of the proximal term\n\n\n\n\n\ncb_get_weightu(self::CBBundleDiagonalTrustRegionProx)\n\nreturns the current weight of the proximal term\n\n\n\n\n\ncb_get_weightu(self::CBBundleDLRTrustRegionProx)\n\nreturns the current weight in use\n\n\n\n\n\ncb_get_weightu(self::CBBundleIdProx)\n\nreturns the current weight of the proximal term\n\n\n\n\n\ncb_get_weightu(self::CBBundleLowRankTrustRegionProx)\n\nreturns the current weight in use\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_x!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_x!","text":"cb_get_x!(self::CBUQPSolver)\n\nreturn the joint model vector (primal solution) produced by the last solve\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_y!","page":"Reference of C++ interface","title":"ConicBundle.cb_get_y!","text":"cb_get_y!(self::CBUQPSolver)\n\nreturn the joint dual vector (dual solution) produced by the last solve\n\n\n\n\n\ncb_get_y!(self::CBUQPConeModelBlock)\n\nget the current dual value of the trace constraint\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_get_yfixed","page":"Reference of C++ interface","title":"ConicBundle.cb_get_yfixed","text":"cb_get_yfixed(self::CBLPGroundset)\n\nif not NULL (iff getuseyfixing()==false) it returns the vector yfixed with yfixed(i)=0 if not fixed, =1 is fixed already, =2 if newly fixed\n\n\n\n\n\ncb_get_yfixed(self::CBUnconstrainedGroundset)\n\nif not NULL (iff getuseyfixing()==false) it returns the vector yfixed with yfixed(i)=0 if not fixed, =1 is fixed already, =2 if newly fixed\n\n\n\n\n\ncb_get_yfixed(self::CBBundleSolver)\n\nif the groundset has constraints and setdoyfixing was set with true enty i of the returned matrix is !=0 if the coordinate was fixed at one of its bounds and 0 if the coordinate is still free\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_gramip","page":"Reference of C++ interface","title":"ConicBundle.cb_gramip","text":"cb_gramip(self::CBCMgramdense, P::CBMatrix)\n\nreturns ip(this,PP^T)=trace P^T(this)P\n\n\n\n\n\ncb_gramip(self::CBCMgramdense, P::CBMatrix, start_row::Integer, Lam::Union{<:CBMatrix,Nothing} = nothing)\n\nreturns ip(this,QQ^T)=trace Q^T(this)Q for Q=P.rows(startrow,startrow+dim-1)\n\n\n\n\n\ncb_gramip(self::CBCMgramsparse, P::CBMatrix)\n\nreturns ip(this,PP^T)=trace P^T(this)P\n\n\n\n\n\ncb_gramip(self::CBCMgramsparse, P::CBMatrix, start_row::Integer, Lam::Union{<:CBMatrix,Nothing} = nothing)\n\nreturns ip(this,QQ^T)=trace Q^T(this)Q for Q=P.rows(startrow,startrow+dim-1)\n\n\n\n\n\ncb_gramip(self::CBCMgramsparse_withoutdiag, P::CBMatrix)\n\nreturns ip(this,PP^T)=trace P^T(this)P\n\n\n\n\n\ncb_gramip(self::CBCMgramsparse_withoutdiag, P::CBMatrix, start_row::Integer, Lam::Union{<:CBMatrix,Nothing} = nothing)\n\nreturns ip(this,QQ^T)=trace Q^T(this)Q for Q=P.rows(startrow,startrow+dim-1)\n\n\n\n\n\ncb_gramip(self::CBCMlowrankdd, P::CBMatrix)\n\nreturns ip(this,PP^T)=trace P^T(this)P\n\n\n\n\n\ncb_gramip(self::CBCMlowrankdd, P::CBMatrix, start_row::Integer, Lam::Union{<:CBMatrix,Nothing} = nothing)\n\nreturns ip(this,QQ^T)=trace Q^T(this)Q for Q=P.rows(startrow,startrow+dim-1)\n\n\n\n\n\ncb_gramip(self::CBCMlowranksd, P::CBMatrix)\n\nreturns ip(this,PP^T)=trace P^T(this)P\n\n\n\n\n\ncb_gramip(self::CBCMlowranksd, P::CBMatrix, start_row::Integer, Lam::Union{<:CBMatrix,Nothing} = nothing)\n\nreturns ip(this,QQ^T)=trace Q^T(this)Q for Q=P.rows(startrow,startrow+dim-1)\n\n\n\n\n\ncb_gramip(self::CBCMlowrankss, P::CBMatrix)\n\nreturns ip(this,PP^T)=trace P^T(this)P\n\n\n\n\n\ncb_gramip(self::CBCMlowrankss, P::CBMatrix, start_row::Integer, Lam::Union{<:CBMatrix,Nothing} = nothing)\n\nreturns ip(this,QQ^T)=trace Q^T(this)Q for Q=P.rows(startrow,startrow+dim-1)\n\n\n\n\n\ncb_gramip(self::CBCMsingleton, P::CBMatrix)\n\nreturns ip(this,PP^T)=trace P^T(this)P\n\n\n\n\n\ncb_gramip(self::CBCMsingleton, P::CBMatrix, start_row::Integer, Lam::Union{<:CBMatrix,Nothing} = nothing)\n\nreturns ip(this,QQ^T)=trace Q^T(this)Q for Q=P.rows(startrow,startrow+dim-1)\n\n\n\n\n\ncb_gramip(self::CBCMsymdense, P::CBMatrix)\n\nreturns ip(this,PP^T)=trace P^T(this)P\n\n\n\n\n\ncb_gramip(self::CBCMsymdense, P::CBMatrix, start_row::Integer, Lam::Union{<:CBMatrix,Nothing} = nothing)\n\nreturns ip(this,QQ^T)=trace Q^T(this)Q for Q=P.rows(startrow,startrow+dim-1)\n\n\n\n\n\ncb_gramip(self::CBCMsymsparse, P::CBMatrix)\n\nreturns ip(this,PP^T)=trace P^T(this)P\n\n\n\n\n\ncb_gramip(self::CBCMsymsparse, P::CBMatrix, start_row::Integer, Lam::Union{<:CBMatrix,Nothing} = nothing)\n\nreturns ip(this,QQ^T)=trace Q^T(this)Q for Q=P.rows(startrow,startrow+dim-1)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_groundset_changes_suffice_for_identity!","page":"Reference of C++ interface","title":"ConicBundle.cb_groundset_changes_suffice_for_identity!","text":"cb_groundset_changes_suffice_for_identity!(self::CBAFTModification)\n\nreturns true if for an AFT with argtrafo==0 the changes in the ground set reflect all modifications\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_guess_curvature","page":"Reference of C++ interface","title":"ConicBundle.cb_guess_curvature","text":"cb_guess_curvature(self::CBSumBundleHandler, mnrts::CBMinorantBundle, selected_indices::CBIndexmatrix, cand_id::Integer, cand_y::CBMatrix, model_maxviol::Real)\n\ncomputes an estimate of the current curvature to support SumModel in the selection of submodles\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_handles!","page":"Reference of C++ interface","title":"ConicBundle.cb_handles!","text":"cb_handles!(self::CBSumBundleHandler, ft::CBFunctionTask)\n\nreturns true if this FunctionTask is handled\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_has_bundle_data","page":"Reference of C++ interface","title":"ConicBundle.cb_has_bundle_data","text":"cb_has_bundle_data(self::CBSumBundle)\n\nreturns true if BData exists\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_has_bundle_for","page":"Reference of C++ interface","title":"ConicBundle.cb_has_bundle_for","text":"cb_has_bundle_for(self::CBSumBundle, ft::CBFunctionTask)\n\nreturns true if BData exists for this mode\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_has_contributions","page":"Reference of C++ interface","title":"ConicBundle.cb_has_contributions","text":"cb_has_contributions(self::CBSumBundle)\n\nreturns true if one of its parts is a child\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_has_roots","page":"Reference of C++ interface","title":"ConicBundle.cb_has_roots","text":"cb_has_roots(self::CBSumBundle)\n\nreturns true if one of its parts is a root\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_has_working_roots","page":"Reference of C++ interface","title":"ConicBundle.cb_has_working_roots","text":"cb_has_working_roots(self::CBSumBundle)\n\nreturns true if one of its parts is a root with n_contributors>0\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_hhmmss","page":"Reference of C++ interface","title":"ConicBundle.cb_hhmmss","text":"cb_hhmmss(self::CBMicroseconds)\n\nconvert and store the value of (*this) to hours, minutes, seconds\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_hhmmssdd","page":"Reference of C++ interface","title":"ConicBundle.cb_hhmmssdd","text":"cb_hhmmssdd(self::CBMicroseconds)\n\nconvert and store the value of (*this) to hours, minutes, seconds, hundredths\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_house","page":"Reference of C++ interface","title":"ConicBundle.cb_house","text":"cb_house(A::CBMatrix, i::Integer, j::Integer, tol::Real)\n\nreturns the Householder vector of size A.rowdim() for the subcolumn A(i:A.rowdim(),j)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_ignore_groundset_modification","page":"Reference of C++ interface","title":"ConicBundle.cb_ignore_groundset_modification","text":"cb_ignore_groundset_modification(self::CBAFTModification)\n\nreturns true if groundset_modifications should be ignored\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_incorporate!","page":"Reference of C++ interface","title":"ConicBundle.cb_incorporate!","text":"cb_incorporate!(self::CBAFTModification, m::CBAFTModification)\n\nincorporate the AFTModification @a m into this one; after factor and offset are dealt with it calls Modification::incorporate\n\n\n\n\n\ncb_incorporate!(self::CBAFTModification, m::CBOracleModification)\n\nincorporate the OracleModification @a m (it should only contain variable changes, but this is not checked!) into this one; calls Modification::incorporate\n\n\n\n\n\ncb_incorporate!(self::CBGroundsetModification, m::CBOracleModification)\n\nincorporate the OracleModification @a m (it should only contain variable changes, but this is not checked!) into this one; calls Modification::incorporate\n\n\n\n\n\ncb_incorporate!(self::CBNNCBoxSupportModification, m::CBOracleModification)\n\nincorporate the OracleModification @a m (it should only contain variable changes, but this is not checked!) into this one; calls Modification::incorporate\n\n\n\n\n\ncb_incorporate!(self::CBPSCAffineModification, m::CBOracleModification)\n\n@brief add the modification specified in @a m on top of       the modifications collected so far\n  If m is in fact an PSCAffineModification,\n  the old_vardim() of modification @a m must be\n  identical to new_vardim() of this and\n  old_rowdim() of modification @a m must be identical to\n  new_rodim() of this.  The return value is the number of\n  errors in this respect. If such occured, this incorporation\n  is not performed.\n\n  A general OracleModification @a m should only contain variable\n  changes (this is not checked) and appending variables appends\n  zero blocks.\n\n\n\n\n\ncb_incorporate!(self::CBSOCSupportModification, m::CBOracleModification)\n\nincorporate the OracleModification @a m (it should only contain variable changes, but this is not checked!) into this one; calls Modification::incorporate\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_init!","page":"Reference of C++ interface","title":"ConicBundle.cb_init!","text":"cb_init!(self::CBMatrix, A::CBMatrix, d::Real = 1., atrans::Integer = 0)\n\ninitialize to this=Ad where A may be transposed\n\n\n\n\n\ncb_init!(self::CBMatrix, A::CBIndexmatrix, d::Real = 1.)\n\ninitialize to this=Ad\n\n\n\n\n\ncb_init!(self::CBMatrix, A::CBSparsemat, d::Real = 1.)\n\ninitialize to this=Ad\n\n\n\n\n\ncb_init!(self::CBMatrix, S::CBSymmatrix, d::Real = 1.)\n\ninitialize to this=Ad\n\n\n\n\n\ncb_init!(self::CBMatrix, param0::CBSparsesym, d::Real = 1.)\n\ninitialize to this=Ad\n\n\n\n\n\ncb_init!(self::CBMatrix, param0::AbstractRange{<:Real}, param0_tol::Real = 1e-8)\n\ninitialize *this to a column vector holding the elements of Realrange\n\n\n\n\n\ncb_init!(self::CBMatrix, nr::Integer, nc::Integer, d::Real)\n\nintialize *this to a matrix of size nr x nc initializing all elements to the value d\n\n\n\n\n\ncb_init!(self::CBMatrix, nr::Integer, nc::Integer, dp::Union{<:AbstractVector{Cdouble},Nothing}, d::Real = 1.)\n\ngenerate a matrix of size nr x nc initializing the elements from the (one dimensional) array dp with increment incr and scaled by d\n\n\n\n\n\ncb_init!(self::CBIndexmatrix, A::CBIndexmatrix, d::Integer = 1)\n\ninitialize to this=Ad\n\n\n\n\n\ncb_init!(self::CBIndexmatrix, param0::AbstractRange{<:Integer})\n\ninitialize *this to a column vector holding the indices of #CHMatrixClasses::Range\n\n\n\n\n\ncb_init!(self::CBIndexmatrix, nr::Integer, nc::Integer, d::Integer)\n\nintialize *this to a matrix of size nr x nc initializing all elements to the value d\n\n\n\n\n\ncb_init!(self::CBIndexmatrix, nr::Integer, nc::Integer, dp::Union{<:AbstractVector{Cint},Nothing})\n\ngenerate a matrix of size nr x nc initializing the elements from the (one dimensional) array dp with increment incr\n\n\n\n\n\ncb_init!(self::CBSparsemat, A::CBSparsemat, d::Real = 1.)\n\ninitialize to this=Ad\n\n\n\n\n\ncb_init!(self::CBSparsemat, A::CBMatrix, d::Real = 1.)\n\ninitialize to this=Ad, abs(values)<tol are removed from the support\n\n\n\n\n\ncb_init!(self::CBSparsemat, A::CBIndexmatrix, d::Real = 1.)\n\ninitialize to this=Ad, zeros are removed from the support\n\n\n\n\n\ncb_init!(self::CBSparsemat, param0::CBSymmatrix, d::Real = 1.)\n\ninitialize to this=Ad, abs(values)<tol are removed from the support\n\n\n\n\n\ncb_init!(self::CBSparsemat, param0::CBSparsesym, d::Real = 1.)\n\ninitialize to this=Ad\n\n\n\n\n\ncb_init!(self::CBSparsemat, nr::Integer, nc::Integer)\n\ninitialize to zero-matrix of size nr*nc\n\n\n\n\n\ncb_init!(self::CBSparsemat, nr::Integer, nc::Integer, nz::Integer, ini::Union{<:AbstractVector{Cint},Nothing}, inj::Union{<:AbstractVector{Cint},Nothing}, va::Union{<:AbstractVector{Cdouble},Nothing})\n\ninitialize to size nr*nc and nz nonzeros so that this(ini[i],inj[i])=val[i] for i=0,..,nz-1; multiple elements are summed up.\n\n\n\n\n\ncb_init!(self::CBSparsemat, nr::Integer, nc::Integer, nz::Integer, ini::CBIndexmatrix, inj::CBIndexmatrix, va::CBMatrix)\n\ninitialize to size nr*nc and nz nonzeros so that this(ini(i),inj(i))=val(i) for i=0,..,nz-1; multiple elements are summed up.\n\n\n\n\n\ncb_init!(self::CBSymmatrix, A::CBSymmatrix, d::Real = 1.)\n\ninitialize to this=Ad\n\n\n\n\n\ncb_init!(self::CBSymmatrix, A::CBMatrix, d::Real = 1.)\n\ninitialize to this=d(A+transpose(A))/2.\n\n\n\n\n\ncb_init!(self::CBSymmatrix, A::CBIndexmatrix, d::Real = 1.)\n\ninitialize to this=d(A+transpose(A))/2.\n\n\n\n\n\ncb_init!(self::CBSymmatrix, A::CBSparsesym, d::Real = 1.)\n\ninitialize to this=Ad\n\n\n\n\n\ncb_init!(self::CBSymmatrix, nr::Integer, d::Real)\n\nintialize *this to a matrix of size nr x nr initializing all elements to the value d\n\n\n\n\n\ncb_init!(self::CBSymmatrix, nr::Integer, dp::Union{<:AbstractVector{Cdouble},Nothing})\n\ngenerate a matrix of size nr x nc initializing the elements from the (one dimensional) array dp which must have the elements arranged consecutively in internal order\n\n\n\n\n\ncb_init!(self::CBSparsesym, param0::CBSparsesym, d::Real = 1.)\n\ninitialize to this=Ad\n\n\n\n\n\ncb_init!(self::CBSparsesym, param0::CBMatrix, d::Real = 1.)\n\ninitialize to this=d(A+transpose(A))/2., abs(values)<tol are removed from the support\n\n\n\n\n\ncb_init!(self::CBSparsesym, param0::CBIndexmatrix, d::Real = 1.)\n\ninitialize to this=d(A+transpose(A))/2., zeros are removed from the support\n\n\n\n\n\ncb_init!(self::CBSparsesym, param0::CBSymmatrix, d::Real = 1.)\n\ninitialize to this=Ad, abs(values)<tol are removed from the support\n\n\n\n\n\ncb_init!(self::CBSparsesym, param0::CBSparsemat, d::Real = 1.)\n\ninitialize to this=d(A+transpose(A))/2.\n\n\n\n\n\ncb_init!(self::CBSparsesym, nr::Integer)\n\ninitialize to zero-matrix of size nr*nr\n\n\n\n\n\ncb_init!(self::CBSparsesym, nr::Integer, nz::Integer, ini::Union{<:AbstractVector{Cint},Nothing}, inj::Union{<:AbstractVector{Cint},Nothing}, va::Union{<:AbstractVector{Cdouble},Nothing})\n\ninitialize to size nr*nr and nz nonzeros so that this(ini[i],inj[i])=val[i] for i=0,..,nz-1; specify only one of (i,j) and (j,i), multiple elements are summed up.\n\n\n\n\n\ncb_init!(self::CBSparsesym, nr::Integer, nz::Integer, ini::CBIndexmatrix, inj::CBIndexmatrix, va::CBMatrix)\n\ninitialize to size nr*nr and nz nonzeros so that this(ini(i),inj(i))=val[i] for i=0,..,nz-1; specify only one of (i,j) and (j,i), multiple elements are summed up.\n\n\n\n\n\ncb_init!(self::CBSparseCoeffmatMatrix, block_dim::CBIndexmatrix, col_dim::Integer, block_ind::Union{<:CBIndexmatrix,Nothing} = nothing, col_ind::Union{<:CBIndexmatrix,Nothing} = nothing, coeff_vec::Union{<:CBCoeffmatVector,Nothing} = nothing)\n\nfirst calls clear() and then it sets the new values (if one of blockind, colind, or coeff_vec is !=NULL, all must be !=NULL and of the same size)\n\n\n\n\n\ncb_init!(self::CBGB_rand, seed::Integer = 1)\n\nrestart generator with seed\n\n\n\n\n\ncb_init!(self::CBAffineFunctionTransformation, fun_coeff::Real = 1., fun_offset::Real = 0., linear_cost::Union{<:CBMatrix,Nothing} = nothing, arg_offset::Union{<:CBMatrix,Nothing} = nothing, arg_trafo::Union{<:CBSparsemat,Nothing} = nothing, model_calls_delete::Bool = true)\n\nsets the parameters of the transformation. The ownership of objects pointed to is passed to *this (they will be deleted here). If *this is entered into an AFTModel, modelcallsdelete==true tells the AFTModel to delete this AffineFunctionTransformation at the end.\n\n\n\n\n\ncb_init!(self::CBMinorantPointer, mp::CBMinorantPointer, factor::Real = 1., enforce_copy::Bool = false)\n\nif factor!=1 it generates another MinorantUseData referring to the one of mp, otherwise it simply uses the same one (empty stays empty)\n\n\n\n\n\ncb_init!(self::CBMinorantPointer, mp::Union{<:CBMinorant,Nothing}, modification_id::Integer = -1, factor::Real = 1.)\n\nif mp==0 it becomes empty, otherwise it creates and then points to a MinorantUseData for holding mp with this modification_id and factor\n\n\n\n\n\ncb_init!(self::CBPSCBundleParameters, bp::CBBundleParameters)\n\n*@brief initialize to given values \n\n\n\n\n\ncb_init!(self::CBAFTData, bd::Union{<:CBBundleData,Nothing})\n\ninitialize from other BundleData\n\n\n\n\n\ncb_init!(self::CBBoxData, bd::Union{<:CBBundleData,Nothing})\n\nif @a bd is of type BoxData, initialize to this data\n\n\n\n\n\ncb_init!(self::CBNNCData, bd::Union{<:CBBundleData,Nothing})\n\nif @a bd is of type NNCData, initialize to this data\n\n\n\n\n\ncb_init!(self::CBPSCData, bd::Union{<:CBBundleData,Nothing})\n\nif @a bd is of type PSCData, initialize to this data\n\n\n\n\n\ncb_init!(self::CBSOCData, bd::Union{<:CBBundleData,Nothing})\n\nif @a bd is of type SOCData, initialize to this data\n\n\n\n\n\ncb_init!(self::CBBundleHKWeight, aggr_dnmormsqr::Real, groundset::Union{<:CBGroundset,Nothing}, model::Union{<:CBBundleModel,Nothing})\n\ncompute first weight and set some parameters\n\n\n\n\n\ncb_init!(self::CBBundleRQBWeight, aggr_dnmormsqr::Real, groundset::Union{<:CBGroundset,Nothing}, model::Union{<:CBBundleModel,Nothing})\n\ncompute first weight and set some parameters\n\n\n\n\n\ncb_init!(self::CBBundleDenseTrustRegionProx, in_H::CBSymmatrix)\n\nset H with the information, whether it is factored\n\n\n\n\n\ncb_init!(self::CBBundleDLRTrustRegionProx, in_D::CBMatrix, in_vecH::CBMatrix)\n\nreset the prox information; the diagaonal part inD must be a nonnegative column vector, the low rank part invecH must have the same number of rows as in_D\n\n\n\n\n\ncb_init!(self::CBBundleLowRankTrustRegionProx, in_vecH::CBMatrix, in_lamH::CBMatrix)\n\nreset the prox information; invecH must be an orthogonal matrix with invecH.rowdim() matching the dimension but maybe with zero columns; inlamH must be a column vector with row dimension matching the column dimension of invecH and all entries positive\n\n\n\n\n\ncb_init!(self::CBQPConeModelBlock, constant_minorant::CBMinorantPointer, bundle::CBMinorantBundle, nnc_dim::Integer, soc_dim::CBIndexmatrix, psc_dim::CBIndexmatrix, box_lb::CBMatrix, box_ub::CBMatrix, b::Real, ft::CBFunctionTask, oracle_data::Union{<:CBQPModelOracleDataObject,Nothing} = nothing, scale_box::Bool = true)\n\nsets up the model with bundle information and how to combine it, see QPConeModelDataObject::init() for a detailed description\n\n\n\n\n\ncb_init!(self::CBUQPConeModelBlock, constant_minorant::CBMinorantPointer, bundle::CBMinorantBundle, nnc_dim::Integer, soc_dim::CBIndexmatrix, sdp_dim::CBIndexmatrix, box_lb::CBMatrix, box_ub::CBMatrix, b::Real, ft::CBFunctionTask, oracle_data::Union{<:CBQPModelOracleDataObject,Nothing} = nothing, scale_box::Bool = true)\n\nsets up the model with bundle information and how to combine it, see QPConeModelDataObject::init() for a detailed description\n\n\n\n\n\ncb_init!(self::CBSumBundle, sb::CBSumBundle)\n\ninitialize\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_init_data!","page":"Reference of C++ interface","title":"ConicBundle.cb_init_data!","text":"cb_init_data!(self::CBQPKKTSubspaceHPrecond, Hp::Union{<:CBQPSolverProxObject,Nothing}, model::Union{<:CBQPModelBlockObject,Nothing}, A::Union{<:CBSparsemat,Nothing}, eq_indices::Union{<:CBIndexmatrix,Nothing}, SchurComplAineq::Bool)\n\nreturns 1 if this class is not applicable in the current data situation, otherwise it stores the data pointers and these need to stay valid throught the use of the other routines but are not deleted here\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_init_diag!","page":"Reference of C++ interface","title":"ConicBundle.cb_init_diag!","text":"cb_init_diag!(self::CBMatrix, nr::Integer, d::Real = 1.)\n\ninitialize to a diagonal nr x nr matrix with constant diagonal value d\n\n\n\n\n\ncb_init_diag!(self::CBMatrix, vec::CBMatrix, d::Real = 1.)\n\ninitialize to a diagonal matrix with diagonal given by vec\n\n\n\n\n\ncb_init_diag!(self::CBMatrix, vec::CBIndexmatrix, d::Real = 1.)\n\ninitialize to a diagonal matrix with diagonal given by vec\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_init_problem!-Tuple{ConicBundle.CBMatrixCBSolver, Integer, Union{Nothing, ConicBundle.CBMatrix}, Union{Nothing, ConicBundle.CBMatrix}, Union{Nothing, ConicBundle.CBMatrix}, Union{Nothing, ConicBundle.CBMatrix}, Real}","page":"Reference of C++ interface","title":"ConicBundle.cb_init_problem!","text":"cb_init_problem!(self::CBMatrixCBSolver, dim::Integer, lbounds::Union{<:CBMatrix,Nothing} = nothing, ubounds::Union{<:CBMatrix,Nothing} = nothing, startval::Union{<:CBMatrix,Nothing} = nothing, costs::Union{<:CBMatrix,Nothing} = nothing, offset::Real = 0.)\n\n@brief Initializes the problem by setting up the design space       (the dimension and possibly box constraints on the variables)\nClears all data structures and sets the dimension @ m for a new problem.   for solving   min{y in R^m}  f0(y) + f1(y) + ...   Box constraints may be specified for y. (The functions fi must be added    by add_function()).\nLower and/or upper bounds must be speicified for all variables    or for none of them. To specify no bounds at all, give Null    pointers. Otherwise use ConicBundle::CBminusinfinity for    unbounded below and ConicBundle::CBplusinfinity for unbounded above.    For NULL pointers, unbounded will be used as default for all    variables. Specifying bounds selectively is also possible    by setlowerbound() or setupperbound(). For further constraints    see append_constraints().\n@param[in] dim  (int)        the dimension of the argument/design space/the number of Lagrange multipliers\n@param[in] lbounds  (const Matrix*)        If NULL, all variables are considered unbounded below,        otherwise lbounds[i] gives the minimum feasible value for variable y[i],        use ConicBundle::CBminusinfinity for unbounded below.\n@param[in] ubounds (const Matrix*)        If NULL, all variables are considered unbounded above,        otherwise ubounds[i] gives the maximum feasible value for variable y[i],        use ConicBundle::CBplusinfinity for unbounded above.\n@param[in] startval (const Matrix*)       If NULL, the starting values are obtained by projecting       zero onto the feasible set given by the lower and upper bounds resulting from the arguments before\n@param[in] costs (const Matrix*)        Use this in order to specify linear costs on the variables in addition  to the functions (may be convenient in Lagrangean relaxation for  the right hand side of coupling contsraints); NULL is equivalent  to costs zero.\n@param[in] offset (Real)        Use this in order to specify linear costs on the variables in addition  to the functions (may be convenient in Lagrangean relaxation for  the right hand side of coupling contsraints); NULL is equivalent  to costs zero.\n@return       - 0 on success       - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_init_size!","page":"Reference of C++ interface","title":"ConicBundle.cb_init_size!","text":"cb_init_size!(self::CBUQPSolver, maxdim::Integer)\n\nreserve memory for this size\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_init_support!","page":"Reference of C++ interface","title":"ConicBundle.cb_init_support!","text":"cb_init_support!(self::CBSparsesym, A::CBSparsesym, d::Real = 0.)\n\ninitialize to the same support as A but with constant value d; the same support will be generated even for d=0.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_init_svec!","page":"Reference of C++ interface","title":"ConicBundle.cb_init_svec!","text":"cb_init_svec!(self::CBSymmatrix, nr::Integer, dp::Union{<:AbstractVector{Cdouble},Nothing}, d::Real = 1.)\n\ninitialize from an svec stored in a real array (or matrix)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_init_system!","page":"Reference of C++ interface","title":"ConicBundle.cb_init_system!","text":"cb_init_system!(self::CBQPKKTSubspaceHPrecond, KKTdiagx::CBMatrix, KKTdiagy::CBMatrix, Hfactor::Real, prec::Real, params::Union{<:CBQPSolverParameters,Nothing})\n\nset up the primal dual KKT system for being solved for predictor and corrector rhs; the input objects KKTdiagx and KKTdiagy will not change during use of the preconditioner, so it suffices to store the address if they are need during application of the preconditioner\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_initialization_needed","page":"Reference of C++ interface","title":"ConicBundle.cb_initialization_needed","text":"cb_initialization_needed(self::CBSumBundleHandler, ft::CBFunctionTask)\n\nreturns true if the corresponding part is root with contributions but has bundle_size 0\n\n\n\n\n\ncb_initialization_needed(self::CBSumBundleHandler)\n\nreturns true if one of the parts is root with contributions but has bundle_size 0\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_initialize!","page":"Reference of C++ interface","title":"ConicBundle.cb_initialize!","text":"cb_initialize!(self::CBBundleSolver, dim::Integer, bp::Union{<:CBBundleModel,Nothing} = nothing)\n\ncalls clear(), initializes an unconstrained groundset to this dimension and sets the bundle model to bp\n\n\n\n\n\ncb_initialize!(self::CBBundleSolver, gs::Union{<:CBGroundset,Nothing}, bp::Union{<:CBBundleModel,Nothing} = nothing)\n\ncalls clear(), initializes the groundset to gs and the bundle model to bp\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_inner_line_search!","page":"Reference of C++ interface","title":"ConicBundle.cb_inner_line_search!","text":"cb_inner_line_search!(self::CBUQPConeModelBlock, qp_dx::CBMatrix, qp_dy::CBMatrix, dz::CBMatrix, duz::CBMatrix, box_ds::Real, ds::Real)\n\nperform a line search for the given direction and return a feasible step length\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_insert_col!","page":"Reference of C++ interface","title":"ConicBundle.cb_insert_col!","text":"cb_insert_col!(self::CBMatrix, i::Integer, v::CBMatrix)\n\ninsert a column before column i, 0<=i<= column dimension, for i==column dimension the column is appended at the right; appending to a 0x0 matrix is allowed, returns *this\n\n\n\n\n\ncb_insert_col!(self::CBIndexmatrix, i::Integer, v::CBIndexmatrix)\n\ninsert a column before column i, 0<=i<= column dimension, for i==column dimension the column is appended at the right; appending to a 0x0 matrix is allowed, returns *this\n\n\n\n\n\ncb_insert_col!(self::CBSparsemat, i::Integer, v::CBSparsemat)\n\ninsert a column before column i, 0<=i<= column dimension, for i==column dimension the column is appended at the right; appending to a 0x0 matrix is allowed, returns *this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_insert_row!","page":"Reference of C++ interface","title":"ConicBundle.cb_insert_row!","text":"cb_insert_row!(self::CBMatrix, i::Integer, v::CBMatrix)\n\ninsert the row vector v before row i, 0<=i<= row dimension, for i==row dimension the row is appended below; appending to a 0x0 matrix is allowed, returns *this\n\n\n\n\n\ncb_insert_row!(self::CBIndexmatrix, i::Integer, v::CBIndexmatrix)\n\ninsert the row vector v before row i, 0<=i<= row dimension, for i==row dimension the row is appended below; appending to a 0x0 matrix is allowed, returns *this\n\n\n\n\n\ncb_insert_row!(self::CBSparsemat, i::Integer, v::CBSparsemat)\n\ninsert the row vector v before row i, 0<=i<= row dimension, for i==row dimension the row is appended below; appending to a 0x0 matrix is allowed, returns *this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_install_external_aggregate!","page":"Reference of C++ interface","title":"ConicBundle.cb_install_external_aggregate!","text":"cb_install_external_aggregate!(self::CBSumBundleHandler, ft::CBFunctionTask, aggr::CBMinorantPointer, aggr_coeff::Real)\n\n@brief replace the aggregate by one from outside\n This is only possible, if the handler handles a bundle for this and\n the bundle is not active. The main purpose is to switch from an\n external model to a newly contributing sumbundle that has been\n updated all along but not been in use. Installing the external\n aggregate then ensures convergence.\n\n If primal is not zero, it must already have one nonzero entry per\n column of existing minorants and all future calls via set_cand_minorant()\n also have to provide exactly one primal for each update.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_inv","page":"Reference of C++ interface","title":"ConicBundle.cb_inv","text":"cb_inv(A::CBMatrix)\n\nreturns a matrix with elements (i,j)=1./((*this)(i,j)) for all i,j; ATTENTION: no check for division by zero\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_inv!","page":"Reference of C++ interface","title":"ConicBundle.cb_inv!","text":"cb_inv!(self::CBMatrix)\n\nsets (this)(i,j)=1./(this)(i,j) for all i,j and returns *this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_ip","page":"Reference of C++ interface","title":"ConicBundle.cb_ip","text":"cb_ip(A::CBMatrix, B::CBMatrix)\n\nreturns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j\n\n\n\n\n\ncb_ip(A::CBIndexmatrix, B::CBIndexmatrix)\n\nreturns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j\n\n\n\n\n\ncb_ip(A::CBSparsemat, B::CBSparsemat)\n\nreturns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j\n\n\n\n\n\ncb_ip(A::CBSparsemat, B::CBMatrix)\n\nreturns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j\n\n\n\n\n\ncb_ip(A::CBMatrix, B::CBSparsemat)\n\nreturns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j\n\n\n\n\n\ncb_ip(A::CBSymmatrix, B::CBSymmatrix)\n\nreturns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j\n\n\n\n\n\ncb_ip(A::CBMatrix, B::CBSymmatrix)\n\nreturns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j\n\n\n\n\n\ncb_ip(A::CBSymmatrix, B::CBMatrix)\n\nreturns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j\n\n\n\n\n\ncb_ip(A::CBSymmatrix, B::CBSparsesym)\n\nreturns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j\n\n\n\n\n\ncb_ip(A::CBSparsesym, B::CBSymmatrix)\n\nreturns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j\n\n\n\n\n\ncb_ip(A::CBSparsesym, B::CBSparsesym)\n\nreturns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j\n\n\n\n\n\ncb_ip(A::CBMatrix, B::CBSparsesym)\n\nreturns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j\n\n\n\n\n\ncb_ip(A::CBSparsesym, B::CBMatrix)\n\nreturns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j\n\n\n\n\n\ncb_ip(self::CBCMgramdense, S::CBSymmatrix)\n\nreturns ip(this,S)=trace(this*S), the trace inner product\n\n\n\n\n\ncb_ip(self::CBCMgramdense, S::CBSparsesym)\n\nreturns the inner product of the constraint matrix with S\n\n\n\n\n\ncb_ip(self::CBCMgramsparse, S::CBSymmatrix)\n\nreturns ip(this,S)=trace(this*S), the trace inner product\n\n\n\n\n\ncb_ip(self::CBCMgramsparse, S::CBSparsesym)\n\nreturns the inner product of the constraint matrix with S\n\n\n\n\n\ncb_ip(self::CBCMgramsparse_withoutdiag, S::CBSymmatrix)\n\nreturns ip(this,S)=trace(this*S), the trace inner product\n\n\n\n\n\ncb_ip(self::CBCMgramsparse_withoutdiag, S::CBSparsesym)\n\nreturns the inner product of the constraint matrix with S\n\n\n\n\n\ncb_ip(self::CBCMlowrankdd, S::CBSymmatrix)\n\nreturns ip(this,S)=trace(this*S), the trace inner product\n\n\n\n\n\ncb_ip(self::CBCMlowrankdd, S::CBSparsesym)\n\nreturns the inner product of the constraint matrix with S\n\n\n\n\n\ncb_ip(self::CBCMlowranksd, S::CBSymmatrix)\n\nreturns ip(this,S)=trace(this*S), the trace inner product\n\n\n\n\n\ncb_ip(self::CBCMlowranksd, S::CBSparsesym)\n\nreturns the inner product of the constraint matrix with S\n\n\n\n\n\ncb_ip(self::CBCMlowrankss, S::CBSymmatrix)\n\nreturns ip(this,S)=trace(this*S), the trace inner product\n\n\n\n\n\ncb_ip(self::CBCMlowrankss, S::CBSparsesym)\n\nreturns the inner product of the constraint matrix with S\n\n\n\n\n\ncb_ip(self::CBCMsingleton, S::CBSymmatrix)\n\nreturns ip(this,S)=trace(this*S), the trace inner product\n\n\n\n\n\ncb_ip(self::CBCMsingleton, S::CBSparsesym)\n\nreturns the inner product of the constraint matrix with S\n\n\n\n\n\ncb_ip(self::CBCMsymdense, S::CBSymmatrix)\n\nreturns ip(this,S)=trace(this*S), the trace inner product\n\n\n\n\n\ncb_ip(self::CBCMsymdense, S::CBSparsesym)\n\nreturns the inner product of the constraint matrix with S\n\n\n\n\n\ncb_ip(self::CBCMsymsparse, S::CBSymmatrix)\n\nreturns ip(this,S)=trace(this*S), the trace inner product\n\n\n\n\n\ncb_ip(self::CBCMsymsparse, S::CBSparsesym)\n\nreturns the inner product of the constraint matrix with S\n\n\n\n\n\ncb_ip(self::CBMinorantPointer, mp::CBMinorantPointer, skip_fixed::Union{<:CBIndexmatrix,Nothing} = nothing, ipdiag::Union{<:CBMatrix,Nothing} = nothing)\n\n@brief computes the inner product of the two minorants; if skipfixed!=NULL the corrsponding indices are not considered, if ipdiag!=0 the inner product is taken with respect to this diagonal matrix, i.e.  sumi mp(i)(this)(i)(*ipdiag)(i)\n\n\n\n\n\ncb_ip(self::CBMinorantPointer, m::CBMatrix, ipdiag::Union{<:CBMatrix,Nothing} = nothing, startindex_m::Integer = 0)\n\n@brief computes the inner product with m; if ipdiag!=0 the inner product is taken with respect to this diagonal matrix, i.e.  sumi mp(startindexm+i)(this)(i)(*ipdiag)(i) \n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_ip_min_max","page":"Reference of C++ interface","title":"ConicBundle.cb_ip_min_max","text":"cb_ip_min_max(A::CBMatrix, B::CBMatrix)\n\nreturns in addition to the usual inner product of A and B the minimum and maximum value of A(i,j)*B(i,j) over all (i,j)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_is_DLR","page":"Reference of C++ interface","title":"ConicBundle.cb_is_DLR","text":"cb_is_DLR(self::CBBundleDenseTrustRegionProx)\n\nreturn true if H is of the form diagonal matrix plus Gram matrix of a low rank matrix\n\n\n\n\n\ncb_is_DLR(self::CBBundleDiagonalTrustRegionProx)\n\nreturn true if H is of the form diagonal matrix plus Gram matrix of a low rank matrix\n\n\n\n\n\ncb_is_DLR(self::CBBundleDLRTrustRegionProx)\n\nreturn true if H is of the form diagonal matrix plus Gram matrix of a low rank matrix\n\n\n\n\n\ncb_is_DLR(self::CBBundleIdProx)\n\nreturn true if H is of the form diagonal matrix plus Gram matrix of a low rank matrix\n\n\n\n\n\ncb_is_DLR(self::CBBundleLowRankTrustRegionProx)\n\nreturn true if H is of the form diagonal matrix plus Gram matrix of a low rank matrix\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_is_feasible!","page":"Reference of C++ interface","title":"ConicBundle.cb_is_feasible!","text":"cb_is_feasible!(self::CBLPGroundset, y::CBMatrix, relprec::Real = 1e-10)\n\nreturns true if still feasible, see Groundset::is_feasible()\n\n\n\n\n\ncb_is_feasible!(self::CBUnconstrainedGroundset, y::CBMatrix, relprec::Real = 1e-10)\n\n@brief on input value ingroundsetid the input y was feasible. Return true if the id did not change, otherwise check if y is still feasible for the given precision.\nThe routine is called by the internal bundle solver to check    whether the given center is still valid (in some applications the    groundset might change during the runtime of the bundle method),    where validity of y was already checked at a point in time when the    groundset had the ingroundsetid. If the groundset_id is still the    same, then y is simply assumed to be still correct (the precision    is not even looked at in this case). Otherwise the routine checks    the validitiy of y with respect to the given precision but does not    enforce validity. It returns true if y is valid and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_lb_function!","page":"Reference of C++ interface","title":"ConicBundle.cb_lb_function!","text":"cb_lb_function!(self::CBAFTModel, y_id::Integer, y::CBMatrix)\n\nsee SumBlockModel::lb_function\n\n\n\n\n\ncb_lb_function!(self::CBBoxModel, y_id::Integer, y::CBMatrix)\n\nsee SumBlockModel::lb_function\n\n\n\n\n\ncb_lb_function!(self::CBNNCModel, y_id::Integer, y::CBMatrix)\n\nsee SumBlockModel::lb_function\n\n\n\n\n\ncb_lb_function!(self::CBPSCModel, y_id::Integer, y::CBMatrix)\n\nsee SumBlockModel::lb_function\n\n\n\n\n\ncb_lb_function!(self::CBSOCModel, y_id::Integer, y::CBMatrix)\n\nsee SumBlockModel::lb_function\n\n\n\n\n\ncb_lb_function!(self::CBSumModel, y_id::Integer, y::CBMatrix)\n\nsee SumBlockModel::lb_function()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_lb_model","page":"Reference of C++ interface","title":"ConicBundle.cb_lb_model","text":"cb_lb_model(self::CBSumBundleHandler, yid::Integer, y::CBMatrix)\n\nreturns a quick lower bound for the model value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_left_genmult","page":"Reference of C++ interface","title":"ConicBundle.cb_left_genmult","text":"cb_left_genmult(self::CBMinorantPointer, B::CBMatrix, C::CBMatrix, alpha::Real = 1., beta::Real = 0., thistrans::Integer = 0, btrans::Integer = 0, thisindex::Integer = 0)\n\ncomputes and returns C=alpha(this)B+betaC where B and *this may be transposed and *this is considered to be a column with thisindex in a bigger matrix\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_left_right_prod","page":"Reference of C++ interface","title":"ConicBundle.cb_left_right_prod","text":"cb_left_right_prod(self::CBCMgramdense, P::CBMatrix, Q::CBMatrix, R::CBMatrix)\n\ncomputes R=P^T(this)*Q\n\n\n\n\n\ncb_left_right_prod(self::CBCMgramsparse, P::CBMatrix, Q::CBMatrix, R::CBMatrix)\n\ncomputes R=P^T(this)*Q\n\n\n\n\n\ncb_left_right_prod(self::CBCMgramsparse_withoutdiag, P::CBMatrix, Q::CBMatrix, R::CBMatrix)\n\ncomputes R=P^T(this)*Q\n\n\n\n\n\ncb_left_right_prod(self::CBCMlowrankdd, P::CBMatrix, Q::CBMatrix, R::CBMatrix)\n\ncomputes R=P^T(this)*Q\n\n\n\n\n\ncb_left_right_prod(self::CBCMlowranksd, P::CBMatrix, Q::CBMatrix, R::CBMatrix)\n\ncomputes R=P^T(this)*Q\n\n\n\n\n\ncb_left_right_prod(self::CBCMlowrankss, P::CBMatrix, Q::CBMatrix, R::CBMatrix)\n\ncomputes R=P^T(this)*Q\n\n\n\n\n\ncb_left_right_prod(self::CBCMsingleton, P::CBMatrix, Q::CBMatrix, R::CBMatrix)\n\ncomputes R=P^T(this)*Q\n\n\n\n\n\ncb_left_right_prod(self::CBCMsymdense, P::CBMatrix, Q::CBMatrix, R::CBMatrix)\n\ncomputes R=P^T(this)*Q\n\n\n\n\n\ncb_left_right_prod(self::CBCMsymsparse, P::CBMatrix, Q::CBMatrix, R::CBMatrix)\n\ncomputes R=P^T(this)*Q\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_left_right_product!","page":"Reference of C++ interface","title":"ConicBundle.cb_left_right_product!","text":"cb_left_right_product!(self::CBPSCAffineFunction, i::Integer, E::CBMatrix, F::CBMatrix, G::CBMatrix)\n\nsee PSCOracle::leftrightproduct()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_line_search!","page":"Reference of C++ interface","title":"ConicBundle.cb_line_search!","text":"cb_line_search!(self::CBUQPConeModelBlock, qp_dx::CBMatrix, qp_dy::CBMatrix, rhs_residual::CBMatrix)\n\n@brief perform a line search for the block variables\ndx,dy give the final step direction, alpha is on input\nan upper bound on the step size.\n\nOn output alpha has to be no larger than on input and\nhas to guarantee strict feasibility of the primal/dual step on\nthe local variables.\n\nThe block has to compute the step direction dz as well as\nfor additional internal variables now and to choose alpha so\nthat strict feasibility is guaranteed for the internal\nvariables as well\n\n\n\n\n\ncb_line_search!(self::CBUQPSumModelBlock, qp_dx::CBMatrix, qp_dy::CBMatrix, rhs_residual::CBMatrix)\n\nget/do this from/for all subblocks\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_linesearch","page":"Reference of C++ interface","title":"ConicBundle.cb_linesearch","text":"cb_linesearch(self::CBQPConeModelBlock)\n\nif necessary, reduce alpha to the biggest value so that feasibility is maintained with this step size\n\n\n\n\n\ncb_linesearch(self::CBQPSumModelBlock)\n\nif necessary, reduce alpha to the biggest value so that feasibility is maintained with this step size\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_localsys_mult!","page":"Reference of C++ interface","title":"ConicBundle.cb_localsys_mult!","text":"cb_localsys_mult!(self::CBQPConeModelBlock, in_vec::CBMatrix, out_vec::CBMatrix, startindex_model::Integer, startindex_constraints::Integer)\n\n@brief multiply the local system diagonal block consisting of the model and local contraints rows and columns by invec[startindexmodel+0,...,+dimmodel(),startindexconstraints+0,...,+dimconstraints]  into the same coordinates of outvec. \n\n\n\n\n\ncb_localsys_mult!(self::CBQPSumModelBlock, in_vec::CBMatrix, out_vec::CBMatrix, startindex_model::Integer, startindex_constraints::Integer)\n\n@brief multiply the local system diagonal block consisting of the model and local contraints rows and columns by invec[startindexmodel+0,...,+dimmodel(),startindexconstraints+0,...,+dimconstraints]  into the same coordinates of outvec. \n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_ls!","page":"Reference of C++ interface","title":"ConicBundle.cb_ls!","text":"cb_ls!(self::CBMatrix, rhs::CBMatrix, tol::Real)\n\ncomputes a least squares solution by #QRsolve, overwriting (*this). rhs is overwritten with the solution. In fact, the full code is return this->QRsolve(rhs,tol);\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_make_model_aggregate!","page":"Reference of C++ interface","title":"ConicBundle.cb_make_model_aggregate!","text":"cb_make_model_aggregate!(self::CBAFTModel, penalty_parameter_increased::Bool, keep_penalty_fixed::Bool)\n\nsee SumBlockModel::makemodelaggregate\n\n\n\n\n\ncb_make_model_aggregate!(self::CBSumModel, penalty_parameter_increased::Bool, keep_penalty_fixed::Bool)\n\nsee SumBlockModel::makemodelaggregate\n\n\n\n\n\ncb_make_model_aggregate!(self::CBSumBundleHandler, increased::Bool, fixed::Bool)\n\nsee SumBlockModel::makemodelaggregate\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_make_symmatrix","page":"Reference of C++ interface","title":"ConicBundle.cb_make_symmatrix","text":"cb_make_symmatrix(self::CBCMgramdense, S::CBSymmatrix)\n\nreturns a dense symmetric constraint matrix\n\n\n\n\n\ncb_make_symmatrix(self::CBCMgramsparse, S::CBSymmatrix)\n\nreturns a dense symmetric constraint matrix\n\n\n\n\n\ncb_make_symmatrix(self::CBCMgramsparse_withoutdiag, S::CBSymmatrix)\n\nreturns a dense symmetric constraint matrix\n\n\n\n\n\ncb_make_symmatrix(self::CBCMlowrankdd, S::CBSymmatrix)\n\nreturns a dense symmetric constraint matrix\n\n\n\n\n\ncb_make_symmatrix(self::CBCMlowranksd, S::CBSymmatrix)\n\nreturns a dense symmetric constraint matrix\n\n\n\n\n\ncb_make_symmatrix(self::CBCMlowrankss, S::CBSymmatrix)\n\nreturns a dense symmetric constraint matrix\n\n\n\n\n\ncb_make_symmatrix(self::CBCMsingleton, S::CBSymmatrix)\n\nreturns a dense symmetric constraint matrix (useful for testing)\n\n\n\n\n\ncb_make_symmatrix(self::CBCMsymdense, S::CBSymmatrix)\n\nreturns a dense symmetric constraint matrix\n\n\n\n\n\ncb_make_symmatrix(self::CBCMsymsparse, S::CBSymmatrix)\n\nreturns a dense symmetric constraint matrix\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_map_to_old_blocks","page":"Reference of C++ interface","title":"ConicBundle.cb_map_to_old_blocks","text":"cb_map_to_old_blocks(self::CBPSCAffineModification)\n\nreturns null if there are index changes, otherwise the Indexmatrix pointed to is a vector whose i-th entry holds the old index of the new i-th row (injective!), index values exceeding old_rowdim() refer to newly appended rows\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_map_to_old_rows","page":"Reference of C++ interface","title":"ConicBundle.cb_map_to_old_rows","text":"cb_map_to_old_rows(self::CBAFTModification)\n\nreturns null if there are no index changes, otherwise the Indexmatrix pointed to is a vector whose i-th entry holds the old index of the new i-th row (injective!), index values exceeding old_rowdim() refer to newly appended rows\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_map_to_old_variables","page":"Reference of C++ interface","title":"ConicBundle.cb_map_to_old_variables","text":"cb_map_to_old_variables(self::CBAFTModification)\n\nreturns null if there are no index changes, otherwise the Indexmatrix pointed to is a vector whose i-th entry holds the old index of the new i-th variable (injective!), index values exceeding old_vardim() refer to newly appended variables\n\n\n\n\n\ncb_map_to_old_variables(self::CBGroundsetModification)\n\nreturns null if there are no index changes, otherwise the Indexmatrix pointed to is a vector whose i-th entry holds the old index of the new i-th variable (injective!), index values exceeding old_vardim() refer to newly appended variables\n\n\n\n\n\ncb_map_to_old_variables(self::CBNNCBoxSupportModification)\n\nreturns null if there are no index changes, otherwise the Indexmatrix pointed to is a vector whose i-th entry holds the old index of the new i-th variable (injective!), index values exceeding old_vardim() refer to newly appended variables\n\n\n\n\n\ncb_map_to_old_variables(self::CBPSCAffineModification)\n\nreturns null if there are no index changes, otherwise the Indexmatrix pointed to is a vector whose i-th entry holds the old index of the new i-th variable (injective!), index values exceeding old_vardim() refer to newly appended variables\n\n\n\n\n\ncb_map_to_old_variables(self::CBSOCSupportModification)\n\nreturns null if there are no index changes, otherwise the Indexmatrix pointed to is a vector whose i-th entry holds the old index of the new i-th variable (injective!), index values exceeding old_vardim() refer to newly appended variables\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_mapped_variables_are_equal","page":"Reference of C++ interface","title":"ConicBundle.cb_mapped_variables_are_equal","text":"cb_mapped_variables_are_equal(self::CBAFTModification, newpoint::CBMatrix, oldpoint::CBMatrix)\n\nreturns true if the values in newpoint (must be a vector of length newvardim()) that correspond to old variables match the old values stored in oldpoint (must be a vector of length oldvardim()) and false otherwise\n\n\n\n\n\ncb_mapped_variables_are_equal(self::CBGroundsetModification, newpoint::CBMatrix, oldpoint::CBMatrix)\n\nreturns true if the values in newpoint (must be a vector of length newvardim()) that correspond to old variables match the old values stored in oldpoint (must be a vector of length oldvardim()) and false otherwise\n\n\n\n\n\ncb_mapped_variables_are_equal(self::CBNNCBoxSupportModification, newpoint::CBMatrix, oldpoint::CBMatrix)\n\nreturns true if the values in newpoint (must be a vector of length newvardim()) that correspond to old variables match the old values stored in oldpoint (must be a vector of length oldvardim()) and false otherwise\n\n\n\n\n\ncb_mapped_variables_are_equal(self::CBPSCAffineModification, newpoint::CBMatrix, oldpoint::CBMatrix)\n\nreturns true if the values in newpoint (must be a vector of length newvardim()) that correspond to old variables match the old values stored in oldpoint (must be a vector of length oldvardim()) and false otherwise\n\n\n\n\n\ncb_mapped_variables_are_equal(self::CBSOCSupportModification, newpoint::CBMatrix, oldpoint::CBMatrix)\n\nreturns true if the values in newpoint (must be a vector of length newvardim()) that correspond to old variables match the old values stored in oldpoint (must be a vector of length oldvardim()) and false otherwise\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_max","page":"Reference of C++ interface","title":"ConicBundle.cb_max","text":"cb_max(A::CBMatrix, iindex::Union{<:AbstractVector{Cint},Nothing}, jindex::Union{<:AbstractVector{Cint},Nothing})\n\nreturns the maximum value over all elements of the matrix\n\n\n\n\n\ncb_max(A::CBIndexmatrix, iindex::Union{<:AbstractVector{Cint},Nothing}, jindex::Union{<:AbstractVector{Cint},Nothing})\n\nreturns the maximum value over all elements of the matrix\n\n\n\n\n\ncb_max(A::CBSymmatrix)\n\nreturns the maximum value over all elements of the matrix\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_maxcols","page":"Reference of C++ interface","title":"ConicBundle.cb_maxcols","text":"cb_maxcols(A::CBMatrix)\n\nreturns a column vector holding in each row the maximum over all columns in this row\n\n\n\n\n\ncb_maxcols(A::CBIndexmatrix)\n\nreturns a column vector holding in each row the maximum over all columns in this row\n\n\n\n\n\ncb_maxcols(A::CBSymmatrix)\n\nreturns a column vector holding in each row the maximum over all columns in this row\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_maxrows","page":"Reference of C++ interface","title":"ConicBundle.cb_maxrows","text":"cb_maxrows(A::CBMatrix)\n\nreturns a row vector holding in each column the maximum over all rows in this column\n\n\n\n\n\ncb_maxrows(A::CBIndexmatrix)\n\nreturns a row vector holding in each column the maximum over all rows in this column\n\n\n\n\n\ncb_maxrows(A::CBSymmatrix)\n\nreturns a row vector holding in each column the maximum over all rows in this column\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_mfile_data","page":"Reference of C++ interface","title":"ConicBundle.cb_mfile_data","text":"cb_mfile_data(self::CBBundleDenseTrustRegionProx)\n\noutput the description of the scaling in mfile-suitable format\n\n\n\n\n\ncb_mfile_data(self::CBBundleDiagonalTrustRegionProx)\n\noutput the description of the scaling in mfile-suitable format\n\n\n\n\n\ncb_mfile_data(self::CBBundleDLRTrustRegionProx)\n\noutput the description of the scaling in mfile-suitable format\n\n\n\n\n\ncb_mfile_data(self::CBBundleIdProx)\n\noutput the description of the prox term in mfile-suitable format\n\n\n\n\n\ncb_mfile_data(self::CBBundleLowRankTrustRegionProx)\n\noutput the description of the prox term in mfile-suitable format\n\n\n\n\n\ncb_mfile_data(self::CBQPSolver)\n\noutput the data describing the QP in m-file style\n\n\n\n\n\ncb_mfile_data(self::CBLPGroundset)\n\nm-file output routine for debugging or testing in Matlab (not yet working)\n\n\n\n\n\ncb_mfile_data(self::CBUnconstrainedGroundset)\n\nm-file output routine for debugging or testing in Matlab (not yet working)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_mfile_output","page":"Reference of C++ interface","title":"ConicBundle.cb_mfile_output","text":"cb_mfile_output(self::CBMatrix, precision::Integer = 16, width::Integer = 0)\n\n@brief outputs a matrix A in the format \"[ A(0,1) ... A(0,nc-1)\\n ... A(nr-1,nc-1)];\\n\" so that it can be read e.g. by octave as an m-file\n\n\n\n\n\ncb_mfile_output(self::CBIndexmatrix, precision::Integer = 16, width::Integer = 0)\n\n@brief outputs a matrix A in the format \"[ A(0,1) ... A(0,nc-1)\\n ... A(nr-1,nc-1)];\\n\" so that it can be read e.g. by octave as an m-file\n\n\n\n\n\ncb_mfile_output(self::CBSymmatrix, precision::Integer = 16, width::Integer = 0)\n\n@brief outputs a matrix A in the format \"[ A(0,1) ... A(0,nc-1)\\n ... A(nr-1,nc-1)];\\n\" so that it can be read e.g. by octave as an m-file\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_min","page":"Reference of C++ interface","title":"ConicBundle.cb_min","text":"cb_min(A::CBMatrix, iindex::Union{<:AbstractVector{Cint},Nothing}, jindex::Union{<:AbstractVector{Cint},Nothing})\n\nreturns the minimum value over all elements of the matrix\n\n\n\n\n\ncb_min(A::CBIndexmatrix, iindex::Union{<:AbstractVector{Cint},Nothing}, jindex::Union{<:AbstractVector{Cint},Nothing})\n\nreturns the minimum value over all elements of the matrix\n\n\n\n\n\ncb_min(A::CBSymmatrix)\n\nreturns the minimum value over all elements of the matrix\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_mincols","page":"Reference of C++ interface","title":"ConicBundle.cb_mincols","text":"cb_mincols(A::CBMatrix)\n\nreturns a column vector holding in each row the minimum over all columns in this row\n\n\n\n\n\ncb_mincols(A::CBIndexmatrix)\n\nreturns a column vector holding in each row the minimum over all columns in this row\n\n\n\n\n\ncb_mincols(A::CBSymmatrix)\n\nreturns a column vector holding in each row the minimum over all columns in this row\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_minrows","page":"Reference of C++ interface","title":"ConicBundle.cb_minrows","text":"cb_minrows(A::CBMatrix)\n\nreturns a row vector holding in each column the minimum over all rows in this column\n\n\n\n\n\ncb_minrows(A::CBIndexmatrix)\n\nreturns a row vector holding in each column the minimum over all rows in this column\n\n\n\n\n\ncb_minrows(A::CBSymmatrix)\n\nreturns a row vector holding in each column the minimum over all rows in this column\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_model","page":"Reference of C++ interface","title":"ConicBundle.cb_model","text":"cb_model(self::CBSumModel, fo::Union{<:CBFunctionObject,Nothing})\n\nreturns the submodel for FunctionObject fo if it in this model, otherwise 0\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_model_aggregate_modified!","page":"Reference of C++ interface","title":"ConicBundle.cb_model_aggregate_modified!","text":"cb_model_aggregate_modified!(self::CBAFTData, last_aggr_id::Integer)\n\ncheck whether aggregate is available and has the same id\n\n\n\n\n\ncb_model_aggregate_modified!(self::CBAFTModel, old_model_aggregate_id::Integer)\n\nsee BundleModel::modelaggregatemodified\n\n\n\n\n\ncb_model_aggregate_modified!(self::CBSumModel, old_model_aggregate_id::Integer)\n\nsee BundleModel::modelaggregatemodified\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_modified_transform_argument","page":"Reference of C++ interface","title":"ConicBundle.cb_modified_transform_argument","text":"cb_modified_transform_argument(self::CBAffineFunctionTransformation, transformed_y::CBMatrix, input_y::CBMatrix, aftmdf::Union{<:CBAFTModification,Nothing}, gsmdf::CBGroundsetModification)\n\n@brief given the modification aftmdf or if 0, gsmdf, compute the       transformed argument that would arise after this modification as in transform_argument()\nOn input @a transformedy is supposed to be of dimension zero. The matrix returned is transformedy unless the modification preserves the identity transformation. In this case, the       returned matrix is input_y.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_multiply!","page":"Reference of C++ interface","title":"ConicBundle.cb_multiply!","text":"cb_multiply!(self::CBCMgramdense, d::Real)\n\nmultiply constraint permanentely by d; this is to allow scaling or sign changes in the constraints\n\n\n\n\n\ncb_multiply!(self::CBCMgramsparse, d::Real)\n\nmultiply constraint permanentely by d; this is to allow scaling or sign changes in the constraints\n\n\n\n\n\ncb_multiply!(self::CBCMgramsparse_withoutdiag, d::Real)\n\nmultiply constraint permanentely by d; this is to allow scaling or sign changes in the constraints\n\n\n\n\n\ncb_multiply!(self::CBCMlowrankdd, d::Real)\n\nmultiply constraint permanentely by d; this is to allow scaling or sign changes in the constraints\n\n\n\n\n\ncb_multiply!(self::CBCMlowranksd, d::Real)\n\nmultiply constraint permanentely by d; this is to allow scaling or sign changes in the constraints\n\n\n\n\n\ncb_multiply!(self::CBCMlowrankss, d::Real)\n\nmultiply constraint permanentely by d; this is to allow scaling or sign changes in the constraints\n\n\n\n\n\ncb_multiply!(self::CBCMsingleton, d::Real)\n\nmultiply constraint permanentely by d; this is to allow scaling or sign changes in the constraints\n\n\n\n\n\ncb_multiply!(self::CBCMsymdense, d::Real)\n\nmultiply constraint permanentely by d; this is to allow scaling or sign changes in the constraints\n\n\n\n\n\ncb_multiply!(self::CBCMsymsparse, d::Real)\n\nmultiply constraint permanentely by d; this is to allow scaling or sign changes in the constraints\n\n\n\n\n\ncb_multiply!(self::CBCoeffmatInfo, sf::Real)\n\nscales the scale factor\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_new_block_indices","page":"Reference of C++ interface","title":"ConicBundle.cb_new_block_indices","text":"cb_new_block_indices(self::CBPSCAffineModification)\n\nreturns null if no rows were added, otherwise the Indexmatrix pointed ato is a vector holding the new indices of the new rows in increasing order\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_new_blockdim","page":"Reference of C++ interface","title":"ConicBundle.cb_new_blockdim","text":"cb_new_blockdim(self::CBPSCAffineModification)\n\nreturns the number of rows once all stored modifications have been performed\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_new_initial_oraclemodification","page":"Reference of C++ interface","title":"ConicBundle.cb_new_initial_oraclemodification","text":"cb_new_initial_oraclemodification(self::CBAFTModification, old_var_dim::Integer)\n\nreturns a new object on the heap, that allows to incorporate this but starts off from a function whose input argument dimension is oldvardim\n\n\n\n\n\ncb_new_initial_oraclemodification(self::CBGroundsetModification, old_var_dim::Integer)\n\nreturns a new object on the heap, that allows to incorporate this but starts off from a function whose input argument dimension is oldvardim\n\n\n\n\n\ncb_new_initial_oraclemodification(self::CBNNCBoxSupportModification, old_var_dim::Integer)\n\nreturns a new object on the heap, that allows to incorporate this but starts off from a function whose input argument dimension is oldvardim\n\n\n\n\n\ncb_new_initial_oraclemodification(self::CBPSCAffineModification, old_var_dim::Integer)\n\nreturns a new object on the heap, that allows to incorporate this but starts off from a function whose input argument dimension is oldvardim\n\n\n\n\n\ncb_new_initial_oraclemodification(self::CBSOCSupportModification, old_var_dim::Integer)\n\nreturns a new object on the heap, that allows to incorporate this but starts off from a function whose input argument dimension is oldvardim\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_new_row_indices","page":"Reference of C++ interface","title":"ConicBundle.cb_new_row_indices","text":"cb_new_row_indices(self::CBAFTModification)\n\nreturns null if no variables were added, otherwise the Indexmatrix pointed to is a vector holding the new indices of the new rows in increasing order\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_new_rowdim","page":"Reference of C++ interface","title":"ConicBundle.cb_new_rowdim","text":"cb_new_rowdim(self::CBAFTModification)\n\nreturns the number of rows once all stored modifications have been performed\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_new_var_indices","page":"Reference of C++ interface","title":"ConicBundle.cb_new_var_indices","text":"cb_new_var_indices(self::CBAFTModification)\n\nreturns null if no variables were added, otherwise the Indexmatrix pointed to is a vector holding the new indices of the new variables in increasing order\n\n\n\n\n\ncb_new_var_indices(self::CBGroundsetModification)\n\nreturns null if no variables were added, otherwise the Indexmatrix pointed ato is a vector holding the new indices of the new variables in increasing order\n\n\n\n\n\ncb_new_var_indices(self::CBNNCBoxSupportModification)\n\nreturns null if no variables were added, otherwise the Indexmatrix pointed ato is a vector holding the new indices of the new variables in increasing order\n\n\n\n\n\ncb_new_var_indices(self::CBPSCAffineModification)\n\nreturns null if no variables were added, otherwise the Indexmatrix pointed to is a vector holding the new indices of the new variables in increasing order\n\n\n\n\n\ncb_new_var_indices(self::CBSOCSupportModification)\n\nreturns null if no variables were added, otherwise the Indexmatrix pointed ato is a vector holding the new indices of the new variables in increasing order\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_new_vardim","page":"Reference of C++ interface","title":"ConicBundle.cb_new_vardim","text":"cb_new_vardim(self::CBAFTModification)\n\nreturns the number of variables once all stored modifications have been performed\n\n\n\n\n\ncb_new_vardim(self::CBGroundsetModification)\n\nreturns the number of variables once all stored modifications have been performed\n\n\n\n\n\ncb_new_vardim(self::CBNNCBoxSupportModification)\n\nreturns the number of variables once all stored modifications have been performed\n\n\n\n\n\ncb_new_vardim(self::CBPSCAffineModification)\n\nreturns the number of variables once all stored modifications have been performed\n\n\n\n\n\ncb_new_vardim(self::CBSOCSupportModification)\n\nreturns the number of variables once all stored modifications have been performed\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_new_variables_are_zero","page":"Reference of C++ interface","title":"ConicBundle.cb_new_variables_are_zero","text":"cb_new_variables_are_zero(self::CBAFTModification, newpoint::CBMatrix)\n\nreturns true if all entries in newpoint (must be a vector of length new_vardim()) that correspond to new variables have value 0 and false otherwise\n\n\n\n\n\ncb_new_variables_are_zero(self::CBGroundsetModification, newpoint::CBMatrix)\n\nreturns true if all entries in newpoint (must be a vector of length new_vardim()) that correspond to new variables have value 0 and false otherwise\n\n\n\n\n\ncb_new_variables_are_zero(self::CBNNCBoxSupportModification, newpoint::CBMatrix)\n\nreturns true if all entries in newpoint (must be a vector of length new_vardim()) that correspond to new variables have value 0 and false otherwise\n\n\n\n\n\ncb_new_variables_are_zero(self::CBPSCAffineModification, newpoint::CBMatrix, newmat::CBSparseCoeffmatMatrix)\n\nreturns true if for all indices of new variables the entries in newpoint (must be a vector of length new_vardim()) or the matrices in newmat are 0 and false otherwise\n\n\n\n\n\ncb_new_variables_are_zero(self::CBSOCSupportModification, newpoint::CBMatrix)\n\nreturns true if all entries in newpoint (must be a vector of length new_vardim()) that correspond to new variables have value 0 and false otherwise\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_newsize!","page":"Reference of C++ interface","title":"ConicBundle.cb_newsize!","text":"cb_newsize!(self::CBMatrix, nr::Integer, nc::Integer)\n\n@brief resize the matrix to nr x nc elements but WITHOUT initializing the memory\n  If initializing the memory externally and CONICBUNDLE_DEBUG is defined, please use\n  set_init() via matrix.set_init(true) in order to avoid warnings concerning improper\n  initialization\n\n\n\n\n\ncb_newsize!(self::CBIndexmatrix, nr::Integer, nc::Integer)\n\n@brief resize the matrix to nr x nc elements but WITHOUT initializing the memory\n  If initializing the memory externally and CONICBUNDLE_DEBUG is defined, please use\n  set_init() via matrix.set_init(true) in order to avoid warnings concerning improper\n  initialization\n\n\n\n\n\ncb_newsize!(self::CBSymmatrix, n::Integer)\n\n@brief resize the matrix to nr x nr elements but WITHOUT initializing the memory\n  If initializing the memory externally and CONICBUNDLE_DEBUG is defined, please use\n  set_init() via matrix.set_init(true) in order to avoid warnings concerning improper\n  initialization\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_next!","page":"Reference of C++ interface","title":"ConicBundle.cb_next!","text":"cb_next!(self::CBGB_rand)\n\nreturns a random double number \"uniformly distributed\" in (0,1)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_nnls","page":"Reference of C++ interface","title":"ConicBundle.cb_nnls","text":"cb_nnls(self::CBMatrix, rhs::CBMatrix, dual::Union{<:CBMatrix,Nothing} = nothing, tol::Real = 1e-10)\n\n@brief computes a nonnegative least squares solution; rhs is overwritten by the solution; if dual!=0, the dual variables are stored there; returns 0 on success, 1 on failure\nComputes the least squares solution of min ||Ax-b|| s.t. x >=0;\\n\nThe KKT system A'*A*x - A'*b - l = 0; x >=0, l>=0, x'*l=0 is solved\nsolved by interior point method with QR-solution of the extended system.\n\nThe current implementation is based on\n[P. Matsoms, \"Sparse Linear Least Squares Problems in Optimization\",\nComput. Opt. and Appl., 7, 89-110 (1997)] but is only\na quick and rather sloppy implementation of it ...\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_no_additions_or_deletions_in_rows","page":"Reference of C++ interface","title":"ConicBundle.cb_no_additions_or_deletions_in_rows","text":"cb_no_additions_or_deletions_in_rows(self::CBAFTModification)\n\nreturns true if no rows were added or deleted (allows permutations), false otherwise\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_no_additions_or_deletions_in_vars","page":"Reference of C++ interface","title":"ConicBundle.cb_no_additions_or_deletions_in_vars","text":"cb_no_additions_or_deletions_in_vars(self::CBAFTModification)\n\nreturns true if no columns/variables were added or deleted (allows permutations), false otherwise\n\n\n\n\n\ncb_no_additions_or_deletions_in_vars(self::CBGroundsetModification)\n\nreturns true if no variables were added or deleted (allows permutations), false otherwise\n\n\n\n\n\ncb_no_additions_or_deletions_in_vars(self::CBNNCBoxSupportModification)\n\nreturns true if no variables were added or deleted (allows permutations), false otherwise\n\n\n\n\n\ncb_no_additions_or_deletions_in_vars(self::CBSOCSupportModification)\n\nreturns true if no variables were added or deleted (allows permutations), false otherwise\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_no_modification","page":"Reference of C++ interface","title":"ConicBundle.cb_no_modification","text":"cb_no_modification(self::CBAFTModification)\n\nreturns true if no modifications need to be executed\n\n\n\n\n\ncb_no_modification(self::CBGroundsetModification)\n\nreturns true if no modifications need to be executed except possibly an offset change for the ground set minorant\n\n\n\n\n\ncb_no_modification(self::CBNNCBoxSupportModification)\n\nreturns true if no modifications need to be executed except possibly an offset change for the ground set minorant\n\n\n\n\n\ncb_no_modification(self::CBPSCAffineModification)\n\nreturns true if no modifications need to be executed\n\n\n\n\n\ncb_no_modification(self::CBSOCSupportModification)\n\nreturns true if no modifications need to be executed except possibly an offset change for the ground set minorant\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_nonzeros","page":"Reference of C++ interface","title":"ConicBundle.cb_nonzeros","text":"cb_nonzeros(self::CBSparsemat)\n\nreturns the number of nonzeros\n\n\n\n\n\ncb_nonzeros(self::CBSparsesym)\n\nreturns the number of nonzeros in the lower triangle (including diagonal)\n\n\n\n\n\ncb_nonzeros(self::CBMinorantPointer)\n\nreturns the number of nonzero coefficients\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_nonzeros!","page":"Reference of C++ interface","title":"ConicBundle.cb_nonzeros!","text":"cb_nonzeros!(self::CBMinorant)\n\nreturns the number of nonzero coefficients\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_norm","page":"Reference of C++ interface","title":"ConicBundle.cb_norm","text":"cb_norm(self::CBCMgramdense)\n\nreturns the Frobenius norm of the matrix\n\n\n\n\n\ncb_norm(self::CBCMgramsparse)\n\nreturns the Frobenius norm of the matrix\n\n\n\n\n\ncb_norm(self::CBCMgramsparse_withoutdiag)\n\nreturns the Frobenius norm of the matrix\n\n\n\n\n\ncb_norm(self::CBCMlowrankdd)\n\nreturns the Frobenius norm of the matrix\n\n\n\n\n\ncb_norm(self::CBCMlowranksd)\n\nreturns the Frobenius norm of the matrix\n\n\n\n\n\ncb_norm(self::CBCMlowrankss)\n\nreturns the Frobenius norm of the matrix\n\n\n\n\n\ncb_norm(self::CBCMsingleton)\n\nreturns the Frobenius norm of the matrix\n\n\n\n\n\ncb_norm(self::CBCMsymdense)\n\nreturns the Frobenius norm of the matrix\n\n\n\n\n\ncb_norm(self::CBCMsymsparse)\n\nreturns the Frobenius norm of the matrix\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_norm2","page":"Reference of C++ interface","title":"ConicBundle.cb_norm2","text":"cb_norm2(A::CBMatrix)\n\nreturns the Frobenius norm of A, i.e., the square root of the sum of A(i,j)*A(i,j) over all i,j\n\n\n\n\n\ncb_norm2(A::CBIndexmatrix)\n\nreturns the Frobenius norm of A, i.e., the square root of the sum of A(i,j)*A(i,j) over all i,j\n\n\n\n\n\ncb_norm2(A::CBSparsemat)\n\nreturns the Frobenius norm of A, i.e., the square root of the sum of A(i,j)*A(i,j) over all i,j\n\n\n\n\n\ncb_norm2(A::CBSymmatrix)\n\nreturns the Frobenius norm of A, i.e., the square root of the sum of A(i,j)*A(i,j) over all i,j\n\n\n\n\n\ncb_norm2(A::CBSparsesym)\n\nreturns the Frobenius norm of A, i.e., the square root of the sum of A(i,j)*A(i,j) over all i,j\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_normDsquared","page":"Reference of C++ interface","title":"ConicBundle.cb_normDsquared","text":"cb_normDsquared(A::CBMatrix, d::CBMatrix, atrans::Integer, dinv::Integer)\n\nreturns trace(A^TDA)=\\|A\\|^2_D with D=Diag(d). A may be transposed, D may be inverted but there is no check for division by zero\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_norm_sqr","page":"Reference of C++ interface","title":"ConicBundle.cb_norm_sqr","text":"cb_norm_sqr(self::CBBundleDenseTrustRegionProx, B::CBMatrix)\n\nreturns B^2_H (with weightu included in H)\n\n\n\n\n\ncb_norm_sqr(self::CBBundleDiagonalTrustRegionProx, B::CBMatrix)\n\nreturns \\fB^2_Hf\n\n\n\n\n\ncb_norm_sqr(self::CBBundleDLRTrustRegionProx, B::CBMatrix)\n\nreturns B^2_H (with weight included)\n\n\n\n\n\ncb_norm_sqr(self::CBBundleIdProx, B::CBMatrix)\n\nreturns \\fB^2_Hf\n\n\n\n\n\ncb_norm_sqr(self::CBBundleLowRankTrustRegionProx, B::CBMatrix)\n\nreturns B^2_H (with weight included)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_norm_squared","page":"Reference of C++ interface","title":"ConicBundle.cb_norm_squared","text":"cb_norm_squared(self::CBMinorantPointer, D::Union{<:CBMatrix,Nothing} = nothing)\n\nCompute the norm squared of this for the given diagonal matrix D (identity if not given), i.e. \\f(*this)^2_Df\n\n\n\n\n\ncb_norm_squared(self::CBMinorant)\n\nreturn the squared Euclidean norm\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_normalize_sumbundle!","page":"Reference of C++ interface","title":"ConicBundle.cb_normalize_sumbundle!","text":"cb_normalize_sumbundle!(self::CBSumBundleHandler)\n\nbrief bring the bundle into a normal form so that contributions may be added and subtracted consistently\nThe normal form has the aggregate w.r.t. to the last bundle cofficients   stored in column aggr->index in scaled form so that in coeff all weight is   set to it. No other columns are modified.\nWhen addcontributions is called, it is assumed that parent bundle and   contributing bundle are in this form. Some care has to be taken that this   normalization is happening for parent and children in coordinated form so   that removecontribution() does not cause havoc. For this, the sumbundle   should always be normalized in (or right before) calling   SumBlockModel::sumbundle_contribution() before starting any interaction with   the parent or the children.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_nsubmodels","page":"Reference of C++ interface","title":"ConicBundle.cb_nsubmodels","text":"cb_nsubmodels(self::CBSumModel)\n\nreturns the number of submodels in this model\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_nullstep_update!","page":"Reference of C++ interface","title":"ConicBundle.cb_nullstep_update!","text":"cb_nullstep_update!(self::CBBundleHKWeight, newval::Real, oldval::Real, modelval::Real, y::CBMatrix, newy::CBMatrix, new_minorant::CBMinorantPointer, aggregate::CBMinorantPointer, nullstep_bound::Real, normsubg2::Real, Hp::Union{<:CBBundleProxObject,Nothing})\n\ndetermine next weight after a null step\n\n\n\n\n\ncb_nullstep_update!(self::CBBundleRQBWeight, newval::Real, oldval::Real, modelval::Real, y::CBMatrix, newy::CBMatrix, new_minorant::CBMinorantPointer, aggregate::CBMinorantPointer, nullstep_bound::Real, normsubg2::Real, Hp::Union{<:CBBundleProxObject,Nothing})\n\ndetermine next weight after a null step\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_number_aggregated","page":"Reference of C++ interface","title":"ConicBundle.cb_number_aggregated","text":"cb_number_aggregated(self::CBMinorant)\n\nreturns the number of minorants aggregated in this one, value 1 thus means not aggregated\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_nzcoldim","page":"Reference of C++ interface","title":"ConicBundle.cb_nzcoldim","text":"cb_nzcoldim(self::CBSparseCoeffmatMatrix)\n\nreturns the number of columns with nonzero coefficient matrices\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_objective_value","page":"Reference of C++ interface","title":"ConicBundle.cb_objective_value","text":"cb_objective_value(self::CBAffineFunctionTransformation, offset::Real, function_value::Real)\n\n@brief  if @a offset is the value computed in transformargument and      @a functionvalue results form an evaluation in the respective point,      the routine returns the objective value obtained by the affine transformation\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_offset","page":"Reference of C++ interface","title":"ConicBundle.cb_offset","text":"cb_offset(self::CBMinorantPointer)\n\nreturns the offset of the minorant (including the internal scalings) or CBminusinfinity if empty\n\n\n\n\n\ncb_offset(self::CBMinorantUseData)\n\nreturn the offset of the minorant\n\n\n\n\n\ncb_offset(self::CBMinorant)\n\nreturns the current offset value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_offset_gives_value_at_origin","page":"Reference of C++ interface","title":"ConicBundle.cb_offset_gives_value_at_origin","text":"cb_offset_gives_value_at_origin(self::CBMinorant)\n\ntrue if the offset refers to origin and false, if the offset refers to the value of the  minorant in the point of the oracle evaluation at which this minorant was supplied\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_offset_gives_value_at_origin!","page":"Reference of C++ interface","title":"ConicBundle.cb_offset_gives_value_at_origin!","text":"cb_offset_gives_value_at_origin!(self::CBMinorant)\n\nallows to specify/modify whether the offset refers to origin or to the point of evaluation at which this minorant was supplied\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_old_blockdim","page":"Reference of C++ interface","title":"ConicBundle.cb_old_blockdim","text":"cb_old_blockdim(self::CBPSCAffineModification)\n\nreturns the number of rows before modification (given on initialization)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_old_rowdim","page":"Reference of C++ interface","title":"ConicBundle.cb_old_rowdim","text":"cb_old_rowdim(self::CBAFTModification)\n\nreturns the number of rows before modification (given on initialization)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_old_vardim","page":"Reference of C++ interface","title":"ConicBundle.cb_old_vardim","text":"cb_old_vardim(self::CBAFTModification)\n\nreturns the number of variables before modification (given on initialization)\n\n\n\n\n\ncb_old_vardim(self::CBGroundsetModification)\n\nreturns the number of variables before modification (given on initialization)\n\n\n\n\n\ncb_old_vardim(self::CBNNCBoxSupportModification)\n\nreturns the number of variables before modification (given on initialization)\n\n\n\n\n\ncb_old_vardim(self::CBPSCAffineModification)\n\nreturns the number of variables before modification (given on initialization)\n\n\n\n\n\ncb_old_vardim(self::CBSOCSupportModification)\n\nreturns the number of variables before modification (given on initialization)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_one_user","page":"Reference of C++ interface","title":"ConicBundle.cb_one_user","text":"cb_one_user(self::CBMinorantPointer)\n\nreturns true if not valid or this is the only active pointer to the minorant\n\n\n\n\n\ncb_one_user(self::CBMinorantUseData)\n\nreturns true if not valid or use_cnt==1 recursively\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_only_scalars_change","page":"Reference of C++ interface","title":"ConicBundle.cb_only_scalars_change","text":"cb_only_scalars_change(self::CBAFTModification)\n\nreturns true if linear_cost, matrix and affine rhs offset are not changed\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_out","page":"Reference of C++ interface","title":"ConicBundle.cb_out","text":"cb_out(self::CBCMgramdense)\n\nput entire contents onto ostream with the class type in the beginning so that the derived class can be recognized by in().\n\n\n\n\n\ncb_out(self::CBCMgramsparse)\n\nput entire contents onto ostream with the class type in the beginning so that the derived class can be recognized by in().\n\n\n\n\n\ncb_out(self::CBCMgramsparse_withoutdiag)\n\nput entire contents onto ostream with the class type in the beginning so that the derived class can be recognized by in().\n\n\n\n\n\ncb_out(self::CBCMlowrankdd)\n\nput entire contents onto ostream with the class type in the beginning so that the derived class can be recognized by in().\n\n\n\n\n\ncb_out(self::CBCMlowranksd)\n\nput entire contents onto ostream with the class type in the beginning so that the derived class can be recognized by in().\n\n\n\n\n\ncb_out(self::CBCMlowrankss)\n\nput entire contents onto ostream with the class type in the beginning so that the derived class can be recognized by in().\n\n\n\n\n\ncb_out(self::CBCMsingleton)\n\nput entire contents onto outstream with the class type in the beginning so that the derived class can be recognized by in().\n\n\n\n\n\ncb_out(self::CBCMsymdense)\n\nput entire contents onto outstream with the class type in the beginning so that the derived class can be recognized by in().\n\n\n\n\n\ncb_out(self::CBCMsymsparse)\n\nput entire contents onto outstream with the class type in the beginning so that the derived class can be recognized by in().\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_output_aft_data","page":"Reference of C++ interface","title":"ConicBundle.cb_output_aft_data","text":"cb_output_aft_data(self::CBAffineFunctionTransformation)\n\nfor testing purposes this outputs the data in mfile readable form\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_output_bundle_data","page":"Reference of C++ interface","title":"ConicBundle.cb_output_bundle_data","text":"cb_output_bundle_data(self::CBPSCModel)\n\nthis outputs the qp model data recursively for testing purposes\n\n\n\n\n\ncb_output_bundle_data(self::CBSOCModel)\n\nthis outputs the qp model data recursively for testing purposes\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_pivot_permute!","page":"Reference of C++ interface","title":"ConicBundle.cb_pivot_permute!","text":"cb_pivot_permute!(self::CBSymmatrix, piv::CBIndexmatrix, inverse::Bool = false)\n\nfor i=0 to rowdim row (and column) i of this matrix is swapped with row piv(j); for inverse=true the inverse permutation is generated\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_pivot_permute_cols!","page":"Reference of C++ interface","title":"ConicBundle.cb_pivot_permute_cols!","text":"cb_pivot_permute_cols!(self::CBMatrix, piv::CBIndexmatrix, inverse::Bool = false)\n\nfor j=0 to coldim column  j of this matrix is swapped with column piv(j); for inverse =true the inverse permutation is generated\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_pivot_permute_rows!","page":"Reference of C++ interface","title":"ConicBundle.cb_pivot_permute_rows!","text":"cb_pivot_permute_rows!(self::CBMatrix, piv::CBIndexmatrix, inverse::Bool = false)\n\nfor i=0 to rowdim row i of this matrix is swapped with row piv(i); for inverse =true the inverse permutation is generated\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_pop_aft!","page":"Reference of C++ interface","title":"ConicBundle.cb_pop_aft!","text":"cb_pop_aft!(self::CBBundleDenseTrustRegionProx)\n\nsee  BundleProxObject::pop_aft();\n\n\n\n\n\ncb_pop_aft!(self::CBBundleDiagonalTrustRegionProx)\n\nsee  BundleProxObject::pop_aft();\n\n\n\n\n\ncb_pop_aft!(self::CBBundleDLRTrustRegionProx)\n\nsee  BundleProxObject::pop_aft();\n\n\n\n\n\ncb_pop_aft!(self::CBBundleLowRankTrustRegionProx)\n\nsee  BundleProxObject::pop_aft();\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_postgenmult","page":"Reference of C++ interface","title":"ConicBundle.cb_postgenmult","text":"cb_postgenmult(self::CBCMgramdense, B::CBMatrix, C::CBMatrix, alpha::Real = 1., beta::Real = 0., btrans::Integer = 0)\n\ncomputes C= alpha(this)B^(T if btrans) + betaC, C is also returned\n\n\n\n\n\ncb_postgenmult(self::CBCMgramsparse, B::CBMatrix, C::CBMatrix, alpha::Real = 1., beta::Real = 0., btrans::Integer = 0)\n\ncomputes C= alpha(this)B^(T if btrans) + betaC, C is also returned\n\n\n\n\n\ncb_postgenmult(self::CBCMgramsparse_withoutdiag, B::CBMatrix, C::CBMatrix, alpha::Real = 1., beta::Real = 0., btrans::Integer = 0)\n\ncomputes C= alpha(this)B^(T if btrans) + betaC, C is also returned\n\n\n\n\n\ncb_postgenmult(self::CBCMlowrankdd, D::CBMatrix, C::CBMatrix, alpha::Real = 1., beta::Real = 0., dtrans::Integer = 0)\n\ncomputes C= alpha(this)D^(T if dtrans) + betaC, C is also returned\n\n\n\n\n\ncb_postgenmult(self::CBCMlowranksd, D::CBMatrix, C::CBMatrix, alpha::Real = 1., beta::Real = 0., dtrans::Integer = 0)\n\ncomputes C= alpha(this)D^(T if dtrans) + betaC, C is also returned\n\n\n\n\n\ncb_postgenmult(self::CBCMlowrankss, D::CBMatrix, C::CBMatrix, alpha::Real = 1., beta::Real = 0., dtrans::Integer = 0)\n\ncomputes C= alpha(this)D^(T if dtrans) + betaC, C is also returned\n\n\n\n\n\ncb_postgenmult(self::CBCMsingleton, B::CBMatrix, C::CBMatrix, alpha::Real = 1., beta::Real = 0., btrans::Integer = 0)\n\ncomputes C= alpha(this)B^(T if btrans) + betaC, C is also returned\n\n\n\n\n\ncb_postgenmult(self::CBCMsymdense, B::CBMatrix, C::CBMatrix, alpha::Real = 1., beta::Real = 0., btrans::Integer = 0)\n\ncomputes C= alpha(this)B^(T if btrans) + betaC, C is also returned\n\n\n\n\n\ncb_postgenmult(self::CBCMsymsparse, B::CBMatrix, C::CBMatrix, alpha::Real = 1., beta::Real = 0., btrans::Integer = 0)\n\ncomputes C= alpha(this)B^(T if btrans) + betaC, C is also returned\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_precondM1!","page":"Reference of C++ interface","title":"ConicBundle.cb_precondM1!","text":"cb_precondM1!(self::CBQPKKTSubspaceHPrecond, vec::CBMatrix)\n\nreturns M1^{-1}*vec; default: M1=I\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_precond_invG1!","page":"Reference of C++ interface","title":"ConicBundle.cb_precond_invG1!","text":"cb_precond_invG1!(self::CBQPKKTSubspaceHPrecond, vec::CBMatrix)\n\nfor estimating the condition number with M1=GG^T this returns G^{-1}vec; default: G=I\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_precond_invG1tran!","page":"Reference of C++ interface","title":"ConicBundle.cb_precond_invG1tran!","text":"cb_precond_invG1tran!(self::CBQPKKTSubspaceHPrecond, vec::CBMatrix)\n\nfor estimating the condition number with M1=GG^T this returns G^{-T}vec; default: G=I\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_precond_size!","page":"Reference of C++ interface","title":"ConicBundle.cb_precond_size!","text":"cb_precond_size!(self::CBQPKKTSubspaceHPrecond)\n\nfor estimating the condition number directly for the preconditioned part only; negative numbers indicate that the routine is not implemented\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_pregenmult","page":"Reference of C++ interface","title":"ConicBundle.cb_pregenmult","text":"cb_pregenmult(self::CBCMgramdense, B::CBMatrix, C::CBMatrix, alpha::Real = 1., beta::Real = 0., btrans::Integer = 0)\n\ncomputes C= alphaB^(T if btrans)(this) + betaC, C is also returned\n\n\n\n\n\ncb_pregenmult(self::CBCMgramsparse, B::CBMatrix, C::CBMatrix, alpha::Real = 1., beta::Real = 0., btrans::Integer = 0)\n\ncomputes C= alphaB^(T if btrans)(this) + betaC, C is also returned\n\n\n\n\n\ncb_pregenmult(self::CBCMgramsparse_withoutdiag, B::CBMatrix, C::CBMatrix, alpha::Real = 1., beta::Real = 0., btrans::Integer = 0)\n\ncomputes C= alphaB^(T if btrans)(this) + betaC, C is also returned\n\n\n\n\n\ncb_pregenmult(self::CBCMlowrankdd, D::CBMatrix, C::CBMatrix, alpha::Real = 1., beta::Real = 0., dtrans::Integer = 0)\n\ncomputes C= alphaD^(T if dtrans)(this) + betaC, C is also returned\n\n\n\n\n\ncb_pregenmult(self::CBCMlowranksd, D::CBMatrix, C::CBMatrix, alpha::Real = 1., beta::Real = 0., dtrans::Integer = 0)\n\ncomputes C= alphaD^(T if dtrans)(this) + betaC, C is also returned\n\n\n\n\n\ncb_pregenmult(self::CBCMlowrankss, D::CBMatrix, C::CBMatrix, alpha::Real = 1., beta::Real = 0., dtrans::Integer = 0)\n\ncomputes C= alphaD^(T if dtrans)(this) + betaC, C is also returned\n\n\n\n\n\ncb_pregenmult(self::CBCMsingleton, B::CBMatrix, C::CBMatrix, alpha::Real = 1., beta::Real = 0., btrans::Integer = 0)\n\ncomputes C= alphaB^(T if btrans)(this) + betaC, C is also returned\n\n\n\n\n\ncb_pregenmult(self::CBCMsymdense, B::CBMatrix, C::CBMatrix, alpha::Real = 1., beta::Real = 0., btrans::Integer = 0)\n\ncomputes C= alphaB^(T if btrans)(this) + betaC, C is also returned\n\n\n\n\n\ncb_pregenmult(self::CBCMsymsparse, B::CBMatrix, C::CBMatrix, alpha::Real = 1., beta::Real = 0., btrans::Integer = 0)\n\ncomputes C= alphaB^(T if btrans)(this) + betaC, C is also returned\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_prepare_BCSchur_JLprecond!","page":"Reference of C++ interface","title":"ConicBundle.cb_prepare_BCSchur_JLprecond!","text":"cb_prepare_BCSchur_JLprecond!(self::CBQPConeModelBlock, glob_lowrank::CBMatrix, subspace::CBMatrix, append_globtransp_times_mat_to_subspace::Bool, globalbundle::CBMinorantBundle, startindex_bundle::Integer)\n\n@brief compute the preconditioning low-rank representation of the Schur complementd blocks belonging to bundle and local constraints by adding a Johnson-Lindenstrauss projection onto the given subspace to glob_lowrank\n\n\n\n\n\ncb_prepare_BCSchur_JLprecond!(self::CBQPSumModelBlock, glob_lowrank::CBMatrix, subspace::CBMatrix, append_globtransp_times_mat_to_subspace::Bool, globalbundle::CBMinorantBundle, startindex_bundle::Integer)\n\n@brief compute the preconditioning low-rank representation of the Schur complementd blocks belonging to bundle and local constraints by adding a Johnson-Lindenstrauss projection onto the given subspace to glob_lowrank\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_preserves_identity","page":"Reference of C++ interface","title":"ConicBundle.cb_preserves_identity","text":"cb_preserves_identity(self::CBAFTModification)\n\nreturns true if the modifications are consistent with the AffineFunctionTransformation matrix staying the identity\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_primal_ip","page":"Reference of C++ interface","title":"ConicBundle.cb_primal_ip","text":"cb_primal_ip(self::CBSparseCoeffmatMatrix, ipvec::CBMatrix, primal::Union{<:CBPSCPrimal,Nothing}, ind::Union{<:CBIndexmatrix,Nothing} = nothing)\n\ncomputes the inner products of (selected) columns (which represent block diagonal symmetric matrices) with the primal into the column vector ipvec(j)=ip(primal,A.column((ind)(j)}) (j=0,...,ind->dim()-1); if ind==NULL, use all columns\n\n\n\n\n\ncb_primal_ip(self::CBSparseCoeffmatMatrix, primal::Union{<:CBPSCPrimal,Nothing}, j::Integer)\n\ncomputes the inner product of the block diagonal symmetric matrix stored in colummn j with the primal into ipval=ip(*primal,A.column(j))\n\n\n\n\n\ncb_primal_ip(self::CBBlockPSCPrimal, A::CBSparseCoeffmatMatrix, column::Integer)\n\nif compatible evaluate value=ip(*this,A.column[i])\n\n\n\n\n\ncb_primal_ip(self::CBDensePSCPrimal, A::CBSparseCoeffmatMatrix, column::Integer)\n\nif compatible evaluate value=ip(*this,A.column[i])\n\n\n\n\n\ncb_primal_ip(self::CBGramSparsePSCPrimal, A::CBSparseCoeffmatMatrix, column::Integer)\n\nif compatible evaluate value=ip(*this,A.column[i])\n\n\n\n\n\ncb_primal_ip(self::CBSparsePSCPrimal, A::CBSparseCoeffmatMatrix, column::Integer)\n\nif compatible evaluate value=ip(*this,A.column[i])\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_primalviol_2normsqr!","page":"Reference of C++ interface","title":"ConicBundle.cb_primalviol_2normsqr!","text":"cb_primalviol_2normsqr!(self::CBQPConeModelBlock)\n\nreturn squared Euclidean norm of constraint violation of modelx\n\n\n\n\n\ncb_primalviol_2normsqr!(self::CBQPSumModelBlock)\n\nreturn the squared Euclidean norm of constraint violation of modelx\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_principal_submatrix","page":"Reference of C++ interface","title":"ConicBundle.cb_principal_submatrix","text":"cb_principal_submatrix(self::CBSymmatrix, ind::CBIndexmatrix, S::CBSymmatrix)\n\nreturns S and in S the principal submatrix indexed by ind (multiple indices are allowed)\n\n\n\n\n\ncb_principal_submatrix(self::CBSymmatrix, ind::CBIndexmatrix)\n\nreturns the principal submatrix indexed by ind (multiple indices are allowed)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_print_id","page":"Reference of C++ interface","title":"ConicBundle.cb_print_id","text":"cb_print_id(self::CBCoeffmatInfo)\n\noutput a name if there is one for recognizing the type\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_print_line_summary","page":"Reference of C++ interface","title":"ConicBundle.cb_print_line_summary","text":"cb_print_line_summary(self::CBMatrixCBSolver)\n\nprint a one line summary of important evaluation data\n\n\n\n\n\ncb_print_line_summary(self::CBBundleSolver)\n\n@brief print a one line summary about the current state of progress of the algorithm to @a out\n  Assuming that an external clock has been set, the line looks as follows\n\n  hh:mm:ss.hh endit dd ii uu weightu aggr_dnorm modelval center_ub (N)\n\n  These are\n  - hh:mm:ss.hh hours, mintues, seconds, hundreth of secondes\n  - \"endit\" this string is short for \"end of iteration\" and is\n    convenient for the unix command grep; in the case the code\n    has terminated it shows \"_endit\" instead\n  - dd gives the number of descent steps as in @a descent_steps\n  - ii gives the total number of iterations of the bundle method,\n    counting descent steps and null steps\n  - uu gives the total number of quadratic bundle subproblem\n    evaluations as counted by @a sumupdatecnt\n  - weight gives the value of the weight factor for the proximal\n    term used in the last quadratic bundle subproblem\n  - aggr_dnorm gives the dual norm of the aggregate (dual with\n    respect to the quadratic proximal term)\n  - modelval gives the model value used for deciding on null or\n    descent step; this is @a linval if @a use_linval ==true and\n@a cutval otherwise       - centerub gives the upper bound computed by the oracle on the          function value in the center       - \"N\" is only shown if the code has not terminated and a null          step just occured before returning (nullstep is true)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_print_problem_data","page":"Reference of C++ interface","title":"ConicBundle.cb_print_problem_data","text":"cb_print_problem_data(self::CBNNCBoxSupportFunction)\n\nwrite the problem description to out so that it can be read again by readproblemdata()\n\n\n\n\n\ncb_print_problem_data(self::CBPSCAffineFunction)\n\nwrite the problem description to out so that it can be read again by readproblemdata()\n\n\n\n\n\ncb_print_problem_data(self::CBSOCSupportFunction)\n\nwrite the problem description to out so that it can be read again by readproblemdata()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_print_problem_data_to_mfile","page":"Reference of C++ interface","title":"ConicBundle.cb_print_problem_data_to_mfile","text":"cb_print_problem_data_to_mfile(self::CBNNCBoxSupportFunction, blocknr::Integer)\n\nundocumented highly volatile variant for external testing\n\n\n\n\n\ncb_print_problem_data_to_mfile(self::CBPSCAffineFunction, blocknr::Integer)\n\nundocumented highly volatile variant for external testing\n\n\n\n\n\ncb_print_problem_data_to_mfile(self::CBSOCSupportFunction, blocknr::Integer)\n\nundocumented highly volatile variant for external testing\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_print_statistics","page":"Reference of C++ interface","title":"ConicBundle.cb_print_statistics","text":"cb_print_statistics(self::CBMatrixCBSolver)\n\nprint a cryptic summary of computation times of important components\n\n\n\n\n\ncb_print_statistics(self::CBUQPSolver)\n\noutput some statistical information on performance\n\n\n\n\n\ncb_print_statistics(self::CBBundleSolver)\n\noutput some time statistic paramters\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_print_status","page":"Reference of C++ interface","title":"ConicBundle.cb_print_status","text":"cb_print_status(self::CBBundleTerminator)\n\noutput an explanation string for the current termination code\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_print_termination_code-Tuple{ConicBundle.CBMatrixCBSolver}","page":"Reference of C++ interface","title":"ConicBundle.cb_print_termination_code","text":"cb_print_termination_code(self::CBMatrixCBSolver)\n\n@brief Outputs a text version of termination code, see termination_code().\n@return\n  - 0 on success\n  - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_print_time","page":"Reference of C++ interface","title":"ConicBundle.cb_print_time","text":"cb_print_time(m::CBMicroseconds, secondsonly::Integer = 0)\n\nprint Microseconds in the format \"hh:mm:ss.dd\" or \"hh:mm:ss\"\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_prodvec_flops","page":"Reference of C++ interface","title":"ConicBundle.cb_prodvec_flops","text":"cb_prodvec_flops(self::CBCMgramdense)\n\nreturns an estimate of number of flops to compute addprodto for a vector\n\n\n\n\n\ncb_prodvec_flops(self::CBCMgramsparse)\n\nreturns an estimate of number of flops to compute addprodto for a vector\n\n\n\n\n\ncb_prodvec_flops(self::CBCMgramsparse_withoutdiag)\n\nreturns an estimate of number of flops to compute addprodto for a vector\n\n\n\n\n\ncb_prodvec_flops(self::CBCMlowrankdd)\n\nreturns an estimate of number of flops to compute addprodto for a vector\n\n\n\n\n\ncb_prodvec_flops(self::CBCMlowranksd)\n\nreturns an estimate of number of flops to compute addprodto for a vector\n\n\n\n\n\ncb_prodvec_flops(self::CBCMlowrankss)\n\nreturns an estimate of number of flops to compute addprodto for a vector\n\n\n\n\n\ncb_prodvec_flops(self::CBCMsingleton)\n\nreturns an estimate of number of flops to compute addprodto for a vector\n\n\n\n\n\ncb_prodvec_flops(self::CBCMsymdense)\n\nreturns an estimate of number of flops to compute addprodto for a vector\n\n\n\n\n\ncb_prodvec_flops(self::CBCMsymsparse)\n\nreturns an estimate of number of flops to compute addprodto for a vector\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_project","page":"Reference of C++ interface","title":"ConicBundle.cb_project","text":"cb_project(self::CBCMgramdense, S::CBSymmatrix, P::CBMatrix)\n\ncomputes S=P^T(this)*P\n\n\n\n\n\ncb_project(self::CBCMgramsparse, S::CBSymmatrix, P::CBMatrix)\n\ncomputes S=P^T(this)*P\n\n\n\n\n\ncb_project(self::CBCMgramsparse_withoutdiag, S::CBSymmatrix, P::CBMatrix)\n\ncomputes S=P^T(this)*P\n\n\n\n\n\ncb_project(self::CBCMlowrankdd, S::CBSymmatrix, P::CBMatrix)\n\ncomputes S=P^T(this)*P\n\n\n\n\n\ncb_project(self::CBCMlowranksd, S::CBSymmatrix, P::CBMatrix)\n\ncomputes S=P^T(this)*P\n\n\n\n\n\ncb_project(self::CBCMlowrankss, S::CBSymmatrix, P::CBMatrix)\n\ncomputes S=P^T(this)*P\n\n\n\n\n\ncb_project(self::CBCMsingleton, S::CBSymmatrix, P::CBMatrix)\n\ncomputes S=P^T(this)*P\n\n\n\n\n\ncb_project(self::CBCMsymdense, S::CBSymmatrix, P::CBMatrix)\n\ncomputes S=P^T(this)*P\n\n\n\n\n\ncb_project(self::CBCMsymsparse, S::CBSymmatrix, P::CBMatrix)\n\ncomputes S=P^T(this)*P\n\n\n\n\n\ncb_project(self::CBSparseCoeffmatMatrix, S::CBSymmatrix, P::CBMatrix, j::Integer)\n\ncomputes S=P^TA.column(j)P\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_projected_clone!","page":"Reference of C++ interface","title":"ConicBundle.cb_projected_clone!","text":"cb_projected_clone!(self::CBBundleDenseTrustRegionProx, indices::CBIndexmatrix)\n\n@brief in order to allow for fixed variables, this generates a clone restricted to the given indices\n\n\n\n\n\ncb_projected_clone!(self::CBBundleDiagonalTrustRegionProx, indices::CBIndexmatrix)\n\n@brief in order to allow for fixed variables, this generates a clone restricted to the given indices\n\n\n\n\n\ncb_projected_clone!(self::CBBundleDLRTrustRegionProx, indices::CBIndexmatrix)\n\n@brief in order to allow for fixed variables, this generates a clone restricted to the given indices\n\n\n\n\n\ncb_projected_clone!(self::CBBundleIdProx, indices::CBIndexmatrix)\n\n@brief in order to allow for fixed variables, this generates a clone restricted to the given indices\n\n\n\n\n\ncb_projected_clone!(self::CBBundleLowRankTrustRegionProx, indices::CBIndexmatrix)\n\n@brief in order to allow for fixed variables, this generates a clone restricted to the given indices\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_projection!","page":"Reference of C++ interface","title":"ConicBundle.cb_projection!","text":"cb_projection!(self::CBSOCSupportFunction, offset::CBMatrix, coeffs::CBMatrix, bar_P::CBMatrix, index_subset::Union{<:CBIndexmatrix,Nothing} = nothing)\n\nsee SOCOracle::projection()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_propose_BCSchur_pcsubspace!","page":"Reference of C++ interface","title":"ConicBundle.cb_propose_BCSchur_pcsubspace!","text":"cb_propose_BCSchur_pcsubspace!(self::CBQPConeModelBlock, lowrank::CBMatrix, sigma_guess::CBMatrix, Diag_inv::CBMatrix, minval::Real, diaginvval::Real, globalbundle::CBMinorantBundle, startindex_bundle::Integer)\n\n@brief append to lowrank \"large\" columns that should serve well for generating a low rank projection of the Schur complemented model part. For each column i the coordinate sigmaguess(i) gives the Diaginv-norm for this column. The parameter minval asks to ignore columns whose norms are smaller than minval. If diaginvval is positive, the vector Diag_inv is this value times the all ones vector.\nOn input lowrank must have the correct number of rows already but may\nhave 0 columns.\n\n\n\n\n\ncb_propose_BCSchur_pcsubspace!(self::CBQPSumModelBlock, lowrank::CBMatrix, sigma_guess::CBMatrix, Diag_inv::CBMatrix, minval::Real, diaginvval::Real, globalbundle::CBMinorantBundle, startindex_bundle::Integer)\n\n@brief append to lowrank \"large\" columns that should serve well for generating a low rank projection of the Schur complemented model part. For each column i the coordinate sigmaguess(i) gives the Diaginv-norm for this column. The parameter minval asks to ignore columns whose norms are smaller than minval. If diaginvval is positive, the vector Diag_inv is this value times the all ones vector.\nOn input lowrank must have the correct number of rows already but may\nhave 0 columns.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_provide_model_aggregate!","page":"Reference of C++ interface","title":"ConicBundle.cb_provide_model_aggregate!","text":"cb_provide_model_aggregate!(self::CBAFTModel, y_id::Integer, y::CBMatrix)\n\nsee BundleModel::providemodelaggregate\n\n\n\n\n\ncb_provide_model_aggregate!(self::CBSumModel, y_id::Integer, y::CBMatrix)\n\nsee BundleModel::providemodelaggregate\n\n\n\n\n\ncb_provide_model_aggregate!(self::CBSumBundleHandler)\n\nsee SumBlockModel::providemodelaggregate\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_push_aft!","page":"Reference of C++ interface","title":"ConicBundle.cb_push_aft!","text":"cb_push_aft!(self::CBBundleDenseTrustRegionProx, aft::Union{<:CBAffineFunctionTransformation,Nothing})\n\nsee  BundleProxObject::push_aft();\n\n\n\n\n\ncb_push_aft!(self::CBBundleDiagonalTrustRegionProx, aft::Union{<:CBAffineFunctionTransformation,Nothing})\n\nsee  BundleProxObject::push_aft();\n\n\n\n\n\ncb_push_aft!(self::CBBundleDLRTrustRegionProx, aft::Union{<:CBAffineFunctionTransformation,Nothing})\n\nsee  BundleProxObject::push_aft();\n\n\n\n\n\ncb_push_aft!(self::CBBundleLowRankTrustRegionProx, aft::Union{<:CBAffineFunctionTransformation,Nothing})\n\nsee  BundleProxObject::push_aft();\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_qp_cost_indices","page":"Reference of C++ interface","title":"ConicBundle.cb_qp_cost_indices","text":"cb_qp_cost_indices(self::CBAffineFunctionTransformation, provide_row_indices::CBIndexmatrix, needed_col_indices::Union{<:CBIndexmatrix,Nothing})\n\n@brief if the algorithm only requires the indices given in @a      neededcolindices (NULL means all indices) then it suffices to supply      the @a providerowindices as @a indices in transform_minorant (a 0x0      return matrix again means all indices, while a 0x1 matrix means no      indices). Any input or output indices must be in strictly increasing      order.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_qp_mfile_data","page":"Reference of C++ interface","title":"ConicBundle.cb_qp_mfile_data","text":"cb_qp_mfile_data(self::CBBundleSolver, center_y::CBMatrix, Hp::Union{<:CBBundleProxObject,Nothing}, gs_subg::CBMinorantPointer, Q::CBSymmatrix, c::CBMatrix, offset::Real, yfixed::CBIndexmatrix)\n\noutput the data of the Gauss-Seidel qp to in an m file format\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_rand","page":"Reference of C++ interface","title":"ConicBundle.cb_rand","text":"cb_rand(nr::Integer, nc::Integer, random_generator::Union{<:CBGB_rand,Nothing})\n\nreturn a nr x nc matrix with (i,j) assigned a random number uniformly from [0,1] for all i,j\n\n\n\n\n\ncb_rand(nr::Integer, nc::Integer, lb::Integer, ub::Integer, random_generator::Union{<:CBGB_rand,Nothing})\n\nreturn a nr x nc matrix with (i,j) assigned a random number uniformly from [lowerb,upperb] for all i,j\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_rand!","page":"Reference of C++ interface","title":"ConicBundle.cb_rand!","text":"cb_rand!(self::CBMatrix, nr::Integer, nc::Integer, random_generator::Union{<:CBGB_rand,Nothing} = nothing)\n\nresize *this to an nr x nc matrix and assign to (i,j) a random number uniformly from [0,1] for all i,j\n\n\n\n\n\ncb_rand!(self::CBIndexmatrix, nr::Integer, nc::Integer, lowerb::Integer, upperb::Integer, random_generator::Union{<:CBGB_rand,Nothing} = nothing)\n\nresize *this to an nr x nc matrix and assign to (i,j) a random number uniformly from [lowerb,upperb] for all i,j\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_rand_normal!","page":"Reference of C++ interface","title":"ConicBundle.cb_rand_normal!","text":"cb_rand_normal!(self::CBMatrix, nr::Integer, nc::Integer, mean::Real = 0., variance::Real = 1., generator_type::Integer = 0)\n\nresize *this to an nr x nc matrix and assign to (i,j) a random number from the normal distribution with given mean and variance (generators: 0 std, 1 mt, 2 mt64)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_rank2add","page":"Reference of C++ interface","title":"ConicBundle.cb_rank2add","text":"cb_rank2add(A::CBSparsemat, B::CBMatrix, C::CBSymmatrix, alpha::Real, beta::Real, trans::Integer)\n\nreturns C=betaC+alpha(AB^T+BA^T)/2 [or for transposed (A^TB+B^TA)/2]. If beta==0. then C is initiliazed to the correct size.\n\n\n\n\n\ncb_rank2add(A::CBMatrix, B::CBMatrix, C::CBSymmatrix, alpha::Real, beta::Real, trans::Integer)\n\nreturns C=betaC+alpha(AB^T+BA^T)/2 [or for transposed (A^TB+B^TA)/2]. If beta==0. then C is initiliazed to the correct size.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_rankadd","page":"Reference of C++ interface","title":"ConicBundle.cb_rankadd","text":"cb_rankadd(A::CBSparsemat, C::CBSymmatrix, alpha::Real, beta::Real, trans::Integer)\n\nreturns C=betaC+alpha A*A^T, where A may be transposed; if beta==0. then C is initialized to the correct size\n\n\n\n\n\ncb_rankadd(A::CBMatrix, C::CBSymmatrix, alpha::Real, beta::Real, trans::Integer)\n\nreturns C=betaC+alpha A*A^T, where A may be transposed. If beta==0. then C is initiliazed to the correct size.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_reassign_blocks!","page":"Reference of C++ interface","title":"ConicBundle.cb_reassign_blocks!","text":"cb_reassign_blocks!(self::CBSparseCoeffmatMatrix, map_to_old::CBIndexmatrix)\n\nafterwards the new block i is the previous block maptoold(i); no multiple appearances are allowed, but not all have to appear (these are deleted)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_reassign_coeffs!","page":"Reference of C++ interface","title":"ConicBundle.cb_reassign_coeffs!","text":"cb_reassign_coeffs!(self::CBMinorant, n_elements::Integer, map_to_old_coeffs::Union{<:AbstractVector{Integer},Nothing})\n\nresorts (and deletes) coefficients so that afterwards it has nelements and the new coeff(i) has the previous value of coeff(maptooldcoeff(i))\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_reassign_columns!","page":"Reference of C++ interface","title":"ConicBundle.cb_reassign_columns!","text":"cb_reassign_columns!(self::CBSparseCoeffmatMatrix, map_to_old::CBIndexmatrix)\n\nafterwards the new column i is the previous column maptoold(i); no multiple appearances are allowed, but not all have to appear (these are deleted)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_reassign_variables!-Tuple{ConicBundle.CBMatrixCBSolver, ConicBundle.CBIndexmatrix}","page":"Reference of C++ interface","title":"ConicBundle.cb_reassign_variables!","text":"cb_reassign_variables!(self::CBMatrixCBSolver, assign_new_from_old::CBIndexmatrix)\n\n@brief Reassigns variables to new index positions by mapping to position @a i       the variable that previously had index @a assignnewfrom_old[i].\n  Old variables, that are not mapped to any position will be deleted.\n  It is not allowed to generate several copies of old variables.\n@attention Be sure to include a desription of required changes to your      functions via @a affectedfunctionswith_modifications\n@param[in] assignnewfromold  (const IVector&)       entry assignnewfromold[i] specifies       the old index of the variable, that has to be copied to index position i.\n@param[in] affectedfunctionswith_modifications (const FunObjModMap*)       If NULL, default actions are performed on all functions. In       particular, for those admitting dynamic argument changes all those variables will be deleted whose row in a corresponding updated affine function transformation (so after mapping the columns of the incoming variables) correspond to the zero map (i.e., offset and matrix row are both zero); furthermore, if the transformation was the identity to start with, this will be preserved by mapping the arguments in the same way. For those       not admitting changes in their arguments, their corresponding       (possibly newly created) affine function transformation will       only get the columns mapped, but there will be no row deleltions. If !=NULL, for the listed functions (and their parents up to the root function) the default deletion action is performed unless their       FunctionObjectModification entry gives explicit modification       instructions which are then applied instead. For all functions       NOT listed in the map and not having modified offsprings their       corresponding aft will be set up to keep the arguments unchanged.\n@return       - 0 on success       - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_recompute_center!","page":"Reference of C++ interface","title":"ConicBundle.cb_recompute_center!","text":"cb_recompute_center!(self::CBAFTModel, center_id::Integer, y::CBMatrix, accept_only_higher_values::Bool = false, relprec::Real = -1.)\n\nsee BundleModel::recompute_center\n\n\n\n\n\ncb_recompute_center!(self::CBSumModel, center_id::Integer, y::CBMatrix, accept_only_higher_values::Bool = false, relprec::Real = -1.)\n\nsee BundleModel::recompute_center\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_recursive_copy_data_of!","page":"Reference of C++ interface","title":"ConicBundle.cb_recursive_copy_data_of!","text":"cb_recursive_copy_data_of!(self::CBQPConeModelBlock, param0::Union{<:CBQPModelBlockObject,Nothing})\n\nsofar this is only needed for some comparative evaluations; to work *this must be a clone of the the argument and the content of the objects is copied recursively\n\n\n\n\n\ncb_recursive_copy_data_of!(self::CBQPSumModelBlock, param0::Union{<:CBQPModelBlockObject,Nothing})\n\nsofar this is only needed for some comparative evaluations\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_recursive_delete_and_clear!","page":"Reference of C++ interface","title":"ConicBundle.cb_recursive_delete_and_clear!","text":"cb_recursive_delete_and_clear!(self::CBQPConeModelBlock)\n\nusually the objects of the recursive block structure and not deleted in a clear. If needed, this can be invoked explicitly here, e.g., in order to clean up clones\n\n\n\n\n\ncb_recursive_delete_and_clear!(self::CBQPSumModelBlock)\n\nusually the objects of the recursive block structure and not deleted in a clear. If needed, this can be invoked explicitly here, e.g., in order to clean up clones\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_reduce_length!","page":"Reference of C++ interface","title":"ConicBundle.cb_reduce_length!","text":"cb_reduce_length!(self::CBMatrix, n::Integer)\n\n(*this) is set to a column vector of length min{max{0,n},dim()}; usually used to truncate a vector, returns *this\n\n\n\n\n\ncb_reduce_length!(self::CBIndexmatrix, n::Integer)\n\n(*this) is set to a column vector of length min{max{0,n},dim()}; usually used to truncate a vector, returns *this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_reinit_function_model!-Tuple{ConicBundle.CBMatrixCBSolver, Union{Nothing, ConicBundle.CBFunctionObject}}","page":"Reference of C++ interface","title":"ConicBundle.cb_reinit_function_model!","text":"cb_reinit_function_model!(self::CBMatrixCBSolver, function_::Union{<:CBFunctionObject,Nothing} = nothing)\n\n@brief Clears cutting model, subgradients and stored function values      for the specified @a function (but only for the given one, not recursively)\n There should be no need to call this if the modification\n routines of this interface were used correctly. If, however,\n the oracle is modified by other means outside this interface,\n this has to be called whenever the specified function was\n modified so that the old subgradients and/or primal generators\n are no longer valid.\n@param[in] function      if the aggregate subgradient of a particular function is desired,      provide the pointer here, otherwise this referrs to the root function      (if there is only one function to be optimized over, this is this single      function, otherwise it is the sum of functions)\n@return\n  - 0 on success\n  - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_remove_contributions!","page":"Reference of C++ interface","title":"ConicBundle.cb_remove_contributions!","text":"cb_remove_contributions!(self::CBSumBundleHandler)\n\nremove own contributions to the parent and set the states correspondingly\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_remove_model!","page":"Reference of C++ interface","title":"ConicBundle.cb_remove_model!","text":"cb_remove_model!(self::CBSumModel, fo::Union{<:CBFunctionObject,Nothing})\n\nremove the submodel identified by @a fo from this model, this does NOT destruct the model. It returns the pointer to the model if there is one, otherwise 0\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_reset_function_factor!","page":"Reference of C++ interface","title":"ConicBundle.cb_reset_function_factor!","text":"cb_reset_function_factor!(self::CBSumBundleHandler, ft::CBFunctionTask, factor::Real)\n\nresets the value of the function factor for this part of sumbundle\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_reset_starting_point!","page":"Reference of C++ interface","title":"ConicBundle.cb_reset_starting_point!","text":"cb_reset_starting_point!(self::CBQPConeModelBlock, y::CBMatrix, mu::Real, global_bundle::CBMinorantBundle, startindex_bundle::Integer)\n\nbundlevalues holds the negative evaluation of the bundle for the current y\n\n\n\n\n\ncb_reset_starting_point!(self::CBQPSumModelBlock, y::CBMatrix, mu::Real, global_bundle::CBMinorantBundle, startindex_bundle::Integer)\n\nreset the starting point for this value of the design variables y\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_reset_t_precond_mult!","page":"Reference of C++ interface","title":"ConicBundle.cb_reset_t_precond_mult!","text":"cb_reset_t_precond_mult!(self::CBQPKKTSubspaceHPrecond)\n\nfor evaluation purposes with iterative solvers, reset the time spent in the multiplication with the preconditioner to zero\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_resolve!","page":"Reference of C++ interface","title":"ConicBundle.cb_resolve!","text":"cb_resolve!(self::CBUQPSolver)\n\nresolve the QP for the same cost function as last time with slightly modified feasible set\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_restart_x!","page":"Reference of C++ interface","title":"ConicBundle.cb_restart_x!","text":"cb_restart_x!(self::CBUQPConeModelBlock, qp_x::CBMatrix, qp_c::CBMatrix, qp_dc::CBMatrix)\n\n@brief it is assumed that the problem was solved already once and is now    resolved for a new linear cost term qpc that resulted from the old    one by adding qpdc.\non input qpx holds the old optimal solution and on output    the coorespoind qpxrange should be replaced by a reasonable    strictly feasible solution for x suitable for restarting    (see also restart_yz)\nreturns 0 on success, 1 on failure\n\n\n\n\n\ncb_restart_x!(self::CBUQPSumModelBlock, qp_x::CBMatrix, qp_c::CBMatrix, qp_dc::CBMatrix)\n\nget a good restarting x of all subblocks for this change in costs\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_restart_y!","page":"Reference of C++ interface","title":"ConicBundle.cb_restart_y!","text":"cb_restart_y!(self::CBUQPConeModelBlock, qp_y::CBMatrix, qp_Qx::CBMatrix, qp_c::CBMatrix, qp_dc::CBMatrix)\n\n@brief this is called after restart_x (see there)\n on input qp_y and qp_z hold the old optimal solution and on output\n the coorespoind qpy/qpx_range should be replaced by a reasonable\n strictly feasible solution for y/z suitable for restarting\n\n returns 0 on success, 1 on failure\n\n\n\n\n\ncb_restart_y!(self::CBUQPSumModelBlock, qp_y::CBMatrix, qp_Qx::CBMatrix, qp_c::CBMatrix, qp_dc::CBMatrix)\n\nget a good restarting y  of all subblocks for this change in costs\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_right_genmult","page":"Reference of C++ interface","title":"ConicBundle.cb_right_genmult","text":"cb_right_genmult(self::CBMinorantPointer, A::CBMatrix, C::CBMatrix, alpha::Real = 1., beta::Real = 0., atrans::Integer = 0, thistrans::Integer = 0, thisindex::Integer = 0)\n\ncomputes and returns C=alphaA(this)+betaC where A and *this may be transposed and *this is considered to be a column with thisindex in a bigger matrix\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_rint","page":"Reference of C++ interface","title":"ConicBundle.cb_rint","text":"cb_rint(A::CBMatrix)\n\nreturns a matrix with elements (i,j)=rint((*this)(i,j)) for all i,j\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_rint!","page":"Reference of C++ interface","title":"ConicBundle.cb_rint!","text":"cb_rint!(self::CBMatrix)\n\nsets (this)(i,j)=rint((this)(i,j)) for all i,j and returns *this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_round","page":"Reference of C++ interface","title":"ConicBundle.cb_round","text":"cb_round(A::CBMatrix)\n\nreturns a matrix with elements (i,j)=round((*this)(i,j)) for all i,j\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_round!","page":"Reference of C++ interface","title":"ConicBundle.cb_round!","text":"cb_round!(self::CBMatrix)\n\nsets (this)(i,j)=round((this)(i,j)) for all i,j and returns *this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_roundhundredths","page":"Reference of C++ interface","title":"ConicBundle.cb_roundhundredths","text":"cb_roundhundredths(self::CBMicroseconds)\n\nround the value to hundredths\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_roundsecs","page":"Reference of C++ interface","title":"ConicBundle.cb_roundsecs","text":"cb_roundsecs(self::CBMicroseconds)\n\nround the value to seconds\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_row","page":"Reference of C++ interface","title":"ConicBundle.cb_row","text":"cb_row(self::CBMatrix, i::Integer)\n\nreturns row i copied to a new matrix\n\n\n\n\n\ncb_row(self::CBIndexmatrix, i::Integer)\n\nreturns row i copied to a new matrix\n\n\n\n\n\ncb_row(self::CBSparsemat, i::Integer)\n\nreturns row i copied to a new sparse matrix\n\n\n\n\n\ncb_row(self::CBSymmatrix, i::Integer)\n\nreturns row i copied to a new Matrix\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_row_nonzeros","page":"Reference of C++ interface","title":"ConicBundle.cb_row_nonzeros","text":"cb_row_nonzeros(self::CBSparsemat, i::Integer, startind::Union{<:AbstractVector{Cint},Nothing} = nothing)\n\nreturns the number of nonzeros in row i; if nonzeros>0 and startind!=0 then the index of the first nonzero in rowindex/rowval is stored there\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_rowdim","page":"Reference of C++ interface","title":"ConicBundle.cb_rowdim","text":"cb_rowdim(self::CBMatrix)\n\nreturns the row dimension\n\n\n\n\n\ncb_rowdim(self::CBIndexmatrix)\n\nreturns the row dimension\n\n\n\n\n\ncb_rowdim(self::CBSparsemat)\n\nreturns the row dimension\n\n\n\n\n\ncb_rowdim(self::CBSymmatrix)\n\nreturns the row dimension\n\n\n\n\n\ncb_rowdim(self::CBSparsesym)\n\nreturns the row dimension\n\n\n\n\n\ncb_rowdim(self::CBSparseCoeffmatMatrix)\n\nreturns the number of blocks\n\n\n\n\n\ncb_rowdim(self::CBQPSolver)\n\nnumber of linear constraints\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_rowhouse","page":"Reference of C++ interface","title":"ConicBundle.cb_rowhouse","text":"cb_rowhouse(A::CBMatrix, v::CBMatrix, i::Integer, j::Integer)\n\nHousholder pre-multiplication of A with Householder vector v; the first nonzero of v is index i, the multplication is applied to all columns of A with index >=j; always returns 0\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_rowip","page":"Reference of C++ interface","title":"ConicBundle.cb_rowip","text":"cb_rowip(A::CBMatrix, i::Integer, scaling::Union{<:CBMatrix,Nothing})\n\nreturns the squared Frobenius norm of row i of A, i.e., the sum of A(i,j)A(i,j) over all j  with possibly (if scaling!=0) each term j multiplied by (scaling)(j)\n\n\n\n\n\ncb_rowip(A::CBSparsemat, i::Integer, scaling::Union{<:CBMatrix,Nothing})\n\nreturns the squared Frobenius norm of row i of A, i.e., the sum of A(i,j)A(i,j) over all j with possibly (if scaling!=0) each term j multiplied by (scaling)(j)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_rows","page":"Reference of C++ interface","title":"ConicBundle.cb_rows","text":"cb_rows(self::CBMatrix, vec::CBIndexmatrix)\n\nreturns a matrix of size vec.dim() x this->coldim(), with row i a copy of row vec(i) of *this\n\n\n\n\n\ncb_rows(self::CBIndexmatrix, vec::CBIndexmatrix)\n\nreturns a matrix of size vec.dim() x this->rowdim(), with row i a copy of row vec(i) of *this\n\n\n\n\n\ncb_rows(self::CBSparsemat, ind::CBIndexmatrix)\n\nreturns a sparse matrix of size vec.dim() x this->rowdim(), with row i a copy of row vec(i) of *this\n\n\n\n\n\ncb_rows(self::CBSymmatrix, vec::CBIndexmatrix)\n\nreturns a matrix of size vec.dim() x this->coldim(), with row i a copy of row vec(i) of *this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_rowsip","page":"Reference of C++ interface","title":"ConicBundle.cb_rowsip","text":"cb_rowsip(A::CBMatrix)\n\nreturns the row vector of the squared Frobenius norm of all rowd i of A, i.e., the sum of A(i,j)*A(i,j) over all j for each i\n\n\n\n\n\ncb_rowsip(A::CBSparsemat, scaling::Union{<:CBMatrix,Nothing})\n\nreturns the row vector of the squared Frobenius norm of all rows i of A, i.e., the sum of A(i,j)A(i,j) over all j for each i with possibly (if scaling~=0) each term j multiplied by (scaling)(j)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_save","page":"Reference of C++ interface","title":"ConicBundle.cb_save","text":"cb_save(self::CBGB_rand)\n\nsave current configuration to out so as to continue identically after restore\n\n\n\n\n\ncb_save(self::CBUQPSolver)\n\nsave the current settings and values\n\n\n\n\n\ncb_save(self::CBBundleTerminator)\n\noutput current parameter settings\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_scale!","page":"Reference of C++ interface","title":"ConicBundle.cb_scale!","text":"cb_scale!(self::CBMinorantPointer, val::Real)\n\nmultiply the MinorantPointer by val (this is an external factor for the minorant and possibly its primal information, but it will be used in aggreagation and when retrieving the approximate primal)\n\n\n\n\n\ncb_scale!(self::CBMinorantUseData, factor::Real)\n\ncarries through the scaling for the underlying minorant, afterwards scaleval==1., may only be carried out if use_cnt==1\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_scale_cols!","page":"Reference of C++ interface","title":"ConicBundle.cb_scale_cols!","text":"cb_scale_cols!(self::CBMatrix, vec::CBMatrix)\n\nscales each column i of (this) by vec(i), i.e., (this)=(this)diag(vec), and returns (*this)\n\n\n\n\n\ncb_scale_cols!(self::CBSparsemat, vec::CBMatrix)\n\nscales each column i of (this) by vec(i), i.e., (this)=(this)diag(vec), and returns (*this)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_scale_minorant!","page":"Reference of C++ interface","title":"ConicBundle.cb_scale_minorant!","text":"cb_scale_minorant!(self::CBMinorant, scale_val::Real)\n\nmutliply offset and coefficients (and PrimalData, if given) by scale_val\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_scale_primal_data!","page":"Reference of C++ interface","title":"ConicBundle.cb_scale_primal_data!","text":"cb_scale_primal_data!(self::CBPrimalMatrix, myfactor::Real)\n\nmultiply/scale *this with a nonnegative myfactor\n\n\n\n\n\ncb_scale_primal_data!(self::CBBlockPSCPrimal, factor::Real)\n\nmultiply/scale *this with a nonnegative factor\n\n\n\n\n\ncb_scale_primal_data!(self::CBDensePSCPrimal, factor::Real)\n\nmultiply/scale *this with a nonnegative factor\n\n\n\n\n\ncb_scale_primal_data!(self::CBGramSparsePSCPrimal, factor::Real)\n\nmultiply/scale *this with a nonnegative factor\n\n\n\n\n\ncb_scale_primal_data!(self::CBSparsePSCPrimal, factor::Real)\n\nmultiply/scale *this with a nonnegative factor\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_scale_rows!","page":"Reference of C++ interface","title":"ConicBundle.cb_scale_rows!","text":"cb_scale_rows!(self::CBMatrix, vec::CBMatrix)\n\nscales each row i of (this) by vec(i), i.e., (this)=diag(vec)(this), and returns (*this)\n\n\n\n\n\ncb_scale_rows!(self::CBSparsemat, vec::CBMatrix)\n\nscales each row i of (this) by vec(i), i.e., (this)=diag(vec)(this), and returns (*this)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_scaled_index","page":"Reference of C++ interface","title":"ConicBundle.cb_scaled_index","text":"cb_scaled_index(self::CBAffineFunctionTransformation, index::Integer)\n\n@brief returns false if index is mapped to more than one index, otherwise true with mapped_index==-1 if mapped to zero, else >=0 and @a coeff gives the coefficient\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_scaled_index_subset","page":"Reference of C++ interface","title":"ConicBundle.cb_scaled_index_subset","text":"cb_scaled_index_subset(self::CBAffineFunctionTransformation, col_ind::Union{<:CBIndexmatrix,Nothing}, row_ind::Union{<:CBIndexmatrix,Nothing})\n\n@brief returns true if the transformation maps each index (in colind if !=0) onto at most one index and vice versa (out of rowind if !=0)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_scaledrankadd","page":"Reference of C++ interface","title":"ConicBundle.cb_scaledrankadd","text":"cb_scaledrankadd(A::CBSparsemat, D::CBMatrix, C::CBSymmatrix, alpha::Real, beta::Real, trans::Integer)\n\nreturns C=betaC+alpha ADA^T, where D is a vector representing a diagonal matrix and A may be transposed; if beta==0. then C is initialized to the correct size\n\n\n\n\n\ncb_scaledrankadd(A::CBMatrix, D::CBMatrix, C::CBSymmatrix, alpha::Real, beta::Real, trans::Integer)\n\nreturns C=betaC+alpha ADA^T, where D is a vector representing a diagonal matrix and A may be transposed; if beta==0. then C is initialized to the correct size\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_scaling_indices","page":"Reference of C++ interface","title":"ConicBundle.cb_scaling_indices","text":"cb_scaling_indices(self::CBAffineFunctionTransformation, row_indices::CBIndexmatrix, col_indices::CBIndexmatrix)\n\n@brief if AFTModel::adddiagonalscaling() is called with @a indices specified by @a colindices, then AFTmodel has to provide a diagonal scaling matrix of dimension todim() as @a indiagscale in adddiagonalscaling() with the entries in the output vector @a rowindices computed correctly.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_select_model!","page":"Reference of C++ interface","title":"ConicBundle.cb_select_model!","text":"cb_select_model!(self::CBBoxModelParameters, box_model::CBMinorantBundle, box_coeff::CBMatrix, box_indicators::CBMatrix, box_coords::CBIndexmatrix, box_complvalues::CBMatrix, nnc_model::CBMinorantBundle, nnc_coeff::CBMatrix, nnc_indicators::CBMatrix, coord_switching::CBMatrix, minorants::CBMinorantBundle, cand_minorant::CBMinorantPointer, cand_boxvec::CBPrimalMatrix, aggr_boxvec::CBPrimalMatrix, aggr_scaleval::Real, oracle::Union{<:CBBoxOracle,Nothing}, modification_id::Integer, function_task::CBFunctionTask, function_factor::Real, model_update::CBModelUpdate, center_id::Integer, center_y::CBMatrix, cand_id::Integer, cand_y::CBMatrix, model_maxviol::Real, H::CBBundleProxObject)\n\n@brief BoxModel calls this for selecting the next coordinates        for a specialized polyhedral model with a box part and an        nnc part for aggregates, see the general explanation of the        class.\n   There is little experience on how to do this.\n   The current routine is minimalistic and simply uses\n   the weighted number of switches in each coordinate\n   between lower and upper bounds to select coordinates.\n\n   To allow maybe better choices in future implementations\n   the arguments try to pass all potentially relevant\n   information items.\n\n   On putput the coefficient values of the new model must be\n   feasible and have to generate the same aggregate (the aggregate\n   is maintained), and the new candidate minorant must be in the\n   feasible set.\n\n@param[in,out] box_model\n   the boxmodel holds the minorants describing the BoxBlock part of\n   the model for selected coordinates and, unless exact or empty,\n   in the last position the complement coordinates of a feasible\n   point (e.g. aggr_boxvec)\n\n@param[in,out] box_coeff\n   - on input coefficients of BoxBlock determined in last\n     BundleMethod::eval_augmodel giving rise (together with nnc_coeff)\n     to the aggrgate,\n   - on output they match the new model and still give rise to\n     the same aggregate\n\n@param[in,out] box_indicators\n   indicators for activity of box minorants, indicators may but need\n   not be maintained\n\n@param[in,out] box_coords\n   the coordinates selected to have their respective interval range\n   in the model\n\n@param[in,out] box_complvalues\n   a point with 0 in the box_coords and feasible\n   coordinate values in the complement (if not empty)\n\n@param[in,out] nnc_model\n   if box_model is empty, this spans at least the aggregate (if available)\n   and the candidate (always); if box_model is not empty but not\n   the entire box, nnc_model typically holds one of the candidate or\n   the aggregate; if box_model is the entire box, nnc_model is empty\n\n@param[in,out] nnc_coeff\n   - on input coefficients of BoxBlock determined in last\n     BundleMethod::eval_augmodel giving rise (together with box_coeff)\n     to the aggrgate,\n   - on output they match the new model and still give rise to\n     the same aggregate\n\n@param[in,out] nnc_indicators\n   indicators for activity of minorants, indicators may but need\n   not be maintained\n\n@param[in] coord_switching\n   keeps track of which coordinates where changing the most in the past\n   by forming a weighted average in BoxModel::eval_function()\n\n@param[in] minorants\n    the vector of MinorantPointer gives additional minorants\ncollected over time (some may be duplicates also of those in         nnc_model)\n@param[in] candminorant        the (eps)sugradient linear minorant returned        by BoxModel::evalfunction for the candidate (without function factor)\n@param[in] cand_boxvec        the maximizer over the box for the current candidate\n@param[in] aggrboxvec        the primal aggregate vector in the box (without functionfactor)        giving rise to the aggregate; not initialized if zerodimensional\n@param[in] aggrscaleval        0<= aggrscalevale <= functionfactor, ==functionfactor if        functiontask==ObjectiveFunction; the aggregate with        functionfactor is aggrboxvec*aggr_scaleval;\n@param[in] oracle\n    gives access to lower and upper bounds of the box\n\n@param[in] modification_id\n    the identifier of the current function version to be used in generating\n    specialized minorants corresponding to the coordinate vectors\n\n@param[in] function_task\n    see FunctionTask\n\n@param[in] function_factor\n     interpreted according to function_task and the coefficients sum up to at most this value\n\n@param[in] model_update\n    informs about whether cand_y is the result of a null_step or descent_step or a new set up.\n\n@param[in] center_id\n    the identifier of the center point\n\n@param[in] center_y\n    the center point\n\n@param[in] cand_id\n    the identifier of the candidate point\n\n@param[in] cand_y\n    the candidate (mostly differnt from the center), close to it the model should be good\n\n@param[in] model_maxviol\n    a minorant violated by this would have caused a null step\n\n@param[in] H\n    the variable metric used in the proximal term (function_factor is already removed in this)\n\n@return\n - 0 on success\n - 1 on failure\n\n\n\n\n\ncb_select_model!(self::CBNNCModelParameters, model::CBMinorantBundle, coefficients::CBMatrix, activity_indicators::CBMatrix, aggregate::CBMinorantPointer, center_minorant::CBMinorantPointer, cand_minorants::CBMinorantBundle, old_minorants::CBMinorantBundle, oracle::Union{<:CBMatrixFunctionOracle,Nothing}, function_task::CBFunctionTask, function_factor::Real, model_update::CBModelUpdate, center_id::Integer, center_y::CBMatrix, cand_id::Integer, cand_y::CBMatrix, model_maxviol::Real, H::CBBundleProxObject)\n\n@brief NNCModel calls this for selecting the next minorants for a polyhedral model\n@param[in,out] model\n    contains the model of the previous subproblem or a minimal starting choice\n\n@param[in,out]  coefficients\n    contains the coefficients resulting from the last bundel subproblem (on input and on output they should generate the aggregate, if the aggregate is valid)\n\n@param[in,out]  activity_indicators\n    contains activity_indicators resulting from the last bundel subproblem (currently 1 if considered active and 0 otherwise). Those indicated active in the bundle on input will also be indicated active\n\n@param[in] aggregate\n    if valid, it holds the current aggregate. It arises as nonnegative combinations of the model by the coefficients (so it inculde the current function_factor). This property of model and coefficients should be maintained on output\n\n@param[in] center_minorant\n    if valid, it holds the current aggregate. It arises as nonnegative combinations of the model by the coefficients, and that should be maintained on output\n\n@param[in] cand_minorants\n    holds the vector of minorants returned by evaluation in the candidate point\n\n@param[in] old_minorants\n    the vector of MinorantPointer gives additional minorants\ncollected over time (some may be duplicates, some are   most certainly already contained in the bundle on input)\n@param[in] oracle\n    gives access to the evaluation oracle\n\n@param[in] function_task\n    see FunctionTask\n\n@param[in] function_factor\n     interpreted according to function_task and the coefficients sum up to at most this value\n\n@param[in] model_update\n    informs about whether cand_y is the result of a null_step or descent_step or a new set up.\n\n@param[in] center_id\n    the identifier of the center point\n\n@param[in] center_y\n    the center point\n\n@param[in] cand_id\n    the identifier of the candidate point\n\n@param[in] cand_y\n    the candidate (mostly differnt from the center), close to it the model should be good\n\n@param[in] model_maxviol\n    a minorant violated by this would have caused a null step\n\n@param[in] H\n    the variable metric used in the proximal term (function_factor is already removed in this)\n\n@return\n - 0 on success\n - 1 on failure\n\n\n\n\n\ncb_select_model!(self::CBPSCModelParameters, modelvecs::CBMatrix, model_aggregate::CBMinorantPointer, topvecs::CBMatrix, Ritz_values::CBMatrix, primal_Ritzval::Real, primaleigs::CBMatrix, primalvecs::CBMatrix, primal_aggregate::CBMinorantPointer, primal_aggregate_coeff::Real, growthrate::Real, primalgrowth::CBMatrix, dualgrowth::CBMatrix, cand_Ritzvec::CBMatrix, cand_Ritzval::CBMatrix, oracle::Union{<:CBPSCOracle,Nothing}, modification_id::Integer, function_task::CBFunctionTask, function_factor::Real, model_update::CBModelUpdate, center_id::Integer, center_y::CBMatrix, cand_id::Integer, cand_y::CBMatrix, model_maxviol::Real, diffval_center_aggregate::Real, H::CBBundleProxObject)\n\n@brief PSCModel calls this for selecting the next positive semidefinite model\n@param[in,out] modelvecs\n    * on input: orthonormal basis of the subspace used in the last\n      semidefinite model\n    * on output: orthonormal subspace basis to be used in the next\n      semidefinite model, it includes the subspace of the primalvecs of\n      the keepsize largest primaleigs. In particular for null steps\nthe remaining columns of primalvecs with nonzero primaleigs\n      have to be included with the current aggregate in a new aggregate\n      of the model; this will be taken care of outside this routine\n      aftwards\n\n@param[in,out] model_aggregate (MinorantPointer)\n    aggregate in use in the last and then the next model.\n\n@param[in,out] topvecs\n    * on input: orthonormal basis of the collected subspace that is\n      supposed to approximate the eigenspace to the largest eigenvalues,\nsee Ritz_values\n    * on output: same thing but maybe reduced in size\n\n@param[in,out] Ritz_values\n    * on input: Ritz_values in cand_y for the vectors in topvecs\n    * on output: same thing but maybe reduced in size as in topvecs\n\n@param[in,out] activedim\n    * on input: the dimension of the subspace (first columns in topvecs)\n       regarded as active in the last iterations of the bundle subproblem solution\non output: the dimension of the subspace (first columns of topvecs) regarded as (maybe weakly) active now        (typically it will increase during null steps and may be tightened        at descent steps)\n@param[out] keepsize     columns 0..keepsize-1 of primalvecs (corresponding to the keepsize\nlargest primaleigs) are included in modelvecs. The remaining         columns need to be aggregated afterwards into the aggregate of the model\n@param[out] skippedsize\n    columns activedim..activedim+skippedsize-1 of topvecs should be used\n    for setting up the scaling matrix after descent steps.\n\n@param[in] primal_Ritzval\n    the (common) Ritz value of the active subspace of the model\n    (if not available use some guess like Ritz_values(0))\n\n@param[in] primaleigs\n    eigenvalues of the last primal semdifinite model matrix\n    (sorted nonincreasingly)\n\n@param[in] primalvecs\n    corresponding (orthonormal) eigenvectors to primaleigs\n\n@param[in] primal_aggregate (MinorantPointer)\n    aggregate in use in the last model.\n\n@param[in] primal_aggregate_coeff\n    coefficient on how strongly the aggregated was used in the last\n    primal solution to the model\n\n@param[in] growthrate (Real)\n    factor <X,Z>/<X^-,Z^->, where X^- and Z^- are the last but one\n    iterates of the interior point method\n\n@param[in] primalgrowth (Matrix)\n    factor by which primaleigs changed in the last interior point iteration\n\n@param[in] dualgrowth (Matrix)\n    factor by which the dual Ritz values to primalvecs changed\nduring the last interior point iteration\n@param[in] cand_Ritzvec (const Matrix&)\n    the (orthonormal) vectors returned by the evaluation call to the oracle\n\n@param[in] cand_Ritzval (const Matrix&)\nthe Ritz values of cand_Ritzvec returned by the evaluation call to the oracle\n@param[in] oracle\n    gives access to the evaluation oracle\n\n@param[in] modification_id\n   the identifier for the current version of the function accounting for dynamic modifications\n\n @param[in] function_task\n    see FunctionTask\n\n@param[in] function_factor\n     interpreted according to function_task and the coefficients sum up to at most this value\n\n@param[in] model_update\n    informs about whether cand_y is the result of a null_step or descent_step or a new set up.\n\n@param[in] center_id\n    the identifier of the center point\n\n@param[in] center_y\n    the center point\n\n@param[in] cand_id\n    the identifier of the candidate point\n\n@param[in] cand_y\n    the candidate (mostly differnt from the center), close to it the model should be good\n\n@param[in] model_maxviol\n    a minorant violated by this would have caused a null step\n\n@param[in] diffval_center_aggregate\n    difference of center value to aggregate value (nonnegative, without function_factor)\n\n@param[in] H\n    the variable metric used in the proximal term (function_factor is already removed in this)\n\n@return\n - 0 on success\n - 1 on failure\n\n\n\n\n\ncb_select_model!(self::CBSOCModelParameters, modelvecs::CBMatrix, aggrvec::CBMatrix, cand_SOCval::Real, cand_SOCvec::CBMatrix, center_SOCval::Real, center_SOCvec::CBMatrix, SOCvecs::CBMatrix, oracle::Union{<:CBSOCOracle,Nothing}, function_task::CBFunctionTask, function_factor::Real, model_update::CBModelUpdate, center_id::Integer, center_y::CBMatrix, cand_id::Integer, cand_y::CBMatrix, model_maxviol::Real, H::CBBundleProxObject)\n\n@brief SOCModel calls this for selecting the next minorants for a polyhedral model\n@param[in,out] modelvecs       the columns span the barx subspace of the SOC face (the model is initialized if modelvecs.coldim()>0). On output it has to span at least the subspace spanned by aggrvec and cand_SOCvec\n@param[in,out] aggrvec       current aggregate soc vector (includes all coordinates and @a functionfactor according to @a functiontask); if not valid it has coldim==0.\n@param[in] cand_SOCval       lower bound on the candidate value\n@param[in] candSOCvec       the SOCvector generating candSOCval (includes all coordinates but no function_factor)\n@param[in] center_SOCval       lower bound on the center value\n@param[in] centerSOCvec       the SOCvector generating centerSOCval (includes all coordinates but no function_factor)\n@param[in] SOCvecs       collects the barx parts of the old SOCvecs\n@param[in] oracle       gives access to the evaluation oracle\n@param[in] function_task       see FunctionTask\n@param[in] functionfactor        interpreted according to functiontask and the coefficients sum up to at most this value\n@param[in] modelupdate       informs about whether candy is the result of a nullstep or descentstep or a new set up.\n@param[in] center_id       the identifier of the center point\n@param[in] center_y       the center point\n@param[in] cand_id       the identifier of the candidate point\n@param[in] cand_y       the candidate (mostly differnt from the center), close to it the model should be good\n@param[in] model_maxviol       a minorant violated by this would have caused a null step\n@param[in] H       the variable metric used in the proximal term (function_factor is already removed in this)\n\n@return\n - 0 on success\n - 1 on failure\n\n\n\n\n\ncb_select_model!(self::CBSumBundleParameters, model_indices::CBIndexmatrix, cand_id::Integer, cand_y::CBMatrix, minorants::CBMinorantBundle, aggr_index::Integer, model_maxviol::Real, H::CBBundleProxObject, model_update::CBModelUpdate)\n\n@brief FunctionModel and SumBundleHandler call this for selecting the next minorants for a polyhedral model\n@param[out] model_indices\n    the indices of minorants selected for the model; index 0 is always the aggregate indicated by the input index aggr_index\n\n@param[in] cand_id\n    the identifier of the candidate point supplied next\n\n@param[in] cand_y\n    the candidate (differnte from the center), close to it the model should be good\n\n@param[in] minorants\n    the vector of MinorantPointer gives the minorants\nout of which the model should be selected.\n@param[in] aggr_index\n    the index of the aggregate within the minorants\n\n@param[in] model_maxviol\n    a minorant violated by this would have caused a null step\n\n@param[in] H\n    the proximal term used for determining the given cand_y\n\n@param[in] model_update\n    informs about whether cand_y is the result of a null_step or descent_step or aomw other a new set up.\n\n@return\n - 0 on success\n - 1 on failure\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set!","page":"Reference of C++ interface","title":"ConicBundle.cb_set!","text":"cb_set!(self::CBSparseCoeffmatMatrix, i::Integer, j::Integer, cm::CBCoeffmatPointer)\n\nsets the CoeffmatPointer of block i in column j (blockdiagonal matrix j) (may be empty)\n\n\n\n\n\ncb_set!(self::CBSparseCoeffmatMatrix, i::Integer, j::Integer, cm::Union{<:CBCoeffmat,Nothing})\n\nsets the CoeffmatPointer of block i in column j (blockdiagonal matrix j) to point to cm (or deletes it if cm==0)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_D!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_D!","text":"cb_set_D!(self::CBBundleDiagonalTrustRegionProx, in_D::CBMatrix)\n\nset the diagonal (it needs to be >=0 but this is not checked)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_active_bounds_fixing!-Tuple{ConicBundle.CBMatrixCBSolver, Bool}","page":"Reference of C++ interface","title":"ConicBundle.cb_set_active_bounds_fixing!","text":"cb_set_active_bounds_fixing!(self::CBMatrixCBSolver, allow_fixing::Bool)\n\n@brief If set to true (the default is false), variables may be       fixed automatically to active bounds if these are strongly       active (i.e., the corresponding multipliers are big) and the center values are also right on these bounds already.\n  The coordinates to be fixed are redetermined in each\n  call following a descent step or a change of the function.\n  An indicator vector of the variables fixed during the last call\n  can be obtained via the routine get_fixed_active_bounds().\n\n  Setting this value to true might improve the performance\n  of the algorithm in some instances but there is no\n  convergence theory. It might be particularly helpful\n  within Lagrangian relaxation if a primal cutting plane\n  approach is used and non-tight inequalities should be\n  eliminated quickly (fixing then indicates large primal\n  slack values as these are the dual variables to the bounds\non the Lagrange mulitpliers). Furthermore, if the value of a variable is fixed to zero, the variable can typically be deleted without affecting the validity of the current cutting model and function values.\n@param[in] allow_fixing (bool)\n\n@return\n  - 0 on success\n  - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_set_aggr_dnormsqr!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_aggr_dnormsqr!","text":"cb_set_aggr_dnormsqr!(self::CBBundleTerminator, sg::Real)\n\nset an upper bound for the dual norm squared of the aggregate at termination (or <=0 if no such bound is desired)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_append_to_old!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_append_to_old!","text":"cb_set_append_to_old!(self::CBAFTModification, append_only::Bool)\n\nif set to true, no deletions/reassignments may be present or specified in the future, only appensions are allowed\n\n\n\n\n\ncb_set_append_to_old!(self::CBGroundsetModification, append_only::Bool)\n\nif set to true, no deletions/reassignments may be present or specified in the future, only appensions are allowed\n\n\n\n\n\ncb_set_append_to_old!(self::CBNNCBoxSupportModification, append_only::Bool)\n\nif set to true, no deletions/reassignments may be present or specified in the future, only appensions are allowed\n\n\n\n\n\ncb_set_append_to_old!(self::CBPSCAffineModification, append_only::Bool)\n\nif set to true, no deletions/reassignments may be present or specified in the future, only appensions are allowed\n\n\n\n\n\ncb_set_append_to_old!(self::CBSOCSupportModification, append_only::Bool)\n\nif set to true, no deletions/reassignments may be present or specified in the future, only appensions are allowed\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_augvalfailslimit!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_augvalfailslimit!","text":"cb_set_augvalfailslimit!(self::CBBundleTerminator, al::Integer)\n\nset upper bound on the value returned by BundleTerminatorData::get_sumaugvalfails(), <0 if no limit\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_bundle_parameters!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_bundle_parameters!","text":"cb_set_bundle_parameters!(self::CBMatrixCBSolver, params::CBBundleParameters, function_::Union{<:CBFunctionObject,Nothing} = nothing)\n\n*@brief Sets the maximum bundlesize and the maximum number of new subgradients         added in a bundle update of the cutting model for the specified @a function.         The meaning of this routine may differ from standard for   predefined special functions with special bundle types.\n\n @param[in] params (const BundleParameters&)\n   some update parameters for the cutting model, see e.g. ConicBundle::BundleParameters\n\n @param[in] function\n   if the aggregate subgradient of a particular function is desired,\n   provide the pointer here, otherwise this referrs to the root function\n   (if there is only one function to be optimized over, this is this single\n   function, otherwise it is the sum of functions)\n\n\n @return\n   - 0 on success\n   - != 0 otherwise\n\n\n\n\n\ncb_set_bundle_parameters!(self::CBAFTModel, param0::CBBundleParameters)\n\nan AFT has no bundle, so it returns 1, see SumBlockModel::setbundleparameters\n\n\n\n\n\ncb_set_bundle_parameters!(self::CBBoxModel, bp::CBBundleParameters)\n\nsee SumBlockModel::setbundleparameters\n\n\n\n\n\ncb_set_bundle_parameters!(self::CBNNCModel, bp::CBBundleParameters)\n\nif bp is an NNCParametersObject, it is cloned, otherwise the paraemters are copied\n\n\n\n\n\ncb_set_bundle_parameters!(self::CBPSCModel, bp::CBBundleParameters)\n\nsee SumBlockModel::setbundleparameters\n\n\n\n\n\ncb_set_bundle_parameters!(self::CBSOCModel, bp::CBBundleParameters)\n\nsee SumBlockModel::setbundleparameters\n\n\n\n\n\ncb_set_bundle_parameters!(self::CBSumModel, bp::CBBundleParameters)\n\nif bp is a SumBundleParametersObject, it is cloned, otherwise the paraemters are copied\n\n\n\n\n\ncb_set_bundle_parameters!(self::CBSumBundleHandler, bp::CBBundleParameters)\n\nsets maxbundlesize and maxmodelsize for all parts; this may be increased internally if the mode and/or the parent handler require this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_bundleweight!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_bundleweight!","text":"cb_set_bundleweight!(self::CBBundleSolver, bw::Union{<:CBBundleWeight,Nothing})\n\nreplace the previous BundleWeight by bw; bw will be deleted when replaced or on destruction of this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_cand_minorant!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_cand_minorant!","text":"cb_set_cand_minorant!(self::CBSumBundleHandler, ft::CBFunctionTask, minorant::CBMinorantPointer)\n\n@brief set the new minorant information of the candidate\n Only one minorant can take this position.\n This is mainly due to that only one primal information can be associated\n with each minorant. Thus adding must involve compatible primals and\n this is easiest to guarantee if there is only one inital type at the\n lowest level. Contributions to parents will not care about the primals.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_cbout!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_cbout!","text":"cb_set_cbout!(self::CBGroundsetModification, incr::Integer = -1)\n\nsee CBout::set_out\n\n\n\n\n\ncb_set_cbout!(self::CBNNCBoxSupportModification, incr::Integer = -1)\n\nsee CBout::set_out\n\n\n\n\n\ncb_set_cbout!(self::CBPSCAffineModification, incr::Integer = -1)\n\nsee CBout::set_cbout\n\n\n\n\n\ncb_set_cbout!(self::CBSOCSupportModification, incr::Integer = -1)\n\nsee CBout::set_out\n\n\n\n\n\ncb_set_cbout!(self::CBNNCBoxSupportFunction, incr::Integer = -1)\n\nsee ConicBundle::CBout\n\n\n\n\n\ncb_set_cbout!(self::CBPSCAffineFunction, incr::Integer = -1)\n\nsee ConicBundle::CBout\n\n\n\n\n\ncb_set_cbout!(self::CBSOCSupportFunction, incr::Integer = -1)\n\nsee ConicBundle::CBout\n\n\n\n\n\ncb_set_cbout!(self::CBQPSolver, incr::Integer = -1)\n\nset output settings\n\n\n\n\n\ncb_set_cbout!(self::CBLPGroundset, incr::Integer = -1)\n\noutput settings\n\n\n\n\n\ncb_set_cbout!(self::CBUnconstrainedGroundset, incr::Integer = -1)\n\noutput settings\n\n\n\n\n\ncb_set_cbout!(self::CBQPConeModelBlock, incr::Integer = -1)\n\noutput settings\n\n\n\n\n\ncb_set_cbout!(self::CBUQPSumModelBlock, incr::Integer = -1)\n\ndo this for all subblocks\n\n\n\n\n\ncb_set_cbout!(self::CBBundleSolver, incr::Integer)\n\nset output and outputlevel of warnings and errors recursively with CBout\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_check_correctness!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_check_correctness!","text":"cb_set_check_correctness!(self::CBPSCAffineFunction, chk::Bool)\n\nif set to true, ConicBundle employs some additional consistency checks\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_clock!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_clock!","text":"cb_set_clock!(self::CBBundleSolver, myclock::CBClock)\n\nset the external clock to be used for output\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_data!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_data!","text":"cb_set_data!(self::CBAFTModel, bd::Union{<:CBBundleData,Nothing})\n\nsee SumBlockModel::set_data\n\n\n\n\n\ncb_set_data!(self::CBBoxModel, bd::Union{<:CBBundleData,Nothing})\n\nsee SumBlockModel::set_data\n\n\n\n\n\ncb_set_data!(self::CBNNCModel, bd::Union{<:CBBundleData,Nothing})\n\nsee SumBlockModel::set_data\n\n\n\n\n\ncb_set_data!(self::CBPSCModel, bd::Union{<:CBBundleData,Nothing})\n\nsee SumBlockModel::set_data\n\n\n\n\n\ncb_set_data!(self::CBSOCModel, bd::Union{<:CBBundleData,Nothing})\n\nsee SumBlockModel::set_data\n\n\n\n\n\ncb_set_data!(self::CBSumModel, bd::Union{<:CBBundleData,Nothing})\n\nsee SumBlockModel::set_data()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_defaults!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_defaults!","text":"cb_set_defaults!(self::CBMatrixCBSolver)\n\n@brief Sets default values for algorithmic parameters that are not function specific (e.g., relative precision, weight and weight bounds for the augmentedproblem, etc.)\n\n\n\n\n\ncb_set_defaults!(self::CBBundleHKWeight)\n\nset default values for 'constant' parameters, e.g. minweight and maxweight\n\n\n\n\n\ncb_set_defaults!(self::CBBundleRQBWeight)\n\nset default values for 'constant' parameters, e.g. minweight and maxweight\n\n\n\n\n\ncb_set_defaults!(self::CBUQPSolver)\n\nreset parameters to default values\n\n\n\n\n\ncb_set_defaults!(self::CBBundleSolver)\n\nresets all parameters to default values and calls BundleTerminator::setdefaults() for *terminator and BundleWeight::setdefaults() for *bundleweight\n\n\n\n\n\ncb_set_defaults!(self::CBBundleTerminator)\n\nsets the default parameter values\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_do_yfixing!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_do_yfixing!","text":"cb_set_do_yfixing!(self::CBBundleSolver, dofix::Bool)\n\nif set to true, the groundset may use a heuristic to decide whether a variable is fixed to one of its bounds (often helps to reduce inner update iterations)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_eval_limit!-Tuple{ConicBundle.CBMatrixCBSolver, Integer}","page":"Reference of C++ interface","title":"ConicBundle.cb_set_eval_limit!","text":"cb_set_eval_limit!(self::CBMatrixCBSolver, eval_limit::Integer)\n\n@brief Sets an upper bound on the number of calls to the oracle (use negative numbers for no limit).\n  If this number is reached, the algorithm will terminate\nindependently of whether the last step was a descent or a null step. A negative number will be interepreted as no limit.\n@param[in] eval_limit (Integer)\n\n@return\n  - 0 on success\n  - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_set_fun_coeff!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_fun_coeff!","text":"cb_set_fun_coeff!(self::CBAffineFunctionTransformation)\n\nallows to set the factor for the function\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_fun_offset!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_fun_offset!","text":"cb_set_fun_offset!(self::CBAffineFunctionTransformation)\n\nallows to set the constant offset for the funciton\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_groundset_id!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_groundset_id!","text":"cb_set_groundset_id!(self::CBLPGroundset, gsid::Integer)\n\nsets the groundset_id to the desired value, increasing it is safer here because this is used to indicate changes\n\n\n\n\n\ncb_set_groundset_id!(self::CBUnconstrainedGroundset, gsid::Integer)\n\nsets the groundset_id to the desired value, increasing it is safer here because this is used to indicate changes\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_infinity!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_infinity!","text":"cb_set_infinity!(self::CBMicroseconds, infty::Bool)\n\nuse true to regard value as infinity\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_inner_update_limit!-Tuple{ConicBundle.CBMatrixCBSolver, Integer}","page":"Reference of C++ interface","title":"ConicBundle.cb_set_inner_update_limit!","text":"cb_set_inner_update_limit!(self::CBMatrixCBSolver, update_limit::Integer)\n\n@brief Set an upper bound on the number of inner updates for the       cutting model with primal slacks within one null step (use negative numbers for no limit).\n  A negative number will be interepreted as no limit, i.e.,\n  the updates will be done till a certain precision of the\n  cutting model is achieved.\n\n@param[in] update_limit (Integer)\n\n@return\n  - 0 on success\n  - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_set_lower_bound!-Tuple{ConicBundle.CBMatrixCBSolver, Integer, Real}","page":"Reference of C++ interface","title":"ConicBundle.cb_set_lower_bound!","text":"cb_set_lower_bound!(self::CBMatrixCBSolver, i::Integer, lb::Real)\n\n*@brief Sets lower bound for variable i,   use ConicBundle::CBminusinfinity for unbounded from below.\n\n   The algorithm may have to adapt the center point aftwards.\n   In this case the old function values will be marked as outdated and\n   will be recomputed at the next call to e.g. solve().\n\n@return\n  - 0 on success\n  - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_set_mL!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_mL!","text":"cb_set_mL!(self::CBBundleSolver, in_mL::Real)\n\nset the acceptance level for descent steps (rather don't change this!)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_mN!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_mN!","text":"cb_set_mN!(self::CBBundleSolver, in_mN::Real)\n\nset the acceptance level for null steps (mL<=in_mN<1., rather don't change this!)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_max_Ritzvecs!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_max_Ritzvecs!","text":"cb_set_max_Ritzvecs!(self::CBPSCAffineFunction, maxv::Integer)\n\nset the maximum number of new Ritzvectors returned by evaluate(); values<1 default to 5\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_max_bundlesize!-Tuple{ConicBundle.CBMatrixCBSolver, Integer, Union{Nothing, ConicBundle.CBFunctionObject}}","page":"Reference of C++ interface","title":"ConicBundle.cb_set_max_bundlesize!","text":"cb_set_max_bundlesize!(self::CBMatrixCBSolver, max_bundlesize::Integer, function_::Union{<:CBFunctionObject,Nothing} = nothing)\n\n@brief Sets the maximum number of subgradients stored for use in forming the model or determining scaling information, it must be as least as large as max_modelsize (and is increased to this if not)\nThe meaning of this routine may differ from standard for predefined special functions with special bundle types.\n\n @param[in] max_bundlesize (int)\n   maximum number of subgradients stored for use in forming the model\n\n @param[in] function\n   if the aggregate subgradient of a particular function is desired,\n   provide the pointer here, otherwise this referrs to the root function\n   (if there is only one function to be optimized over, this is this single\n   function, otherwise it is the sum of functions)\n\n\n\n @return\n   - 0 on success\n   - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_set_max_modelsize!-Tuple{ConicBundle.CBMatrixCBSolver, Integer, Union{Nothing, ConicBundle.CBFunctionObject}}","page":"Reference of C++ interface","title":"ConicBundle.cb_set_max_modelsize!","text":"cb_set_max_modelsize!(self::CBMatrixCBSolver, max_modelsize::Integer, function_::Union{<:CBFunctionObject,Nothing} = nothing)\n\n@brief Sets the maximum number of subgradients used in forming the       cutting model of the specified @a function\n  Quite often a very small model, e.g., 2, yields very fast iterations\n  and good progress in time (sometimes at the cost of more evaluations).\n  By limited numerical experience, a significant reduction in the number of\n  evaluations can  only be expected if the bundle is large enough to\n  wrap the function rather tightly. Quite frequently, unfortunately,\n  this entails that solving the quadratic subproblems\n  is more expensive than function evaluation.\n\n  The meaning of this routine may differ from standard for\npredefined special functions with special bundle types.\n@param[in] max_modelsize (int)        maximum number of subgradients to be used in forming the cutting model\n@param[in] function      if the aggregate subgradient of a particular function is desired,      provide the pointer here, otherwise this referrs to the root function      (if there is only one function to be optimized over, this is this single      function, otherwise it is the sum of functions)\n@return       - 0 on success       - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_set_max_new!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_max_new!","text":"cb_set_max_new!(self::CBCFunction, mn::Integer)\n\nset the maximum number of new subgardients per evaluations\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_max_updates!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_max_updates!","text":"cb_set_max_updates!(self::CBBundleSolver, mu::Integer)\n\nset the maximum number of Gauss-Seidel iterations until the next evaluations for descent/null step, use negative numbers for infinite, 0 or 1 for at most 1\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_max_weight!-Tuple{ConicBundle.CBMatrixCBSolver, Real}","page":"Reference of C++ interface","title":"ConicBundle.cb_set_max_weight!","text":"cb_set_max_weight!(self::CBMatrixCBSolver, max_weight::Real)\n\n@brief Sets an upper bound on the  weight for the quadratic term of the       augmented subproblem.\n  Nonpositive values indicate no bound.\n  The new value shows its effect only at first dynamic change of\n  the weight.\n\n@param[in] max_weight (double)\n\n@return\n  - 0 on success\n  - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_set_maxeigval_factor!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_maxeigval_factor!","text":"cb_set_maxeigval_factor!(self::CBPSCVariableMetricSelection, ef::Real)\n\nsets the parameter\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_maxit!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_maxit!","text":"cb_set_maxit!(self::CBMinRes, in_maxit::Integer)\n\nset maximum number of iterations\n\n\n\n\n\ncb_set_maxit!(self::CBPCG, in_maxit::Integer)\n\nset maximum number of iterations\n\n\n\n\n\ncb_set_maxit!(self::CBPsqmr, in_maxit::Integer)\n\nset maximum number of iterations\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_maxiter!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_maxiter!","text":"cb_set_maxiter!(self::CBUQPSolver, mi::Integer)\n\nsets the upper bound on the number of interior point iterations (<0 means no bound)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_maxweight!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_maxweight!","text":"cb_set_maxweight!(self::CBBundleHKWeight, mw::Real)\n\n<=0 means no bound\n\n\n\n\n\ncb_set_maxweight!(self::CBBundleRQBWeight, mw::Real)\n\n<=0 means no bound\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_min_weight!-Tuple{ConicBundle.CBMatrixCBSolver, Real}","page":"Reference of C++ interface","title":"ConicBundle.cb_set_min_weight!","text":"cb_set_min_weight!(self::CBMatrixCBSolver, min_weight::Real)\n\n@brief Sets a lower bound on the  weight for the quadratic term of the       augmented subproblem.\n  Nonpositive values indicate no bound.\n  The new value shows its effect only at first dynamic change of\n  the weight.\n@param[in] min_weight (double)\n@return       - 0 on success       - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_set_mineigval_factor!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_mineigval_factor!","text":"cb_set_mineigval_factor!(self::CBPSCVariableMetricSelection, ef::Real)\n\nsets the parameter\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_minweight!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_minweight!","text":"cb_set_minweight!(self::CBBundleHKWeight, mw::Real)\n\n<=0 means no bound\n\n\n\n\n\ncb_set_minweight!(self::CBBundleRQBWeight, mw::Real)\n\n<=0 means no bound\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_model!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_model!","text":"cb_set_model!(self::CBBundleSolver, bp::Union{<:CBBundleModel,Nothing})\n\nset/change the model that should be optimized over (for the existing groundset and starting point)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_model_calls_delete!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_model_calls_delete!","text":"cb_set_model_calls_delete!(self::CBAffineFunctionTransformation, mcd::Bool)\n\nset to true if the model has to delete this, to false if it is destructed elsewhere\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_modeleps!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_modeleps!","text":"cb_set_modeleps!(self::CBBundleSolver, in_eps::Real)\n\nset the required model precision by @a in_eps (if it is positive)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_modelfailslimit!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_modelfailslimit!","text":"cb_set_modelfailslimit!(self::CBBundleTerminator, ml::Integer)\n\nset upper bound on the value returned by BundleTerminatorData::get_summodelfails, <0 if no limit\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_modification_id!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_modification_id!","text":"cb_set_modification_id!(self::CBMinorantUseData)\n\nreturns the modification id also for overwriting\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_n_latest_minorants!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_n_latest_minorants!","text":"cb_set_n_latest_minorants!(self::CBVariableMetricSVDSelection, nlm::Integer)\n\nsets nlatestminorants\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_new_center!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_new_center!","text":"cb_set_new_center!(self::CBBundleSolver, yp::Union{<:CBMatrix,Nothing} = nothing)\n\nreplace the current center by *yp or, if yp==0, by the default starting point\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_new_center_point!-Tuple{ConicBundle.CBMatrixCBSolver, ConicBundle.CBMatrix}","page":"Reference of C++ interface","title":"ConicBundle.cb_set_new_center_point!","text":"cb_set_new_center_point!(self::CBMatrixCBSolver, center_point::CBMatrix)\n\n@brief Set the starting point/center that will be used in the       next call to  solve(). Each call       to this routine causes an immediate evaluation of all oracles.\n@return       - 0 on success       - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_set_next_weight!-Tuple{ConicBundle.CBBundleHKWeight, Real}","page":"Reference of C++ interface","title":"ConicBundle.cb_set_next_weight!","text":"cb_set_next_weight!(self::CBBundleHKWeight, u::Real)\n\n<=0 leaves everything unchanged and does nothing\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_set_next_weight!-Tuple{ConicBundle.CBBundleRQBWeight, Real}","page":"Reference of C++ interface","title":"ConicBundle.cb_set_next_weight!","text":"cb_set_next_weight!(self::CBBundleRQBWeight, u::Real)\n\n<=0 leaves everything unchanged and does nothing\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_set_next_weight!-Tuple{ConicBundle.CBMatrixCBSolver, Real}","page":"Reference of C++ interface","title":"ConicBundle.cb_set_next_weight!","text":"cb_set_next_weight!(self::CBMatrixCBSolver, weight::Real)\n\n@brief Sets the  weight (>0) to be used in the quadratic term       of the next augmented subproblem       (may be interpreted as 1./step_size or 1./trustregion-radius).\n  Independent of whether the weight violates current min- and max-bounds\n  set in set_min_weight() and set_max_weight(), the next model will\n  be computed for this value. Thereafter, however, it will be updated as\n  usual; in particular, it may be truncated by min and max bounds\n  immediately after the first subproblem.\n\n  In order to guarantee a constant weight (e.g. 1 is frequently a reasonable\n  choice if the automatic default heuristic performs poorly), set the min and max\n   bounds to the same value, too.\n\n@param[in] weight (double)\n\n@return\n  - 0 on success\n  - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_set_nullstep_updates!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_nullstep_updates!","text":"cb_set_nullstep_updates!(self::CBBundleHKWeight, nu::Integer = 0)\n\nset nullstep update strategy (0 ... original, 1 ... none, 2 ... enlarge if subsequence of three norm increases is found\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_objevallimit!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_objevallimit!","text":"cb_set_objevallimit!(self::CBBundleTerminator, ol::Integer)\n\nset upper bound on the value returned by BundleTerminatorData::get_cntobjeval, <0 if no limit\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_offset!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_offset!","text":"cb_set_offset!(self::CBClock, offs::CBMicroseconds)\n\nallows to specify an offset, that will furtheron be added to all time measurements\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_oldfactor!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_oldfactor!","text":"cb_set_oldfactor!(self::CBPSCVariableMetricSelection, of::Real)\n\nsets the parameter\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_oracle!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_oracle!","text":"cb_set_oracle!(self::CBPSCVariableMetricSelection, psco::Union{<:CBPSCOracle,Nothing})\n\nsets the oracle pointer to this value (NULL is allowed, but calling addvariablemetric() then results in a WARNING and an error is returned); this is called by PSCModel when installing this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_oraclefailslimit!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_oraclefailslimit!","text":"cb_set_oraclefailslimit!(self::CBBundleTerminator, ol::Integer)\n\nset upper bound on the value returned by BundleTerminatorData::get_sumoraclefails, <0 if no limit\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_out!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_out!","text":"cb_set_out!(self::CBMatrixCBSolver, print_level::Integer = 1)\n\n@brief Specifies the output level (out==NULL: no output at all,          out!=NULL and level=0: errors and warnings,          level>0 increasingly detailed information)\n@param[in] out  (std::ostream)      direct all output to (out). If out==NULL, there will be no output at all.\n@param[in] print_level (int)\nOutput levels for print_level:     -  0 ... no output except for errors and warnings     -  1 ... line summary after each descent step     - >1 ... undocumented and increasingly detailed log information.            These higher levels should only be used if requested            for debugging purposes.\nExample for level 1:\n\n\\verbatim 00:00:00.00 endit  1   1   1   563.    563.  39041.188  39043.162 00:00:00.00 endit  2   2   2   563.    559.  38488.165  38490.200 00:00:00.00 endit  3   3   3   56.3    555.  33014.533  33211.856 00:00:00.00 endit  4   4   4   5.63    517. -14306.459  2738.0343 00:00:00.00 endit  5   5   5   4.04    148. -2692.1131  2.2150883 00:00:00.00 endit  6   6   6   4.01    1.29  1.7908952  2.0000581 00:00:00.00 endit  7   7   7   3.95  0.0213  1.9999387  2.0000000 00:00:00.00 _endit  8   8   8   3.95 2.94e-05  2.0000000  2.0000000\n\nColumn 1      2     3   4   5    6       7       8          9 \\endverbatim       - Column 1: computation time in hh:mm:ss.dd,       - Column 2: \"endit\" is convenient for grep and stands for \"end of iteration\".          Iterations with terminationcode()!=0 are marked with \"endit\".       - Column 3: number of descent steps       - Column 4: number of descent and null steps. Up to initialization calls          and reevaluations, this is the number of evaluation calls          to the function oracles from within the bundle method.          In the example all calls led to descent steps.       - Column 5: number of innermost iterations. It differs from column 5 only in the           case of variables with bounds in which case it gives the number of updates           of the multipliers for the bounds (or primal slacks in Lagrangean           relaxation). Exceedingly high numbers in this column indicate that           some variables are constantly at their bounds and it might be           possible to improve convergence by deleting them (i.e. set them           as constants to this bound and remove the variable).       - Column 6: the weight of the quadratic term in the augmented problem.       - Column 7: the norm of the aggregate subgradient. If it is small,           say below 0.1, then mostly this is good indication that the           objective value is close to optimal.       - Column 8: the value of the cutting model in the last candidate point. It           is always a lower bound on the true function value in this point       - Column 9: the objective value in the latest point that led to a descent           step, i.e., the point returend by getcenter(). Whenever           terminationcode() returns 0 this is also the objective           value of the latest evaluation call to the function oracles and           the value in the center point of the next iteration.\n\n\n\n\n\ncb_set_out!(self::CBAFTModification, print_level::Integer = 1)\n\nsee CBout::set_out\n\n\n\n\n\ncb_set_out!(self::CBGroundsetModification, print_level::Integer = 1)\n\nsee CBout::set_out\n\n\n\n\n\ncb_set_out!(self::CBNNCBoxSupportModification, print_level::Integer = 1)\n\nsee CBout::set_out\n\n\n\n\n\ncb_set_out!(self::CBPSCAffineModification, print_level::Integer = 1)\n\nsee CBout::set_out\n\n\n\n\n\ncb_set_out!(self::CBSOCSupportModification, print_level::Integer = 1)\n\nsee CBout::set_out\n\n\n\n\n\ncb_set_out!(self::CBNNCBoxSupportFunction, pril::Integer = 1)\n\nsee ConicBundle::CBout\n\n\n\n\n\ncb_set_out!(self::CBPSCAffineFunction, pril::Integer = 1)\n\nsee ConicBundle::CBout\n\n\n\n\n\ncb_set_out!(self::CBSOCSupportFunction, pril::Integer = 1)\n\nsee ConicBundle::CBout\n\n\n\n\n\ncb_set_out!(self::CBAFTModel, pril::Integer = 1)\n\nset output and outputlevel of warnings and errors recursively, see CBout\n\n\n\n\n\ncb_set_out!(self::CBBoxModel, pril::Integer = 1)\n\nset output and outputlevel of warnings and errors recursively, see CBout\n\n\n\n\n\ncb_set_out!(self::CBNNCModel, pril::Integer = 1)\n\nset output and outputlevel of warnings and errors recursively, see CBout\n\n\n\n\n\ncb_set_out!(self::CBPSCModel, pril::Integer = 1)\n\nset output and outputlevel of warnings and errors recursively, see CBout\n\n\n\n\n\ncb_set_out!(self::CBSOCModel, pril::Integer = 1)\n\nset output and outputlevel of warnings and errors recursively, see CBout\n\n\n\n\n\ncb_set_out!(self::CBSumModel, pril::Integer = 1)\n\nset output and outputlevel of warnings and errors recursively, see CBout\n\n\n\n\n\ncb_set_out!(self::CBUQPSumModelBlock, pril::Integer = 1)\n\ndo this for all subblocks\n\n\n\n\n\ncb_set_out!(self::CBMinRes, in_print_level::Integer = 1)\n\nset output stream and level of detail of log output (for debugging)\n\n\n\n\n\ncb_set_out!(self::CBPCG, in_print_level::Integer = 1)\n\nset output stream and level of detail of log output (for debugging)\n\n\n\n\n\ncb_set_out!(self::CBPsqmr, in_print_level::Integer = 1)\n\nset output stream and level of detail of log output (for debugging)\n\n\n\n\n\ncb_set_out!(self::CBBundleSolver, pril::Integer = 1)\n\nset output and outputlevel of warnings and errors recursively, see CBout\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_parent_information!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_parent_information!","text":"cb_set_parent_information!(self::CBSumBundleHandler, parent_sbh::Union{<:CBSumBundleHandler,Nothing}, aft::Union{<:CBAffineFunctionTransformation,Nothing}, in_mode::CBMode)\n\n@brief sets a parent handler, an aft and prepares for the next inmode. If the respective pointers are null and inmode is active, a part in child mode is changed to root.\nIf the parent pointer is not null, the routine calls alignbundle in   order to match the existing bundle to the parent's.  Therefore, if   the parent pointer is not null and the parent has a positive bundle   size, setparent_information may only be called if all parts that   have contributors also have a bundle containing an aggregate,   i.e. they need a bundlesize of at least one.\nIf in_mode==root, the handler has to perpare the sumbundle to serve as root.\nIf in_mode==inactive, the handler has to remove any relevant   contributions and to deactivate the sumbundle\nIf inmode==child, the action depends on the the current mode. If   the mode is child or root already, no changes are required. In   particular, if the mode is root and the inmode child is desired,   this needs to be achieved later by a call to addcontributions()   (once all bundle components have been collected). If the current   mode is inactive, the sumbundle's mode is changed to root and again   an addcontributions() will be needed to change that to child.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_point!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_point!","text":"cb_set_point!(self::CBUQPConeModelBlock, qp_x::CBMatrix, qp_y::CBMatrix, alpha::Real)\n\nx,y,z is the new point and has to be stored, alpha is the step size used in the step, it is passed so thatthe block can take the same step for internal variables if needed.\n\n\n\n\n\ncb_set_point!(self::CBUQPSumModelBlock, qp_x::CBMatrix, qp_y::CBMatrix, alpha::Real)\n\ndo this for all subblocks\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_primal!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_primal!","text":"cb_set_primal!(self::CBMinorant, param0::Union{<:CBPrimalData,Nothing})\n\nif the minorant is generated by PrimalData and this should be aggregated along, insert a heap object of it here (see PrimalData)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_prox!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_prox!","text":"cb_set_prox!(self::CBMatrixCBSolver, proxp::Union{<:CBBundleProxObject,Nothing})\n\n@brief For variable metric install the BundleProxObject pointed to; the object is passed to the solver who will delete it on termination or when replaced\n@param[in] proxp (BundleProxObject*)\n    replace the current BundleProxObject by this object on the heap;\nNULL is allowed and results in the default choice;   the object pointed to will be deleted by the solver\n@return\n  - 0 on success\n  - != 0 otherwise\n\n\n\n\n\ncb_set_prox!(self::CBBundleSolver, bsp::Union{<:CBBundleProxObject,Nothing})\n\nset the proximal term by replacing BundleProxObject with bsp, the latter is deleted when replaced or on destruction of this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_prox_diagonal!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_prox_diagonal!","text":"cb_set_prox_diagonal!(self::CBBundleSolver, insc::CBMatrix)\n\nset the prox term to the given diagonal matrix\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_qp_solver!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_qp_solver!","text":"cb_set_qp_solver!(self::CBMatrixCBSolver, qpparams::Union{<:CBQPSolverParametersObject,Nothing}, newqpsolver::Union{<:CBQPSolverObject,Nothing} = nothing)\n\n@brief Set parameters for the internal QP solver, possibly after first exchanging the solver with a new one\nThe objects passed need to be heap objects; their ownership is transferred    to the bundle code and they will be deleted there. The pointers may be null,    in which case nothing is done for this object\n@param[in] qpparams (QPSolverParametersObject*)\n@param[in] newqpsolver (QPSolverObject*)\n@return      - 0 on success      - != 0 otherwise\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_qp_solver_parameters!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_qp_solver_parameters!","text":"cb_set_qp_solver_parameters!(self::CBLPGroundset, param0::Union{<:CBQPSolverParametersObject,Nothing})\n\nset parameters for the QP_Solver\n\n\n\n\n\ncb_set_qp_solver_parameters!(self::CBUnconstrainedGroundset, param0::Union{<:CBQPSolverParametersObject,Nothing})\n\nset parameters for the QP_Solver\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_qp_xstart!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_qp_xstart!","text":"cb_set_qp_xstart!(self::CBUQPConeModelBlock, x_start_index::Integer)\n\nthe indices of the local variables correspond to the indices of the qp variables x and z starting with this index; returns 0 on success, 1 on failure\n\n\n\n\n\ncb_set_qp_xstart!(self::CBUQPSumModelBlock, x_start_index::Integer)\n\nset the starting index of x also for all subblocks\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_qp_ystart!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_qp_ystart!","text":"cb_set_qp_ystart!(self::CBUQPConeModelBlock, y_start_index::Integer)\n\nthe indices of the local variables correspond to the indices of the qp variables y starting with this index; returns 0 on success, 1 on failure\n\n\n\n\n\ncb_set_qp_ystart!(self::CBUQPSumModelBlock, y_start_index::Integer)\n\nset the starting index of y also for all subblocks\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_qpfailslimit!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_qpfailslimit!","text":"cb_set_qpfailslimit!(self::CBBundleTerminator, ql::Integer)\n\nset upper bound on the value returned by BundleTerminatorData::get_sumqpfails, <0 if no limit\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_qpsolver!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_qpsolver!","text":"cb_set_qpsolver!(self::CBLPGroundset, qpparams::Union{<:CBQPSolverParametersObject,Nothing}, qpsolver::Union{<:CBQPSolverObject,Nothing} = nothing)\n\nSet the qp solver's parameters to qpparams (if not null); if the second argument qpsolver is also given, the old solver is first discarded and replaced by this new solver and then the parameters are set (if given).  Any object passed here will be owned and deleted by *this. For correct continuaton a new qpsolver needs to have the same feasible set as the current solver but this must be ensured by the caller.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_recomplimit!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_recomplimit!","text":"cb_set_recomplimit!(self::CBBundleTerminator, rl::Integer)\n\nset upper bound on the value returned by BundleTerminatorData::get_sumrecomp, <0 if no limit\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_scalefactor!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_scalefactor!","text":"cb_set_scalefactor!(self::CBCoeffmatInfo, sf::Real)\n\nsets the scale factor\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_selection_method!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_selection_method!","text":"cb_set_selection_method!(self::CBPSCVariableMetricSelection, sm::Integer)\n\nsets selection_method\n\n\n\n\n\ncb_set_selection_method!(self::CBVariableMetricSVDSelection, sm::Integer)\n\nsets selection_method\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_skip_extension!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_skip_extension!","text":"cb_set_skip_extension!(self::CBPSCAffineModification, skip::Bool)\n\n@brief if this time no extension is possible for newly added variables       with the availabel generating primal, set this to true;\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_starting_point!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_starting_point!","text":"cb_set_starting_point!(self::CBLPGroundset, vec::CBMatrix)\n\nstores the a new starting point irrespective of whether it is feasible or not and returns 0 if it feasible, 1 if it is infeasible\n\n\n\n\n\ncb_set_starting_point!(self::CBUnconstrainedGroundset, vec::CBMatrix)\n\nstores the a new starting point irrespective of whether it is feasible or not and returns 0 if it feasible, 1 if it is infeasible\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_subspace!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_subspace!","text":"cb_set_subspace!(self::CBQPKKTSubspaceHPrecond, insubspace::CBMatrix)\n\nif the method admits this, let the subspace be chosen externally\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_sumbundle!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_sumbundle!","text":"cb_set_sumbundle!(self::CBMatrixCBSolver, use_sumbundle::Bool, n_local_models::Integer = -1, bundle_parameters::Union{<:CBBundleParameters,Nothing} = nothing, strategy::Integer = 1)\n\n@brief Starts/ends the use of a common SumBundle of the given bundlesize       with a heuristic rule for selecting up to nlocal_models in each bundle iteration\n  If the function is the sum of many functions, having a local model for every one\n  of them may result in a huge quadratic subproblem. It may then be better to\nform a common model of most of the functions, where a heuristic dynamically selects a few of the functions, for which a local model seems worth while. Whether such a common model should be used, how many subgradients it should contain, and how many local models are to be selected at most are the parameters set here.\nSetting these parameters only has an effect if bundle models of functions are present. If further functions are added later, the call should be repeated.\nThis interface provides a simpler access to the SumBundle features by using some default parameter choices that could be set separately in setbundleparameters() and setsumbundleparameters() in a refined way.\n@param[in] use_sumbundle (bool)       use value true to switch the sumbundle on, use value false to switch it off\n@param[in] nlocalmodels (int)        upper bound on the number of local models to be used on top of the sumbundle's model,  negative values correspond to no upper bound and all functions may have local models\n@param[in] bundle_parameters (const BundleParameters*)        the maximum number of subgradients to be used in forming the SumBundle model,  values <=1 are set to 2;\n@param[in] strategy (int)        this is currently in experimental stage and allows to choose among some internal        sumbundle strategies (currently 0,1,2,11 are available)\n@return       - 0 on success       - != 0 otherwise\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_sumbundle_parameters!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_sumbundle_parameters!","text":"cb_set_sumbundle_parameters!(self::CBMatrixCBSolver, params::CBSumBundleParametersObject, function_::Union{<:CBFunctionObject,Nothing} = nothing)\n\n*@brief Specifies the behavior of the model (of the specified function)         concerning requests to join or start a SumBundle that subsumes several   models instead of providing a separate model for each funciton.\n\n    The abstract interface for these Parameters is specified in\n    SumBundleParametersObject, a concrete implementation is\n    SumBundleParameters. Besides the usual BundleParameters\n    the new main parameter is specified in\n\nSumBundleParametersObject::setacceptablemode(), see there.\n\n @param[in] params (const BundleParameters&)\n   some update parameters for the cutting model, see e.g. ConicBundle::BundleParameters\n\n @param[in] function\n   if the aggregate subgradient of a particular function is desired,\n   provide the pointer here, otherwise this referrs to the root function\n   (if there is only one function to be optimized over, this is this single\n   function, otherwise it is the sum of functions)\n\n\n @return\n   - 0 on success\n   - != 0 otherwise\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_term_relprec!-Tuple{ConicBundle.CBMatrixCBSolver, Real}","page":"Reference of C++ interface","title":"ConicBundle.cb_set_term_relprec!","text":"cb_set_term_relprec!(self::CBMatrixCBSolver, term_relprec::Real)\n\n@brief Sets the relative precision requirements for successful termination              (default 1e-5).\n@param[in] termrelprec (double)      The algorithm stops with termination code 1, if predicted progress for      the next step is less than termrelprec times      absolute function value plus one.\n@return     - 0 on success     - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_set_termbounds!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_termbounds!","text":"cb_set_termbounds!(self::CBUQPSolver, lb::Real, ub::Real)\n\nsets the termination lower and upper bounds\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_termeps!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_termeps!","text":"cb_set_termeps!(self::CBUQPSolver, te::Real)\n\nsets the termination precision\n\n\n\n\n\ncb_set_termeps!(self::CBBundleTerminator, teps::Real)\n\nset the termination precision (>0!)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_terminator!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_terminator!","text":"cb_set_terminator!(self::CBBundleSolver, bt::Union{<:CBBundleTerminator,Nothing})\n\nreplace the previous BundleTerminator by bt; bt will be deleted when replaced or on destruction of this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_time_limit!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_time_limit!","text":"cb_set_time_limit!(self::CBMatrixCBSolver, time_limit::Integer)\n\n@brief Set an upper bound on the number of seconds (user time, use negative numbers for no limit)\n@param[in] time_limit (Integer)\n\n@return\n  - 0 on success\n  - != 0 otherwise\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_timelimit!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_timelimit!","text":"cb_set_timelimit!(self::CBBundleTerminator, cp::Union{<:CBClock,Nothing}, tl::CBMicroseconds)\n\nset cp==0 for no timelimit, otherwise specify clock and microseconds\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_tol!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_tol!","text":"cb_set_tol!(self::CBSparsemat, t::Real)\n\nset tolerance for recognizing zero values to t\n\n\n\n\n\ncb_set_tol!(self::CBSparsesym, t::Real)\n\nset tolerance for recognizing zero values to t\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_upper_bound!-Tuple{ConicBundle.CBMatrixCBSolver, Integer, Real}","page":"Reference of C++ interface","title":"ConicBundle.cb_set_upper_bound!","text":"cb_set_upper_bound!(self::CBMatrixCBSolver, i::Integer, ub::Real)\n\n*@brief Sets upper bound for variable i,   use ConicBundle::CBplusinfinity for unbounded from below.\n\n   The algorithm may have to adapt the center point aftwards.\n   In this case the old function values will be marked as outdated and\n   will be recomputed at the next call to e.g. solve().\n\n @return\n  - 0 on success\n  - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_set_use_linval!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_use_linval!","text":"cb_set_use_linval!(self::CBBundleSolver, ul::Bool)\n\nif set to true, the value of the aggregate in the candidate is used for deciding on null or descent step, otherwise the model value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_use_yfixing!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_use_yfixing!","text":"cb_set_use_yfixing!(self::CBLPGroundset, uyf::Bool)\n\nset to true to switch on the cooridinate fixing heuristic (only constrained cases)\n\n\n\n\n\ncb_set_use_yfixing!(self::CBUnconstrainedGroundset, uyf::Bool)\n\nset to true to switch on the cooridinate fixing heuristic (only constrained cases)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_variable_metric!-Tuple{ConicBundle.CBBundleSolver, Integer}","page":"Reference of C++ interface","title":"ConicBundle.cb_set_variable_metric!","text":"cb_set_variable_metric!(self::CBBundleSolver, ds::Integer)\n\n0 ... use no scaling, 1 ... use a scaling heuristic, 2 ... also allow groundset to influence the scaling so as to favor feasibility,\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_set_variable_metric!-Tuple{ConicBundle.CBMatrixCBSolver, Integer}","page":"Reference of C++ interface","title":"ConicBundle.cb_set_variable_metric!","text":"cb_set_variable_metric!(self::CBMatrixCBSolver, do_variable_metric::Integer)\n\n@brief Use a variable metric heuristic or switch off general metrics alltogether.      (variable metric resets the quadratic term e.g. to some diagonal matrix,      switching it off resets the quadratic term to the identity times the weight)\n@param[in] dovariablemetric (int)       - 0 switch off the scaling heuristic       - 1 use a diagonal scaling heuristic       - 2 use a diagonal scaling heuristic combined with one for the bounds       - 3 use a low rank scaling heuristic       - 4 use a low rank scaling heuristic combined with a diagonal term       - 5 use a dense scaling heuristic\n@return\n  - 0 on success\n  - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_set_variable_metric_selection!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_variable_metric_selection!","text":"cb_set_variable_metric_selection!(self::CBLPGroundset, vms::Union{<:CBVariableMetricSelection,Nothing} = nothing)\n\ndelete old selector and set a new one (0 is allowed resulting in no local selector)\n\n\n\n\n\ncb_set_variable_metric_selection!(self::CBPSCModel, vms::Union{<:CBVariableMetricSelection,Nothing} = nothing)\n\ndelete old selector and set a new one (0 is allowed resulting in no local selector); if vms casts to  PSCVariableMetricSelection*, the oracle is immediately set to this one\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_weight_update!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_weight_update!","text":"cb_set_weight_update!(self::CBMatrixCBSolver, bw::Union{<:CBBundleWeight,Nothing})\n\n@brief Replaces the internal update routine for choosing the weight used in the proximal term; input NULL reinstalls the default routine.\n  The BundleWeight class instance pointed to will be deleted on\n  construction, i.e., ownership is passe over to the solver.\n\n@param[in] bw\n  replace internal update routine by bw, value 0 reinstalls the default routine\n\n@return\n  - 0 on success\n  - != 0 otherwise\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_weightu!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_weightu!","text":"cb_set_weightu!(self::CBBundleDenseTrustRegionProx, in_weightu::Real)\n\nset the weight of the proximal term\n\n\n\n\n\ncb_set_weightu!(self::CBBundleDiagonalTrustRegionProx, in_weightu::Real)\n\nset the weight of the proximal term\n\n\n\n\n\ncb_set_weightu!(self::CBBundleDLRTrustRegionProx, in_weightu::Real)\n\nsets the next weight\n\n\n\n\n\ncb_set_weightu!(self::CBBundleIdProx, in_weightu::Real)\n\nset the weight of the proximal term\n\n\n\n\n\ncb_set_weightu!(self::CBBundleLowRankTrustRegionProx, in_weightu::Real)\n\nsets the next weight\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_set_yfixed!","page":"Reference of C++ interface","title":"ConicBundle.cb_set_yfixed!","text":"cb_set_yfixed!(self::CBLPGroundset)\n\nif not NULL (iff getuseyfixing()==false) returns the vector yfixed with yfixed(i)=0 if not fixed, =1 is fixed already, =2 if newly fixed\n\n\n\n\n\ncb_set_yfixed!(self::CBUnconstrainedGroundset)\n\nif not NULL (iff getuseyfixing()==false) returns the vector yfixed with yfixed(i)=0 if not fixed, =1 is fixed already, =2 if newly fixed\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_shift_diag!","page":"Reference of C++ interface","title":"ConicBundle.cb_shift_diag!","text":"cb_shift_diag!(self::CBSymmatrix, s::Real)\n\nshifts the diagonal by s, i.e., (*this)(i,i)+=s for all i\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_shuffle!","page":"Reference of C++ interface","title":"ConicBundle.cb_shuffle!","text":"cb_shuffle!(self::CBMatrix, random_generator::Union{<:CBGB_rand,Nothing} = nothing)\n\nshuffle the elements randomly (does not change dimensions)\n\n\n\n\n\ncb_shuffle!(self::CBIndexmatrix, random_generator::Union{<:CBGB_rand,Nothing} = nothing)\n\nshuffle the elements randomly (does not change dimensions)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_sign","page":"Reference of C++ interface","title":"ConicBundle.cb_sign","text":"cb_sign(A::CBMatrix, tol::Real)\n\nreturns a matrix with elements (i,j)=sign((*this)(i,j)) for all i,j using ::sign(double,double)\n\n\n\n\n\ncb_sign(A::CBIndexmatrix)\n\nreturn a matrix of the same size as A with (i,j)=sign(A(i,j)) for all i,j, see also CHMatrixClasses::sign()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_sign!","page":"Reference of C++ interface","title":"ConicBundle.cb_sign!","text":"cb_sign!(self::CBMatrix, tol::Real = 1e-12)\n\nsets (this)(i,j)=sign((this)(i,j),tol) for all i,j using ::sign(double,double) and returns *this\n\n\n\n\n\ncb_sign!(self::CBIndexmatrix)\n\nusing ::sign assign (this)(i,j)=sign((this)(i,j)) for all i,j\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_skron","page":"Reference of C++ interface","title":"ConicBundle.cb_skron","text":"cb_skron(A::CBSymmatrix, B::CBSymmatrix, alpha::Real, add::Bool, startindex_S::Integer)\n\nthe symmetric Kronecker product, defined via (A skron B)svec(C)=(BCA'+ACB')/2; sets or adds (if add==true) the symmetric matrix a*(A skron B) into S starting at startindexS; if add==false and startindexS<0, S is initialzed to the correct size\n\n\n\n\n\ncb_skron(A::CBSymmatrix, B::CBSymmatrix, S::CBSymmatrix, a::Real, add::Bool, startindex_S::Integer)\n\ndef symmetric Kronecker product (A skron B)svec(C)=(BCA'+ACB')/2; sets S=alpha(A skron B) or S=... (if add==true) possibly shifted to the block starting at startindexS;  if add==false and startindexS<0, S is initialzed to the correct size\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_solve!-Tuple{ConicBundle.CBBundleSolver, Integer, Bool}","page":"Reference of C++ interface","title":"ConicBundle.cb_solve!","text":"cb_solve!(self::CBBundleSolver, maxsteps::Integer = 0, stop_at_descent_steps::Bool = false)\n\nexecute at most maxsteps iterations of the bundle method stopping before if termination occurs or stopatdescent_steps==true and a descent step occurs; maxsteps<=0 indicates no bound on the steps\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_solve!-Tuple{ConicBundle.CBMatrixCBSolver, Integer, Bool}","page":"Reference of C++ interface","title":"ConicBundle.cb_solve!","text":"cb_solve!(self::CBMatrixCBSolver, maxsteps::Integer = 0, stop_at_descent_steps::Bool = false)\n\n@brief solves or does a prescribed number of iterations\nBundle methods solve a problem by a sequence of so called       descent steps that actually bring progress by moving from the       current \"center point\" to a new center with better objective.       A descent step may consist of several function evaluations       (null steps), that lead to no immediate progress but mainly improve a cutting model of the objective function close to       the current center point.  A minimizer to the model is       accepted as descent step if the function value at this point       satisfies a sufficient decrease criterion in comparison to the       decrease predicted by the model. Having found a descent step,       the next center is automatically shifted to this successful       candidate.  Termination criteria may stop the process of       seeking for a descent step, in which case the current center       is kept and the routine termination_code() returns the       termination code.\n  Restarting, after each descent step, the bundle method from scratch\n  with the new center as starting point does not endanger convergence.\n  Therefore, a descent step is the smallest unit, after which\n  user interaction can take place safely. To allow this there\nis a flag stopatdescent_steps that will cause the code to return after the next descent step.\nIf you know what your are doing, you may also use the input       parameter maxsteps to force the algorithm to return after       at most maxsteps null steps. Calling solve again       without any intermediate problem configurations will then       simply continue the process where it stopped and convergence       is save. During null steps one may not decrease the weight       or delete nonzero variables of the center or the current candidate!\n  In a Lagrangean relaxation cutting plane approach one may want\n  to separate and enlarge the dimension after a certain number\n  of null steps. In this case the code will try to preserve the model,\n  given appropriate subgradient extension routines have been\n  provided. If the model cannot be extended, it has to be\n  discarded (if subgradient extension is not successful\n  this is done automatically), and the algorithm will be restarted\n  from the current center point.\n\n@param[in] maxsteps (int)\n    if maxsteps>0 the code returns after at most so many null steps\n\n@param[in] stop_at_descent_steps (int)\n    if true the code also returns whenever a descent step occured\n\n@return\n  - 0 on success\n  - != 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_solve!-Tuple{ConicBundle.CBQPSolver, Union{Nothing, ConicBundle.CBBundleProxObject}, ConicBundle.CBMatrix, Vararg{Real, 5}}","page":"Reference of C++ interface","title":"ConicBundle.cb_solve!","text":"cb_solve!(self::CBQPSolver, Hp::Union{<:CBBundleProxObject,Nothing}, c::CBMatrix, gamma::Real, lowerbound::Real, upperbound::Real, relprec::Real, skip_factor::Real)\n\nsolve the quadratic problem for the given cost function and precision (without cutting model, usually for finding feasible starting points)\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_solve!-Tuple{ConicBundle.CBUQPSolver, ConicBundle.CBSymmatrix, ConicBundle.CBMatrix, Real}","page":"Reference of C++ interface","title":"ConicBundle.cb_solve!","text":"cb_solve!(self::CBUQPSolver, Q::CBSymmatrix, c::CBMatrix, offset::Real)\n\nsolve the QP for this cost function from scratch\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_solve_constrsys!","page":"Reference of C++ interface","title":"ConicBundle.cb_solve_constrsys!","text":"cb_solve_constrsys!(self::CBQPConeModelBlock, ABchol::CBSymmatrix, LinvABrhs::CBMatrix, LinvABsol::CBMatrix, startindex_model::Integer, Crhs_and_sol::CBMatrix, startindex_constraints::Integer)\n\n@brief  given the Cholesky factorization LL' of minus the blocks A and B (contraints on design variables and Bundle-modelx) and LinvABrhs, solve for the local constraints C and add the new contribution of tracedual*LinvTrace to LinvABsol; store the tracedual in Crhsandsol but not yet locally (this will be done by computed_step() ).\n\n\n\n\n\ncb_solve_constrsys!(self::CBQPSumModelBlock, ABchol::CBSymmatrix, LinvABrhs::CBMatrix, LinvABsol::CBMatrix, startindex_model::Integer, Crhs_and_sol::CBMatrix, startindex_constraints::Integer)\n\n@brief  given the Cholesky factorization LL' of minus the blocks A and B (contraints on design variables and Bundle-modelx) and LinvABrhs, solve for the local constraints C and add the new contribution of tracedual*LinvTrace to LinvABsol; store the tracedual in Crhsandsol but not yet locally (this will be done by computed_step() ).\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_sortindex","page":"Reference of C++ interface","title":"ConicBundle.cb_sortindex","text":"cb_sortindex(vec::CBMatrix, nondecreasing::Bool)\n\nreturns an Indexmatrix ind so that vec(ind(0))<=vec(ind(1))<=...<=vec(ind(vec.dim()-1)) (vec may be rectangular, set nondecreasing=false for opposite order)\n\n\n\n\n\ncb_sortindex(vec::CBMatrix, ind::CBIndexmatrix, nondecreasing::Bool)\n\nsets ind so that vec(ind(0))<=vec(ind(1))<=...<=vec(ind(vec.dim()-1)) (vec may be rectangular, set nondecreasing=false for opposite order)\n\n\n\n\n\ncb_sortindex(vec::CBIndexmatrix, nondecreasing::Bool)\n\nreturns an Indexmatrix ind so that vec(ind(0))<=vec(ind(1))<=...<=vec(ind(vec.dim()-1)) (vec may be rectangular, set nondecreasing=false for opposite order)\n\n\n\n\n\ncb_sortindex(vec::CBIndexmatrix, ind::CBIndexmatrix, nondecreasing::Bool)\n\nsets ind so that vec(ind(0))<=vec(ind(1))<=...<=vec(ind(vec.dim()-1)) (vec may be rectangular, set nondecreasing=false for opposite order)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_sparse","page":"Reference of C++ interface","title":"ConicBundle.cb_sparse","text":"cb_sparse(self::CBCMgramdense)\n\nreturns 0 if not sparse, otherwise 1\n\n\n\n\n\ncb_sparse(self::CBCMgramdense, param0::CBIndexmatrix, param1::CBIndexmatrix, param2::CBMatrix, param3::Real)\n\nreturns 0 if not sparse. If it is sparse it returns 1 and the nonzero structure in I,J and v, where v is multiplied by d. Only the upper triangle (including diagonal) is delivered\n\n\n\n\n\ncb_sparse(self::CBCMgramsparse)\n\nreturns 0 if not sparse, otherwise 1\n\n\n\n\n\ncb_sparse(self::CBCMgramsparse, param0::CBIndexmatrix, param1::CBIndexmatrix, param2::CBMatrix, param3::Real)\n\nreturns 0 if not sparse. If it is sparse it returns 1 and the nonzero structure in I,J and v, where v is multiplied by d. Only the upper triangle (including diagonal) is delivered\n\n\n\n\n\ncb_sparse(self::CBCMgramsparse_withoutdiag)\n\nreturns 0 if not sparse, otherwise 1\n\n\n\n\n\ncb_sparse(self::CBCMgramsparse_withoutdiag, param0::CBIndexmatrix, param1::CBIndexmatrix, param2::CBMatrix, param3::Real)\n\nreturns 0 if not sparse. If it is sparse it returns 1 and the nonzero structure in I,J and v, where v is multiplied by d. Only the upper triangle (including diagonal) is delivered\n\n\n\n\n\ncb_sparse(self::CBCMlowrankdd)\n\nreturns 0 if not sparse, otherwise 1\n\n\n\n\n\ncb_sparse(self::CBCMlowrankdd, param0::CBIndexmatrix, param1::CBIndexmatrix, param2::CBMatrix, param3::Real)\n\nreturns 0 if not sparse. If it is sparse it returns 1 and the nonzero structure in I,J and val, where val is multiplied by d. Only the upper triangle (including diagonal) is delivered\n\n\n\n\n\ncb_sparse(self::CBCMlowranksd)\n\nreturns 0 if not sparse, otherwise 1\n\n\n\n\n\ncb_sparse(self::CBCMlowranksd, param0::CBIndexmatrix, param1::CBIndexmatrix, param2::CBMatrix, param3::Real)\n\nreturns 0 if not sparse. If it is sparse it returns 1 and the nonzero structure in I,J and val, where val is multiplied by d. Only the upper triangle (including diagonal) is delivered\n\n\n\n\n\ncb_sparse(self::CBCMlowrankss)\n\nreturns 0 if not sparse, otherwise 1\n\n\n\n\n\ncb_sparse(self::CBCMlowrankss, param0::CBIndexmatrix, param1::CBIndexmatrix, param2::CBMatrix, param3::Real)\n\nreturns 0 if not sparse. If it is sparse it returns 1 and the nonzero structure in I,J and val, where val is multiplied by d. Only the upper triangle (including diagonal) is delivered\n\n\n\n\n\ncb_sparse(self::CBCMsingleton)\n\nreturns 0 if not sparse, otherwise 1\n\n\n\n\n\ncb_sparse(self::CBCMsingleton, I::CBIndexmatrix, J::CBIndexmatrix, v::CBMatrix, d::Real = 1.)\n\nreturns 0 if not sparse. If it is sparse it returns 1 and the nonzero structure in I,J and v, where v is multiplied by d. Only the upper triangle (including diagonal) is delivered\n\n\n\n\n\ncb_sparse(self::CBCMsymdense)\n\nreturns 0 if not sparse, otherwise 1\n\n\n\n\n\ncb_sparse(self::CBCMsymdense, param0::CBIndexmatrix, param1::CBIndexmatrix, param2::CBMatrix, param3::Real)\n\nreturns 0 if not sparse. If it is sparse it returns 1 and the nonzero structure in I,J and v, where v is multiplied by d. Only the upper triangle (including diagonal) is delivered\n\n\n\n\n\ncb_sparse(self::CBCMsymsparse)\n\nreturns 0 if not sparse, otherwise 1\n\n\n\n\n\ncb_sparse(self::CBCMsymsparse, I::CBIndexmatrix, J::CBIndexmatrix, val::CBMatrix, d::Real = 1.)\n\nreturns 0 if not sparse. If it is sparse it returns 1 and the nonzero structure in I,J and val, where val is multiplied by d. Only the upper triangle (including diagonal) is delivered\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_sparseDiag","page":"Reference of C++ interface","title":"ConicBundle.cb_sparseDiag","text":"cb_sparseDiag(A::CBMatrix, tol::Real)\n\nforms a sparse symmetrix matrix having vector A on its diagonal\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_sparse_argument_changes","page":"Reference of C++ interface","title":"ConicBundle.cb_sparse_argument_changes","text":"cb_sparse_argument_changes(self::CBAffineFunctionTransformation)\n\n@brief returns true if argtrafo influences at most two thirds of the entries of localargument\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_sparsemult","page":"Reference of C++ interface","title":"ConicBundle.cb_sparsemult","text":"cb_sparsemult(self::CBSparsesym, A::CBMatrix)\n\ncompute (this)A and return the result in a Sparsemat\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_sparsify!","page":"Reference of C++ interface","title":"ConicBundle.cb_sparsify!","text":"cb_sparsify!(self::CBMinorant, tol::Real = CB_minorant_zero_tolerance, sparsity_ratio::Real = CB_minorant_sparsity_ratio)\n\nconverts to sparse format with zeros of absolut value at most tol*(fabs(offset)+1) if the given ratio of elements is zero in relation to the maximum nonzero index\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_sqr","page":"Reference of C++ interface","title":"ConicBundle.cb_sqr","text":"cb_sqr(A::CBMatrix)\n\nreturns a matrix with elements (i,j)=sqr((*this)(i,j)) for all i,j\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_sqr!","page":"Reference of C++ interface","title":"ConicBundle.cb_sqr!","text":"cb_sqr!(self::CBMatrix)\n\nsets (this)(i,j)=sqr((this)(i,j)) for all i,j and returns *this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_sqrt","page":"Reference of C++ interface","title":"ConicBundle.cb_sqrt","text":"cb_sqrt(A::CBMatrix)\n\nreturns a matrix with elements (i,j)=sqrt((*this)(i,j)) for all i,j\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_sqrt!","page":"Reference of C++ interface","title":"ConicBundle.cb_sqrt!","text":"cb_sqrt!(self::CBMatrix)\n\nsets (this)(i,j)=sqrt((this)(i,j)) for all i,j and returns *this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_start!","page":"Reference of C++ interface","title":"ConicBundle.cb_start!","text":"cb_start!(self::CBClock)\n\nread current time, all further time measurements will be in relation to this time\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_start_augmodel!","page":"Reference of C++ interface","title":"ConicBundle.cb_start_augmodel!","text":"cb_start_augmodel!(self::CBSumBundleHandler, bp::CBQPModelDataPointer, cand_id::Integer, cand_y::CBMatrix, indices::Union{<:CBIndexmatrix,Nothing}, ft::CBFunctionTask)\n\nstart the augmented model block for FunctionTask ft if to be handled here and increase xdim correspondingly; if there are several, use startaugmodel(QPSumBlock&,Integer&) instead\n\n\n\n\n\ncb_start_augmodel!(self::CBSumBundleHandler, bp::CBQPModelDataPointer, sumblock::CBQPSumModelDataObject, cand_id::Integer, cand_y::CBMatrix, indices::Union{<:CBIndexmatrix,Nothing} = nothing)\n\nadd augmented model blocks to the sumblock for parts to be handled here and increase xdim correspondingly\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_start_modification!","page":"Reference of C++ interface","title":"ConicBundle.cb_start_modification!","text":"cb_start_modification!(self::CBLPGroundset)\n\npropagates the call to QPSolverObject::QPstart_modification() of the current qpsolver\n\n\n\n\n\ncb_start_modification!(self::CBUnconstrainedGroundset)\n\nreturn a new modification object on the heap that is initialized for modification of *this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_start_sumaugmodel!","page":"Reference of C++ interface","title":"ConicBundle.cb_start_sumaugmodel!","text":"cb_start_sumaugmodel!(self::CBAFTModel, blockp::CBQPModelDataPointer, cand_id::Integer, cand_y::CBMatrix, indices::Union{<:CBIndexmatrix,Nothing} = nothing, bh::Union{<:CBSumBundleHandler,Nothing} = nothing, mode::CBMode = cbm_inactive, aft::Union{<:CBAffineFunctionTransformation,Nothing} = nothing)\n\nsee BundleModel::startaugmodel() for the first four parameters; for the others see sumbundlecontribution()\n\n\n\n\n\ncb_start_sumaugmodel!(self::CBSumModel, blockp::CBQPModelDataPointer, cand_id::Integer, cand_y::CBMatrix, indices::Union{<:CBIndexmatrix,Nothing} = nothing, bh::Union{<:CBSumBundleHandler,Nothing} = nothing, mode::CBMode = cbm_inactive, aft::Union{<:CBAffineFunctionTransformation,Nothing} = nothing)\n\nsee BundleModel::startaugmodel() for the first four parameters; for the others see sumbundlecontribution()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_starting_x!","page":"Reference of C++ interface","title":"ConicBundle.cb_starting_x!","text":"cb_starting_x!(self::CBUQPConeModelBlock, qp_x::CBMatrix)\n\ngenerate a strictly feasible primal starting point, store it in the qpx_range of x; returns 0 on success, 1 on failure\n\n\n\n\n\ncb_starting_x!(self::CBUQPSumModelBlock, qp_x::CBMatrix)\n\nget the starting x of all subblocks\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_starting_y!","page":"Reference of C++ interface","title":"ConicBundle.cb_starting_y!","text":"cb_starting_y!(self::CBUQPConeModelBlock, qp_y::CBMatrix, qp_Qx::CBMatrix, qp_c::CBMatrix)\n\ngenerate a strictly feasible dual starting point, store it in the qpyrange of y,  x is fixed already by a previous call to startingx and Qx=Q*x; returns 0 on success, 1 on failure\n\n\n\n\n\ncb_starting_y!(self::CBUQPSumModelBlock, qp_y::CBMatrix, qp_Qx::CBMatrix, qp_c::CBMatrix)\n\nget the starting y information of all subblocks\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_store_SOCvec!","page":"Reference of C++ interface","title":"ConicBundle.cb_store_SOCvec!","text":"cb_store_SOCvec!(self::CBSOCData, SOCvec::CBMatrix)\n\nif maxoldminorants > 0, it adds the SOCvec cyclically to SOCvecs keeping maxoldminorants of them\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_store_svec","page":"Reference of C++ interface","title":"ConicBundle.cb_store_svec","text":"cb_store_svec(self::CBSymmatrix, dp::Union{<:AbstractVector{Cdouble},Nothing}, d::Real = 1.)\n\nstore in the form of an svec in the real array (or matrix)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_subassign!","page":"Reference of C++ interface","title":"ConicBundle.cb_subassign!","text":"cb_subassign!(self::CBMatrix, vecrow::CBIndexmatrix, veccol::CBIndexmatrix, A::CBMatrix)\n\nassigns A to a submatrix of this,  (this)(vecrow(i),veccol(j))=A(i,j) for 0<=i<vecrow.dim(), 0<=j<veccol.dim()\n\n\n\n\n\ncb_subassign!(self::CBMatrix, vec::CBIndexmatrix, A::CBMatrix)\n\nassigns vector A to a subvector of this,  (this)(vec(i))=A(i) for 0<=i<vec.dim(), *this, vec, and A may be rectangular matrices, their dimesions are not changed, returns *this\n\n\n\n\n\ncb_subassign!(self::CBIndexmatrix, vecrow::CBIndexmatrix, veccol::CBIndexmatrix, A::CBIndexmatrix)\n\nassigns A to a submatrix of this,  (this)(vecrow(i),veccol(j))=A(i,j) for 0<=i<vecrow.dim(), 0<=j<veccol.dim()\n\n\n\n\n\ncb_subassign!(self::CBIndexmatrix, vec::CBIndexmatrix, A::CBIndexmatrix)\n\nassigns vector A to a subvector of this,  (this)(vec(i))=A(i) for 0<=i<vec.dim(), *this, vec, and A may be rectangular matrices, their dimesions are not changed, returns *this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_subspace","page":"Reference of C++ interface","title":"ConicBundle.cb_subspace","text":"cb_subspace(self::CBCMgramdense, P::CBMatrix)\n\ndelivers a new object on the heap corresponding to the matrix P^T(*this)P, the caller is responsible for deleting the object\n\n\n\n\n\ncb_subspace(self::CBCMgramsparse, P::CBMatrix)\n\ndelivers a new object on the heap corresponding to the matrix P^T(*this)P, the caller is responsible for deleting the object\n\n\n\n\n\ncb_subspace(self::CBCMgramsparse_withoutdiag, P::CBMatrix)\n\ndelivers a new object on the heap corresponding to the matrix P^T(*this)P, the caller is responsible for deleting the object\n\n\n\n\n\ncb_subspace(self::CBCMlowrankdd, P::CBMatrix)\n\ndelivers a new object on the heap corresponding to the matrix P^T(*this)P, the caller is responsible for deleting the object\n\n\n\n\n\ncb_subspace(self::CBCMlowranksd, P::CBMatrix)\n\ndelivers a new object on the heap corresponding to the matrix P^T(*this)P, the caller is responsible for deleting the object\n\n\n\n\n\ncb_subspace(self::CBCMlowrankss, P::CBMatrix)\n\ndelivers a new object on the heap corresponding to the matrix P^T(*this)P, the caller is responsible for deleting the object\n\n\n\n\n\ncb_subspace(self::CBCMsingleton, P::CBMatrix)\n\ndelivers a new object on the heap corresponding to the matrix P^T(*this)P, the caller is responsible for deleting the object\n\n\n\n\n\ncb_subspace(self::CBCMsymdense, P::CBMatrix)\n\ndelivers a new object on the heap corresponding to the matrix P^T(*this)P, the caller is responsible for deleting the object\n\n\n\n\n\ncb_subspace(self::CBCMsymsparse, P::CBMatrix)\n\ndelivers a new object on the heap corresponding to the matrix P^T(*this)P, the caller is responsible for deleting the object\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_subtract_z","page":"Reference of C++ interface","title":"ConicBundle.cb_subtract_z","text":"cb_subtract_z(self::CBUQPConeModelBlock, dual_residual::CBMatrix, with_step::Bool = false)\n\nadd the contributions of the dual slacks and return dual_residual returns 0 on success, 1 on failure\n\n\n\n\n\ncb_subtract_z(self::CBUQPSumModelBlock, dual_residual::CBMatrix, with_step::Bool = false)\n\ndo this for all subblocks\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_suggest_mu!","page":"Reference of C++ interface","title":"ConicBundle.cb_suggest_mu!","text":"cb_suggest_mu!(self::CBUQPConeModelBlock, qp_dx::CBMatrix, qp_dy::CBMatrix, rhs_residual::CBMatrix)\n\n@brief supply the information for the choice of the next barrier parameter value\n dx, dy is the predictor direction giving rise to the\n rhs_residual -(c-At(y+dy)-Q(x+dx)). Compute the direction dz and\n local step and based on the predictor (x+dx,y+dy,z+dz) suggest a\n value for mu by specifying the inner product of the dual cone\n variables ip_xz=ip(x,z)+ip(s,t), the dimension of the conic\n variable space mu_dim= cone_x.dim+cone_s.dim a value for the\n factor on mu to obtain the new target\n\n\n\n\n\ncb_suggest_mu!(self::CBUQPSumModelBlock, qp_dx::CBMatrix, qp_dy::CBMatrix, rhs_residual::CBMatrix)\n\nget this from all subblocks\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_sum","page":"Reference of C++ interface","title":"ConicBundle.cb_sum","text":"cb_sum(A::CBMatrix)\n\nreturns the sum over all elements of A, i.e., (1 1 ... 1)A(1 1 ... 1)^T\n\n\n\n\n\ncb_sum(A::CBIndexmatrix)\n\nreturns the sum over all elements of A, i.e., (1 1 ... 1)A(1 1 ... 1)^T\n\n\n\n\n\ncb_sum(A::CBSparsemat)\n\nreturns the sum over all elements of A, i.e., (1 1 ... 1)A(1 1 ... 1)^T\n\n\n\n\n\ncb_sum(A::CBSymmatrix)\n\nreturns the sum over all elements of A, i.e., (1 1 ... 1)A(1 1 ... 1)^T\n\n\n\n\n\ncb_sum(A::CBSparsesym)\n\nreturns the sum over all elements of A, i.e., (1 1 ... 1)A(1 1 ... 1)^T\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_sumbundle_mode!","page":"Reference of C++ interface","title":"ConicBundle.cb_sumbundle_mode!","text":"cb_sumbundle_mode!(self::CBAFTModel, bh::Union{<:CBSumBundleHandler,Nothing} = nothing, aft::Union{<:CBAffineFunctionTransformation,Nothing} = nothing)\n\nsee SumBlockModel::sumbundle_mode\n\n\n\n\n\ncb_sumbundle_mode!(self::CBSumModel, bh::Union{<:CBSumBundleHandler,Nothing} = nothing, aft::Union{<:CBAffineFunctionTransformation,Nothing} = nothing)\n\nsee SumBlockModel::sumbundle_mode\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_sumcols","page":"Reference of C++ interface","title":"ConicBundle.cb_sumcols","text":"cb_sumcols(A::CBMatrix)\n\nreturns a column vector holding the sum over all columns, i.e., A*(1 1 ... 1)^T\n\n\n\n\n\ncb_sumcols(A::CBIndexmatrix)\n\nreturns a column vector holding the sum over all columns, i.e., A*(1 1 ... 1)^T\n\n\n\n\n\ncb_sumcols(A::CBSparsemat)\n\nreturns a column vector holding the sum over all columns, i.e., A*(1 1 ... 1)^T\n\n\n\n\n\ncb_sumcols(A::CBSymmatrix)\n\nreturns a column vector holding the sum over all columns, i.e., A*(1 1 ... 1)^T\n\n\n\n\n\ncb_sumcols(A::CBSparsesym)\n\nreturns a column vector holding the sum over all columns, i.e., A*(1 1 ... 1)^T\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_sumrows","page":"Reference of C++ interface","title":"ConicBundle.cb_sumrows","text":"cb_sumrows(A::CBMatrix)\n\nreturns a row vector holding the sum over all rows, i.e., (1 1 ... 1)*A\n\n\n\n\n\ncb_sumrows(A::CBIndexmatrix)\n\nreturns a row vector holding the sum over all rows, i.e., (1 1 ... 1)*A\n\n\n\n\n\ncb_sumrows(A::CBSparsemat)\n\nreturns a row vector holding the sum over all rows, i.e., (1 1 ... 1)*A\n\n\n\n\n\ncb_sumrows(A::CBSymmatrix)\n\nreturns a row vector holding the sum over all rows, i.e., (1 1 ... 1)*A\n\n\n\n\n\ncb_sumrows(A::CBSparsesym)\n\nreturns a row vector holding the sum over all rows, i.e., (1 1 ... 1)*A\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_support_in","page":"Reference of C++ interface","title":"ConicBundle.cb_support_in","text":"cb_support_in(self::CBCMgramdense, param0::CBSparsesym)\n\nreturns 0 if the support of the costraint matrix is not contained in the support of the sparse symmetric matrix S, 1 if it is contained.\n\n\n\n\n\ncb_support_in(self::CBCMgramsparse, param0::CBSparsesym)\n\nreturns 0 if the support of the costraint matrix is not contained in the support of the sparse symmetric matrix S, 1 if it is contained.\n\n\n\n\n\ncb_support_in(self::CBCMgramsparse_withoutdiag, param0::CBSparsesym)\n\nreturns 0 if the support of the costraint matrix is not contained in the support of the sparse symmetric matrix S, 1 if it is contained.\n\n\n\n\n\ncb_support_in(self::CBCMlowrankdd, param0::CBSparsesym)\n\nreturns 0 if the support of the costraint matrix is not contained in the support of the sparse symmetric matrix S, 1 if it is contained.\n\n\n\n\n\ncb_support_in(self::CBCMlowranksd, param0::CBSparsesym)\n\nreturns 0 if the support of the costraint matrix is not contained in the support of the sparse symmetric matrix S, 1 if it is contained.\n\n\n\n\n\ncb_support_in(self::CBCMlowrankss, param0::CBSparsesym)\n\nreturns 0 if the support of the costraint matrix is not contained in the support of the sparse symmetric matrix S, 1 if it is contained.\n\n\n\n\n\ncb_support_in(self::CBCMsingleton, S::CBSparsesym)\n\nreturns 0 if the support of the costraint matrix is not contained in the support of the sparse symmetric matrix S, 1 if it is contained.\n\n\n\n\n\ncb_support_in(self::CBCMsymdense, param0::CBSparsesym)\n\nreturns 0 if the support of the costraint matrix is not contained in the support of the sparse symmetric matrix S, 1 if it is contained.\n\n\n\n\n\ncb_support_in(self::CBCMsymsparse, S::CBSparsesym)\n\nreturns 0 if the support of the costraint matrix is not contained in the support of the sparse symmetric matrix S, 1 if it is contained.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_support_rankadd","page":"Reference of C++ interface","title":"ConicBundle.cb_support_rankadd","text":"cb_support_rankadd(A::CBMatrix, C::CBSparsesym, alpha::Real, beta::Real, trans::Integer)\n\nreturns C=betaC+alphaAA^T (or A^TA), but only on the current support of C\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_support_xbpeya!","page":"Reference of C++ interface","title":"ConicBundle.cb_support_xbpeya!","text":"cb_support_xbpeya!(self::CBSparsesym, y::CBSparsesym, alpha::Real = 1., beta::Real = 0.)\n\nreturns this= alphay+beta(this) restricted to the curent support of *this; if beta==0, then *this is initialized to 0 on its support first\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_supports_dense_variable_metric","page":"Reference of C++ interface","title":"ConicBundle.cb_supports_dense_variable_metric","text":"cb_supports_dense_variable_metric(self::CBBundleDenseTrustRegionProx)\n\nreturns true if dynamic scaling with dense symmetric matrices is supported\n\n\n\n\n\ncb_supports_dense_variable_metric(self::CBBundleDLRTrustRegionProx)\n\nreturns true if variable metric with dense symmetric matrices is supported\n\n\n\n\n\ncb_supports_dense_variable_metric(self::CBBundleLowRankTrustRegionProx)\n\nreturns true if dynamic scaling with dense symmetric matrices is supported\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_supports_diagonal_bounds_scaling","page":"Reference of C++ interface","title":"ConicBundle.cb_supports_diagonal_bounds_scaling","text":"cb_supports_diagonal_bounds_scaling(self::CBBundleDenseTrustRegionProx)\n\n@brief this implementation does not support a diagonal scaling heuristic,       therefore the following routine has to return true.\n\n\n\n\n\ncb_supports_diagonal_bounds_scaling(self::CBBundleDiagonalTrustRegionProx)\n\n@brief this implementation supports a diagonal scaling heuristic for       bounds in the groundset, therefore the following routine has to return true.\n\n\n\n\n\ncb_supports_diagonal_bounds_scaling(self::CBBundleDLRTrustRegionProx)\n\n@brief this implementation does not support a diagonal scaling heuristic,       therefore the following routine has to return true.\n\n\n\n\n\ncb_supports_diagonal_bounds_scaling(self::CBBundleLowRankTrustRegionProx)\n\n@brief this implementation does not support a diagonal scaling heuristic,       therefore the following routine has to return true.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_supports_diagonal_variable_metric","page":"Reference of C++ interface","title":"ConicBundle.cb_supports_diagonal_variable_metric","text":"cb_supports_diagonal_variable_metric(self::CBBundleDenseTrustRegionProx)\n\nreturns true if dynamic scaling with diagonal matrices is supported\n\n\n\n\n\ncb_supports_diagonal_variable_metric(self::CBBundleDiagonalTrustRegionProx)\n\nreturns true if dynamic scaling with diagonal matrices is supported\n\n\n\n\n\ncb_supports_diagonal_variable_metric(self::CBBundleDLRTrustRegionProx)\n\nreturns true if variable metric with diagonal matrices is supported\n\n\n\n\n\ncb_supports_diagonal_variable_metric(self::CBBundleLowRankTrustRegionProx)\n\nreturns true if dynamic scaling with diagonal matrices is supported\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_supports_lowrank_variable_metric","page":"Reference of C++ interface","title":"ConicBundle.cb_supports_lowrank_variable_metric","text":"cb_supports_lowrank_variable_metric(self::CBBundleDenseTrustRegionProx)\n\nreturns true if dynamic scaling with low rank structure is supported\n\n\n\n\n\ncb_supports_lowrank_variable_metric(self::CBBundleDiagonalTrustRegionProx)\n\nreturns true if dynamic scaling with low rank matrices is supported\n\n\n\n\n\ncb_supports_lowrank_variable_metric(self::CBBundleDLRTrustRegionProx)\n\nreturns true if variable metric with low rank structure is supported\n\n\n\n\n\ncb_supports_lowrank_variable_metric(self::CBBundleLowRankTrustRegionProx)\n\nreturns true if dynamic scaling with low rank structure is supported\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_svec","page":"Reference of C++ interface","title":"ConicBundle.cb_svec","text":"cb_svec(A::CBSymmatrix, v::CBMatrix, a::Real, add::Bool, startindex_vec::Integer, startindex_A::Integer, blockdim::Integer)\n\nthe symmetric vec operator stacks the lower triangle of A to a n*(n+1)/2 vector with the same norm2 as A; here it sets svec(A)=[a11,sqrt(2)a12,...,sqrt(2)a1n,a22,...,sqrt(2)a(n-1,n),ann]', multiplies it by a and sets or adds (if add==true) it to v starting from startindexvec possibly restricted to the subblock of order blockdim (whenever >=0, else blockdim is set to A.rowdim()-startindexA) starting from startindexA (must be >=0); if add==false and startindexvec<0 then vec is also reinitialzed to the appropriate size\n\n\n\n\n\ncb_svec(A::CBSymmatrix)\n\nthe symmetric vec operator, stacks the lower triangle of A to a n*(n+1)/2 vector with the same norm2 as A; i.e., it returns svec(A)=[a11,sqrt(2)a12,...,sqrt(2)a1n,a22,...,sqrt(2)a(n-1,n),ann]'\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_svec_projection!","page":"Reference of C++ interface","title":"ConicBundle.cb_svec_projection!","text":"cb_svec_projection!(self::CBPSCAffineFunction, svec_offset::CBMatrix, svec_coeffs::CBMatrix, P::CBMatrix, index_subset::Union{<:CBIndexmatrix,Nothing} = nothing)\n\nsee PSCOracle::svec_projection()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_sveci","page":"Reference of C++ interface","title":"ConicBundle.cb_sveci","text":"cb_sveci(v::CBMatrix, A::CBSymmatrix, a::Real, add::Bool, startindex_vec::Integer, startindex_A::Integer, blockdim::Integer)\n\nthe inverse operator to svec, extracts from v at startindexvec (>=0) the symmetric matrix of blockdim adding its mutliple by a into A starting at startindexA; if add==false and startindexA<0 A is initialized to the size of blockdim; if the latter is also negative then v.dim()-startindexvec must match an exact order and  matrix A is initialized to this size. In all other cases the size of the symmetric matrix determines the missing parameters and vec.dim-startindex_vec\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_swap","page":"Reference of C++ interface","title":"ConicBundle.cb_swap","text":"cb_swap(A::CBMatrix, B::CBMatrix)\n\nswap the content of the two matrices A and B (involves no copying)\n\n\n\n\n\ncb_swap(A::CBIndexmatrix, B::CBIndexmatrix)\n\nswap the content of the two matrices A and B (involves no copying)\n\n\n\n\n\ncb_swap(A::CBSparsemat, B::CBSparsemat)\n\nswap the content of the two sparse matrices A and B (involves no copying)\n\n\n\n\n\ncb_swap(A::CBSymmatrix, B::CBSymmatrix)\n\nswap the content of the two matrices A and B (involves no copying)\n\n\n\n\n\ncb_swap(A::CBSparsesym, B::CBSparsesym)\n\nswap the content of the two sparse matrices A and B (involves no copying)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_swap_colsij!","page":"Reference of C++ interface","title":"ConicBundle.cb_swap_colsij!","text":"cb_swap_colsij!(self::CBMatrix, i::Integer, j::Integer)\n\ncolumn i of this matrix is swapped with column j\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_swap_rowsij!","page":"Reference of C++ interface","title":"ConicBundle.cb_swap_rowsij!","text":"cb_swap_rowsij!(self::CBMatrix, i::Integer, j::Integer)\n\nrow i of this matrix is swapped with row j\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_swapij!","page":"Reference of C++ interface","title":"ConicBundle.cb_swapij!","text":"cb_swapij!(self::CBSymmatrix, i::Integer, j::Integer)\n\nswaps rows (and columns) i and j\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_symscale","page":"Reference of C++ interface","title":"ConicBundle.cb_symscale","text":"cb_symscale(A::CBSymmatrix, B::CBMatrix, S::CBSymmatrix, a::Real, b::Real, btrans::Integer)\n\nsets S=betaS+alphaB'AB for symmatrix A and matrix B\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_synchronize_ids!","page":"Reference of C++ interface","title":"ConicBundle.cb_synchronize_ids!","text":"cb_synchronize_ids!(self::CBMinorantPointer, new_modification_id::Integer, new_center_id::Integer, old_center_id::Integer, new_cand_id::Integer, old_cand_id::Integer, new_prex_id::Integer = 0)\n\nif not empty it sets the modification_id to its new id and reinitializes the evaluation map\n\n\n\n\n\ncb_synchronize_ids!(self::CBMinorantUseData, new_modification_id::Integer, new_center_id::Integer, old_center_id::Integer, new_cand_id::Integer, old_cand_id::Integer, new_prex_id::Integer)\n\nsets the modification_id to its new id and reinitializes the evaluation map\n\n\n\n\n\ncb_synchronize_ids!(self::CBAFTData, new_center_id::Integer, old_center_id::Integer, new_cand_id::Integer, old_cand_id::Integer, new_prex_id::Integer = 0)\n\nsynchronize ids in any case by discarding inconsistent parts but return number of errors\n\n\n\n\n\ncb_synchronize_ids!(self::CBBoxData, new_center_id::Integer, old_center_id::Integer, new_cand_id::Integer, old_cand_id::Integer, new_prex_id::Integer = 0)\n\nsynchronize ids in any case by discarding inconsistent parts but return number of errors\n\n\n\n\n\ncb_synchronize_ids!(self::CBNNCData, new_center_id::Integer, old_center_id::Integer, new_cand_id::Integer, old_cand_id::Integer, new_prex_id::Integer = 0)\n\nsynchronize ids in any case by discarding inconsistent parts but return number of errors\n\n\n\n\n\ncb_synchronize_ids!(self::CBPSCData, new_center_id::Integer, old_center_id::Integer, new_cand_id::Integer, old_cand_id::Integer, new_prex_id::Integer = 0)\n\nsynchronize ids in any case by discarding inconsistent parts but return number of errors\n\n\n\n\n\ncb_synchronize_ids!(self::CBSOCData, new_center_id::Integer, old_center_id::Integer, new_cand_id::Integer, old_cand_id::Integer, new_prex_id::Integer = 0)\n\nsynchronize ids in any case by discarding inconsistent parts but return number of errors\n\n\n\n\n\ncb_synchronize_ids!(self::CBAFTModel, new_center_id::Integer, old_center_id::Integer, new_cand_id::Integer, old_cand_id::Integer)\n\nsee BundleModel::synchronize_ids\n\n\n\n\n\ncb_synchronize_ids!(self::CBSumModel, new_center_id::Integer, old_center_id::Integer, new_cand_id::Integer, old_cand_id::Integer)\n\nsee BundleModel::synchronize_ids\n\n\n\n\n\ncb_synchronize_ids!(self::CBSumBundle, new_modification_id::Integer, new_center_id::Integer, old_center_id::Integer, new_cand_id::Integer, old_cand_id::Integer, new_prex_id::Integer = 0)\n\nsets the modification_id to id\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_termination_code-Tuple{ConicBundle.CBMatrixCBSolver}","page":"Reference of C++ interface","title":"ConicBundle.cb_termination_code","text":"cb_termination_code(self::CBMatrixCBSolver)\n\n@brief Returns the termination code of the bundle algorithm for the latest descent step\nFor resetting all counters relevant for termination see clear_fail_counts() .\n\n@return\n-  0  :    Not terminated.\n       (Continue with the next solve())\n-  1  :    Relative precision criterion satisfied. (See set_term_relprec())\n-  2  :    Timelimit exceeded.\n       (Currently the C interface does not offer a timelimit.)\n-  4  :    Maximum number of function reevaluations exceeded.\n       (Indicates that there is a problem with one of the function\n       oracles that seems to deliver no valid upper bounds on the true\n       function value for descent steps)\n-  8  :    Maximum number of quadratic subproblem failures exceeded.\n       (Indicates that the numerical limits of the inner quadratic\n       programming solver are reached, no further progress expected)\n- 16  :    maximum number of model evaluation failures exceeded\n       (Indicates that the numerical limits of the setup of the\n       subproblem are reached, no further progress expected)\n- 32  :    maximum number of failures to increase the augmented model value exceeded\n       (Indicates that the numerical limits  of the interplay between\n       subproblem and quadratic programming solver are reached,\n       no further progress expected)\n - 64  :   maximum number of oracle calls (function evaluations) exceeded,\n           see set_eval_limit()\n - 128  :   maximum number of oracle failures exceeded.\n       This refers to function evaluations that terminate with insufficient\n precision but still provide a new approximate subgradient. A failure typically\n       indicates numerical difficulties with the precision requirements.\n       (Currently the interface does not allow to manipulate the limit, it is set to 10)\n\n\n\n\n\n","category":"method"},{"location":"cppref.html#ConicBundle.cb_time","page":"Reference of C++ interface","title":"ConicBundle.cb_time","text":"cb_time(self::CBClock)\n\nreturn time elapsed since last call to start() in Microseconds (possibly adding an optional offset)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_times_B!","page":"Reference of C++ interface","title":"ConicBundle.cb_times_B!","text":"cb_times_B!(self::CBQPConeModelBlock, A::CBMatrix, C::CBMatrix, alpha::Real, beta::Real, Atrans::Integer, Btrans::Integer, startindex_model::Integer, globalbundle::CBMinorantBundle, startindex_bundle::Integer)\n\nC=betaC+alphaA*B where A and B may be transposed; carry out the model part of this beginning at startindex_model\n\n\n\n\n\ncb_times_B!(self::CBQPSumModelBlock, A::CBMatrix, C::CBMatrix, alpha::Real, beta::Real, Atrans::Integer, Btrans::Integer, startindex_model::Integer, globalbundle::CBMinorantBundle, startindex_bundle::Integer)\n\nC=betaC+alphaA*B where A and B may be transposed; carry out the model part of this beginning at startindex_model\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_times_Q","page":"Reference of C++ interface","title":"ConicBundle.cb_times_Q","text":"cb_times_Q(self::CBMatrix, A::CBMatrix, r::Integer)\n\ncomputes A=AQ, assuming a housholder Q is coded in the first r columns of the lower triangle of (this); it always returns 0\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_to_dim","page":"Reference of C++ interface","title":"ConicBundle.cb_to_dim","text":"cb_to_dim(self::CBAffineFunctionTransformation)\n\nreturns the dimension of the output argument or -1 if it is unknown\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_trace","page":"Reference of C++ interface","title":"ConicBundle.cb_trace","text":"cb_trace(A::CBMatrix)\n\nreturns the sum of the diagonal elements A(i,i) over all i\n\n\n\n\n\ncb_trace(A::CBIndexmatrix)\n\nreturns the sum of the diagonal elements A(i,i) over all i\n\n\n\n\n\ncb_trace(A::CBSparsemat)\n\nreturns the sum of the diagonal elements A(i,i) over all i\n\n\n\n\n\ncb_trace(A::CBSymmatrix)\n\nreturns the sum of the diagonal elements A(i,i) over all i\n\n\n\n\n\ncb_trace(A::CBSparsesym)\n\nreturns the sum of the diagonal elements A(i,i) over all i\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_tracedual","page":"Reference of C++ interface","title":"ConicBundle.cb_tracedual","text":"cb_tracedual(self::CBQPConeModelBlock, prec::Union{<:AbstractVector{Cdouble},Nothing} = nothing)\n\nreturn the value of the dual variable to the trace consrat == support function value\n\n\n\n\n\ncb_tracedual(self::CBUQPConeModelBlock, prec::Union{<:AbstractVector{Cdouble},Nothing} = nothing)\n\nreturn the value of the dual variable to the trace consrat == support function value\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_transform_argument","page":"Reference of C++ interface","title":"ConicBundle.cb_transform_argument","text":"cb_transform_argument(self::CBAffineFunctionTransformation, transformed_y::CBMatrix, input_y::CBMatrix)\n\n@brief computes @a transformedoffset and, if @a this is not the identity,@a transformedy and returns either @a inputy (id) or @a transformedy\nOn input @a transformedy is supposed to be of dimension zero, unless it was already the result of a previous transformation for exactly this AFT with this data (no intermediate modifications). This is important, because if @a transformedy has the correct size, only the data changed by the transformation is overwritten and the constant parts are assumed to be already initialized. On output it is again of dimension 0 if the transformation is the identity.\n  The @a transformed_offset = fun_offset+ip(linear_cost,@a input_y) is\n  the value needed in objective_value() together with the result of the\n  evaluation of the function for @a transformed_y in order to compute\n  the transformed objective value.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_transform_minorant","page":"Reference of C++ interface","title":"ConicBundle.cb_transform_minorant","text":"cb_transform_minorant(self::CBAffineFunctionTransformation, out_minorant::CBMinorantPointer, in_minorant::CBMinorantPointer, alpha::Real = 1., add_trafo_minorant::Bool = false, provided_row_indices::Union{<:CBIndexmatrix,Nothing} = nothing, needed_column_indices::Union{<:CBIndexmatrix,Nothing} = nothing)\n\n@brief transforms the in linear minorant (scaled by alpha) and       initializes or adds it to the out linear minorant\n  if out_minorant.empty()==true, the out_minorant is initialized,\n  otherwise the information is added.\n\n  the constant_minorant of the transformation is only added if\n  add_trafo_minorant is set to true.\nIf given, providedrowindices and neededcolumnindices must be as       specified in qpcostindices, i.e. of inminorant only the       providedrowindices (all if NULL) will be used to compute only the       neededcolumnindices (as rows, all if NULL) of outminorant.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_transform_minorants","page":"Reference of C++ interface","title":"ConicBundle.cb_transform_minorants","text":"cb_transform_minorants(self::CBAffineFunctionTransformation, out_minorants::CBMinorantBundle, in_minorants::CBMinorantBundle, alpha::Real = 1.)\n\n@brief transforms several linear minorants (scaled by alpha) and       initializes or adds them to the out linear minorants\n  for out_minorant[i].empty()==true the out_minorant is initialized,\n  otherwise the information is added.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_transpose","page":"Reference of C++ interface","title":"ConicBundle.cb_transpose","text":"cb_transpose(A::CBSymmatrix)\n\n(drop it or use a constructor instead)\n\n\n\n\n\ncb_transpose(A::CBSparsesym)\n\n(drop it or use a constructor instead)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_transpose!","page":"Reference of C++ interface","title":"ConicBundle.cb_transpose!","text":"cb_transpose!(self::CBMatrix)\n\ntransposes itself (cheap for vectors, expensive for matrices)\n\n\n\n\n\ncb_transpose!(self::CBIndexmatrix)\n\ntransposes itself (cheap for vectors, expensive for matrices)\n\n\n\n\n\ncb_transpose!(self::CBSparsemat)\n\ntransposes itself (swaps row and column representations, thus cheap)\n\n\n\n\n\ncb_transpose!(self::CBSymmatrix)\n\ntransposes itself (at almost no cost)\n\n\n\n\n\ncb_transpose!(self::CBSparsesym)\n\ntransposes itself (at almost no cost)\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_tril","page":"Reference of C++ interface","title":"ConicBundle.cb_tril","text":"cb_tril(A::CBMatrix, i::Integer)\n\nretuns a matrix that keeps the lower triangle of A starting with diagonal d, i.e., (i,j)=A(i,j) for 0<=i<row dimension, 0<=j<min(i+d+1,column dimension), and sets (i,j)=0 otherwise\n\n\n\n\n\ncb_tril(A::CBIndexmatrix, d::Integer)\n\nretuns a matrix that keeps the lower triangle of A starting with diagonal d, i.e., (i,j)=A(i,j) for 0<=i<row dimension, 0<=j<min(i+d+1,column dimension), and sets (i,j)=0 otherwise\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_tril!","page":"Reference of C++ interface","title":"ConicBundle.cb_tril!","text":"cb_tril!(self::CBMatrix, d::Integer = 0)\n\nkeeps everything below and including diagonal d, everything above is set to zero, returns *this\n\n\n\n\n\ncb_tril!(self::CBIndexmatrix, d::Integer = 0)\n\nkeeps lower triangle starting with diagonal d; set (*this)(i,j)=0 for 0<=i<row dimension, max(0,i+d)<=j<column dimension, returns *this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_tril_solve!","page":"Reference of C++ interface","title":"ConicBundle.cb_tril_solve!","text":"cb_tril_solve!(self::CBMatrix, rhs::CBMatrix, tol::Real = 1e-10)\n\nsolves (this)x=rhs for x by forward substitution regarding (this) as an upper triangle matrix and stores x in rhs. Returns 0 on success, otherwise i+1 if abs(this)(i,i)<tol and the reduced row of rhs is nonzero.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_triu","page":"Reference of C++ interface","title":"ConicBundle.cb_triu","text":"cb_triu(A::CBMatrix, i::Integer)\n\nretuns a matrix that keeps the upper triangle of A starting with diagonal d, i.e., (i,j)=A(i,j) for 0<=i<row dimension, max(0,i+d)<=j<column dimension, and sets (i,j)=0 otherwise\n\n\n\n\n\ncb_triu(A::CBIndexmatrix, d::Integer)\n\nretuns a matrix that keeps the upper triangle of A starting with diagonal d, i.e., (i,j)=A(i,j) for 0<=i<row dimension, max(0,i+d)<=j<column dimension, and sets (i,j)=0 otherwise\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_triu!","page":"Reference of C++ interface","title":"ConicBundle.cb_triu!","text":"cb_triu!(self::CBMatrix, d::Integer = 0)\n\nkeeps everything above and including diagonal d, everything below is set to zero, returns *this\n\n\n\n\n\ncb_triu!(self::CBIndexmatrix, d::Integer = 0)\n\nkeeps upper triangle starting with diagonal d; set (*this)(i,j)=0 for 0<=i<row dimension, 0<=j<min(i+d,column dimension), returns *this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_triu_solve!","page":"Reference of C++ interface","title":"ConicBundle.cb_triu_solve!","text":"cb_triu_solve!(self::CBMatrix, rhs::CBMatrix, tol::Real = 1e-10)\n\nsolves (this)x=rhs for x by back substitution regarding (this) as an upper triangle matrix and stores x in rhs. Returns 0 on success, otherwise i+1 if abs(this)(i,i)<tol and the remaining row of rhs is nonzero.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_unif_long!","page":"Reference of C++ interface","title":"ConicBundle.cb_unif_long!","text":"cb_unif_long!(self::CBGB_rand, m::Integer)\n\nreturns a random integer number \"uniformly distributed\" in {0,..,m-1}\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_update!","page":"Reference of C++ interface","title":"ConicBundle.cb_update!","text":"cb_update!(self::CBUQPSolver, dQ::CBSymmatrix, dc::CBMatrix, doffset::Real)\n\nresolve the QP for the same feasible set but update the cost terms by the given argumetns first\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_update_QP_costs!","page":"Reference of C++ interface","title":"ConicBundle.cb_update_QP_costs!","text":"cb_update_QP_costs!(self::CBBundleDenseTrustRegionProx, delta_Q::CBSymmatrix, delta_d::CBMatrix, constant_minorant::CBMinorantPointer, bundle::CBMinorantBundle, center_y::CBMatrix, groundset_minorant::CBMinorantPointer, delta_groundset_minorant::CBMinorantPointer, delta_index::CBIndexmatrix, yfixed::Union{<:CBIndexmatrix,Nothing})\n\nupdates the dual QP costs Q, d, and the constant offset to the bundle subproblem, see BundleProxObject::updateQPcosts\n\n\n\n\n\ncb_update_QP_costs!(self::CBBundleDiagonalTrustRegionProx, delta_Q::CBSymmatrix, delta_d::CBMatrix, constant_minorant::CBMinorantPointer, bundle::CBMinorantBundle, center_y::CBMatrix, groundset_minorant::CBMinorantPointer, delta_groundset_minorant::CBMinorantPointer, delta_index::CBIndexmatrix, yfixed::Union{<:CBIndexmatrix,Nothing})\n\nupdates the dual QP costs Q, d, and the constant offset to the bundle subproblem, see BundleProxObject::updateQPcosts\n\n\n\n\n\ncb_update_QP_costs!(self::CBBundleDLRTrustRegionProx, delta_Q::CBSymmatrix, delta_d::CBMatrix, constant_minorant::CBMinorantPointer, bundle::CBMinorantBundle, center_y::CBMatrix, groundset_minorant::CBMinorantPointer, delta_groundset_minorant::CBMinorantPointer, delta_index::CBIndexmatrix, yfixed::Union{<:CBIndexmatrix,Nothing})\n\nupdates the dual QP costs Q, d, and the constant offset to the bundle subproblem, see BundleProxObject::updateQPcosts\n\n\n\n\n\ncb_update_QP_costs!(self::CBBundleIdProx, delta_Q::CBSymmatrix, delta_d::CBMatrix, constant_minorant::CBMinorantPointer, bundle::CBMinorantBundle, center_y::CBMatrix, groundset_minorant::CBMinorantPointer, delta_groundset_minorant::CBMinorantPointer, delta_index::CBIndexmatrix, yfixed::Union{<:CBIndexmatrix,Nothing})\n\nupdates the dual QP costs Q, d, and the constant offset to the bundle subproblem, see BundleProxObject::updateQPcosts\n\n\n\n\n\ncb_update_QP_costs!(self::CBBundleLowRankTrustRegionProx, delta_Q::CBSymmatrix, delta_d::CBMatrix, constant_minorant::CBMinorantPointer, bundle::CBMinorantBundle, center_y::CBMatrix, groundset_minorant::CBMinorantPointer, delta_groundset_minorant::CBMinorantPointer, delta_index::CBIndexmatrix, yfixed::Union{<:CBIndexmatrix,Nothing})\n\nupdates the dual QP costs Q, d, and the constant offset to the bundle subproblem, see BundleProxObject::updateQPcosts\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_update_model!","page":"Reference of C++ interface","title":"ConicBundle.cb_update_model!","text":"cb_update_model!(self::CBAFTModel, model_update::CBModelUpdate, center_id::Integer, center_y::CBMatrix, cand_id::Integer, cand_y::CBMatrix, model_maxviol::Real, H::CBBundleProxObject)\n\nsee BundleModel::update_model\n\n\n\n\n\ncb_update_model!(self::CBSumModel, model_update::CBModelUpdate, center_id::Integer, center_y::CBMatrix, cand_id::Integer, cand_y::CBMatrix, model_maxviol::Real, H::CBBundleProxObject)\n\nsee BundleModel::update_model\n\n\n\n\n\ncb_update_model!(self::CBSumBundleHandler, model_update::CBModelUpdate, center_id::Integer, center_y::CBMatrix, cand_id::Integer, cand_y::CBMatrix, model_maxviol::Real, H::CBBundleProxObject)\n\nupdates the sumbundle maybe even if not active; in this it tries to do the same as bh, storing the aggregate at the same place and providing new room at the same place; the new subgradient is not entered here but in setcandminorant()\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_valid","page":"Reference of C++ interface","title":"ConicBundle.cb_valid","text":"cb_valid(self::CBMinorantPointer)\n\nreturns true if the pointer is not empty and the data is valid\n\n\n\n\n\ncb_valid(self::CBMinorantUseData)\n\ncheck validity recursively\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_variable_modifications","page":"Reference of C++ interface","title":"ConicBundle.cb_variable_modifications","text":"cb_variable_modifications(self::CBPSCAffineModification)\n\nreturns true if some modifications are performed on the block structure\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_wall_time","page":"Reference of C++ interface","title":"ConicBundle.cb_wall_time","text":"cb_wall_time(self::CBClock)\n\nreturns the Microseconds passed on the wall clock sind initialization\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_weight_changed","page":"Reference of C++ interface","title":"ConicBundle.cb_weight_changed","text":"cb_weight_changed(self::CBBundleHKWeight)\n\nreturns true if last call of *_update modified current value of tau, else 0\n\n\n\n\n\ncb_weight_changed(self::CBBundleRQBWeight)\n\nreturns true if last call of *_update modified current value of tau, else 0\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_xbpeya","page":"Reference of C++ interface","title":"ConicBundle.cb_xbpeya","text":"cb_xbpeya(x::CBMatrix, y::CBMatrix, alpha::Real, beta::Real, ytrans::Integer)\n\nreturns x= alphay+betax, where y may be transposed (ytrans=1); if beta==0. then x is initialized to the correct size\n\n\n\n\n\ncb_xbpeya(x::CBIndexmatrix, y::CBIndexmatrix, alpha::Integer, beta::Integer, ytrans::Integer)\n\nreturns x= alphay+betax, where y may be transposed (ytrans=1); if beta==0. then x is initialized to the correct size\n\n\n\n\n\ncb_xbpeya(x::CBSparsemat, y::CBSparsemat, alpha::Real, beta::Real, ytrans::Integer)\n\nreturns x= alphay+betax, where y may be transposed (ytrans=1); if beta==0. then x is initialized to the correct size\n\n\n\n\n\ncb_xbpeya(x::CBSymmatrix, y::CBSymmatrix, alpha::Real, beta::Real)\n\nreturns x= alphay+betax; if beta==0. then x is initialized to the correct size\n\n\n\n\n\ncb_xbpeya(x::CBSparsesym, y::CBSparsesym, alpha::Real, beta::Real)\n\nreturns x= alphay+betax; if beta==0. then x is initialized to the correct size\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_xdim","page":"Reference of C++ interface","title":"ConicBundle.cb_xdim","text":"cb_xdim(self::CBUQPConeModelBlock)\n\ndimension of externally visible primal variables\n\n\n\n\n\ncb_xdim(self::CBUQPSumModelBlock)\n\nsum of all xdim of the sublocks\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_xetriu_yza!","page":"Reference of C++ interface","title":"ConicBundle.cb_xetriu_yza!","text":"cb_xetriu_yza!(self::CBSymmatrix, A::CBMatrix, B::CBMatrix, d::Real = 1.)\n\nsets this(i,j), i<=j to the upper triangle of the matrix product dtranspose(A)*B\n\n\n\n\n\ncb_xetriu_yza!(self::CBSymmatrix, A::CBSparsemat, B::CBMatrix, d::Real = 1.)\n\nsets this(i,j), i<=j to the upper triangle of the matrix product dtranspose(A)*B\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_xeya!","page":"Reference of C++ interface","title":"ConicBundle.cb_xeya!","text":"cb_xeya!(self::CBMatrix, A::CBMatrix, d::Real = 1., atrans::Integer = 0)\n\nsets this=dA where A may be transposed and returns *this\n\n\n\n\n\ncb_xeya!(self::CBMatrix, A::CBIndexmatrix, d::Real = 1.)\n\nsets this=dA and returns *this\n\n\n\n\n\ncb_xeya!(self::CBMatrix, A::CBSymmatrix, d::Real = 1.)\n\nsets this=dA and returns *this\n\n\n\n\n\ncb_xeya!(self::CBMatrix, A::CBSparsesym, d::Real = 1.)\n\nsets this=dA and returns *this\n\n\n\n\n\ncb_xeya!(self::CBMatrix, A::CBSparsemat, d::Real = 1.)\n\nsets this=dA and returns *this\n\n\n\n\n\ncb_xeya!(self::CBIndexmatrix, A::CBIndexmatrix, d::Integer = 1)\n\nsets this=dA and returns *this\n\n\n\n\n\ncb_xeya!(self::CBSparsemat, A::CBSparsemat, d::Real = 1.)\n\nsets this=dA and returns *this\n\n\n\n\n\ncb_xeya!(self::CBSparsemat, A::CBMatrix, d::Real = 1.)\n\nsets this=dA removing abs(values)<tol; returns *this\n\n\n\n\n\ncb_xeya!(self::CBSparsemat, A::CBIndexmatrix, d::Real = 1.)\n\nsets this=dA removing zeros; returns *this\n\n\n\n\n\ncb_xeya!(self::CBSparsemat, A::CBSparsesym, d::Real = 1.)\n\nsets this=Ad, abs(values)<tol are removed from the support, and returns *this,\n\n\n\n\n\ncb_xeya!(self::CBSymmatrix, A::CBSymmatrix, d::Real = 1.)\n\nsets this=dA and returns *this\n\n\n\n\n\ncb_xeya!(self::CBSymmatrix, A::CBMatrix, d::Real = 1.)\n\nsets this=d(A+transpose(A))/2. and returns *this\n\n\n\n\n\ncb_xeya!(self::CBSymmatrix, A::CBIndexmatrix, d::Real = 1.)\n\nsets this=d(A+transpose(A))/2. and returns *this\n\n\n\n\n\ncb_xeya!(self::CBSymmatrix, A::CBSparsesym, d::Real = 1.)\n\nsets this=dA and returns *this\n\n\n\n\n\ncb_xeya!(self::CBSparsesym, A::CBSparsesym, d::Real = 1.)\n\nsets this=dA and returns *this\n\n\n\n\n\ncb_xeya!(self::CBSparsesym, A::CBMatrix, d::Real = 1.)\n\nsets and returns this=d(A+transpose(A))/2. where abs(values)<tol are removed from the support\n\n\n\n\n\ncb_xeya!(self::CBSparsesym, A::CBIndexmatrix, d::Real = 1.)\n\nsets and returns this=d(A+transpose(A))/2. where zeros are removed from the support\n\n\n\n\n\ncb_xeya!(self::CBSparsesym, A::CBSymmatrix, d::Real = 1.)\n\nsets and returns this=Ad where abs(values)<tol are removed from the support\n\n\n\n\n\ncb_xeya!(self::CBSparsesym, A::CBSparsemat, d::Real = 1.)\n\nsets and returns this=d.(A+transpose(A))/2.\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_xeyapzb","page":"Reference of C++ interface","title":"ConicBundle.cb_xeyapzb","text":"cb_xeyapzb(x::CBMatrix, y::CBMatrix, z::CBMatrix, alpha::Real, beta::Real)\n\nreturns x= alphay+betaz; x is initialized to the correct size\n\n\n\n\n\ncb_xeyapzb(x::CBIndexmatrix, y::CBIndexmatrix, z::CBIndexmatrix, alpha::Integer, beta::Integer)\n\nreturns x= alphay+betaz; x is initialized to the correct size, see CHMatrixClasses::xeyapzb() for default values of alpha and beta.\n\n\n\n\n\ncb_xeyapzb(x::CBSymmatrix, y::CBSymmatrix, z::CBSymmatrix, alpha::Real, beta::Real)\n\nreturns x= alphay+betaz; x is initialized to the correct size\n\n\n\n\n\ncb_xeyapzb(x::CBSparsesym, y::CBSparsesym, z::CBSparsesym, alpha::Real, beta::Real)\n\nreturns x= alphay+betaz; x is initialized to the correct size\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_xpetriu_yza!","page":"Reference of C++ interface","title":"ConicBundle.cb_xpetriu_yza!","text":"cb_xpetriu_yza!(self::CBSymmatrix, A::CBMatrix, B::CBMatrix, d::Real = 1.)\n\nadds to this(i,j), i<=j the upper triangle of the matrix product dtranspose(A)*B\n\n\n\n\n\ncb_xpetriu_yza!(self::CBSymmatrix, A::CBSparsemat, B::CBMatrix, d::Real = 1.)\n\nadds to this(i,j), i<=j the upper triangle of the matrix product dtranspose(A)*B\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_xpeya!","page":"Reference of C++ interface","title":"ConicBundle.cb_xpeya!","text":"cb_xpeya!(self::CBMatrix, A::CBMatrix, d::Real = 1.)\n\nsets this+=dA and returns *this\n\n\n\n\n\ncb_xpeya!(self::CBMatrix, A::CBIndexmatrix, d::Real = 1.)\n\nsets this+=dA and returns *this\n\n\n\n\n\ncb_xpeya!(self::CBMatrix, A::CBSymmatrix, d::Real = 1.)\n\nsets this+=dA and returns *this\n\n\n\n\n\ncb_xpeya!(self::CBMatrix, A::CBSparsesym, d::Real = 1.)\n\nsets this+=dA and returns *this\n\n\n\n\n\ncb_xpeya!(self::CBMatrix, A::CBSparsemat, d::Real = 1.)\n\nsets this+=dA and returns *this\n\n\n\n\n\ncb_xpeya!(self::CBIndexmatrix, A::CBIndexmatrix, d::Integer = 1)\n\nsets this+=dA and returns *this\n\n\n\n\n\ncb_xpeya!(self::CBSymmatrix, A::CBSymmatrix, d::Real = 1.)\n\nsets this+=dA and returns *this\n\n\n\n\n\ncb_xpeya!(self::CBSymmatrix, A::CBMatrix, d::Real = 1.)\n\nsets this+=d(A+transpose(A))/2. and returns *this\n\n\n\n\n\ncb_xpeya!(self::CBSymmatrix, A::CBIndexmatrix, d::Real = 1.)\n\nsets this+=d(A+transpose(A))/2. and returns *this\n\n\n\n\n\ncb_xpeya!(self::CBSymmatrix, A::CBSparsesym, d::Real = 1.)\n\nsets this+=dA and returns *this\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_ydim","page":"Reference of C++ interface","title":"ConicBundle.cb_ydim","text":"cb_ydim(self::CBUQPConeModelBlock)\n\ndimension of externally visible dual variables\n\n\n\n\n\ncb_ydim(self::CBUQPSumModelBlock)\n\nsum of all ydim of the sublocks\n\n\n\n\n\n","category":"function"},{"location":"cppref.html#ConicBundle.cb_zero","page":"Reference of C++ interface","title":"ConicBundle.cb_zero","text":"cb_zero(self::CBMinorantPointer)\n\nreturns true if the pointer is not empty but all entrys (also the offset) are zero\n\n\n\n\n\n","category":"function"},{"location":"cref.html","page":"Reference of C interface","title":"Reference of C interface","text":"CurrentModule = ConicBundle","category":"page"},{"location":"cref.html#Reference-of-C-interface","page":"Reference of C interface","title":"Reference of C interface","text":"","category":"section"},{"location":"cref.html","page":"Reference of C interface","title":"Reference of C interface","text":"The C interface is manually ported to Julia. In particular, the comments were curated and some logical coding choices were made. This is a good interface. Some of the functions will also be available in the C++ interface; but do not mix them with objects created by the C interface.","category":"page"},{"location":"cref.html","page":"Reference of C interface","title":"Reference of C interface","text":"CBProblem\ncb_clear!(::CBProblem)\ncb_set_default!(::CBProblem)\ncb_init_problem!(::CBProblem, ::Integer)\nCBFunction\nCBSubgExt\nCBFunctionTask\ncb_add_function!(::CBProblem{T}, ::T, ::Function, ::Nothing) where {T}\ncb_set_lower_bound!(::CBProblem, ::Integer, ::Float64)\ncb_set_upper_bound!(::CBProblem, ::Integer, ::Float64)\ncb_append_variables!(::CBProblem, ::Integer)\ncb_delete_variables!(::CBProblem, ::Vector{Cint})\ncb_reassign_variables!(::CBProblem, ::Vector{Cint})\ncb_solve!(::CBProblem, ::Integer, ::Bool)\nCBTerminationCode\ncb_termination_code(::CBProblem)\ncb_print_termination_code(::CBProblem)\ncb_get_objval(::CBProblem)\ncb_get_center(::CBProblem)\ncb_get_center!(::Vector{Float64}, ::CBProblem)\ncb_get_sgnorm(::CBProblem)\ncb_get_subgradient(::CBProblem)\ncb_get_subgradient!(::Vector{Float64}, ::CBProblem)\ncb_get_candidate_value(::CBProblem)\ncb_get_candidate(::CBProblem)\ncb_get_candidate!(::Vector{Float64}, ::CBProblem)\ncb_set_term_relprec!(::CBProblem, ::Float64)\ncb_set_new_center_point!(::CBProblem, ::Vector{Float64})\ncb_get_function_status(::CBProblem{T}, ::T) where {T}\ncb_get_approximate_slacks(::CBProblem)\ncb_get_approximate_slacks!(::Vector{Float64}, ::CBProblem)\ncb_get_approximate_primal!(::Vector{Float64}, ::CBProblem{T}, ::T) where {T}\ncb_get_center_primal!(::Vector{Float64}, ::CBProblem{T}, ::T) where {T}\ncb_get_candidate_primal!(::Vector{Float64}, ::CBProblem{T}, ::T) where {T}\ncb_set_max_modelsize!(::CBProblem{T}, ::T, ::Integer) where {T}\ncb_set_max_bundlesize!(::CBProblem{T}, ::T, ::Integer) where {T}\ncb_set_max_new_subgradients!(::CBProblem{T}, ::T, ::Integer) where {T}\ncb_get_bundle_parameters(::CBProblem{T}, ::T) where {T}\ncb_reinit_function_model!(::CBProblem{T}, ::T) where {T}\ncb_get_last_weight(::CBProblem)\ncb_set_next_weight!(::CBProblem, ::Float64)\ncb_set_min_weight!(::CBProblem, ::Float64)\ncb_set_max_weight!(::CBProblem, ::Float64)\nCBVariableMetric\ncb_set_variable_metric!(::CBProblem, ::CBVariableMetric)\ncb_get_dim(::CBProblem)\ncb_get_n_functions(::CBProblem)\ncb_get_minus_infinity\ncb_get_plus_infinity\ncb_clear_fail_counts!(::CBProblem)\ncb_set_eval_limit!(::CBProblem, ::Integer)\ncb_set_inner_update_limit!(::CBProblem, ::Integer)\ncb_set_active_bounds_fixing!(::CBProblem, ::Bool)\ncb_get_fixed_active_bounds(::CBProblem)\ncb_get_fixed_active_bounds!(::CBProblem, ::Vector{Cint})\ncb_set_print_level!(::CBProblem, ::Integer)\ncb_minus_infinity\ncb_plus_infinity","category":"page"},{"location":"cref.html#ConicBundle.CBProblem","page":"Reference of C interface","title":"ConicBundle.CBProblem","text":"CBProblem{T}(no_bundle::Bool=false)\nCBProblem(no_bundle::Bool=false)\n\nCreates a a new problem object and returns a pointer to it.\n\nArguments:\n\nT\ntype of the function keys (Any if omitted)\nno_bundle::Bool\nif true, then the minimal bundle consisting of just one new and one aggregate gradient is used so that there is no real bundle available and bundle size options are then meaningless.\n\n\n\n\n\n","category":"type"},{"location":"cref.html#ConicBundle.cb_clear!-Tuple{ConicBundle.CBProblem}","page":"Reference of C interface","title":"ConicBundle.cb_clear!","text":"cb_clear!(p::CBProblem)\n\nClears all data structures and problem information but keeps ouptut settings and algorithmic parameter settings.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_set_default!-Tuple{ConicBundle.CBProblem}","page":"Reference of C interface","title":"ConicBundle.cb_set_default!","text":"cb_set_default!(p::CBProblem)\n\nSets default values for algorithmic parameters that are not function specific (e.g., relative precision, weight and weight bounds for the augmented problem, etc.)\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_init_problem!-Tuple{ConicBundle.CBProblem, Integer}","page":"Reference of C interface","title":"ConicBundle.cb_init_problem!","text":"cb_init_problem!(p::CBProblem, m::Integer; lowerb=nothing, upperb=nothing)\n\nInitializes the problem by setting the design space (the dimension and possible box constraints of the variables)\n\nClears all data structures and sets the dimension m for a new problem. for solving min_y in mathbb R^m  f_0(y) + f_1(y) +  Box constraints may be specified for y, the functions f_i must be added by   cb_add_function!.\n\nLower and/or upper bounds must be specified for all variables or for none of them. To specify no bounds at all, give nothing. Otherwise use cb_get_minus_infinity for unbounded below and cb_get_plus_infinity for unbounded above. For nothing, unbounded will be used as default for all variables. Specifying bounds selectively is also possible by cb_set_lower_bound! or cb_set_upper_bound!.\n\nArguments:\n\np::CBProblem\nthe current problem\nm::Integer\nthe dimension of the argument/design space/the number of Lagrange multipliers\nlowerb::Union{Vector{Float64},Nothing} (either double array of length m or nothing)\nIf nothing, all variables are considered unbounded below, otherwise lowerb[i] gives the minimum feasible value for variable y[i], use cb_get_minus_infinity for unbounded below.\nupperb::Union{Vector{Float64},Nothing} (either double array of length m or nothing)\nIf nothing, all variables are considered unbounded above, otherwise upperb[i] gives the maximum feasible value for variable y[i], use cb_get_plus_infinity for unbounded above.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.CBFunction","page":"Reference of C interface","title":"ConicBundle.CBFunction","text":"CBFunction{T}(callback, m, n)\n\nfunction oracle; describe your function as a function of this type to pass it to the solver\n\nThe oracle interface is used to describe a convex function. The dimension of the argument vector of the function must be set in cb_init_problem!, let it be m in the following.\n\nIf the sum of several such functions is to be minimized, it is the task of the user to guarantee that all dimensions match.\n\nIn many applications, computing the function value is an iterative process that approaches the true function value from below. The code offers a bound for the function value, above which it is certain that the code will reject the current point. If in the iterative process a lower bound on the function value exceeds this bound, then it is sufficient to return, instead of the true function value and a subgradient, the current lower bound and a vector so that together they describe a supporting hyperplane (an epsilon subgradient, lying completely below the function) to the function at this point.\n\nIf the function corresponds to Lagrangean relaxation of a primal maximization problem one may want to generate a primal approximate solution. In this case, set in cb_add_function! the desired primal dimension. Then the solver will provide memory in primal for returning in the function the generating primal vectors for each subgradient. If the primal dimension is set to zero, primal will be nothing and no aggregation takes place.\n\nIf primal aggregation is used then it is possible to implement a primal cutting plane framework. This requires the introduction of new (dual) variables in the design space of the function. In this case a function of signature CBSubgExt should be provided for filling in the missing coordinates in existing subgradients. This function need not be specified even if constraints are added, but then the cutting model of the objective is lost at each addition of constraints.\n\nArguments of the callback:\n\nfunction_key::T\nsupplied by the user on entering the function. May be useful if multiple copies of the same function are used with parameters\narg::Vector{Float64} (double array of length m)\nargument of the function (e.g. the Lagrange multipliers)\nrelprec::Float64\nrelative precision requirement for objective values that may lead to descent steps (this precision is not required if it is already certain that the function value will be too poor)\nmax_subg::Cint\nat most max_subg epsilon-subgradients and subg_values may be returned, but at least one must be returned!\nobjective_threshold::Float64\nvalue gives the threshold for a null step; you may stop, if a cutting plane yields at least this;\nsubg_values::Vector{Float64} (caller-allocated, length max_subg)\nstore for each epsilon subgradient the value at the argument\nsubgradients::Matrix{Float64} (caller-allocated, size (m, max_subg))\nsubgradients[i, j] = coefficient of subgradient j at y-coordinate i\nprimal::Union{Matrix{Float64},Nothing} (caller-allocated, size (n, max_subg) or nothing)\nIf the function arises from Lagrangean relaxation and a primal approximation is desired then set the primal dimension in cb_add_function! and return the primal solutions corresponding to the eps-subgradients in the array pointed to by primal.\n\nCallback must return a tuple:\n\nupper bound on the true function value within mathrmrelprec*(operatornameabs(mathrmobjval)+1), if there is no hyperplane cutting above the threshold specified in objective_value on input. Otherwise the max of subg_values.\nthe number of epsilon-subgradients returned. Termination is forced if no new subgradient is returned.\n\n\n\n\n\n","category":"type"},{"location":"cref.html#ConicBundle.CBSubgExt","page":"Reference of C interface","title":"ConicBundle.CBSubgExt","text":"CBSubgExt{T}(callback, n)\n\nThis routine is not needed unless variables (constraints in Lagrangean relaxation) are added on the fly.\n\nThe solver calls this routine whenever new variables have been added on the fly in order to extend old subgradients to the new coordinates. If primal data was supplied for the subgradients then generating_primal holds a pointer to this (possibly aggregated) data, otherwise it is nothing.\n\nIn the presence of primal data, the new coordinates correspond to the violation of the new primal constraints. These have to be returned in the array new_subgradient_values; more precisely, for i=1 to n_indices the element new_subgradient_values[i] has to hold the subgradient information of constraint variable_indices[i];\n\nIf generating_primal is nothing, then the routine can only successfully extend the subgradients, if the new coordinates have no influence on the function; then the new subgradient coordinates are all zero and the components of new_subgradient_values have to be initialized to zero.\n\nIf you do indeed need this, you have to provide one such function with each evaluation function.\n\nArguments of the callback:\n\nfunction_key::T\nsupplied by the user on entering the function. May be useful if multiple copies of the same function are used with parameters\ngenerating_primal::Union{Nothing,Vector{Float64}} (double array of primal length n or nothing) if not nothing it holds the (possibly aggregated) primal solution that generated the subgradient that needs to be extendend\nn_indices::Cint\ngives the number of indices for which the subgradient value has to be computed\nvariable_indices::Vector{Int} (pointer to int array of length n_indices)\nfor the y variables with indices variable_indices[i], i=1,..,n_indices the subgradient coefficient has to be computed\nnew_subgradient_values::Vector{Float64} (caller-allocated, pointer to double array of length n_indices)\nstore the the subgradient coefficient of y variable with index variable_indices[i] at new_subgradient_values[i] for i=1,..,n_indices\n\nCallback must return 0 on success or 1 if extension is impossible\n\n\n\n\n\n","category":"type"},{"location":"cref.html#ConicBundle.CBFunctionTask","page":"Reference of C interface","title":"ConicBundle.CBFunctionTask","text":"enum CBFunctionTask\n\ncbft_objective_function\ncbft_constant_penalty_function\ncbft_adaptive_penalty_function\n\n\n\n\n\n","category":"type"},{"location":"cref.html#ConicBundle.cb_add_function!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Function, Nothing}} where T","page":"Reference of C interface","title":"ConicBundle.cb_add_function!","text":"cb_add_function!(p::CBProblem{T}, function_key::T, f::Function, se::Union{Function,Nothing}=nothing; primaldim::Integer=0,\n    fun_factor::Float64=1., fun_task::CBFunctionTask=cbft_objective_function,\n    aft::Union{CBAffineFunctionTransformation,Nothing}=nothing)\n\nAdds the function, the sum of which should be minimized, to the problem description.\n\nEach function added must be given a unique function_key, f supplies the evaluation function and must not be zero, se can be used to specify a routine for extending subgradients, but it may be nothing. primaldim can be used if an approximate primal solution should  be aggregated (In this case storage will be supplied in the call to the evaluation function for storing for each subgradient the generating primal vector). It may be zero if this is not needed.\n\nArguments:\n\np::CBProblem{T}\nthe problem to which the function should be added\nfunction_key::T\nThe value of the funciton_key must UNIQUELY identify the function, (it may be the address of the function [if unique], or give the address of a struct holding additional user parameters)\nf::Function\nthe function (see CBFunction for parameters)\nse::Union{Function,Nothing}\nThis parameter may be nothing, otherwise the respective function will be called in order to compute coefficients for new subgradient coordinates resulting from added variables. See CBSubgExt for parameters.\nprimaldim::Integer\nMay be zero, otherwise in each call to f enough storage will be provided to store a primal generating vector for each subgradient returned. The primal solutions will be aggregated along with the subgradients. This allows to generate approximate primal optimal solutions, e.g., in Lagrangean relaxation.\nfun_factor::Float64 Allows to specify a scaling factor for the function. fun_factor must be a strictly positive number.\nfun_task::CBFunctionTask Specifies whether the function is to be used as a an ObjectiveFunction, a ConstantPenaltyFunction with fun_factor as maximum penalty factor, or as an AdaptivePenaltyFunction with fun_factor at initial penalty guess that might be increased or decreased over time.\naft::Union{CBAffineFunctionTransformation,Nothing} May be used to modify the argument and give an additional affine term (linear term plus offset). For adding an affine term there are several other possibilities, e.g. in cb_init_problem!, so there is no need to do so here. If, however, an existing function implementation requires only some subset of the variables, it is more convenient to supply a corresponding aft instead of reimplementing the function.\n\nSee also CBFunction, CBFunctionTask, CBAffineFunctionTransformation.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_set_lower_bound!-Tuple{ConicBundle.CBProblem, Integer, Float64}","page":"Reference of C interface","title":"ConicBundle.cb_set_lower_bound!","text":"cb_set_lower_bound!(p::CBProblem, i::Integer, lower_bound::Float64)\n\nset lower bound for variable i, use cb_get_minus_infinity for unbounded from below.\n\nThe algorithm may have to adapt the center point aftwards. In this case the old function values will be marked as outdated and will be recomputed at the next call to e.g. cb_solve!.\n\nArguments:\n\np::CBProblem\nthe problem\ni::Integer\nindex of the variable\nlower_bound::Float64\nvalue of the lower bound on variable i\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_set_upper_bound!-Tuple{ConicBundle.CBProblem, Integer, Float64}","page":"Reference of C interface","title":"ConicBundle.cb_set_upper_bound!","text":"cb_set_upper_bound!(p::CBProblem, i::Integer, lower_bound::Float64)\n\nset upper bound for variable i, use cb_get_plus_infinity for unbounded from below.\n\nThe algorithm may have to adapt the center point aftwards. In this case the old function values will be marked as outdated and will be recomputed at the next call to e.g. cb_solve!.\n\nArguments:\n\np::CBProblem\nthe problem\ni::Integer\nindex of the variable\nlower_bound::Float64\nvalue of the upper bound on variable i\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_append_variables!-Tuple{ConicBundle.CBProblem, Integer}","page":"Reference of C interface","title":"ConicBundle.cb_append_variables!","text":"cb_append_variables!(p::CBProblem, n_append::Integer; lowerb=nothing, upperb=nothing)\n\nAppend new variables (always in last postions in this order).\n\nIf 0 is feasible for the new coordinates then this is selected as starting value for the new coordinates; otherwise, the number closest to zero is used. If all new coordinates can be set to zero then it is assumed that for an existing center point the function values need not be recomputed (this is e.g. the case in Lagrangean relaxation; if this is not correct call cb_reinit_function_model! below). Otherwise the old function values will be marked as outdated and will be recomputed at the next call to e.g. cb_solve!.\n\nBe sure to update your objective functions so that they can handle the new variables before you call this and any further ConicBundle routines that require function evaluations. Also, these operations may lead to inavailability of certain other data such as subgradients and primal approximations.\n\nArguments:\n\np::CBProblem\nthe problem\nn_append::Integer\nnumber of variables to append (always in last position in the same order)\nlower_bound::Union{Vector{Float64},Nothing} (either double array of size n_append or nothing)\nIf nothing, all appended variables are considered unbounded below, otherwise lowerb[i] gives the minimum feasible value for variable y[i], use cb_get_minus_infinity for unbounded below.\nupper_bound::Union{Vector{Float64},Nothing} (either double array of size n_append or nothing)\nIf nothing, all appended variables are considered unbounded above, otherwise upperb[i] gives the maximum feasible value for variable y[i], use cb_get_plus_infinity for unbounded above.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_delete_variables!-Tuple{ConicBundle.CBProblem, Vector{Int32}}","page":"Reference of C interface","title":"ConicBundle.cb_delete_variables!","text":"cb_delete_variables!(p::CBProblem, delete_indices::Vector{Cint})\ncb_delete_variables!(map_to_old::Vector{Cint}, p::CBProblem, delete_indices::Vector{Cint})\n\nDeletes variables corresponding to the specified indices.\n\nThe indices of the remaining variables are reassigned so that they are consecutive again, the routine returns a vector giving for each new index of these remaining variables the old coordinate.\n\nIf all of the deleted variables are zero, function values are assumed to remain correct (if this is not so, call cb_reinit_function_model! below) Otherwise the old function values will be marked as outdated and will be recomputed at the next call to e.g. cb_solve!.\n\nBe sure to update your objective functions so that they can handle the new variables before you call any further ConicBundle routines that require function evaluations. Also, these operations may lead to inavailability of certain other data such as subgradients and primal approximations.\n\nArguments:\n\np::CBProblem\nthe problem\ndelete_indices::Vector{Cint}\nthe entries in delete_indices specify the indices of the variables to be deleted\n\nReturns a Vector{Cint} of length cb_get_dim(p)-length(delete_indices) whose element i contains the old index (before the call) of the variable that now has index position i. Use the three-argument version to avoid allocation.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_reassign_variables!-Tuple{ConicBundle.CBProblem, Vector{Int32}}","page":"Reference of C interface","title":"ConicBundle.cb_reassign_variables!","text":"cb_reassign_variables!(p::CBProblem, assign_new_from_old::Vector{Cint})\n\nReassigns variables to new index positions by mapping to position i the variable that previously had index assign_new_from_old[i].\n\nOld variables, that are not mapped to any position will be deleted. It is allowed to generate several copies of old variables.\n\nIf all of the deleted variables as well as new multiple copies are zero, function values are assumed to remain correct (if this is not so, call cb_reinit_function_model! below). Otherwise the old function values will be marked as outdated and will be recomputed at the next call to e.g. cb_solve!.\n\nBe sure to update your objective functions so that they can handle the new variables before you call any further ConicBundle routines that require function evaluations. Also, these operations may lead to inavailability of certain other data such as subgradients and primal approximations.\n\nArguments:\n\np::CBProblem\nthe problem\nassign_new_from_old::Vector{Cint}\nentry assign_new_from_old[i] specifies the old index of the variable, that has to be copied to index position i.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_solve!-Tuple{ConicBundle.CBProblem, Integer, Bool}","page":"Reference of C interface","title":"ConicBundle.cb_solve!","text":"cb_solve!(p::CBProblem, maxsteps::Integer=0, stop_at_descent_steps::Bool=false)\n\nBundle methods solve a problem by a sequence of so called descent steps that actually bring progress by moving from the current \"center point\" to a new center with better objective. A descent step may consist of several function evaluations (null steps), that lead to no immediate progress but mainly improve a cutting model of the objective function close to the current center point. A minimizer to the model is accepted as descent step if the function value at this point satisfies a sufficient decrease criterion in comparison to the decrease predicted by the model. Having found a descent step, the next center is automatically shifted to this successful candidate. Termination criteria may stop the process of seeking for a descent step, in which case the current center is kept and the routine cb_termination_code returns the termination code.\n\nRestarting, after each descent step, the bundle method from scratch with the new center as starting point does not endanger convergence. Therefore, a descent step is the smallest unit, after which user interaction can take place safely. To allow this there is a flag stop_at_descent_steps that will cause the code to return after the next descent step.\n\nIf you know what your are doing, you may also use the input parameter maxsteps to force the algorithm to return after at most maxsteps null steps. Calling solve again without any intermediate problem configurations will then simply continue the process where it stopped and convergence is save. During null steps one may not decrease the weight or delete nonzero variables of the center or the current candidate!\n\nIn a Lagrangean relaxation cutting plane approach one may want to separate and enlarge the dimension after a certain number of null steps. In this case the code will try to preserve the model, given appropriate subgradient extension routines have been provided. If the model cannot be extended, it has to be discarded (if subgradient extension is not successful this is done automatically), and the algorithm will be restarted from the current center point.\n\nArguments:\n\np::CBProblem\nthe problem\nmaxsteps::Integer\nuse value =0 as default (anything <= serves as infinite upper bound), if maxsteps>0 the code returns after at most so many null steps\nstop_at_descent_steps::Integer\nif true the code also returns whenever a descent step occured, if false it only stops after maxsteps or when a termination criterion is met\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.CBTerminationCode","page":"Reference of C interface","title":"ConicBundle.CBTerminationCode","text":"enum CBTerminationCode\n\ncbt_not_terminated: Not terminated.\n(Continue with the next cb_solve!)\ncbt_relprec_satisfied: Relative precision criterion satisfied.\n(See cb_set_term_relprec!)\ncbt_time_limit: Timelimit exceeded.\n(Currently the C interface does not offer a timelimit.)\ncbt_feval_limit: Maximum number of function reevaluations exceeded.\n(Indicates that there is a problem with one of the function oracles that seems to deliver no valid upper bounds on the true function value for descent steps)\ncbt_subfailure_limit: Maximum number of quadratic subproblem failures exceeded.\n(Indicates that the numerical limits of the inner quadratic programming solver are reached, no further progress expected)\ncbt_mfailure_limit: maximum number of model evaluation failures exceeded\n(Indicates that the numerical limits of the setup of the subproblem are reached, no further progress expected)\ncbt_incfailure_limit: maximum number of failures to increase the augmented model value exceeded\n(Indicates that the numerical limits of the interplay between subproblem and quadratic programming solver are reached, no further progress expected)\ncbt_ocall_limit: maximum number of oracle calls (function evaluations) exceeded, see cb_set_eval_limit!\ncbt_ofailure_limit: maximum number of oracle failures exceeded.\nThis refers to function evaluations that terminate with insufficient precision but still provide a new approximate subgradient. A failure typically indicates numerical difficulties with the precision requirements. (Currently the C interface does not allow to manipulate the limit, it is set to 10)\n\n\n\n\n\n","category":"type"},{"location":"cref.html#ConicBundle.cb_termination_code-Tuple{ConicBundle.CBProblem}","page":"Reference of C interface","title":"ConicBundle.cb_termination_code","text":"cb_termination_code(p::CBProblem)\n\nReturns the termination code of the bundle algorithm for the latest descent step\n\nFor resetting all counters relevant for termination see cb_clear_fail_counts!.\n\nSee also CBTerminationCode.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_print_termination_code-Tuple{ConicBundle.CBProblem}","page":"Reference of C interface","title":"ConicBundle.cb_print_termination_code","text":"cb_print_termination_code(p::CBProblem)\n\nOutputs a text version of termination code, see cbterminationcode().\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_get_objval-Tuple{ConicBundle.CBProblem}","page":"Reference of C interface","title":"ConicBundle.cb_get_objval","text":"cb_get_objval(p::CBProblem)\n\nReturns the objective value resulting from last descent step (initially undefined).\n\nIf no problem modification routines were called since then, it is the objective value at the point returned by cb_get_center.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_get_center-Tuple{ConicBundle.CBProblem}","page":"Reference of C interface","title":"ConicBundle.cb_get_center","text":"cb_get_center(p::CBProblem)\n\nReturns the next center point that was produced by the last call to cb_solve! (in some problem modification routines the center point may be updated immediately, in others the center point will be corrected automatically directly before starting the next descent step and its values may be infeasible till then).\n\nReturns a double vector of length cb_get_dim. Element i will be the value of design variable y_i in the next center point (mostly the result of the latest descent step). Use cb_get_center! to avoid allocation.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_get_center!-Tuple{Vector{Float64}, ConicBundle.CBProblem}","page":"Reference of C interface","title":"ConicBundle.cb_get_center!","text":"cb_get_center!(center::Vector{Float64}, p::CBProblem)\n\nMutating variant of cb_get_center\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_get_sgnorm-Tuple{ConicBundle.CBProblem}","page":"Reference of C interface","title":"ConicBundle.cb_get_sgnorm","text":"cb_get_sgnorm(p::CBProblem)\n\nReturns Euclidean norm of the latest aggregate subgradient.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_get_subgradient-Tuple{ConicBundle.CBProblem}","page":"Reference of C interface","title":"ConicBundle.cb_get_subgradient","text":"cb_get_subgradient(p::CBProblem)\n\nReturns the latest aggregate subgradient.\n\nReturns a double vector of length cb_get_dim. Element i will be filled with the coordinate value i. Use cb_get_subgradient! to avoid allocation.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_get_subgradient!-Tuple{Vector{Float64}, ConicBundle.CBProblem}","page":"Reference of C interface","title":"ConicBundle.cb_get_subgradient!","text":"cb_get_subgradient!(subgradient::Vector{Float64}, p::CBProblem)\n\nMutating variant of cb_get_subgradient\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_get_candidate_value-Tuple{ConicBundle.CBProblem}","page":"Reference of C interface","title":"ConicBundle.cb_get_candidate_value","text":"cb_get_candidate_value(p::CBProblem)\n\nReturns the objective value computed in the last step of cb_solve!, independent of whether this was a descent step or a null step (initially undefined).\n\nIf no problem modification routines were called since then, it is the objective value at the point returned by cb_get_candidate. If this last evaluation led to a descent step, then it is the same value as in cb_get_objval.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_get_candidate-Tuple{ConicBundle.CBProblem}","page":"Reference of C interface","title":"ConicBundle.cb_get_candidate","text":"cb_get_candidate(p::CBProblem)\n\nReturns the last point, the \"candidate\", at which the function was evaluated in cb_solve!.\n\nIf this evaluation lead to a descent step, it is the same point as in cb_get_center.\n\nReturns a double array of length cb_get_dim. Element i will be the value of design variable y_i of the point. Use cb_get_candidate! to avoid allocation.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_get_candidate!-Tuple{Vector{Float64}, ConicBundle.CBProblem}","page":"Reference of C interface","title":"ConicBundle.cb_get_candidate!","text":"cb_get_candidate!(candidate::Vector{Float64}, p::CBProblem)\n\nMutating variant of cb_get_candidate\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_set_term_relprec!-Tuple{ConicBundle.CBProblem, Float64}","page":"Reference of C interface","title":"ConicBundle.cb_set_term_relprec!","text":"cb_set_term_relprec!(p::CBProblem, term_relprec::Float64)\n\nSets the relative precision requirements for successful termination (default 1e-5). The algorithm stops with termination code cbt_relprec_satisfied, if predicted progress for the next step is less than term_relprec times absolute function value plus one.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_set_new_center_point!-Tuple{ConicBundle.CBProblem, Vector{Float64}}","page":"Reference of C interface","title":"ConicBundle.cb_set_new_center_point!","text":"cb_set_new_center_point!(p::CBProblem, center::Vector{Float64})\n\nSet the starting point/center that will be used in the next call to cb_solve!. Each call to this routine causes an immediate evaluation of all oracles.\n\nArguments:\n\np::CBProblem\nthe problem\ncenter::Vector{Float64} (length cb_get_dim)\ncenter[i] holds the value of design variable y_i\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_get_function_status-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T}} where T","page":"Reference of C interface","title":"ConicBundle.cb_get_function_status","text":"cb_get_function_status(p::CBProblem{T}, function_key::T)\n\nReturns the return value of the latest evaluation call to the function with this function_key\n\nRemember, a unique function_key must be specified in cb_add_function!.\n\nArguments:\n\np::CBProblem{T}\nthe problem\nfunction_key::T\nunique identifier as set in cb_add_function!.\n\nReturns value of latest call to the function having this function_key\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_get_approximate_slacks-Tuple{ConicBundle.CBProblem}","page":"Reference of C interface","title":"ConicBundle.cb_get_approximate_slacks","text":"cb_get_approximate_slacks(p::CBProblem)\n\nReturns the multipliers for the bound constraints on the design variables; in Lagrangean relaxation they may be interpreted as primal slacks for inequality constraints.\n\nReturns a double array of length cb_get_dim. Element i will be filled with the coordinate value i Use cb_get_approximate_slacks! to avoid allocation.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_get_approximate_slacks!-Tuple{Vector{Float64}, ConicBundle.CBProblem}","page":"Reference of C interface","title":"ConicBundle.cb_get_approximate_slacks!","text":"cb_get_approximate_slacks!(slacks::Vector{Float64}, p::CBProblem)\n\nMutating variant of cb_get_approximate_slacks\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_get_approximate_primal!-Union{Tuple{T}, Tuple{Vector{Float64}, ConicBundle.CBProblem{T}, T}} where T","page":"Reference of C interface","title":"ConicBundle.cb_get_approximate_primal!","text":"cb_get_approximate_primal!(primal::Vector{Float64}, p::CBProblem{T}, function_key::T)\n\nReturns the current approximate primal solution for the function having this function_key\n\nThe function_key must match the one specified in cb_add_function!. Likewise, the routine is meaningful only if primaldim was set in   cb_add_function! and primal vectors were   returned along with the subgradients in all calls to CBFunction with this function_key. In this case it returns the current approximate primal solution aggregated alongside with the aggregate subgradient. A primal solution may not be available after addition of constraints, if extension of the aggregate subgradient to the new coordinates failed.\n\nIf no primal dimension was set for this function, the routine does nothing.\n\nArguments:\n\nprimal::Vector{Float64} (caller-allocated of length primaldim)\nprimal[i] will be filled with the coordinate value i\np::CBProblem{T}\nthe problem\nfunction_key::T\nunique identifier as set in cb_add_function!\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_get_center_primal!-Union{Tuple{T}, Tuple{Vector{Float64}, ConicBundle.CBProblem{T}, T}} where T","page":"Reference of C interface","title":"ConicBundle.cb_get_center_primal!","text":"cb_get_center_primal!(primal::Vector{Float64}, p::CBProblem{T}, function_key::T)\n\nReturns the best primal solution obtained in the current center point in evaluating the function having this function_key\n\nThe function_key must match the one specified in cb_add_function!. Likewise, the routine is meaningful only if primaldim was set in cb_add_function! and primal vectors were returned along with the subgradients in all calls to CBFunction with this function_key. In this case it returns the current approximate primal solution aggregated alongside with the aggregate subgradient. A primal solution may not be available after addition of constraints, if extension of the aggregate subgradient to the new coordinates failed.\n\nIf no primal dimension was set for this function, the routine does nothing.\n\nArguments:\n\nprimal::Vector{Float64} (caller-allocated of length primaldim)\nprimal[i] will be filled with the coordinate value i\np::CBProblem{T}\nthe problem\nfunction_key::T\nunique identifier as set in cb_add_function!\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_get_candidate_primal!-Union{Tuple{T}, Tuple{Vector{Float64}, ConicBundle.CBProblem{T}, T}} where T","page":"Reference of C interface","title":"ConicBundle.cb_get_candidate_primal!","text":"cb_get_candidate_primal!(primal::Vector{Float64}, p::CBProblem{T}, function_key::T)\n\nReturns the best primal solution returned by the last evaluation of the function having this function_key in the point cb_get_candidate.\n\nThe function_key must match the one specified in cb_add_function!. Likewise, the routine is meaningful only if primaldim was set in   cb_add_function! and primal vectors were   returned along with the subgradients in all calls to CBFunction with this function_key. In this case it returns the current approximate primal solution aggregated alongside with the aggregate subgradient. A primal solution may not be available after addition of constraints, if extension of the aggregate subgradient to the new coordinates failed.\n\nIf no primal dimension was set for this function, the routine does nothing.\n\nArguments:\n\nprimal::Vector{Float64} (caller-allocated of length primaldim)\nprimal[i] will be filled with the coordinate value i\np::CBProblem{T}\nthe problem\nfunction_key::T\nunique identifier as set in cb_add_function!\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_set_max_modelsize!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Integer}} where T","page":"Reference of C interface","title":"ConicBundle.cb_set_max_modelsize!","text":"cb_set_max_modelsize!(p::CBProblem{T}, function_key::T, modelsize::Integer)\n\nSets the maximum number of subgradients used in forming the cutting model of the function having this function_key\n\nThe function_key must match the one specified in cb_add_function!.\n\nQuite often a very small model, e.g., 2, yields very fast iterations and good progress in time (sometimes at the cost of more evaluations). By limited numerical experience, a significant reduction in the number of evaluations can only be expected if the bundle is large enough to wrap the function rather tightly. Quite frequently, unfortunately, this entails that solving the quadratic subproblems is more expensive than function evaluation.\n\nArguments:\n\np::CBProblem{T}\nthe problem\nfunction_key::T\nunique identifier as set in cb_add_function!\nmodelsize::Integer\nmaximum number of subgradients to be used in forming the cutting model\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_set_max_bundlesize!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Integer}} where T","page":"Reference of C interface","title":"ConicBundle.cb_set_max_bundlesize!","text":"cb_set_max_bundlesize!(p::CBProblem{T}, function_key::T, bundlesize::Integer)\n\nSets the maximum number of subgradients stored for use in forming the model or determining metric information of the function having this function_key. it must be as least as large as max_modelsize (and is increased to this if not)\n\nThe function_key must match the one specified in cb_add_function!.\n\nArguments:\n\np::CBProblem{T}\nthe problem\nfunction_key::T\nunique identifier as set in cb_add_function!\nbundlesize::Integer\nmaximum number of subgradients to be used in forming the cutting model\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_set_max_new_subgradients!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Integer}} where T","page":"Reference of C interface","title":"ConicBundle.cb_set_max_new_subgradients!","text":"cb_set_max_new_subgradients!(p::CBProblem{T}, function_key::T, max_new_subg::Integer)\n\nSets the maximum number of epsilon subgradients that can be returned in one call to the function having this function_key.\n\nThe function_key must match the one specified in cb_add_function!.\n\nThe parameter max_new_subg corresponds directly to the parameter max_subg in CBFunction.\n\nArguments:\n\np::CBProblem{T}\nthe problem\nfunction_key::T\nunique identifier as set in cb_add_function!\nmax_new_subg::Integer\nmaximum number of subgradients to be used in forming the cutting model\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_get_bundle_parameters-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T}} where T","page":"Reference of C interface","title":"ConicBundle.cb_get_bundle_parameters","text":" cb_get_bundle_parameters(p::CBProblem{T}, function_key::T)\n\nRetrieves the two bundle parameters specified in the routines cb_set_max_modelsize! and cb_set_max_bundlesize! for the function having this function_key.\n\nThe function_key must match the one specified in cb_add_function!.\n\nArguments:\n\np::CBProblem{T}\nthe problem\nfunction_key::T\nunique identifier as set in cb_add_function!\n\nReturns two integers:\n\nthe maximum number of subgradients to be used in forming the cutting model\nthe maximum number of subgradients stored for use in forming the cutting model\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_reinit_function_model!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T}} where T","page":"Reference of C interface","title":"ConicBundle.cb_reinit_function_model!","text":"cb_reinit_function_model!(p::CBProblem{T}, function_key::T)\n\nClears cutting model, subgradients and stored function values for the function with this function_key\n\nThis has to be called whenever the specified function was modified so that the old subgradients and/or primal generators are no longer valid.\n\nThe function_key must match the one specified in cb_add_function!.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_get_last_weight-Tuple{ConicBundle.CBProblem}","page":"Reference of C interface","title":"ConicBundle.cb_get_last_weight","text":"cb_get_last_weight(p::CBProblem)\n\nReturns the current weight for the quadratic term in the augmented subproblem (may be interpreted as 1./step_size or 1./trustregion-radius).\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_set_next_weight!-Tuple{ConicBundle.CBProblem, Float64}","page":"Reference of C interface","title":"ConicBundle.cb_set_next_weight!","text":"cb_set_next_weight!(p::CBProblem, weight::Float64)\n\nSets the  weight (>0) to be used in the quadratic term of the next augmented subproblem (may be interpreted as 1./step_size or 1./trustregion-radius).\n\nIndependent of whether the weight violates current min- and max-bounds set in cb_set_min_weight! and cb_set_max_weight!, the next model will be computed for this value. Thereafter, however, it will be updated as usual; in particular, it may be truncated by min and max bounds immediately after the first subproblem.\n\nIn order to guarantee a constant weight (e.g. 1 is frequently a reasonable choice if the automatic default heuristic performs poorly), set the min and max bounds to the same value, too.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_set_min_weight!-Tuple{ConicBundle.CBProblem, Float64}","page":"Reference of C interface","title":"ConicBundle.cb_set_min_weight!","text":"cb_set_min_weight!(p::CBProblem, min_weight::Float64)\n\nSets a lower bound on the weight for the quadratic term of the augmented subproblem.\n\nNonpositive values indicate no bound. The new value shows its effect only at first dynamic change of the weight.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_set_max_weight!-Tuple{ConicBundle.CBProblem, Float64}","page":"Reference of C interface","title":"ConicBundle.cb_set_max_weight!","text":"cb_set_max_weight!(p::CBProblem, max_weight::Float64)\n\nSets a upper bound on the weight for the quadratic term of the augmented subproblem.\n\nNonpositive values indicate no bound. The new value shows its effect only at first dynamic change of the weight.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.CBVariableMetric","page":"Reference of C interface","title":"ConicBundle.CBVariableMetric","text":"CBVariableMetric\n\ncbvm_no_scaling\ncbvm_diagonal_scaling\ncbvm_diagonal_scaling_with_bounds\n\n\n\n\n\n","category":"type"},{"location":"cref.html#ConicBundle.cb_set_variable_metric!-Tuple{ConicBundle.CBProblem, ConicBundle.CBVariableMetric}","page":"Reference of C interface","title":"ConicBundle.cb_set_variable_metric!","text":"cb_set_variable_metric!(p::CBProblem, do_variable_metric::CBVariableMetric)\n\nSets a upper bound on the weight for the quadratic term of the augmented subproblem.\n\nNonpositive values indicate no bound. The new value shows its effect only at first dynamic change of the weight.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_get_dim-Tuple{ConicBundle.CBProblem}","page":"Reference of C interface","title":"ConicBundle.cb_get_dim","text":"cb_get_dim(p::CBProblem)\n\nReturns the current dimension of the design space/argument or -1 if no dimension is set.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_get_n_functions-Tuple{ConicBundle.CBProblem}","page":"Reference of C interface","title":"ConicBundle.cb_get_n_functions","text":"cb_get_n_functions(p::CBProblem)\n\nReturns the current number of functions in the problem.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_get_minus_infinity","page":"Reference of C interface","title":"ConicBundle.cb_get_minus_infinity","text":"cb_get_minus_infinity()\n\nReturns the value \"minus infinity\", i.e., all bounds <= this value are set to this value and are regarded as minus infinity Use the constant cb_minus_infinity instead of calling this function.\n\n\n\n\n\n","category":"function"},{"location":"cref.html#ConicBundle.cb_get_plus_infinity","page":"Reference of C interface","title":"ConicBundle.cb_get_plus_infinity","text":"cb_get_plus_infinity()\n\nReturns the value \"plus infinity\", i.e., all bounds >= this value are set to this value and are regarded as plus infinity Use the constant cb_plus_infinity instead of calling this function.\n\n\n\n\n\n","category":"function"},{"location":"cref.html#ConicBundle.cb_clear_fail_counts!-Tuple{ConicBundle.CBProblem}","page":"Reference of C interface","title":"ConicBundle.cb_clear_fail_counts!","text":"cb_clear_fail_counts!(p::CBProblem)\n\nclears all fail counts on numerical function oder model failures, may be useful if this caused premature termination.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_set_eval_limit!-Tuple{ConicBundle.CBProblem, Integer}","page":"Reference of C interface","title":"ConicBundle.cb_set_eval_limit!","text":"cb_set_eval_limit!(p::CBProblem, eval_limit::Integer)\n\nSets an upper bound on the number of calls to the oracle (use negative numbers for no limit).\n\nIf this number is reached, the algorithm will terminate independently of whether the last step was a descent or a null step. A negative number will be interepreted as no limit.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_set_inner_update_limit!-Tuple{ConicBundle.CBProblem, Integer}","page":"Reference of C interface","title":"ConicBundle.cb_set_inner_update_limit!","text":"cb_set_inner_update_limit!(p::CBProblem, update_limit::Integer)\n\nSet an upper bound on the number of inner updates for the cutting model with primal slacks within one null step (use negative numbers for no limit).\n\nA negative number will be interepreted as no limit, i.e., the updates will be done till a certain precision of the cutting model is achieved.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_set_active_bounds_fixing!-Tuple{ConicBundle.CBProblem, Bool}","page":"Reference of C interface","title":"ConicBundle.cb_set_active_bounds_fixing!","text":"cb_set_active_bounds_fixing!(p::CBProblem, allow_fixing::Bool)\n\nIf set to true (the default is false), some variables will be fixed automatically to the center value if their bounds are strongly active (i.e., the corresponding multipliers are big).\n\nThe coordinates to be fixed are redetermined in each call following a descent step or a change of the function. An indicator vector of the variables fixed in the last call can be obtained via the routine cb_get_fixed_active_bounds.\n\nSetting this value to true might improve the performance of the algorithm in some instances but there is no convergence theory. It might be particularly helpful within Lagrangian relaxation if a primal cutting plane approach is used and non-tight inequalities should be eliminated quickly (fixing then indicates large primal slack values).\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_get_fixed_active_bounds-Tuple{ConicBundle.CBProblem}","page":"Reference of C interface","title":"ConicBundle.cb_get_fixed_active_bounds","text":"cb_get_fixed_active_bounds(p::CBProblem)\n\nReturns the indicator vector of variables temporarily fixed to the center value due to significantly positive multipliers for the box constraints, see cb_set_active_bounds_fixing!.\n\nSuch a fixing indicates that the corresponding variables would like to stay at their bounds. If no variables were fixed, the dimension of the vector is zero.\n\nReturns a int array of length cb_get_dim. Element i will be 1 if the variable i was fixed to the bound and 0 otherwise Use cb_get_fixed_active_bounds! to avoid allocation.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_get_fixed_active_bounds!-Tuple{ConicBundle.CBProblem, Vector{Int32}}","page":"Reference of C interface","title":"ConicBundle.cb_get_fixed_active_bounds!","text":"cb_get_fixed_active_bounds!(p::CBProblem, indicator::Vector{Cint})\n\nMutating variant of cb_get_fixed_active_bounds\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_set_print_level!-Tuple{ConicBundle.CBProblem, Integer}","page":"Reference of C interface","title":"ConicBundle.cb_set_print_level!","text":"cb_set_print_level!(p::CBProblem, pril::Integer)\n\nSpecifies the output level (<0 no output at all, =0 errors and warnings, >0 increasingly detailed information)\n\nOutput levels:\n\n<0 ... no output, not even errors or warnings\n0 ... no output except for errors and warnings\n1 ... line summary after each descent step\n>1 ... undocumented and increasingly detailed log information.         These higher levels should only be used if requested         for debugging purposes.\n\nExample for level 1:\n\n00:00:00.00 endit  1   1   1   563.    563.  39041.188  39043.162\n00:00:00.00 endit  2   2   2   563.    559.  38488.165  38490.200\n00:00:00.00 endit  3   3   3   56.3    555.  33014.533  33211.856\n00:00:00.00 endit  4   4   4   5.63    517. -14306.459  2738.0343\n00:00:00.00 endit  5   5   5   4.04    148. -2692.1131  2.2150883\n00:00:00.00 endit  6   6   6   4.01    1.29  1.7908952  2.0000581\n00:00:00.00 endit  7   7   7   3.95  0.0213  1.9999387  2.0000000\n00:00:00.00 _endit  8   8   8   3.95 2.94e-05  2.0000000  2.0000000\n\nColumn 1      2     3   4   5    6       7       8          9\n\nColumn 1: computation time in hh:mm:ss.dd,\nColumn 2: \"endit\" is convenient for grep and stands for \"end of iteration\".   Iterations with cb_termination_code != 0 are marked with \"_endit\".\nColumn 3: number of descent steps (= calls to cb_solve!)\nColumn 4: number of descent and null steps. Up to initialization calls and reevaluations, this is the number of   evaluation calls to the function oracles from within the bundle method. In the example all calls led to descent steps.\nColumn 5: number of innermost iterations. It differs from column 5 only in the case of variables with bounds in which   case it gives the number of updates of the multipliers for the bounds (or primal slacks in Lagrangean relaxation).   Exceedingly high numbers in this column indicate that some variables are constantly at their bounds and it might be   possible to improve convergence by deleting them (i.e. set them as constants to this bound and remove the variable).\nColumn 6: the weight of the quadratic term in the augmented problem.\nColumn 7: the norm of the aggregate subgradient. If it is small, say below 0.1, then mostly this is good indication that   the objective value is close to optimal.\nColumn 8: the value of the cutting model in the last candidate point. It is always a lower bound on the true function   value in this point\nColumn 9: the objective value in the latest point that led to a descent step, i.e., the point returend by   cb_get_center. Whenever cb_termination_code   returns 0 this is also the objective value of the latest evaluation call to the function oracles and the value in the   center point of the next iteration.\n\n\n\n\n\n","category":"method"},{"location":"cref.html#ConicBundle.cb_minus_infinity","page":"Reference of C interface","title":"ConicBundle.cb_minus_infinity","text":"const cb_minus_infinity::Float64\n\nContains the value \"minus infinity\" as returned by cb_get_minus_infinity\n\n\n\n\n\n","category":"constant"},{"location":"cref.html#ConicBundle.cb_plus_infinity","page":"Reference of C interface","title":"ConicBundle.cb_plus_infinity","text":"const cb_plus_infinity::Float64\n\nContains the value \"plus infinity\" as returned by cb_get_plus_infinity\n\n\n\n\n\n","category":"constant"},{"location":"cexample.html#Example-for-the-C-interface","page":"Example for the C interface","title":"Example for the C interface","text":"","category":"section"},{"location":"cexample.html","page":"Example for the C interface","title":"Example for the C interface","text":"This example is the direct counterpart to the miniature C example for a convex quadratic in two variables.","category":"page"},{"location":"cexample.html","page":"Example for the C interface","title":"Example for the C interface","text":"using ConicBundle\n\nfunction eval_fun(function_key, x, relprec, max_new_subg, objective_threshold, subgval, subgradient, primal)\n    # compute objective\n    objective_value = .5*(5x[1]*x[1] + 2x[1]*x[2] + 4x[2]*x[2]) - 12x[1] - 10x[2] + 3;\n    new_subg = 1\n    subgval[1] = objective_value\n    subgradient[1] = (5x[1] + x[2]) - 12;\n    subgradient[2] = (x[1]+4*x[2]) - 10;\n    return objective_value, new_subg\nend\n\np = CBProblem{Int}() # the type parameter specified the type that our function_key will have - irrelevant here\ncb_init_problem!(p, 2) # 2 variables, no bounds\ncb_add_function!(p, 0, eval_fun) # the second parameter is our function_key; no extensions, no primal\ncb_set_print_level!(p, 1)\ncb_set_term_relprec!(p, 1e-8) # set relative precision\ncb_solve!(p) # minimize the function up to termination\ncb_print_termination_code(p)\nx = cb_get_center(p) # retrieve the computed solution\nprint(\"x = \", x, \", objval = \", cb_get_objval(p))\n# problem is automatically freed","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CurrentModule = ConicBundle","category":"page"},{"location":"index.html#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"ConicBundle.jl is the Julia port to the ConicBundle library. The functions that are centered around the CBProblem type address the official C interface of ConicBundle; they were translated by hand, adapted to a Julian way of coding and should work without any problems. However, the C interface is quite restricted and ConicBundle has a lot more to offer. For this reason, a lot of the functionality of the C++ interface was also exported for this Julia port and can be accessed by the C++ interface. Do not mix those two interfaces! The C interface has automatic memory management, the C++ interface does not. Additionally, the latter was created automatically using a script and lots of regular expressions; it comes without any guarantees that the functions will even be callable. Furthermore, the way of just exporting everything is not particularly efficient, as Julia would be able to do a lot of the functionality that is inlined in C++ on its own.","category":"page"},{"location":"index.html#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"ConicBundle","category":"page"},{"location":"index.html#ConicBundle.ConicBundle","page":"Introduction","title":"ConicBundle.ConicBundle","text":"module ConicBundle\n\nSolve min_yinmathbfR^m  f_0(y) + f_1(y) +  + f_k(y) for convex functions f_i, the y-variables may be bounded or box constrained. The most important steps are explained here. Internal details are sketched in internal_cinterface.\n\nSetting up the Problem, the Functions, and the Main Loop\n\nFirst open a new problem by constructing a CBProblem object [use CBProblem(1) in order to employ a minimal bundle solver with just one aggregate and one new subgradient in each iteration; this is an attractive choice, if fast iterations and/or little memory consumption are of special importance]. The object will be needed for every manipulation of this problem. Cleanup is performed automatically.\n\nNext, set the dimension of the design variables/argument as well as possible box constraints on these by the function cb_init_problem!.\n\nNow set up your functions f_i as functions that respect the call signature detailed in CBFunction. Via these functions you will supply, for a given argument, the function value and a subgradient (=the gradient if the function is differentiable) to the solver.\n\nThe callbacks have to be added to the solver using the routine cb_add_function!.\n\nOnce all functions are added, the optimization process can be started. If you know a good starting point then set it with cb_set_new_center_point! now, otherwise the method will pick the zero vector or, in the case of box constraints, the point closest to zero as starting point.\n\nFinally, set up a loop that calls cb_solve! until cb_termination_code is nonzero.\n\nAfter the first call to cb_solve! you can retrieve, at any time, the current objective value by cb_get_objval and the argument leading to this value by cb_get_center. For some screen output, use cb_set_print_level!.\n\nLagrangean Relaxation, Primal Approximations, and Cutting Planes\n\nIf you are optimizing a Lagrangean relaxation, you might be interested in getting an approximation to your primal optimal solution. This can be done by specifying in each function for each (epsilon) subgradient the corresponding primal vectors that generate it, see CBFunction and cb_add_function! as a start. Then for each of your functions, you can retrieve the current primal approximation using cb_get_approximate_primal!.\n\nIf, in addition, you plan to improve your primal relaxation via cutting planes, that are strongly violated by the current primal approximation, you should have a look at cb_append_variables!, CBSubgExt, cb_reinit_function_model!, cb_get_approximate_slacks, and cb_delete_variables!.\n\n\n\n\n\n","category":"module"}]
}
