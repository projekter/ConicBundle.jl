<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference of C interface · ConicBundle.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ConicBundle.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="cexample.html">Example for the C interface</a></li><li><a class="tocitem" href="cppexample.html">Example for the C++ interface</a></li><li><a class="tocitem" href="cppref.html">Reference of C++ interface</a></li><li class="is-active"><a class="tocitem" href="cref.html">Reference of C interface</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="cref.html">Reference of C interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="cref.html">Reference of C interface</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/projekter/ConicBundle.jl/blob/main/docs/src/cref.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference-of-C-interface"><a class="docs-heading-anchor" href="#Reference-of-C-interface">Reference of C interface</a><a id="Reference-of-C-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Reference-of-C-interface" title="Permalink"></a></h1><p>The C interface is manually ported to Julia. In particular, the comments were curated and some logical coding choices were made. This is a good interface. Some of the functions will also be available in the C++ interface; but do not mix them with objects created by the C interface.</p><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.CBProblem" href="#ConicBundle.CBProblem"><code>ConicBundle.CBProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CBProblem{T}(no_bundle::Bool=false)
CBProblem(no_bundle::Bool=false)</code></pre><p>Creates a a new problem object and returns a pointer to it.</p><p>Arguments:</p><ul><li><p><code>T</code></p><p>type of the function keys (<code>Any</code> if omitted)</p></li><li><p><code>no_bundle::Bool</code></p><p>if <code>true</code>, then the minimal bundle consisting of just one new and one aggregate gradient is used so that there is no real bundle available and bundle size options are then meaningless.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L76-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_clear!-Tuple{ConicBundle.CBProblem}" href="#ConicBundle.cb_clear!-Tuple{ConicBundle.CBProblem}"><code>ConicBundle.cb_clear!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_clear!(p::CBProblem)</code></pre><p>Clears all data structures and problem information but keeps ouptut settings and algorithmic parameter settings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L113-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_set_default!-Tuple{ConicBundle.CBProblem}" href="#ConicBundle.cb_set_default!-Tuple{ConicBundle.CBProblem}"><code>ConicBundle.cb_set_default!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_set_default!(p::CBProblem)</code></pre><p>Sets default values for algorithmic parameters that are not function specific (e.g., relative precision, weight and weight bounds for the augmented problem, etc.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L120-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_init_problem!-Tuple{ConicBundle.CBProblem, Integer}" href="#ConicBundle.cb_init_problem!-Tuple{ConicBundle.CBProblem, Integer}"><code>ConicBundle.cb_init_problem!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_init_problem!(p::CBProblem, m::Integer; lowerb=nothing, upperb=nothing)</code></pre><p>Initializes the problem by setting the design space (the dimension and possible box constraints of the variables)</p><p>Clears all data structures and sets the dimension <span>$m$</span> for a new problem. for solving <span>$\min_{y in \mathbb R^m}  f_0(y) + f_1(y) + ...$</span> Box constraints may be specified for <span>$y$</span>, the functions <span>$f_i$</span> must be added by   <a href="cref.html#ConicBundle.cb_add_function!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Function, Nothing}} where T"><code>cb_add_function!</code></a>.</p><p>Lower and/or upper bounds must be specified for all variables or for none of them. To specify no bounds at all, give <code>nothing</code>. Otherwise use <a href="cref.html#ConicBundle.cb_get_minus_infinity"><code>cb_get_minus_infinity</code></a> for unbounded below and <a href="cref.html#ConicBundle.cb_get_plus_infinity"><code>cb_get_plus_infinity</code></a> for unbounded above. For <code>nothing</code>, unbounded will be used as default for all variables. Specifying bounds selectively is also possible by <a href="cref.html#ConicBundle.cb_set_lower_bound!-Tuple{ConicBundle.CBProblem, Integer, Float64}"><code>cb_set_lower_bound!</code></a> or <a href="cref.html#ConicBundle.cb_set_upper_bound!-Tuple{ConicBundle.CBProblem, Integer, Float64}"><code>cb_set_upper_bound!</code></a>.</p><p>Arguments:</p><ul><li><p><code>p::CBProblem</code></p><p>the current problem</p></li><li><p><code>m::Integer</code></p><p>the dimension of the argument/design space/the number of Lagrange multipliers</p></li><li><p><code>lowerb::Union{Vector{Float64},Nothing}</code> (either double array of length <code>m</code> or <code>nothing</code>)</p><p>If <code>nothing</code>, all variables are considered unbounded below, otherwise <code>lowerb[i]</code> gives the minimum feasible value for variable <code>y[i]</code>, use <a href="cref.html#ConicBundle.cb_get_minus_infinity"><code>cb_get_minus_infinity</code></a> for unbounded below.</p></li><li><p><code>upperb::Union{Vector{Float64},Nothing}</code> (either double array of length <code>m</code> or <code>nothing</code>)</p><p>If <code>nothing</code>, all variables are considered unbounded above, otherwise <code>upperb[i]</code> gives the maximum feasible value for variable <code>y[i]</code>, use <a href="cref.html#ConicBundle.cb_get_plus_infinity"><code>cb_get_plus_infinity</code></a> for unbounded above.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L128-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.CBFunction" href="#ConicBundle.CBFunction"><code>ConicBundle.CBFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CBFunction{T}(callback, m, n)</code></pre><p>function oracle; describe your function as a function of this type to pass it to the solver</p><p>The oracle interface is used to describe a convex function. The dimension of the argument vector of the function must be set in <a href="cref.html#ConicBundle.cb_init_problem!-Tuple{ConicBundle.CBProblem, Integer}"><code>cb_init_problem!</code></a>, let it be <code>m</code> in the following.</p><p>If the sum of several such functions is to be minimized, it is the task of the user to guarantee that all dimensions match.</p><p>In many applications, computing the function value is an iterative process that approaches the true function value from below. The code offers a bound for the function value, above which it is certain that the code will reject the current point. If in the iterative process a lower bound on the function value exceeds this bound, then it is sufficient to return, instead of the true function value and a subgradient, the current lower bound and a vector so that together they describe a supporting hyperplane (an epsilon subgradient, lying completely below the function) to the function at this point.</p><p>If the function corresponds to Lagrangean relaxation of a primal maximization problem one may want to generate a primal approximate solution. In this case, set in <a href="cref.html#ConicBundle.cb_add_function!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Function, Nothing}} where T"><code>cb_add_function!</code></a> the desired primal dimension. Then the solver will provide memory in primal for returning in the function the generating primal vectors for each subgradient. If the primal dimension is set to zero, primal will be <code>nothing</code> and no aggregation takes place.</p><p>If primal aggregation is used then it is possible to implement a primal cutting plane framework. This requires the introduction of new (dual) variables in the design space of the function. In this case a function of signature <a href="cref.html#ConicBundle.CBSubgExt"><code>CBSubgExt</code></a> should be provided for filling in the missing coordinates in existing subgradients. This function need not be specified even if constraints are added, but then the cutting model of the objective is lost at each addition of constraints.</p><p>Arguments of the callback:</p><ul><li><p><code>function_key::T</code></p><p>supplied by the user on entering the function. May be useful if multiple copies of the same function are used with parameters</p></li><li><p><code>arg::Vector{Float64}</code> (double array of length <code>m</code>)</p><p>argument of the function (e.g. the Lagrange multipliers)</p></li><li><p><code>relprec::Float64</code></p><p>relative precision requirement for objective values that may lead to descent steps (this precision is not required if it is already certain that the function value will be too poor)</p></li><li><p><code>max_subg::Cint</code></p><p>at most <code>max_subg</code> epsilon-<code>subgradients</code> and <code>subg_values</code> may be returned, but at least one must be returned!</p></li><li><p><code>objective_threshold::Float64</code></p><p>value gives the threshold for a null step; you may stop, if a cutting plane yields at least this;</p></li><li><p><code>subg_values::Vector{Float64}</code> (caller-allocated, length <code>max_subg</code>)</p><p>store for each epsilon subgradient the value at the argument</p></li><li><p><code>subgradients::Matrix{Float64}</code> (caller-allocated, size <code>(m, max_subg)</code>)</p><p><code>subgradients[i, j]</code> = coefficient of subgradient <code>j</code> at y-coordinate <code>i</code></p></li><li><p><code>primal::Union{Matrix{Float64},Nothing}</code> (caller-allocated, size <code>(n, max_subg)</code> or <code>nothing</code>)</p><p>If the function arises from Lagrangean relaxation and a primal approximation is desired then set the primal dimension in <a href="cref.html#ConicBundle.cb_add_function!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Function, Nothing}} where T"><code>cb_add_function!</code></a> and return the primal solutions corresponding to the eps-subgradients in the array pointed to by primal.</p></li></ul><p>Callback must return a tuple:</p><ul><li>upper bound on the true function value within <span>$\mathrm{relprec}*(\operatorname{abs}(\mathrm{objval})+1.)$</span>, if there is no hyperplane cutting above the threshold specified in <code>objective_value</code> on input. Otherwise the max of <code>subg_values</code>.</li><li>the number of epsilon-<code>subgradients</code> returned. Termination is forced if no new subgradient is returned.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L176-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.CBSubgExt" href="#ConicBundle.CBSubgExt"><code>ConicBundle.CBSubgExt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CBSubgExt{T}(callback, n)</code></pre><p>This routine is not needed unless variables (constraints in Lagrangean relaxation) are added on the fly.</p><p>The solver calls this routine whenever new variables have been added on the fly in order to extend old subgradients to the new coordinates. If primal data was supplied for the subgradients then <code>generating_primal</code> holds a pointer to this (possibly aggregated) data, otherwise it is <code>nothing</code>.</p><p>In the presence of primal data, the new coordinates correspond to the violation of the new primal constraints. These have to be returned in the array <code>new_subgradient_values</code>; more precisely, for i=1 to <code>n_indices</code> the element <code>new_subgradient_values[i]</code> has to hold the subgradient information of constraint <code>variable_indices[i]</code>;</p><p>If <code>generating_primal</code> is <code>nothing</code>, then the routine can only successfully extend the subgradients, if the new coordinates have no influence on the function; then the new subgradient coordinates are all zero and the components of <code>new_subgradient_values</code> have to be initialized to zero.</p><p>If you do indeed need this, you have to provide one such function with each evaluation function.</p><p>Arguments of the callback:</p><ul><li><p><code>function_key::T</code></p><p>supplied by the user on entering the function. May be useful if multiple copies of the same function are used with parameters</p></li><li><p><code>generating_primal::Union{Nothing,Vector{Float64}}</code> (double array of primal length <code>n</code> or <code>nothing</code>) if not <code>nothing</code> it holds the (possibly aggregated) primal solution that generated the subgradient that needs to be extendend</p></li><li><p><code>n_indices::Cint</code></p><p>gives the number of indices for which the subgradient value has to be computed</p></li><li><p><code>variable_indices::Vector{Int}</code> (pointer to int array of length <code>n_indices</code>)</p><p>for the <code>y</code> variables with indices <code>variable_indices[i]</code>, <code>i=1,..,n_indices</code> the subgradient coefficient has to be computed</p></li><li><p><code>new_subgradient_values::Vector{Float64}</code> (caller-allocated, pointer to double array of length <code>n_indices</code>)</p><p>store the the subgradient coefficient of <code>y</code> variable with index <code>variable_indices[i]</code> at <code>new_subgradient_values[i]</code> for <code>i=1,..,n_indices</code></p></li></ul><p>Callback must return 0 on success or 1 if extension is impossible</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L263-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.CBFunctionTask" href="#ConicBundle.CBFunctionTask"><code>ConicBundle.CBFunctionTask</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">enum CBFunctionTask</code></pre><ul><li><code>cbft_objective_function</code></li><li><code>cbft_constant_penalty_function</code></li><li><code>cbft_adaptive_penalty_function</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L318-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_add_function!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Function, Nothing}} where T" href="#ConicBundle.cb_add_function!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Function, Nothing}} where T"><code>ConicBundle.cb_add_function!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_add_function!(p::CBProblem{T}, function_key::T, f::Function, se::Union{Function,Nothing}=nothing; primaldim::Integer=0,
    fun_factor::Float64=1., fun_task::CBFunctionTask=cbft_objective_function,
    aft::Union{CBAffineFunctionTransformation,Nothing}=nothing)</code></pre><p>Adds the function, the sum of which should be minimized, to the problem description.</p><p>Each function added must be given a unique <code>function_key</code>, <code>f</code> supplies the evaluation function and must not be zero, <code>se</code> can be used to specify a routine for extending subgradients, but it may be <code>nothing</code>. <code>primaldim</code> can be used if an approximate primal solution should  be aggregated (In this case storage will be supplied in the call to the evaluation function for storing for each subgradient the generating primal vector). It may be zero if this is not needed.</p><p>Arguments:</p><ul><li><p><code>p::CBProblem{T}</code></p><p>the problem to which the function should be added</p></li><li><p><code>function_key::T</code></p><p>The value of the funciton_key must UNIQUELY identify the function, (it may be the address of the function [if unique], or give the address of a struct holding additional user parameters)</p></li><li><p><code>f::Function</code></p><p>the function (see <a href="cref.html#ConicBundle.CBFunction"><code>CBFunction</code></a> for parameters)</p></li><li><p><code>se::Union{Function,Nothing}</code></p><p>This parameter may be <code>nothing</code>, otherwise the respective function will be called in order to compute coefficients for new subgradient coordinates resulting from added variables. See <a href="cref.html#ConicBundle.CBSubgExt"><code>CBSubgExt</code></a> for parameters.</p></li><li><p><code>primaldim::Integer</code></p><p>May be zero, otherwise in each call to <code>f</code> enough storage will be provided to store a primal generating vector for each subgradient returned. The primal solutions will be aggregated along with the subgradients. This allows to generate approximate primal optimal solutions, e.g., in Lagrangean relaxation.</p></li><li><p><code>fun_factor::Float64</code> Allows to specify a scaling factor for the function. <code>fun_factor</code> must be a strictly positive number.</p></li><li><p><code>fun_task::CBFunctionTask</code> Specifies whether the function is to be used as a an ObjectiveFunction, a ConstantPenaltyFunction with <code>fun_factor</code> as maximum penalty factor, or as an <code>AdaptivePenaltyFunction</code> with <code>fun_factor</code> at initial penalty guess that might be increased or decreased over time.</p></li><li><p><code>aft::Union{CBAffineFunctionTransformation,Nothing}</code> May be used to modify the argument and give an additional affine term (linear term plus offset). For adding an affine term there are several other possibilities, e.g. in <a href="cref.html#ConicBundle.cb_init_problem!-Tuple{ConicBundle.CBProblem, Integer}"><code>cb_init_problem!</code></a>, so there is no need to do so here. If, however, an existing function implementation requires only some subset of the variables, it is more convenient to supply a corresponding <code>aft</code> instead of reimplementing the function.</p></li></ul><p>See also <a href="cref.html#ConicBundle.CBFunction"><code>CBFunction</code></a>, <a href="cref.html#ConicBundle.CBFunctionTask"><code>CBFunctionTask</code></a>, <a href="cppref.html#ConicBundle.CBAffineFunctionTransformation"><code>CBAffineFunctionTransformation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L327-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_set_lower_bound!-Tuple{ConicBundle.CBProblem, Integer, Float64}" href="#ConicBundle.cb_set_lower_bound!-Tuple{ConicBundle.CBProblem, Integer, Float64}"><code>ConicBundle.cb_set_lower_bound!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_set_lower_bound!(p::CBProblem, i::Integer, lower_bound::Float64)</code></pre><p>set lower bound for variable <code>i</code>, use <a href="cref.html#ConicBundle.cb_get_minus_infinity"><code>cb_get_minus_infinity</code></a> for unbounded from below.</p><p>The algorithm may have to adapt the center point aftwards. In this case the old function values will be marked as outdated and will be recomputed at the next call to e.g. <a href="cref.html#ConicBundle.cb_solve!-Tuple{ConicBundle.CBProblem, Integer, Bool}"><code>cb_solve!</code></a>.</p><p>Arguments:</p><ul><li><p><code>p::CBProblem</code></p><p>the problem</p></li><li><p><code>i::Integer</code></p><p>index of the variable</p></li><li><p><code>lower_bound::Float64</code></p><p>value of the lower bound on variable <code>i</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L433-L451">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_set_upper_bound!-Tuple{ConicBundle.CBProblem, Integer, Float64}" href="#ConicBundle.cb_set_upper_bound!-Tuple{ConicBundle.CBProblem, Integer, Float64}"><code>ConicBundle.cb_set_upper_bound!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_set_upper_bound!(p::CBProblem, i::Integer, lower_bound::Float64)</code></pre><p>set upper bound for variable <code>i</code>, use <a href="cref.html#ConicBundle.cb_get_plus_infinity"><code>cb_get_plus_infinity</code></a> for unbounded from below.</p><p>The algorithm may have to adapt the center point aftwards. In this case the old function values will be marked as outdated and will be recomputed at the next call to e.g. <a href="cref.html#ConicBundle.cb_solve!-Tuple{ConicBundle.CBProblem, Integer, Bool}"><code>cb_solve!</code></a>.</p><p>Arguments:</p><ul><li><p><code>p::CBProblem</code></p><p>the problem</p></li><li><p><code>i::Integer</code></p><p>index of the variable</p></li><li><p><code>lower_bound::Float64</code></p><p>value of the upper bound on variable <code>i</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L461-L479">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_append_variables!-Tuple{ConicBundle.CBProblem, Integer}" href="#ConicBundle.cb_append_variables!-Tuple{ConicBundle.CBProblem, Integer}"><code>ConicBundle.cb_append_variables!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_append_variables!(p::CBProblem, n_append::Integer; lowerb=nothing, upperb=nothing)</code></pre><p>Append new variables (always in last postions in this order).</p><p>If 0 is feasible for the new coordinates then this is selected as starting value for the new coordinates; otherwise, the number closest to zero is used. If all new coordinates can be set to zero then it is assumed that for an existing center point the function values need not be recomputed (this is e.g. the case in Lagrangean relaxation; if this is not correct call <a href="cref.html#ConicBundle.cb_reinit_function_model!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T}} where T"><code>cb_reinit_function_model!</code></a> below). Otherwise the old function values will be marked as outdated and will be recomputed at the next call to e.g. <a href="cref.html#ConicBundle.cb_solve!-Tuple{ConicBundle.CBProblem, Integer, Bool}"><code>cb_solve!</code></a>.</p><p>Be sure to update your objective functions so that they can handle the new variables before you call this and any further ConicBundle routines that require function evaluations. Also, these operations may lead to inavailability of certain other data such as subgradients and primal approximations.</p><p>Arguments:</p><ul><li><p><code>p::CBProblem</code></p><p>the problem</p></li><li><p><code>n_append::Integer</code></p><p>number of variables to append (always in last position in the same order)</p></li><li><p><code>lower_bound::Union{Vector{Float64},Nothing}</code> (either double array of size <code>n_append</code> or <code>nothing</code>)</p><p>If <code>nothing</code>, all appended variables are considered unbounded below, otherwise <code>lowerb[i]</code> gives the minimum feasible value for variable <code>y[i]</code>, use <a href="cref.html#ConicBundle.cb_get_minus_infinity"><code>cb_get_minus_infinity</code></a> for unbounded below.</p></li><li><p><code>upper_bound::Union{Vector{Float64},Nothing}</code> (either double array of size <code>n_append</code> or <code>nothing</code>)</p><p>If <code>nothing</code>, all appended variables are considered unbounded above, otherwise <code>upperb[i]</code> gives the maximum feasible value for variable <code>y[i]</code>, use <a href="cref.html#ConicBundle.cb_get_plus_infinity"><code>cb_get_plus_infinity</code></a> for unbounded above.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L489-L520">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_delete_variables!-Tuple{ConicBundle.CBProblem, Vector{Int32}}" href="#ConicBundle.cb_delete_variables!-Tuple{ConicBundle.CBProblem, Vector{Int32}}"><code>ConicBundle.cb_delete_variables!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_delete_variables!(p::CBProblem, delete_indices::Vector{Cint})
cb_delete_variables!(map_to_old::Vector{Cint}, p::CBProblem, delete_indices::Vector{Cint})</code></pre><p>Deletes variables corresponding to the specified indices.</p><p>The indices of the remaining variables are reassigned so that they are consecutive again, the routine returns a vector giving for each new index of these remaining variables the old coordinate.</p><p>If all of the deleted variables are zero, function values are assumed to remain correct (if this is not so, call <a href="cref.html#ConicBundle.cb_reinit_function_model!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T}} where T"><code>cb_reinit_function_model!</code></a> below) Otherwise the old function values will be marked as outdated and will be recomputed at the next call to e.g. <a href="cref.html#ConicBundle.cb_solve!-Tuple{ConicBundle.CBProblem, Integer, Bool}"><code>cb_solve!</code></a>.</p><p>Be sure to update your objective functions so that they can handle the new variables before you call any further ConicBundle routines that require function evaluations. Also, these operations may lead to inavailability of certain other data such as subgradients and primal approximations.</p><p>Arguments:</p><ul><li><p><code>p::CBProblem</code></p><p>the problem</p></li><li><p><code>delete_indices::Vector{Cint}</code></p><p>the entries in delete_indices specify the indices of the variables to be deleted</p></li></ul><p>Returns a <code>Vector{Cint}</code> of length <code>cb_get_dim(p)-length(delete_indices)</code> whose element <code>i</code> contains the old index (before the call) of the variable that now has index position <code>i</code>. Use the three-argument version to avoid allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L534-L563">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_reassign_variables!-Tuple{ConicBundle.CBProblem, Vector{Int32}}" href="#ConicBundle.cb_reassign_variables!-Tuple{ConicBundle.CBProblem, Vector{Int32}}"><code>ConicBundle.cb_reassign_variables!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_reassign_variables!(p::CBProblem, assign_new_from_old::Vector{Cint})</code></pre><p>Reassigns variables to new index positions by mapping to position <code>i</code> the variable that previously had index <code>assign_new_from_old[i]</code>.</p><p>Old variables, that are not mapped to any position will be deleted. It is allowed to generate several copies of old variables.</p><p>If all of the deleted variables as well as new multiple copies are zero, function values are assumed to remain correct (if this is not so, call <a href="cref.html#ConicBundle.cb_reinit_function_model!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T}} where T"><code>cb_reinit_function_model!</code></a> below). Otherwise the old function values will be marked as outdated and will be recomputed at the next call to e.g. <a href="cref.html#ConicBundle.cb_solve!-Tuple{ConicBundle.CBProblem, Integer, Bool}"><code>cb_solve!</code></a>.</p><p>Be sure to update your objective functions so that they can handle the new variables before you call any further ConicBundle routines that require function evaluations. Also, these operations may lead to inavailability of certain other data such as subgradients and primal approximations.</p><p>Arguments:</p><ul><li><p><code>p::CBProblem</code></p><p>the problem</p></li><li><p><code>assign_new_from_old::Vector{Cint}</code></p><p>entry <code>assign_new_from_old[i]</code> specifies the old index of the variable, that has to be copied to index position <code>i</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L579-L603">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_solve!-Tuple{ConicBundle.CBProblem, Integer, Bool}" href="#ConicBundle.cb_solve!-Tuple{ConicBundle.CBProblem, Integer, Bool}"><code>ConicBundle.cb_solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_solve!(p::CBProblem, maxsteps::Integer=0, stop_at_descent_steps::Bool=false)</code></pre><p>Bundle methods solve a problem by a sequence of so called descent steps that actually bring progress by moving from the current &quot;center point&quot; to a new center with better objective. A descent step may consist of several function evaluations (null steps), that lead to no immediate progress but mainly improve a cutting model of the objective function close to the current center point. A minimizer to the model is accepted as descent step if the function value at this point satisfies a sufficient decrease criterion in comparison to the decrease predicted by the model. Having found a descent step, the next center is automatically shifted to this successful candidate. Termination criteria may stop the process of seeking for a descent step, in which case the current center is kept and the routine <a href="cref.html#ConicBundle.cb_termination_code-Tuple{ConicBundle.CBProblem}"><code>cb_termination_code</code></a> returns the termination code.</p><p>Restarting, after each descent step, the bundle method from scratch with the new center as starting point does not endanger convergence. Therefore, a descent step is the smallest unit, after which user interaction can take place safely. To allow this there is a flag <code>stop_at_descent_steps</code> that will cause the code to return after the next descent step.</p><p>If you know what your are doing, you may also use the input parameter <code>maxsteps</code> to force the algorithm to return after at most <code>maxsteps</code> null steps. Calling solve again without any intermediate problem configurations will then simply continue the process where it stopped and convergence is save. During null steps one may not decrease the weight or delete nonzero variables of the center or the current candidate!</p><p>In a Lagrangean relaxation cutting plane approach one may want to separate and enlarge the dimension after a certain number of null steps. In this case the code will try to preserve the model, given appropriate subgradient extension routines have been provided. If the model cannot be extended, it has to be discarded (if subgradient extension is not successful this is done automatically), and the algorithm will be restarted from the current center point.</p><p>Arguments:</p><ul><li><p><code>p::CBProblem</code></p><p>the problem</p></li><li><p><code>maxsteps::Integer</code></p><p>use value <code>=0</code> as default (anything &lt;= serves as infinite upper bound), if <code>maxsteps&gt;0</code> the code returns after at most so many null steps</p></li><li><p><code>stop_at_descent_steps::Integer</code></p><p>if <code>true</code> the code also returns whenever a descent step occured, if <code>false</code> it only stops after maxsteps or when a termination criterion is met</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L613-L651">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.CBTerminationCode" href="#ConicBundle.CBTerminationCode"><code>ConicBundle.CBTerminationCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">enum CBTerminationCode</code></pre><ul><li><p><code>cbt_not_terminated</code>: Not terminated.</p><p>(Continue with the next <a href="cref.html#ConicBundle.cb_solve!-Tuple{ConicBundle.CBProblem, Integer, Bool}"><code>cb_solve!</code></a>)</p></li><li><p><code>cbt_relprec_satisfied</code>: Relative precision criterion satisfied.</p><p>(See <a href="cref.html#ConicBundle.cb_set_term_relprec!-Tuple{ConicBundle.CBProblem, Float64}"><code>cb_set_term_relprec!</code></a>)</p></li><li><p><code>cbt_time_limit</code>: Timelimit exceeded.</p><p>(Currently the C interface does not offer a timelimit.)</p></li><li><p><code>cbt_feval_limit</code>: Maximum number of function reevaluations exceeded.</p><p>(Indicates that there is a problem with one of the function oracles that seems to deliver no valid upper bounds on the true function value for descent steps)</p></li><li><p><code>cbt_subfailure_limit</code>: Maximum number of quadratic subproblem failures exceeded.</p><p>(Indicates that the numerical limits of the inner quadratic programming solver are reached, no further progress expected)</p></li><li><p><code>cbt_mfailure_limit</code>: maximum number of model evaluation failures exceeded</p><p>(Indicates that the numerical limits of the setup of the subproblem are reached, no further progress expected)</p></li><li><p><code>cbt_incfailure_limit</code>: maximum number of failures to increase the augmented model value exceeded</p><p>(Indicates that the numerical limits of the interplay between subproblem and quadratic programming solver are reached, no further progress expected)</p></li><li><p><code>cbt_ocall_limit</code>: maximum number of oracle calls (function evaluations) exceeded, see <a href="cref.html#ConicBundle.cb_set_eval_limit!-Tuple{ConicBundle.CBProblem, Integer}"><code>cb_set_eval_limit!</code></a></p></li><li><p><code>cbt_ofailure_limit</code>: maximum number of oracle failures exceeded.</p><p>This refers to function evaluations that terminate with insufficient precision but still provide a new approximate subgradient. A failure typically indicates numerical difficulties with the precision requirements. (Currently the C interface does not allow to manipulate the limit, it is set to 10)</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L661-L694">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_termination_code-Tuple{ConicBundle.CBProblem}" href="#ConicBundle.cb_termination_code-Tuple{ConicBundle.CBProblem}"><code>ConicBundle.cb_termination_code</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_termination_code(p::CBProblem)</code></pre><p>Returns the termination code of the bundle algorithm for the latest descent step</p><p>For resetting all counters relevant for termination see <a href="cref.html#ConicBundle.cb_clear_fail_counts!-Tuple{ConicBundle.CBProblem}"><code>cb_clear_fail_counts!</code></a>.</p><p>See also <a href="cref.html#ConicBundle.CBTerminationCode"><code>CBTerminationCode</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L698-L706">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_print_termination_code-Tuple{ConicBundle.CBProblem}" href="#ConicBundle.cb_print_termination_code-Tuple{ConicBundle.CBProblem}"><code>ConicBundle.cb_print_termination_code</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_print_termination_code(p::CBProblem)</code></pre><p>Outputs a text version of termination code, see cb<em>termination</em>code().</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L709-L713">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_get_objval-Tuple{ConicBundle.CBProblem}" href="#ConicBundle.cb_get_objval-Tuple{ConicBundle.CBProblem}"><code>ConicBundle.cb_get_objval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_get_objval(p::CBProblem)</code></pre><p>Returns the objective value resulting from last descent step (initially undefined).</p><p>If no problem modification routines were called since then, it is the objective value at the point returned by <a href="cref.html#ConicBundle.cb_get_center-Tuple{ConicBundle.CBProblem}"><code>cb_get_center</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L719-L726">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_get_center-Tuple{ConicBundle.CBProblem}" href="#ConicBundle.cb_get_center-Tuple{ConicBundle.CBProblem}"><code>ConicBundle.cb_get_center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_get_center(p::CBProblem)</code></pre><p>Returns the next center point that was produced by the last call to <a href="cref.html#ConicBundle.cb_solve!-Tuple{ConicBundle.CBProblem, Integer, Bool}"><code>cb_solve!</code></a> (in some problem modification routines the center point may be updated immediately, in others the center point will be corrected automatically directly before starting the next descent step and its values may be infeasible till then).</p><p>Returns a double vector of length <a href="cref.html#ConicBundle.cb_get_dim-Tuple{ConicBundle.CBProblem}"><code>cb_get_dim</code></a>. Element <code>i</code> will be the value of design variable <span>$y_i$</span> in the next center point (mostly the result of the latest descent step). Use <a href="cref.html#ConicBundle.cb_get_center!-Tuple{Vector{Float64}, ConicBundle.CBProblem}"><code>cb_get_center!</code></a> to avoid allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L729-L740">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_get_center!-Tuple{Vector{Float64}, ConicBundle.CBProblem}" href="#ConicBundle.cb_get_center!-Tuple{Vector{Float64}, ConicBundle.CBProblem}"><code>ConicBundle.cb_get_center!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_get_center!(center::Vector{Float64}, p::CBProblem)</code></pre><p>Mutating variant of <a href="cref.html#ConicBundle.cb_get_center-Tuple{ConicBundle.CBProblem}"><code>cb_get_center</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L743-L747">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_get_sgnorm-Tuple{ConicBundle.CBProblem}" href="#ConicBundle.cb_get_sgnorm-Tuple{ConicBundle.CBProblem}"><code>ConicBundle.cb_get_sgnorm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_get_sgnorm(p::CBProblem)</code></pre><p>Returns Euclidean norm of the latest aggregate subgradient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L754-L758">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_get_subgradient-Tuple{ConicBundle.CBProblem}" href="#ConicBundle.cb_get_subgradient-Tuple{ConicBundle.CBProblem}"><code>ConicBundle.cb_get_subgradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_get_subgradient(p::CBProblem)</code></pre><p>Returns the latest aggregate subgradient.</p><p>Returns a double vector of length <a href="cref.html#ConicBundle.cb_get_dim-Tuple{ConicBundle.CBProblem}"><code>cb_get_dim</code></a>. Element <code>i</code> will be filled with the coordinate value <code>i</code>. Use <a href="cref.html#ConicBundle.cb_get_subgradient!-Tuple{Vector{Float64}, ConicBundle.CBProblem}"><code>cb_get_subgradient!</code></a> to avoid allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L761-L769">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_get_subgradient!-Tuple{Vector{Float64}, ConicBundle.CBProblem}" href="#ConicBundle.cb_get_subgradient!-Tuple{Vector{Float64}, ConicBundle.CBProblem}"><code>ConicBundle.cb_get_subgradient!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_get_subgradient!(subgradient::Vector{Float64}, p::CBProblem)</code></pre><p>Mutating variant of <a href="cref.html#ConicBundle.cb_get_subgradient-Tuple{ConicBundle.CBProblem}"><code>cb_get_subgradient</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L772-L776">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_get_candidate_value-Tuple{ConicBundle.CBProblem}" href="#ConicBundle.cb_get_candidate_value-Tuple{ConicBundle.CBProblem}"><code>ConicBundle.cb_get_candidate_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_get_candidate_value(p::CBProblem)</code></pre><p>Returns the objective value computed in the last step of <a href="cref.html#ConicBundle.cb_solve!-Tuple{ConicBundle.CBProblem, Integer, Bool}"><code>cb_solve!</code></a>, independent of whether this was a descent step or a null step (initially undefined).</p><p>If no problem modification routines were called since then, it is the objective value at the point returned by <a href="cref.html#ConicBundle.cb_get_candidate-Tuple{ConicBundle.CBProblem}"><code>cb_get_candidate</code></a>. If this last evaluation led to a descent step, then it is the same value as in <a href="cref.html#ConicBundle.cb_get_objval-Tuple{ConicBundle.CBProblem}"><code>cb_get_objval</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L784-L793">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_get_candidate-Tuple{ConicBundle.CBProblem}" href="#ConicBundle.cb_get_candidate-Tuple{ConicBundle.CBProblem}"><code>ConicBundle.cb_get_candidate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_get_candidate(p::CBProblem)</code></pre><p>Returns the last point, the &quot;candidate&quot;, at which the function was evaluated in <a href="cref.html#ConicBundle.cb_solve!-Tuple{ConicBundle.CBProblem, Integer, Bool}"><code>cb_solve!</code></a>.</p><p>If this evaluation lead to a descent step, it is the same point as in <a href="cref.html#ConicBundle.cb_get_center-Tuple{ConicBundle.CBProblem}"><code>cb_get_center</code></a>.</p><p>Returns a double array of length <a href="cref.html#ConicBundle.cb_get_dim-Tuple{ConicBundle.CBProblem}"><code>cb_get_dim</code></a>. Element <code>i</code> will be the value of design variable <span>$y_i$</span> of the point. Use <a href="cref.html#ConicBundle.cb_get_candidate!-Tuple{Vector{Float64}, ConicBundle.CBProblem}"><code>cb_get_candidate!</code></a> to avoid allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L796-L807">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_get_candidate!-Tuple{Vector{Float64}, ConicBundle.CBProblem}" href="#ConicBundle.cb_get_candidate!-Tuple{Vector{Float64}, ConicBundle.CBProblem}"><code>ConicBundle.cb_get_candidate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_get_candidate!(candidate::Vector{Float64}, p::CBProblem)</code></pre><p>Mutating variant of <a href="cref.html#ConicBundle.cb_get_candidate-Tuple{ConicBundle.CBProblem}"><code>cb_get_candidate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L810-L814">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_set_term_relprec!-Tuple{ConicBundle.CBProblem, Float64}" href="#ConicBundle.cb_set_term_relprec!-Tuple{ConicBundle.CBProblem, Float64}"><code>ConicBundle.cb_set_term_relprec!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_set_term_relprec!(p::CBProblem, term_relprec::Float64)</code></pre><p>Sets the relative precision requirements for successful termination (default <code>1e-5</code>). The algorithm stops with termination code <code>cbt_relprec_satisfied</code>, if predicted progress for the next step is less than <code>term_relprec</code> times absolute function value plus one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L822-L828">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_set_new_center_point!-Tuple{ConicBundle.CBProblem, Vector{Float64}}" href="#ConicBundle.cb_set_new_center_point!-Tuple{ConicBundle.CBProblem, Vector{Float64}}"><code>ConicBundle.cb_set_new_center_point!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_set_new_center_point!(p::CBProblem, center::Vector{Float64})</code></pre><p>Set the starting point/center that will be used in the next call to <a href="cref.html#ConicBundle.cb_solve!-Tuple{ConicBundle.CBProblem, Integer, Bool}"><code>cb_solve!</code></a>. Each call to this routine causes an immediate evaluation of all oracles.</p><p>Arguments:</p><ul><li><p><code>p::CBProblem</code></p><p>the problem</p></li><li><p><code>center::Vector{Float64}</code> (length <a href="cref.html#ConicBundle.cb_get_dim-Tuple{ConicBundle.CBProblem}"><code>cb_get_dim</code></a>)</p><p><code>center[i]</code> holds the value of design variable <span>$y_i$</span></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L835-L849">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_get_function_status-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T}} where T" href="#ConicBundle.cb_get_function_status-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T}} where T"><code>ConicBundle.cb_get_function_status</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_get_function_status(p::CBProblem{T}, function_key::T)</code></pre><p>Returns the return value of the latest evaluation call to the function with this <code>function_key</code></p><p>Remember, a unique <code>function_key</code> must be specified in <a href="cref.html#ConicBundle.cb_add_function!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Function, Nothing}} where T"><code>cb_add_function!</code></a>.</p><p>Arguments:</p><ul><li><p><code>p::CBProblem{T}</code></p><p>the problem</p></li><li><p><code>function_key::T</code></p><p>unique identifier as set in <a href="cref.html#ConicBundle.cb_add_function!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Function, Nothing}} where T"><code>cb_add_function!</code></a>.</p></li></ul><p>Returns value of latest call to the function having this <code>function_key</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L857-L874">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_get_approximate_slacks-Tuple{ConicBundle.CBProblem}" href="#ConicBundle.cb_get_approximate_slacks-Tuple{ConicBundle.CBProblem}"><code>ConicBundle.cb_get_approximate_slacks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_get_approximate_slacks(p::CBProblem)</code></pre><p>Returns the multipliers for the bound constraints on the design variables; in Lagrangean relaxation they may be interpreted as primal slacks for inequality constraints.</p><p>Returns a double array of length <a href="cref.html#ConicBundle.cb_get_dim-Tuple{ConicBundle.CBProblem}"><code>cb_get_dim</code></a>. Element <code>i</code> will be filled with the coordinate value <code>i</code> Use <a href="cref.html#ConicBundle.cb_get_approximate_slacks!-Tuple{Vector{Float64}, ConicBundle.CBProblem}"><code>cb_get_approximate_slacks!</code></a> to avoid allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L878-L887">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_get_approximate_slacks!-Tuple{Vector{Float64}, ConicBundle.CBProblem}" href="#ConicBundle.cb_get_approximate_slacks!-Tuple{Vector{Float64}, ConicBundle.CBProblem}"><code>ConicBundle.cb_get_approximate_slacks!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_get_approximate_slacks!(slacks::Vector{Float64}, p::CBProblem)</code></pre><p>Mutating variant of <a href="cref.html#ConicBundle.cb_get_approximate_slacks-Tuple{ConicBundle.CBProblem}"><code>cb_get_approximate_slacks</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L890-L894">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_get_approximate_primal!-Union{Tuple{T}, Tuple{Vector{Float64}, ConicBundle.CBProblem{T}, T}} where T" href="#ConicBundle.cb_get_approximate_primal!-Union{Tuple{T}, Tuple{Vector{Float64}, ConicBundle.CBProblem{T}, T}} where T"><code>ConicBundle.cb_get_approximate_primal!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_get_approximate_primal!(primal::Vector{Float64}, p::CBProblem{T}, function_key::T)</code></pre><p>Returns the current approximate primal solution for the function having this <code>function_key</code></p><p>The <code>function_key</code> must match the one specified in <a href="cref.html#ConicBundle.cb_add_function!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Function, Nothing}} where T"><code>cb_add_function!</code></a>. Likewise, the routine is meaningful only if <code>primaldim</code> was set in   <a href="cref.html#ConicBundle.cb_add_function!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Function, Nothing}} where T"><code>cb_add_function!</code></a> and primal vectors were   returned along with the subgradients in all calls to <a href="cref.html#ConicBundle.CBFunction"><code>CBFunction</code></a> with this <code>function_key</code>. In this case it returns the current approximate primal solution aggregated alongside with the aggregate subgradient. A primal solution may not be available after addition of constraints, if extension of the aggregate subgradient to the new coordinates failed.</p><p>If no primal dimension was set for this function, the routine does nothing.</p><p>Arguments:</p><ul><li><p><code>primal::Vector{Float64}</code> (caller-allocated of length <code>primaldim</code>)</p><p><code>primal[i]</code> will be filled with the coordinate value <code>i</code></p></li><li><p><code>p::CBProblem{T}</code></p><p>the problem</p></li><li><p><code>function_key::T</code></p><p>unique identifier as set in <a href="cref.html#ConicBundle.cb_add_function!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Function, Nothing}} where T"><code>cb_add_function!</code></a></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L902-L928">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_get_center_primal!-Union{Tuple{T}, Tuple{Vector{Float64}, ConicBundle.CBProblem{T}, T}} where T" href="#ConicBundle.cb_get_center_primal!-Union{Tuple{T}, Tuple{Vector{Float64}, ConicBundle.CBProblem{T}, T}} where T"><code>ConicBundle.cb_get_center_primal!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_get_center_primal!(primal::Vector{Float64}, p::CBProblem{T}, function_key::T)</code></pre><p>Returns the best primal solution obtained in the current center point in evaluating the function having this <code>function_key</code></p><p>The <code>function_key</code> must match the one specified in <a href="cref.html#ConicBundle.cb_add_function!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Function, Nothing}} where T"><code>cb_add_function!</code></a>. Likewise, the routine is meaningful only if <code>primaldim</code> was set in <a href="cref.html#ConicBundle.cb_add_function!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Function, Nothing}} where T"><code>cb_add_function!</code></a> and primal vectors were returned along with the subgradients in all calls to <a href="cref.html#ConicBundle.CBFunction"><code>CBFunction</code></a> with this <code>function_key</code>. In this case it returns the current approximate primal solution aggregated alongside with the aggregate subgradient. A primal solution may not be available after addition of constraints, if extension of the aggregate subgradient to the new coordinates failed.</p><p>If no primal dimension was set for this function, the routine does nothing.</p><p>Arguments:</p><ul><li><p><code>primal::Vector{Float64}</code> (caller-allocated of length <code>primaldim</code>)</p><p><code>primal[i]</code> will be filled with the coordinate value <code>i</code></p></li><li><p><code>p::CBProblem{T}</code></p><p>the problem</p></li><li><p><code>function_key::T</code></p><p>unique identifier as set in <a href="cref.html#ConicBundle.cb_add_function!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Function, Nothing}} where T"><code>cb_add_function!</code></a></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L938-L964">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_get_candidate_primal!-Union{Tuple{T}, Tuple{Vector{Float64}, ConicBundle.CBProblem{T}, T}} where T" href="#ConicBundle.cb_get_candidate_primal!-Union{Tuple{T}, Tuple{Vector{Float64}, ConicBundle.CBProblem{T}, T}} where T"><code>ConicBundle.cb_get_candidate_primal!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_get_candidate_primal!(primal::Vector{Float64}, p::CBProblem{T}, function_key::T)</code></pre><p>Returns the best primal solution returned by the last evaluation of the function having this <code>function_key</code> in the point <a href="cref.html#ConicBundle.cb_get_candidate-Tuple{ConicBundle.CBProblem}"><code>cb_get_candidate</code></a>.</p><p>The <code>function_key</code> must match the one specified in <a href="cref.html#ConicBundle.cb_add_function!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Function, Nothing}} where T"><code>cb_add_function!</code></a>. Likewise, the routine is meaningful only if <code>primaldim</code> was set in   <a href="cref.html#ConicBundle.cb_add_function!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Function, Nothing}} where T"><code>cb_add_function!</code></a> and primal vectors were   returned along with the subgradients in all calls to <a href="cref.html#ConicBundle.CBFunction"><code>CBFunction</code></a> with this <code>function_key</code>. In this case it returns the current approximate primal solution aggregated alongside with the aggregate subgradient. A primal solution may not be available after addition of constraints, if extension of the aggregate subgradient to the new coordinates failed.</p><p>If no primal dimension was set for this function, the routine does nothing.</p><p>Arguments:</p><ul><li><p><code>primal::Vector{Float64}</code> (caller-allocated of length <code>primaldim</code>)</p><p><code>primal[i]</code> will be filled with the coordinate value <code>i</code></p></li><li><p><code>p::CBProblem{T}</code></p><p>the problem</p></li><li><p><code>function_key::T</code></p><p>unique identifier as set in <a href="cref.html#ConicBundle.cb_add_function!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Function, Nothing}} where T"><code>cb_add_function!</code></a></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L974-L1001">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_set_max_modelsize!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Integer}} where T" href="#ConicBundle.cb_set_max_modelsize!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Integer}} where T"><code>ConicBundle.cb_set_max_modelsize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_set_max_modelsize!(p::CBProblem{T}, function_key::T, modelsize::Integer)</code></pre><p>Sets the maximum number of subgradients used in forming the cutting model of the function having this <code>function_key</code></p><p>The <code>function_key</code> must match the one specified in <a href="cref.html#ConicBundle.cb_add_function!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Function, Nothing}} where T"><code>cb_add_function!</code></a>.</p><p>Quite often a very small model, e.g., 2, yields very fast iterations and good progress in time (sometimes at the cost of more evaluations). By limited numerical experience, a significant reduction in the number of evaluations can only be expected if the bundle is large enough to wrap the function rather tightly. Quite frequently, unfortunately, this entails that solving the quadratic subproblems is more expensive than function evaluation.</p><p>Arguments:</p><ul><li><p><code>p::CBProblem{T}</code></p><p>the problem</p></li><li><p><code>function_key::T</code></p><p>unique identifier as set in <a href="cref.html#ConicBundle.cb_add_function!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Function, Nothing}} where T"><code>cb_add_function!</code></a></p></li><li><p><code>modelsize::Integer</code></p><p>maximum number of subgradients to be used in forming the cutting model</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L1011-L1034">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_set_max_bundlesize!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Integer}} where T" href="#ConicBundle.cb_set_max_bundlesize!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Integer}} where T"><code>ConicBundle.cb_set_max_bundlesize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_set_max_bundlesize!(p::CBProblem{T}, function_key::T, bundlesize::Integer)</code></pre><p>Sets the maximum number of subgradients stored for use in forming the model or determining metric information of the function having this <code>function_key</code>. it must be as least as large as <code>max_modelsize</code> (and is increased to this if not)</p><p>The <code>function_key</code> must match the one specified in <a href="cref.html#ConicBundle.cb_add_function!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Function, Nothing}} where T"><code>cb_add_function!</code></a>.</p><p>Arguments:</p><ul><li><p><code>p::CBProblem{T}</code></p><p>the problem</p></li><li><p><code>function_key::T</code></p><p>unique identifier as set in <a href="cref.html#ConicBundle.cb_add_function!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Function, Nothing}} where T"><code>cb_add_function!</code></a></p></li><li><p><code>bundlesize::Integer</code></p><p>maximum number of subgradients to be used in forming the cutting model</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L1044-L1063">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_set_max_new_subgradients!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Integer}} where T" href="#ConicBundle.cb_set_max_new_subgradients!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Integer}} where T"><code>ConicBundle.cb_set_max_new_subgradients!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_set_max_new_subgradients!(p::CBProblem{T}, function_key::T, max_new_subg::Integer)</code></pre><p>Sets the maximum number of epsilon subgradients that can be returned in one call to the function having this <code>function_key</code>.</p><p>The <code>function_key</code> must match the one specified in <a href="cref.html#ConicBundle.cb_add_function!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Function, Nothing}} where T"><code>cb_add_function!</code></a>.</p><p>The parameter <code>max_new_subg</code> corresponds directly to the parameter <code>max_subg</code> in <a href="cref.html#ConicBundle.CBFunction"><code>CBFunction</code></a>.</p><p>Arguments:</p><ul><li><p><code>p::CBProblem{T}</code></p><p>the problem</p></li><li><p><code>function_key::T</code></p><p>unique identifier as set in <a href="cref.html#ConicBundle.cb_add_function!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Function, Nothing}} where T"><code>cb_add_function!</code></a></p></li><li><p><code>max_new_subg::Integer</code></p><p>maximum number of subgradients to be used in forming the cutting model</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L1073-L1093">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_get_bundle_parameters-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T}} where T" href="#ConicBundle.cb_get_bundle_parameters-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T}} where T"><code>ConicBundle.cb_get_bundle_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> cb_get_bundle_parameters(p::CBProblem{T}, function_key::T)</code></pre><p>Retrieves the two bundle parameters specified in the routines <a href="cref.html#ConicBundle.cb_set_max_modelsize!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Integer}} where T"><code>cb_set_max_modelsize!</code></a> and <a href="cref.html#ConicBundle.cb_set_max_bundlesize!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Integer}} where T"><code>cb_set_max_bundlesize!</code></a> for the function having this <code>function_key</code>.</p><p>The <code>function_key</code> must match the one specified in <a href="cref.html#ConicBundle.cb_add_function!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Function, Nothing}} where T"><code>cb_add_function!</code></a>.</p><p>Arguments:</p><ul><li><p><code>p::CBProblem{T}</code></p><p>the problem</p></li><li><p><code>function_key::T</code></p><p>unique identifier as set in <a href="cref.html#ConicBundle.cb_add_function!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Function, Nothing}} where T"><code>cb_add_function!</code></a></p></li></ul><p>Returns two integers:</p><ul><li>the maximum number of subgradients to be used in forming the cutting model</li><li>the maximum number of subgradients stored for use in forming the cutting model</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L1103-L1125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_reinit_function_model!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T}} where T" href="#ConicBundle.cb_reinit_function_model!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T}} where T"><code>ConicBundle.cb_reinit_function_model!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_reinit_function_model!(p::CBProblem{T}, function_key::T)</code></pre><p>Clears cutting model, subgradients and stored function values for the function with this <code>function_key</code></p><p>This has to be called whenever the specified function was modified so that the old subgradients and/or primal generators are no longer valid.</p><p>The <code>function_key</code> must match the one specified in <a href="cref.html#ConicBundle.cb_add_function!-Union{Tuple{T}, Tuple{ConicBundle.CBProblem{T}, T, Function, Nothing}} where T"><code>cb_add_function!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L1138-L1148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_get_last_weight-Tuple{ConicBundle.CBProblem}" href="#ConicBundle.cb_get_last_weight-Tuple{ConicBundle.CBProblem}"><code>ConicBundle.cb_get_last_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_get_last_weight(p::CBProblem)</code></pre><p>Returns the current weight for the quadratic term in the augmented subproblem (may be interpreted as 1./step_size or 1./trustregion-radius).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L1155-L1160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_set_next_weight!-Tuple{ConicBundle.CBProblem, Float64}" href="#ConicBundle.cb_set_next_weight!-Tuple{ConicBundle.CBProblem, Float64}"><code>ConicBundle.cb_set_next_weight!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_set_next_weight!(p::CBProblem, weight::Float64)</code></pre><p>Sets the  weight (&gt;0) to be used in the quadratic term of the next augmented subproblem (may be interpreted as 1./step_size or 1./trustregion-radius).</p><p>Independent of whether the weight violates current min- and max-bounds set in <a href="cref.html#ConicBundle.cb_set_min_weight!-Tuple{ConicBundle.CBProblem, Float64}"><code>cb_set_min_weight!</code></a> and <a href="cref.html#ConicBundle.cb_set_max_weight!-Tuple{ConicBundle.CBProblem, Float64}"><code>cb_set_max_weight!</code></a>, the next model will be computed for this value. Thereafter, however, it will be updated as usual; in particular, it may be truncated by min and max bounds immediately after the first subproblem.</p><p>In order to guarantee a constant weight (e.g. 1 is frequently a reasonable choice if the automatic default heuristic performs poorly), set the min and max bounds to the same value, too.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L1163-L1177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_set_min_weight!-Tuple{ConicBundle.CBProblem, Float64}" href="#ConicBundle.cb_set_min_weight!-Tuple{ConicBundle.CBProblem, Float64}"><code>ConicBundle.cb_set_min_weight!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_set_min_weight!(p::CBProblem, min_weight::Float64)</code></pre><p>Sets a lower bound on the weight for the quadratic term of the augmented subproblem.</p><p>Nonpositive values indicate no bound. The new value shows its effect only at first dynamic change of the weight.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L1183-L1190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_set_max_weight!-Tuple{ConicBundle.CBProblem, Float64}" href="#ConicBundle.cb_set_max_weight!-Tuple{ConicBundle.CBProblem, Float64}"><code>ConicBundle.cb_set_max_weight!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_set_max_weight!(p::CBProblem, max_weight::Float64)</code></pre><p>Sets a upper bound on the weight for the quadratic term of the augmented subproblem.</p><p>Nonpositive values indicate no bound. The new value shows its effect only at first dynamic change of the weight.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L1197-L1204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.CBVariableMetric" href="#ConicBundle.CBVariableMetric"><code>ConicBundle.CBVariableMetric</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CBVariableMetric</code></pre><ul><li><code>cbvm_no_scaling</code></li><li><code>cbvm_diagonal_scaling</code></li><li><code>cbvm_diagonal_scaling_with_bounds</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L1211-L1217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_set_variable_metric!-Tuple{ConicBundle.CBProblem, ConicBundle.CBVariableMetric}" href="#ConicBundle.cb_set_variable_metric!-Tuple{ConicBundle.CBProblem, ConicBundle.CBVariableMetric}"><code>ConicBundle.cb_set_variable_metric!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_set_variable_metric!(p::CBProblem, do_variable_metric::CBVariableMetric)</code></pre><p>Sets a upper bound on the weight for the quadratic term of the augmented subproblem.</p><p>Nonpositive values indicate no bound. The new value shows its effect only at first dynamic change of the weight.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L1220-L1227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_get_dim-Tuple{ConicBundle.CBProblem}" href="#ConicBundle.cb_get_dim-Tuple{ConicBundle.CBProblem}"><code>ConicBundle.cb_get_dim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_get_dim(p::CBProblem)</code></pre><p>Returns the current dimension of the design space/argument or -1 if no dimension is set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L1234-L1238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_get_n_functions-Tuple{ConicBundle.CBProblem}" href="#ConicBundle.cb_get_n_functions-Tuple{ConicBundle.CBProblem}"><code>ConicBundle.cb_get_n_functions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_get_n_functions(p::CBProblem)</code></pre><p>Returns the current number of functions in the problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L1241-L1245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_get_minus_infinity" href="#ConicBundle.cb_get_minus_infinity"><code>ConicBundle.cb_get_minus_infinity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cb_get_minus_infinity()</code></pre><p>Returns the value &quot;minus infinity&quot;, i.e., all bounds &lt;= this value are set to this value and are regarded as minus infinity Use the constant <a href="cref.html#ConicBundle.cb_minus_infinity"><code>cb_minus_infinity</code></a> instead of calling this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L1248-L1253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_get_plus_infinity" href="#ConicBundle.cb_get_plus_infinity"><code>ConicBundle.cb_get_plus_infinity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cb_get_plus_infinity()</code></pre><p>Returns the value &quot;plus infinity&quot;, i.e., all bounds &gt;= this value are set to this value and are regarded as plus infinity Use the constant <a href="cref.html#ConicBundle.cb_plus_infinity"><code>cb_plus_infinity</code></a> instead of calling this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L1263-L1268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_clear_fail_counts!-Tuple{ConicBundle.CBProblem}" href="#ConicBundle.cb_clear_fail_counts!-Tuple{ConicBundle.CBProblem}"><code>ConicBundle.cb_clear_fail_counts!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_clear_fail_counts!(p::CBProblem)</code></pre><p>clears all fail counts on numerical function oder model failures, may be useful if this caused premature termination.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L1278-L1282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_set_eval_limit!-Tuple{ConicBundle.CBProblem, Integer}" href="#ConicBundle.cb_set_eval_limit!-Tuple{ConicBundle.CBProblem, Integer}"><code>ConicBundle.cb_set_eval_limit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_set_eval_limit!(p::CBProblem, eval_limit::Integer)</code></pre><p>Sets an upper bound on the number of calls to the oracle (use negative numbers for no limit).</p><p>If this number is reached, the algorithm will terminate independently of whether the last step was a descent or a null step. A negative number will be interepreted as no limit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L1285-L1292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_set_inner_update_limit!-Tuple{ConicBundle.CBProblem, Integer}" href="#ConicBundle.cb_set_inner_update_limit!-Tuple{ConicBundle.CBProblem, Integer}"><code>ConicBundle.cb_set_inner_update_limit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_set_inner_update_limit!(p::CBProblem, update_limit::Integer)</code></pre><p>Set an upper bound on the number of inner updates for the cutting model with primal slacks within one null step (use negative numbers for no limit).</p><p>A negative number will be interepreted as no limit, i.e., the updates will be done till a certain precision of the cutting model is achieved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L1296-L1304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_set_active_bounds_fixing!-Tuple{ConicBundle.CBProblem, Bool}" href="#ConicBundle.cb_set_active_bounds_fixing!-Tuple{ConicBundle.CBProblem, Bool}"><code>ConicBundle.cb_set_active_bounds_fixing!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_set_active_bounds_fixing!(p::CBProblem, allow_fixing::Bool)</code></pre><p>If set to <code>true</code> (the default is <code>false</code>), some variables will be fixed automatically to the center value if their bounds are strongly active (i.e., the corresponding multipliers are big).</p><p>The coordinates to be fixed are redetermined in each call following a descent step or a change of the function. An indicator vector of the variables fixed in the last call can be obtained via the routine <a href="cref.html#ConicBundle.cb_get_fixed_active_bounds-Tuple{ConicBundle.CBProblem}"><code>cb_get_fixed_active_bounds</code></a>.</p><p>Setting this value to <code>true</code> might improve the performance of the algorithm in some instances but there is no convergence theory. It might be particularly helpful within Lagrangian relaxation if a primal cutting plane approach is used and non-tight inequalities should be eliminated quickly (fixing then indicates large primal slack values).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L1308-L1321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_get_fixed_active_bounds-Tuple{ConicBundle.CBProblem}" href="#ConicBundle.cb_get_fixed_active_bounds-Tuple{ConicBundle.CBProblem}"><code>ConicBundle.cb_get_fixed_active_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_get_fixed_active_bounds(p::CBProblem)</code></pre><p>Returns the indicator vector of variables temporarily fixed to the center value due to significantly positive multipliers for the box constraints, see <a href="cref.html#ConicBundle.cb_set_active_bounds_fixing!-Tuple{ConicBundle.CBProblem, Bool}"><code>cb_set_active_bounds_fixing!</code></a>.</p><p>Such a fixing indicates that the corresponding variables would like to stay at their bounds. If no variables were fixed, the dimension of the vector is zero.</p><p>Returns a int array of length <a href="cref.html#ConicBundle.cb_get_dim-Tuple{ConicBundle.CBProblem}"><code>cb_get_dim</code></a>. Element <code>i</code> will be <code>1</code> if the variable <code>i</code> was fixed to the bound and <code>0</code> otherwise Use <a href="cref.html#ConicBundle.cb_get_fixed_active_bounds!-Tuple{ConicBundle.CBProblem, Vector{Int32}}"><code>cb_get_fixed_active_bounds!</code></a> to avoid allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L1325-L1337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_get_fixed_active_bounds!-Tuple{ConicBundle.CBProblem, Vector{Int32}}" href="#ConicBundle.cb_get_fixed_active_bounds!-Tuple{ConicBundle.CBProblem, Vector{Int32}}"><code>ConicBundle.cb_get_fixed_active_bounds!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_get_fixed_active_bounds!(p::CBProblem, indicator::Vector{Cint})</code></pre><p>Mutating variant of <a href="cref.html#ConicBundle.cb_get_fixed_active_bounds!-Tuple{ConicBundle.CBProblem, Vector{Int32}}"><code>cb_get_fixed_active_bounds</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L1340-L1344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_set_print_level!-Tuple{ConicBundle.CBProblem, Integer}" href="#ConicBundle.cb_set_print_level!-Tuple{ConicBundle.CBProblem, Integer}"><code>ConicBundle.cb_set_print_level!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cb_set_print_level!(p::CBProblem, pril::Integer)</code></pre><p>Specifies the output level (&lt;0 no output at all, =0 errors and warnings, &gt;0 increasingly detailed information)</p><p>Output levels:</p><ul><li><code>&lt;0</code> ... no output, not even errors or warnings</li><li><code>0</code> ... no output except for errors and warnings</li><li><code>1</code> ... line summary after each descent step</li><li><code>&gt;1</code> ... undocumented and increasingly detailed log information.         These higher levels should only be used if requested         for debugging purposes.</li></ul><p><strong>Example for level 1:</strong></p><pre><code class="nohighlight hljs">00:00:00.00 endit  1   1   1   563.    563.  39041.188  39043.162
00:00:00.00 endit  2   2   2   563.    559.  38488.165  38490.200
00:00:00.00 endit  3   3   3   56.3    555.  33014.533  33211.856
00:00:00.00 endit  4   4   4   5.63    517. -14306.459  2738.0343
00:00:00.00 endit  5   5   5   4.04    148. -2692.1131  2.2150883
00:00:00.00 endit  6   6   6   4.01    1.29  1.7908952  2.0000581
00:00:00.00 endit  7   7   7   3.95  0.0213  1.9999387  2.0000000
00:00:00.00 _endit  8   8   8   3.95 2.94e-05  2.0000000  2.0000000

Column 1      2     3   4   5    6       7       8          9</code></pre><ul><li>Column 1: computation time in hh:mm:ss.dd,</li><li>Column 2: &quot;endit&quot; is convenient for grep and stands for &quot;end of iteration&quot;.   Iterations with <a href="cref.html#ConicBundle.cb_termination_code-Tuple{ConicBundle.CBProblem}"><code>cb_termination_code</code></a> != 0 are marked with &quot;_endit&quot;.</li><li>Column 3: number of descent steps (= calls to <a href="cref.html#ConicBundle.cb_solve!-Tuple{ConicBundle.CBProblem, Integer, Bool}"><code>cb_solve!</code></a>)</li><li>Column 4: number of descent and null steps. Up to initialization calls and reevaluations, this is the number of   evaluation calls to the function oracles from within the bundle method. In the example all calls led to descent steps.</li><li>Column 5: number of innermost iterations. It differs from column 5 only in the case of variables with bounds in which   case it gives the number of updates of the multipliers for the bounds (or primal slacks in Lagrangean relaxation).   Exceedingly high numbers in this column indicate that some variables are constantly at their bounds and it might be   possible to improve convergence by deleting them (i.e. set them as constants to this bound and remove the variable).</li><li>Column 6: the weight of the quadratic term in the augmented problem.</li><li>Column 7: the norm of the aggregate subgradient. If it is small, say below 0.1, then mostly this is good indication that   the objective value is close to optimal.</li><li>Column 8: the value of the cutting model in the last candidate point. It is always a lower bound on the true function   value in this point</li><li>Column 9: the objective value in the latest point that led to a descent step, i.e., the point returend by   <a href="cref.html#ConicBundle.cb_get_center-Tuple{ConicBundle.CBProblem}"><code>cb_get_center</code></a>. Whenever <a href="cref.html#ConicBundle.cb_termination_code-Tuple{ConicBundle.CBProblem}"><code>cb_termination_code</code></a>   returns 0 this is also the objective value of the latest evaluation call to the function oracles and the value in the   center point of the next iteration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L1352-L1398">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_minus_infinity" href="#ConicBundle.cb_minus_infinity"><code>ConicBundle.cb_minus_infinity</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const cb_minus_infinity::Float64</code></pre><p>Contains the value &quot;minus infinity&quot; as returned by <a href="cref.html#ConicBundle.cb_get_minus_infinity"><code>cb_get_minus_infinity</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L1256-L1260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConicBundle.cb_plus_infinity" href="#ConicBundle.cb_plus_infinity"><code>ConicBundle.cb_plus_infinity</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const cb_plus_infinity::Float64</code></pre><p>Contains the value &quot;plus infinity&quot; as returned by <a href="cref.html#ConicBundle.cb_get_plus_infinity"><code>cb_get_plus_infinity</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/ConicBundle.jl/blob/61b0d64b0b94bcbe978d3459a00309c874106efd/src/ConicBundle.jl#L1271-L1275">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="cppref.html">« Reference of C++ interface</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 3 July 2023 13:55">Monday 3 July 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
